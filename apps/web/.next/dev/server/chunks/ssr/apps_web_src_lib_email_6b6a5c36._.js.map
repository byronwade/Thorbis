{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/email/domain-validation.ts"],"sourcesContent":["/**\n * Domain Validation Utilities for Multi-Tenant Email System\n *\n * Features:\n * - Subdomain enforcement for reputation isolation\n * - Domain ownership validation\n * - Blocked domain detection (public email providers)\n * - Tier-based domain allocation\n */\n\n// Blocked domains - public email providers that shouldn't be registered\nconst BLOCKED_DOMAINS = new Set([\n\t// Major providers\n\t\"gmail.com\",\n\t\"yahoo.com\",\n\t\"hotmail.com\",\n\t\"outlook.com\",\n\t\"live.com\",\n\t\"msn.com\",\n\t\"aol.com\",\n\t\"icloud.com\",\n\t\"me.com\",\n\t\"mac.com\",\n\t// Other common providers\n\t\"protonmail.com\",\n\t\"proton.me\",\n\t\"zoho.com\",\n\t\"mail.com\",\n\t\"gmx.com\",\n\t\"yandex.com\",\n\t\"fastmail.com\",\n\t// Temporary email services\n\t\"tempmail.com\",\n\t\"guerrillamail.com\",\n\t\"mailinator.com\",\n\t\"10minutemail.com\",\n\t\"throwaway.email\",\n\t// Big tech\n\t\"google.com\",\n\t\"microsoft.com\",\n\t\"apple.com\",\n\t\"amazon.com\",\n\t\"facebook.com\",\n\t\"meta.com\",\n]);\n\n// Reserved subdomains that companies cannot use\nconst RESERVED_SUBDOMAINS = new Set([\n\t\"mail\",\n\t\"email\",\n\t\"smtp\",\n\t\"pop\",\n\t\"imap\",\n\t\"webmail\",\n\t\"mx\",\n\t\"ns\",\n\t\"dns\",\n\t\"www\",\n\t\"api\",\n\t\"app\",\n\t\"admin\",\n\t\"support\",\n\t\"help\",\n\t\"billing\",\n\t\"status\",\n]);\n\nexport interface DomainValidationResult {\n\tvalid: boolean;\n\terror?: string;\n\tnormalizedDomain?: string;\n\tisSubdomain?: boolean;\n\trootDomain?: string;\n\tsubdomain?: string;\n}\n\nexport interface DomainConfig {\n\tallowCustomDomain: boolean;\n\trequireSubdomain: boolean;\n\tmaxDomainsAllowed: number;\n}\n\n/**\n * Get domain configuration - all companies have the same config (no tiers)\n */\nexport function getDomainConfig(): DomainConfig {\n\treturn {\n\t\tallowCustomDomain: true,\n\t\trequireSubdomain: false, // Can use root domain or subdomain\n\t\tmaxDomainsAllowed: 10, // Reasonable limit for organization\n\t};\n}\n\n/**\n * Parse a domain into its components\n */\nexport function parseDomain(domain: string): {\n\tsubdomain: string | null;\n\trootDomain: string;\n\ttld: string;\n} {\n\tconst normalized = domain.toLowerCase().trim();\n\tconst parts = normalized.split(\".\");\n\n\tif (parts.length < 2) {\n\t\treturn { subdomain: null, rootDomain: normalized, tld: \"\" };\n\t}\n\n\t// Handle common multi-part TLDs (co.uk, com.au, etc.)\n\tconst multiPartTlds = [\"co.uk\", \"com.au\", \"co.nz\", \"com.br\", \"co.jp\"];\n\tconst lastTwo = parts.slice(-2).join(\".\");\n\n\tif (multiPartTlds.includes(lastTwo) && parts.length > 2) {\n\t\tconst tld = lastTwo;\n\t\tconst rootDomain = parts.slice(-3).join(\".\");\n\t\tconst subdomain = parts.length > 3 ? parts.slice(0, -3).join(\".\") : null;\n\t\treturn { subdomain, rootDomain, tld };\n\t}\n\n\tconst tld = parts[parts.length - 1];\n\tconst rootDomain = parts.slice(-2).join(\".\");\n\tconst subdomain = parts.length > 2 ? parts.slice(0, -2).join(\".\") : null;\n\n\treturn { subdomain, rootDomain, tld };\n}\n\n/**\n * Validate a domain for registration\n */\nexport function validateDomain(domain: string): DomainValidationResult {\n\tif (!domain || typeof domain !== \"string\") {\n\t\treturn { valid: false, error: \"Domain is required\" };\n\t}\n\n\tconst normalized = domain.toLowerCase().trim();\n\n\t// Basic format validation\n\tconst domainRegex = /^[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*\\.[a-z]{2,}$/;\n\tif (!domainRegex.test(normalized)) {\n\t\treturn { valid: false, error: \"Invalid domain format\" };\n\t}\n\n\t// Check for blocked domains\n\tconst { rootDomain, subdomain } = parseDomain(normalized);\n\tif (BLOCKED_DOMAINS.has(rootDomain)) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: `Cannot register public email provider domain: ${rootDomain}`,\n\t\t};\n\t}\n\n\t// Check for reserved subdomains\n\tif (subdomain && RESERVED_SUBDOMAINS.has(subdomain.split(\".\")[0])) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: `Subdomain \"${subdomain}\" is reserved. Please use a different subdomain.`,\n\t\t};\n\t}\n\n\treturn {\n\t\tvalid: true,\n\t\tnormalizedDomain: normalized,\n\t\tisSubdomain: !!subdomain,\n\t\trootDomain,\n\t\tsubdomain: subdomain || undefined,\n\t};\n}\n\n/**\n * Generate platform subdomain for companies without custom domains\n * Format: {company-slug}.mail.stratos.app\n */\nexport function generatePlatformSubdomain(companySlug: string): string {\n\tconst sanitized = companySlug\n\t\t.toLowerCase()\n\t\t.replace(/[^a-z0-9-]/g, \"-\")\n\t\t.replace(/-+/g, \"-\")\n\t\t.replace(/^-|-$/g, \"\");\n\n\tconst platformDomain = process.env.PLATFORM_EMAIL_DOMAIN || \"mail.stratos.app\";\n\treturn `${sanitized}.${platformDomain}`;\n}\n\n/**\n * Generate default sending address for a company\n */\nexport function generateSendingAddress(\n\tcompanySlug: string,\n\tdomain: string,\n\ttype: \"notifications\" | \"support\" | \"billing\" | \"noreply\" = \"notifications\"\n): string {\n\treturn `${type}@${domain}`;\n}\n\n/**\n * Check if company can register more domains\n */\nexport function canRegisterMoreDomains(\n\tcurrentDomainCount: number\n): { allowed: boolean; reason?: string } {\n\tconst config = getDomainConfig();\n\n\tif (currentDomainCount >= config.maxDomainsAllowed) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: `Maximum ${config.maxDomainsAllowed} domain(s) allowed. Contact support if you need more.`,\n\t\t};\n\t}\n\n\treturn { allowed: true };\n}\n\n/**\n * Suggest subdomain options for a domain\n */\nexport function suggestSubdomains(rootDomain: string): string[] {\n\treturn [\n\t\t`mail.${rootDomain}`,\n\t\t`notifications.${rootDomain}`,\n\t\t`updates.${rootDomain}`,\n\t\t`alerts.${rootDomain}`,\n\t\t`messages.${rootDomain}`,\n\t];\n}\n\n/**\n * Validate email address format\n */\nexport function validateEmailAddress(email: string): {\n\tvalid: boolean;\n\terror?: string;\n\tlocal?: string;\n\tdomain?: string;\n} {\n\tconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n\tif (!emailRegex.test(email)) {\n\t\treturn { valid: false, error: \"Invalid email format\" };\n\t}\n\n\tconst [local, domain] = email.split(\"@\");\n\n\tif (local.length > 64) {\n\t\treturn { valid: false, error: \"Local part of email is too long\" };\n\t}\n\n\tif (domain.length > 255) {\n\t\treturn { valid: false, error: \"Domain part of email is too long\" };\n\t}\n\n\treturn { valid: true, local, domain };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/email/resend-domains.ts"],"sourcesContent":["\"use server\";\n\nimport crypto from \"node:crypto\";\nimport {\n\tvalidateDomain,\n\tgeneratePlatformSubdomain,\n\tgetDomainConfig,\n\tcanRegisterMoreDomains,\n\tsuggestSubdomains,\n\ttype DomainValidationResult,\n} from \"./domain-validation\";\n\nconst RESEND_API_BASE = \"https://api.resend.com\";\n\ntype ResendResponse<T> =\n\t| { success: true; data: T }\n\t| { success: false; error: string };\n\ninterface ResendDomainData {\n\tid: string;\n\tname: string;\n\tstatus: string;\n\tregion: string;\n\trecords: Array<{\n\t\ttype: string;\n\t\tname: string;\n\t\tvalue: string;\n\t\tpriority?: number;\n\t\tttl?: string;\n\t}>;\n\tcreated_at: string;\n}\n\ninterface ResendInboundRouteData {\n\tid: string;\n\tname: string;\n\trecipients: string[];\n\turl: string;\n\tenabled: boolean;\n\tcreated_at: string;\n}\n\nasync function resendRequest<T>(\n\tpath: string,\n\tinit: RequestInit\n): Promise<ResendResponse<T>> {\n\tconst apiKey = process.env.RESEND_API_KEY;\n\tif (!apiKey) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Resend API key is not configured\",\n\t\t};\n\t}\n\n\tconst response = await fetch(`${RESEND_API_BASE}${path}`, {\n\t\t...init,\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${apiKey}`,\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...init.headers,\n\t\t},\n\t});\n\n\tif (!response.ok) {\n\t\tconst message =\n\t\t\t(await response.json().catch(() => null))?.message || response.statusText;\n\t\treturn { success: false, error: message };\n\t}\n\n\tconst data = (await response.json().catch(() => ({}))) as T;\n\treturn { success: true, data };\n}\n\n/**\n * Validate and create a Resend domain\n */\nexport async function createResendDomainWithValidation(params: {\n\tdomain: string;\n\tcurrentDomainCount: number;\n\tcompanySlug: string;\n}): Promise<\n\tResendResponse<ResendDomainData> & {\n\t\tvalidation?: DomainValidationResult;\n\t\tsuggestions?: string[];\n\t}\n> {\n\tconst { domain, currentDomainCount } = params;\n\n\t// Check if company can register more domains\n\tconst canRegister = canRegisterMoreDomains(currentDomainCount);\n\tif (!canRegister.allowed) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: canRegister.reason || \"Cannot register more domains\",\n\t\t};\n\t}\n\n\t// Validate the domain\n\tconst validation = validateDomain(domain);\n\tif (!validation.valid) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: validation.error || \"Invalid domain\",\n\t\t\tvalidation,\n\t\t};\n\t}\n\n\t// Create domain in Resend\n\tconst result = await resendRequest<ResendDomainData>(\"/domains\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify({ name: validation.normalizedDomain }),\n\t});\n\n\treturn {\n\t\t...result,\n\t\tvalidation,\n\t};\n}\n\n/**\n * Create a Resend domain (basic, without validation - for internal use)\n */\nexport async function createResendDomain(name: string) {\n\treturn resendRequest<ResendDomainData>(\"/domains\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify({ name }),\n\t});\n}\n\n/**\n * Get domain details from Resend\n */\nexport async function getResendDomain(domainId: string) {\n\treturn resendRequest<ResendDomainData>(`/domains/${domainId}`, {\n\t\tmethod: \"GET\",\n\t});\n}\n\n/**\n * Trigger domain verification in Resend\n */\nexport async function verifyResendDomain(domainId: string) {\n\treturn resendRequest<ResendDomainData>(`/domains/${domainId}/verify`, {\n\t\tmethod: \"POST\",\n\t});\n}\n\n/**\n * Delete a domain from Resend\n */\nexport async function deleteResendDomain(domainId: string) {\n\treturn resendRequest<void>(`/domains/${domainId}`, {\n\t\tmethod: \"DELETE\",\n\t});\n}\n\n/**\n * List all domains in Resend account\n */\nexport async function listResendDomains() {\n\treturn resendRequest<{ data: ResendDomainData[] }>(\"/domains\", {\n\t\tmethod: \"GET\",\n\t});\n}\n\n/**\n * Create an inbound email route\n */\nexport async function createInboundRoute(params: {\n\tname: string;\n\trecipients: string[];\n\turl: string;\n}) {\n\treturn resendRequest<ResendInboundRouteData>(\"/inbound\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(params),\n\t});\n}\n\n/**\n * Delete an inbound route\n */\nexport async function deleteInboundRoute(routeId: string) {\n\treturn resendRequest<void>(`/inbound/${routeId}`, {\n\t\tmethod: \"DELETE\",\n\t});\n}\n\n/**\n * List all inbound routes\n */\nexport async function listInboundRoutes() {\n\treturn resendRequest<{ data: ResendInboundRouteData[] }>(\"/inbound\", {\n\t\tmethod: \"GET\",\n\t});\n}\n\n/**\n * Get domain metrics from Resend (for deliverability monitoring)\n */\nexport async function getResendDomainMetrics(domainId: string) {\n\t// Resend doesn't have a direct metrics endpoint per domain\n\t// We track metrics in our database via webhook events\n\treturn resendRequest<any>(`/domains/${domainId}`, {\n\t\tmethod: \"GET\",\n\t});\n}\n\n/**\n * Verify Resend webhook signature (Svix)\n */\nexport async function verifyResendWebhookSignature({\n\tpayload,\n\theaders,\n}: {\n\tpayload: string;\n\theaders: {\n\t\tsvixId?: string;\n\t\tsvixTimestamp?: string;\n\t\tsvixSignature?: string;\n\t};\n}): Promise<boolean> {\n\tconst secret = process.env.RESEND_WEBHOOK_SECRET;\n\tconst { svixId, svixTimestamp, svixSignature } = headers;\n\n\tif (!secret || !svixId || !svixTimestamp || !svixSignature) {\n\t\treturn false;\n\t}\n\n\t// Svix signature format: v1,<base64_signature>\n\tconst signatures = svixSignature.split(\" \");\n\tconst signedPayload = `${svixId}.${svixTimestamp}.${payload}`;\n\n\t// Try to decode the secret (Svix uses whsec_ prefix)\n\tconst secretBytes = secret.startsWith(\"whsec_\")\n\t\t? Buffer.from(secret.slice(6), \"base64\")\n\t\t: Buffer.from(secret);\n\n\tconst computed = crypto\n\t\t.createHmac(\"sha256\", secretBytes)\n\t\t.update(signedPayload)\n\t\t.digest(\"base64\");\n\n\t// Check against all provided signatures\n\tfor (const sig of signatures) {\n\t\tconst [version, expectedSig] = sig.split(\",\");\n\t\tif (version === \"v1\" && expectedSig === computed) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// =============================================================================\n// RECEIVED EMAIL FUNCTIONS (Inbound)\n// =============================================================================\n\ninterface ReceivedEmailData {\n\tid: string;\n\tfrom: string;\n\tto: string[];\n\tsubject: string;\n\ttext?: string;\n\thtml?: string;\n\tcreated_at: string;\n\tattachments?: { id: string; filename: string; content_type: string }[];\n}\n\ninterface ReceivedAttachmentData {\n\tid: string;\n\tfilename: string;\n\tcontent_type: string;\n\tcontent: string; // base64 encoded\n}\n\n/**\n * Get a received email by ID\n */\nexport async function getReceivedEmail(\n\temailId: string\n): Promise<ResendResponse<ReceivedEmailData>> {\n\treturn resendRequest<ReceivedEmailData>(`/emails/${emailId}`, {\n\t\tmethod: \"GET\",\n\t});\n}\n\n/**\n * List attachments for a received email\n */\nexport async function listReceivedEmailAttachments(\n\temailId: string\n): Promise<ResendResponse<{ data: ReceivedAttachmentData[] }>> {\n\treturn resendRequest<{ data: ReceivedAttachmentData[] }>(\n\t\t`/emails/${emailId}/attachments`,\n\t\t{ method: \"GET\" }\n\t);\n}\n\n/**\n * Get a specific attachment from a received email\n */\nexport async function getReceivedEmailAttachment(\n\temailId: string,\n\tattachmentId: string\n): Promise<ResendResponse<ReceivedAttachmentData>> {\n\treturn resendRequest<ReceivedAttachmentData>(\n\t\t`/emails/${emailId}/attachments/${attachmentId}`,\n\t\t{ method: \"GET\" }\n\t);\n}\n\n/**\n * Verify DNS records for a domain (for onboarding tracker)\n */\nexport async function verifyDomainDNS(domain: string): Promise<{\n\tsuccess: boolean;\n\trecords: Array<{\n\t\tid: string;\n\t\ttype: string;\n\t\tname: string;\n\t\tvalue: string;\n\t\tpurpose: string;\n\t\tverified: boolean;\n\t}>;\n\terror?: string;\n}> {\n\ttry {\n\t\t// First, get all domains to find the one matching our domain\n\t\tconst listResult = await listResendDomains();\n\n\t\tif (!listResult.success || !listResult.data) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\trecords: [],\n\t\t\t\terror: \"Failed to fetch domains from Resend\",\n\t\t\t};\n\t\t}\n\n\t\t// Find the domain by name\n\t\tconst domainData = listResult.data.data?.find((d) => d.name === domain);\n\n\t\tif (!domainData) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\trecords: [],\n\t\t\t\terror: `Domain ${domain} not found in Resend`,\n\t\t\t};\n\t\t}\n\n\t\t// Trigger verification\n\t\tawait verifyResendDomain(domainData.id);\n\n\t\t// Get fresh domain data after verification\n\t\tconst verifyResult = await getResendDomain(domainData.id);\n\n\t\tif (!verifyResult.success || !verifyResult.data) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\trecords: [],\n\t\t\t\terror: \"Failed to verify domain\",\n\t\t\t};\n\t\t}\n\n\t\t// Format records for the tracker\n\t\tconst records = (verifyResult.data.records || []).map((record, index) => ({\n\t\t\tid: `${record.type.toLowerCase()}-${index}`,\n\t\t\ttype: record.type,\n\t\t\tname: record.name,\n\t\t\tvalue: record.value,\n\t\t\tpurpose: getPurposeLabel(record.type),\n\t\t\tverified: verifyResult.data.status === \"verified\",\n\t\t}));\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\trecords,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\trecords: [],\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get purpose label for DNS record type\n */\nfunction getPurposeLabel(type: string): string {\n\tconst purposes: Record<string, string> = {\n\t\tTXT: \"SPF - Authorizes sending\",\n\t\tCNAME: \"DKIM - Email signing\",\n\t\tMX: \"Email routing\",\n\t\tDMARC: \"DMARC - Policy\",\n\t};\n\treturn purposes[type] || \"Email authentication\";\n}\n\n// Re-export validation utilities for convenience\nexport {\n\tvalidateDomain,\n\tgeneratePlatformSubdomain,\n\tgetDomainConfig,\n\tcanRegisterMoreDomains,\n\tsuggestSubdomains,\n\ttype DomainValidationResult,\n};\n"],"names":[],"mappings":"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"}}]
}