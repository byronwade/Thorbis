{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAIsB,wBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAsDsB,yBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA6GsB,oBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAuJsB,0BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA0NsB,qBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAyPsB,sBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA2VsB,sBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA+VsB,oBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAsWsB,mBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA6WsB,sBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAiZsB,0BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}}]
}