{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/ai/memory-service.ts"],"sourcesContent":["/**\n * AI Memory Service - Semantic memory with embeddings (Mem0-style)\n * Based on Mem0 architecture and industry best practices for AI memory systems\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport crypto from \"crypto\";\n\nexport type MemoryType =\n  | \"fact\"\n  | \"preference\"\n  | \"interaction\"\n  | \"context\"\n  | \"entity\"\n  | \"procedure\"\n  | \"feedback\";\n\nexport type MemoryScope = \"user\" | \"company\" | \"global\";\n\nexport interface MemoryEntry {\n  content: string;\n  memoryType: MemoryType;\n  scope: MemoryScope;\n  entityType?: string;\n  entityId?: string;\n  sourceMessageId?: string;\n  sourceChatId?: string;\n  importance?: number;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\nexport interface MemorySearchResult {\n  id: string;\n  content: string;\n  memoryType: string;\n  similarity: number;\n  importance: number;\n  createdAt: string;\n  accessCount: number;\n}\n\n/**\n * Generate embeddings using OpenAI API (or other provider)\n * This is a placeholder - replace with actual embedding generation\n */\nasync function generateEmbedding(text: string): Promise<number[]> {\n  // In production, call OpenAI or another embedding provider\n  // For now, we'll use a simple hash-based approach for testing\n  // This should be replaced with actual embedding generation\n\n  // Check if we have OpenAI API key configured\n  const openaiKey = process.env.OPENAI_API_KEY;\n\n  if (openaiKey) {\n    try {\n      const response = await fetch(\"https://api.openai.com/v1/embeddings\", {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          model: \"text-embedding-3-small\",\n          input: text,\n          dimensions: 1536,\n        }),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.data[0].embedding;\n      }\n    } catch (error) {\n      console.error(\"Failed to generate OpenAI embedding:\", error);\n    }\n  }\n\n  // Fallback: generate a deterministic pseudo-embedding for testing\n  // This allows the system to work without an API key for development\n  const hash = crypto.createHash(\"sha256\").update(text).digest(\"hex\");\n  const embedding: number[] = [];\n\n  for (let i = 0; i < 1536; i++) {\n    // Generate a value between -1 and 1 based on hash\n    const charCode = hash.charCodeAt(i % hash.length);\n    embedding.push((charCode / 128 - 1) * Math.sin(i));\n  }\n\n  // Normalize the vector\n  const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\n  return embedding.map((val) => val / magnitude);\n}\n\n/**\n * Store a new memory with embedding\n */\nexport async function storeMemory(\n  companyId: string,\n  userId: string | undefined,\n  memory: MemoryEntry\n): Promise<string> {\n  const supabase = createServiceSupabaseClient();\n  const memoryId = crypto.randomUUID();\n\n  // Generate embedding for the content\n  const embedding = await generateEmbedding(memory.content);\n\n  // Calculate content hash for deduplication\n  const contentHash = crypto.createHash(\"sha256\").update(memory.content).digest(\"hex\");\n\n  // Check for duplicate content\n  const { data: existing } = await supabase\n    .from(\"ai_memory\")\n    .select(\"id\")\n    .eq(\"company_id\", companyId)\n    .eq(\"content_hash\", contentHash)\n    .maybeSingle();\n\n  if (existing) {\n    // Update access count instead of creating duplicate\n    await supabase\n      .from(\"ai_memory\")\n      .update({\n        access_count: supabase.rpc(\"increment\", { x: 1 }),\n        last_accessed_at: new Date().toISOString(),\n      })\n      .eq(\"id\", existing.id);\n\n    return existing.id;\n  }\n\n  const { error } = await supabase.from(\"ai_memory\").insert({\n    id: memoryId,\n    company_id: companyId,\n    user_id: userId,\n    content: memory.content,\n    content_hash: contentHash,\n    memory_type: memory.memoryType,\n    scope: memory.scope,\n    entity_type: memory.entityType,\n    entity_id: memory.entityId,\n    source_message_id: memory.sourceMessageId,\n    source_chat_id: memory.sourceChatId,\n    embedding,\n    importance: memory.importance || 0.5,\n    access_count: 0,\n    tags: memory.tags || [],\n    metadata: memory.metadata || {},\n    created_at: new Date().toISOString(),\n  });\n\n  if (error) {\n    console.error(\"Failed to store memory:\", error);\n    throw error;\n  }\n\n  return memoryId;\n}\n\n/**\n * Store multiple memories efficiently\n */\nexport async function storeMemories(\n  companyId: string,\n  userId: string | undefined,\n  memories: MemoryEntry[]\n): Promise<string[]> {\n  const memoryIds: string[] = [];\n\n  for (const memory of memories) {\n    try {\n      const id = await storeMemory(companyId, userId, memory);\n      memoryIds.push(id);\n    } catch (error) {\n      console.error(\"Failed to store memory:\", error);\n    }\n  }\n\n  return memoryIds;\n}\n\n/**\n * Search memories by semantic similarity\n */\nexport async function searchMemories(\n  companyId: string,\n  query: string,\n  options?: {\n    userId?: string;\n    scope?: MemoryScope;\n    memoryTypes?: MemoryType[];\n    entityType?: string;\n    entityId?: string;\n    limit?: number;\n    minSimilarity?: number;\n  }\n): Promise<MemorySearchResult[]> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 10;\n  const minSimilarity = options?.minSimilarity || 0.5;\n\n  // Generate embedding for the query\n  const queryEmbedding = await generateEmbedding(query);\n\n  // Use Supabase's vector similarity search\n  // This requires a custom RPC function in Supabase\n  const { data, error } = await supabase.rpc(\"vector_memory_search\", {\n    p_company_id: companyId,\n    p_query_embedding: queryEmbedding,\n    p_user_id: options?.userId || null,\n    p_scope: options?.scope || null,\n    p_memory_types: options?.memoryTypes || null,\n    p_entity_type: options?.entityType || null,\n    p_entity_id: options?.entityId || null,\n    p_limit: limit,\n    p_min_similarity: minSimilarity,\n  });\n\n  if (error) {\n    console.error(\"Failed to search memories:\", error);\n\n    // Fallback to non-vector search if RPC doesn't exist\n    return fallbackSearch(companyId, query, options);\n  }\n\n  // Update access counts for retrieved memories\n  if (data && data.length > 0) {\n    const memoryIds = data.map((m: { id: string }) => m.id);\n    await updateAccessCounts(companyId, memoryIds);\n  }\n\n  return (data || []).map((m: {\n    id: string;\n    content: string;\n    memory_type: string;\n    similarity: number;\n    importance: number;\n    created_at: string;\n    access_count: number;\n  }) => ({\n    id: m.id,\n    content: m.content,\n    memoryType: m.memory_type,\n    similarity: m.similarity,\n    importance: m.importance,\n    createdAt: m.created_at,\n    accessCount: m.access_count,\n  }));\n}\n\n/**\n * Fallback search when vector search RPC is not available\n */\nasync function fallbackSearch(\n  companyId: string,\n  query: string,\n  options?: {\n    userId?: string;\n    scope?: MemoryScope;\n    memoryTypes?: MemoryType[];\n    entityType?: string;\n    entityId?: string;\n    limit?: number;\n  }\n): Promise<MemorySearchResult[]> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 10;\n\n  let dbQuery = supabase\n    .from(\"ai_memory\")\n    .select(\"id, content, memory_type, importance, created_at, access_count\")\n    .eq(\"company_id\", companyId)\n    .is(\"deleted_at\", null)\n    .order(\"importance\", { ascending: false })\n    .limit(limit);\n\n  if (options?.userId) {\n    dbQuery = dbQuery.eq(\"user_id\", options.userId);\n  }\n\n  if (options?.scope) {\n    dbQuery = dbQuery.eq(\"scope\", options.scope);\n  }\n\n  if (options?.memoryTypes && options.memoryTypes.length > 0) {\n    dbQuery = dbQuery.in(\"memory_type\", options.memoryTypes);\n  }\n\n  if (options?.entityType) {\n    dbQuery = dbQuery.eq(\"entity_type\", options.entityType);\n  }\n\n  if (options?.entityId) {\n    dbQuery = dbQuery.eq(\"entity_id\", options.entityId);\n  }\n\n  // Text search fallback\n  dbQuery = dbQuery.ilike(\"content\", `%${query}%`);\n\n  const { data, error } = await dbQuery;\n\n  if (error) {\n    console.error(\"Fallback search failed:\", error);\n    return [];\n  }\n\n  return (data || []).map((m) => ({\n    id: m.id,\n    content: m.content,\n    memoryType: m.memory_type,\n    similarity: 0.5, // No real similarity score in fallback\n    importance: m.importance,\n    createdAt: m.created_at,\n    accessCount: m.access_count,\n  }));\n}\n\n/**\n * Update access counts for retrieved memories\n */\nasync function updateAccessCounts(companyId: string, memoryIds: string[]): Promise<void> {\n  const supabase = createServiceSupabaseClient();\n\n  // Update in batches to avoid long-running transactions\n  for (const id of memoryIds) {\n    await supabase\n      .from(\"ai_memory\")\n      .update({\n        access_count: supabase.sql`access_count + 1`,\n        last_accessed_at: new Date().toISOString(),\n      })\n      .eq(\"id\", id)\n      .eq(\"company_id\", companyId);\n  }\n}\n\n/**\n * Get memories for a specific entity\n */\nexport async function getEntityMemories(\n  companyId: string,\n  entityType: string,\n  entityId: string,\n  options?: { limit?: number; memoryTypes?: MemoryType[] }\n): Promise<\n  Array<{\n    id: string;\n    content: string;\n    memoryType: string;\n    importance: number;\n    createdAt: string;\n  }>\n> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 20;\n\n  let query = supabase\n    .from(\"ai_memory\")\n    .select(\"id, content, memory_type, importance, created_at\")\n    .eq(\"company_id\", companyId)\n    .eq(\"entity_type\", entityType)\n    .eq(\"entity_id\", entityId)\n    .is(\"deleted_at\", null)\n    .order(\"importance\", { ascending: false })\n    .limit(limit);\n\n  if (options?.memoryTypes && options.memoryTypes.length > 0) {\n    query = query.in(\"memory_type\", options.memoryTypes);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error(\"Failed to get entity memories:\", error);\n    return [];\n  }\n\n  return (data || []).map((m) => ({\n    id: m.id,\n    content: m.content,\n    memoryType: m.memory_type,\n    importance: m.importance,\n    createdAt: m.created_at,\n  }));\n}\n\n/**\n * Update memory importance based on usage patterns\n */\nexport async function updateMemoryImportance(\n  companyId: string,\n  memoryId: string,\n  importance: number\n): Promise<void> {\n  const supabase = createServiceSupabaseClient();\n\n  const { error } = await supabase\n    .from(\"ai_memory\")\n    .update({ importance: Math.max(0, Math.min(1, importance)) })\n    .eq(\"id\", memoryId)\n    .eq(\"company_id\", companyId);\n\n  if (error) {\n    console.error(\"Failed to update memory importance:\", error);\n  }\n}\n\n/**\n * Soft delete a memory\n */\nexport async function deleteMemory(companyId: string, memoryId: string): Promise<boolean> {\n  const supabase = createServiceSupabaseClient();\n\n  const { error } = await supabase\n    .from(\"ai_memory\")\n    .update({ deleted_at: new Date().toISOString() })\n    .eq(\"id\", memoryId)\n    .eq(\"company_id\", companyId);\n\n  if (error) {\n    console.error(\"Failed to delete memory:\", error);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Extract and store memories from a conversation\n */\nexport async function extractMemoriesFromConversation(\n  companyId: string,\n  userId: string | undefined,\n  chatId: string,\n  messageId: string,\n  content: string,\n  role: \"user\" | \"assistant\"\n): Promise<string[]> {\n  // This is a simplified extraction - in production, you might use\n  // an LLM to extract structured memories from the conversation\n\n  const memories: MemoryEntry[] = [];\n\n  // Store the interaction itself\n  memories.push({\n    content: content.substring(0, 500), // Limit content length\n    memoryType: \"interaction\",\n    scope: userId ? \"user\" : \"company\",\n    sourceMessageId: messageId,\n    sourceChatId: chatId,\n    importance: 0.5,\n    metadata: { role },\n  });\n\n  // Extract potential facts (very basic - use LLM in production)\n  const factPatterns = [\n    /(?:remember|note|important)[:\\s]+(.+?)(?:\\.|$)/gi,\n    /(?:always|never|usually)[:\\s]+(.+?)(?:\\.|$)/gi,\n  ];\n\n  for (const pattern of factPatterns) {\n    const matches = content.matchAll(pattern);\n    for (const match of matches) {\n      if (match[1] && match[1].length > 10) {\n        memories.push({\n          content: match[1].trim(),\n          memoryType: \"fact\",\n          scope: userId ? \"user\" : \"company\",\n          sourceMessageId: messageId,\n          sourceChatId: chatId,\n          importance: 0.7,\n        });\n      }\n    }\n  }\n\n  return storeMemories(companyId, userId, memories);\n}\n\n/**\n * Get memory statistics for monitoring\n */\nexport async function getMemoryStatistics(\n  companyId: string\n): Promise<{\n  totalMemories: number;\n  byType: Record<string, number>;\n  byScope: Record<string, number>;\n  averageImportance: number;\n  totalAccessCount: number;\n  memoriesLast7Days: number;\n}> {\n  const supabase = createServiceSupabaseClient();\n\n  const { data, error } = await supabase\n    .from(\"ai_memory\")\n    .select(\"memory_type, scope, importance, access_count, created_at\")\n    .eq(\"company_id\", companyId)\n    .is(\"deleted_at\", null);\n\n  if (error || !data) {\n    return {\n      totalMemories: 0,\n      byType: {},\n      byScope: {},\n      averageImportance: 0,\n      totalAccessCount: 0,\n      memoriesLast7Days: 0,\n    };\n  }\n\n  const byType: Record<string, number> = {};\n  const byScope: Record<string, number> = {};\n  let totalImportance = 0;\n  let totalAccessCount = 0;\n  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n  let memoriesLast7Days = 0;\n\n  for (const memory of data) {\n    byType[memory.memory_type] = (byType[memory.memory_type] || 0) + 1;\n    byScope[memory.scope] = (byScope[memory.scope] || 0) + 1;\n    totalImportance += memory.importance;\n    totalAccessCount += memory.access_count;\n\n    if (new Date(memory.created_at as string) > sevenDaysAgo) {\n      memoriesLast7Days++;\n    }\n  }\n\n  return {\n    totalMemories: data.length,\n    byType,\n    byScope,\n    averageImportance: data.length > 0 ? totalImportance / data.length : 0,\n    totalAccessCount,\n    memoriesLast7Days,\n  };\n}\n\n/**\n * Consolidate similar memories to reduce redundancy\n */\nexport async function consolidateMemories(companyId: string): Promise<{\n  consolidated: number;\n  deleted: number;\n}> {\n  // This would use vector similarity to find and merge similar memories\n  // For now, we'll just return zeros - implement with actual consolidation logic\n  console.log(\"Memory consolidation for company:\", companyId);\n\n  return { consolidated: 0, deleted: 0 };\n}\n\n/**\n * Decay old, unused memories to free up space\n */\nexport async function decayOldMemories(\n  companyId: string,\n  options?: {\n    maxAge?: number; // days\n    minAccessCount?: number;\n    dryRun?: boolean;\n  }\n): Promise<{\n  affected: number;\n  deleted: number;\n}> {\n  const supabase = createServiceSupabaseClient();\n  const maxAge = options?.maxAge || 90; // 90 days default\n  const minAccessCount = options?.minAccessCount || 1;\n  const cutoffDate = new Date(Date.now() - maxAge * 24 * 60 * 60 * 1000);\n\n  // Find old, unused memories\n  const { data, error } = await supabase\n    .from(\"ai_memory\")\n    .select(\"id\")\n    .eq(\"company_id\", companyId)\n    .is(\"deleted_at\", null)\n    .lt(\"created_at\", cutoffDate.toISOString())\n    .lte(\"access_count\", minAccessCount);\n\n  if (error || !data) {\n    return { affected: 0, deleted: 0 };\n  }\n\n  if (options?.dryRun) {\n    return { affected: data.length, deleted: 0 };\n  }\n\n  // Soft delete old memories\n  const ids = data.map((m) => m.id);\n  if (ids.length > 0) {\n    await supabase\n      .from(\"ai_memory\")\n      .update({ deleted_at: new Date().toISOString() })\n      .in(\"id\", ids)\n      .eq(\"company_id\", companyId);\n  }\n\n  return { affected: data.length, deleted: data.length };\n}\n"],"names":[],"mappings":"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"}}]
}