{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/email-folders.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { z } from \"zod\";\n\nconst createFolderSchema = z.object({\n\tname: z.string().min(1).max(100),\n\tdescription: z.string().max(500).optional(),\n\tcolor: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),\n\ticon: z.string().optional(),\n});\n\nconst updateFolderSchema = createFolderSchema.partial().extend({\n\tid: z.string().uuid(),\n\tsort_order: z.number().int().optional(),\n});\n\nconst deleteFolderSchema = z.object({\n\tid: z.string().uuid(),\n});\n\nexport type EmailFolder = {\n\tid: string;\n\tcompany_id: string;\n\tname: string;\n\tslug: string;\n\tdescription: string | null;\n\tcolor: string | null;\n\ticon: string | null;\n\tsort_order: number;\n\tis_system: boolean;\n\tis_active: boolean;\n\tcreated_by: string | null;\n\tcreated_at: string;\n\tupdated_at: string;\n\tdeleted_at: string | null;\n};\n\n/**\n * Get all email folders for the active company\n */\nexport async function getEmailFoldersAction(): Promise<{\n\tsuccess: boolean;\n\tfolders?: EmailFolder[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.eq(\"is_active\", true)\n\t\t\t.order(\"sort_order\", { ascending: true })\n\t\t\t.order(\"name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folders: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new email folder\n */\nexport async function createEmailFolderAction(\n\tinput: z.infer<typeof createFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\tfolder?: EmailFolder;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = createFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data: { user } } = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Generate slug from name\n\t\tconst slug = validated.name\n\t\t\t.toLowerCase()\n\t\t\t.trim()\n\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t.replace(/^-+|-+$/g, \"\");\n\n\t\t// Check if slug already exists\n\t\tconst { data: existing } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"slug\", slug)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (existing) {\n\t\t\treturn { success: false, error: \"A folder with this name already exists\" };\n\t\t}\n\n\t\t// Get max sort_order\n\t\tconst { data: maxOrder } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"sort_order\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"sort_order\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tname: validated.name,\n\t\t\t\tslug,\n\t\t\t\tdescription: validated.description || null,\n\t\t\t\tcolor: validated.color || null,\n\t\t\t\ticon: validated.icon || null,\n\t\t\t\tsort_order: (maxOrder?.sort_order || 0) + 1,\n\t\t\t\tcreated_by: user.id,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folder: data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Update an email folder\n * @deprecated Unused\n */\nasync function updateEmailFolderAction(\n\tinput: z.infer<typeof updateFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\tfolder?: EmailFolder;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = updateFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\t// Check folder exists and belongs to company\n\t\tconst { data: existing, error: fetchError } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id, is_system\")\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !existing) {\n\t\t\treturn { success: false, error: \"Folder not found\" };\n\t\t}\n\n\t\tif (existing.is_system) {\n\t\t\treturn { success: false, error: \"Cannot update system folders\" };\n\t\t}\n\n\t\t// If name is being updated, regenerate slug\n\t\tconst updateData: Record<string, unknown> = {};\n\t\tif (validated.name) {\n\t\t\tupdateData.name = validated.name;\n\t\t\tupdateData.slug = validated.name\n\t\t\t\t.toLowerCase()\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-+|-+$/g, \"\");\n\t\t}\n\t\tif (validated.description !== undefined) updateData.description = validated.description;\n\t\tif (validated.color !== undefined) updateData.color = validated.color;\n\t\tif (validated.icon !== undefined) updateData.icon = validated.icon;\n\t\tif (validated.sort_order !== undefined) updateData.sort_order = validated.sort_order;\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folder: data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Delete an email folder (soft delete)\n */\nexport async function deleteEmailFolderAction(\n\tinput: z.infer<typeof deleteFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = deleteFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data: { user } } = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Check folder exists and belongs to company\n\t\tconst { data: existing, error: fetchError } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id, is_system\")\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !existing) {\n\t\t\treturn { success: false, error: \"Folder not found\" };\n\t\t}\n\n\t\tif (existing.is_system) {\n\t\t\treturn { success: false, error: \"Cannot delete system folders\" };\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tis_active: false,\n\t\t\t})\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n"],"names":[],"mappings":";;;;;;;IAmFsB,0BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/email-actions.ts"],"sourcesContent":["\"use server\";\n\nimport {\n    archiveAllEmails,\n    getCompanyEmails,\n    getEmailById,\n    getEmailStats,\n    getEmailThreads,\n    markEmailAsRead,\n    type CompanyEmail,\n} from \"@/lib/email/email-service\";\nimport { z } from \"zod\";\n\nconst getEmailsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  inboxType: z.enum([\"personal\", \"company\"]).optional(),\n  folder: z.enum([\"inbox\", \"drafts\", \"sent\", \"archive\", \"snoozed\", \"spam\", \"trash\", \"bin\", \"starred\", \"all\"]).optional(),\n  category: z.enum([\"support\", \"sales\", \"billing\", \"general\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\", \"subject\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst getEmailThreadsSchema = z.object({\n  limit: z.number().min(1).max(50).optional().default(20),\n  offset: z.number().min(0).optional().default(0),\n  search: z.string().optional(),\n});\n\nconst markEmailReadSchema = z.object({\n  emailId: z.string().min(1),\n});\n\nexport type GetEmailsInput = z.infer<typeof getEmailsSchema>;\nexport type GetEmailThreadsInput = z.infer<typeof getEmailThreadsSchema>;\nexport type MarkEmailReadInput = z.infer<typeof markEmailReadSchema>;\n\n// Re-export email types from email-service\nexport type { CompanyEmail };\n\nexport type GetEmailsResult = Awaited<ReturnType<typeof getCompanyEmails>>;\nexport type GetEmailThreadsResult = Awaited<ReturnType<typeof getEmailThreads>>;\nexport type GetEmailStatsResult = Awaited<ReturnType<typeof getEmailStats>>;\n\n/**\n * Get emails for the active company\n */\nexport async function getEmailsAction(\n  input: GetEmailsInput\n): Promise<GetEmailsResult> {\n  try {\n    const parseResult = getEmailsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      console.error(\"❌ Zod validation error:\", parseResult.error.issues);\n      throw new Error(`Invalid input parameters: ${parseResult.error.issues.map((e) => `${e.path.map(String).join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    // Convert null to undefined for search field\n    const sanitizedInput = {\n      ...validatedInput,\n      search: validatedInput.search ?? undefined,\n    };\n    return await getCompanyEmails(companyId, sanitizedInput);\n  } catch (error) {\n    console.error(\"❌ getEmailsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get email threads for the active company\n */\nasync function getEmailThreadsAction(\n  input: GetEmailThreadsInput\n): Promise<GetEmailThreadsResult> {\n  try {\n    const validatedInput = getEmailThreadsSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailThreads(companyId, validatedInput);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Get a specific email by ID\n */\nexport async function getEmailByIdAction(emailId: string): Promise<{\n  success: boolean;\n  email?: CompanyEmail;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const email = await getEmailById(companyId, emailId);\n    \n    if (!email) {\n      return { success: false, error: \"Email not found\" };\n    }\n\n    return { success: true, email };\n  } catch (error) {\n    console.error(\"Error getting email by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an email as read\n */\nexport async function markEmailAsReadAction(\n  input: MarkEmailReadInput\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const validatedInput = markEmailReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const result = await markEmailAsRead(companyId, validatedInput.emailId);\n    if (!result) {\n      return { success: false, error: \"Failed to mark email as read - check server logs for details\" };\n    }\n    return { success: true };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, error: `Invalid input: ${error.issues.map((e: { message: string }) => e.message).join(\", \")}` };\n    }\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    console.error(\"Error marking email as read:\", error);\n    return { success: false, error: errorMessage };\n  }\n}\n\n/**\n * Get email statistics for the active company\n */\nasync function getEmailStatsAction(): Promise<GetEmailStatsResult> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailStats();\n  } catch (error) {\n    console.error(\"Error getting email stats:\", error);\n    return {\n      totalEmails: 0,\n      sentEmails: 0,\n      receivedEmails: 0,\n      unreadEmails: 0,\n      threadsCount: 0,\n    };\n  }\n}\n\n/**\n * Get total unread email count for the active company\n * Used for displaying notification badges in the header\n */\nexport async function getTotalUnreadCountAction(): Promise<{\n  success: boolean;\n  count?: number;\n  error?: string\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const stats = await getEmailStats();\n    return { success: true, count: stats.unreadEmails };\n  } catch (error) {\n    console.error(\"Error getting unread count:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Fetch email content from Resend API or update with provided content\n */\nexport async function fetchEmailContentAction(\n  emailId: string,\n  _resendEmailId?: string,\n  providedContent?: { html?: string | null; text?: string | null }\n): Promise<{\n  success: boolean;\n  html?: string | null;\n  text?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    let html: string | null = null;\n    let text: string | null = null;\n\n    // If content is provided directly, use it\n    if (providedContent) {\n      html = providedContent.html || null;\n      text = providedContent.text || null;\n    } else {\n      // First, try to get email from database to check for content in metadata\n      const { data: email, error: emailError } = await supabase\n        .from(\"communications\")\n        .select(\"provider_message_id, provider_metadata, body, body_html\")\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId)\n        .single();\n\n      if (emailError) {\n        // Don't return error for PGRST errors that might be expected\n        if (emailError.code === 'PGRST116') {\n          return { success: false, error: \"Email not found in database\" };\n        }\n        return { success: false, error: `Database error: ${emailError.message}` };\n      }\n\n      if (!email) {\n        return { success: false, error: \"Email not found in database\" };\n      }\n\n      // Check if email already has content stored\n      if (email.body_html || email.body) {\n        html = email.body_html || null;\n        text = email.body || null;\n      } else if (email.provider_metadata) {\n        // Try to extract content from provider_metadata\n        const metadata = email.provider_metadata as Record<string, unknown>;\n        \n        // PRIORITY 1: Check webhook_content first (webhook payload - most reliable source)\n        const webhookContent = metadata.webhook_content as Record<string, unknown> | undefined;\n        if (webhookContent) {\n          const htmlValue = webhookContent.html || webhookContent.body_html;\n          const textValue = webhookContent.text || webhookContent.body;\n          \n          if (htmlValue && typeof htmlValue === \"string\") {\n            const content = htmlValue.trim();\n            if (content.length > 0) {\n              html = content;\n            }\n          }\n          if (!html && textValue && typeof textValue === \"string\") {\n            const content = textValue.trim();\n            if (content.length > 0) {\n              text = content;\n            }\n          }\n        }\n\n        // PRIORITY 2: Check full_content (API response) if webhook didn't have content\n        if (!html && !text) {\n          const fullContent = metadata.full_content as Record<string, unknown> | undefined;\n          if (fullContent) {\n            const htmlFields = [\"html\", \"body_html\", \"bodyHtml\"];\n            const textFields = [\"text\", \"body\", \"plain_text\", \"plainText\"];\n\n            // Try HTML fields first\n            for (const field of htmlFields) {\n              if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                const content = (fullContent[field] as string).trim();\n                if (content.length > 0) {\n                  html = content;\n                  break;\n                }\n              }\n            }\n\n            // If no HTML, try text fields\n            if (!html) {\n              for (const field of textFields) {\n                if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                  const content = (fullContent[field] as string).trim();\n                  if (content.length > 0) {\n                    text = content;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // PRIORITY 3: Check top-level metadata.data for content (webhook payload structure)\n        if (!html && !text) {\n          const webhookData = metadata.data as Record<string, unknown> | undefined;\n          if (webhookData) {\n            const htmlValue = webhookData.html || webhookData.body_html;\n            const textValue = webhookData.text || webhookData.body;\n            \n            if (htmlValue && typeof htmlValue === \"string\") {\n              const content = htmlValue.trim();\n              if (content.length > 0) {\n                html = content;\n              }\n            }\n            if (!html && textValue && typeof textValue === \"string\") {\n              const content = textValue.trim();\n              if (content.length > 0) {\n                text = content;\n              }\n            }\n          }\n        }\n\n        // PRIORITY 4: Check top-level metadata fields directly\n        if (!html && !text) {\n          const htmlFields = [\"html\", \"body_html\"];\n          const textFields = [\"text\", \"body\"];\n          \n          for (const field of htmlFields) {\n            if (metadata[field] && typeof metadata[field] === \"string\") {\n              const content = (metadata[field] as string).trim();\n              if (content.length > 0) {\n                html = content;\n                break;\n              }\n            }\n          }\n          \n          if (!html) {\n            for (const field of textFields) {\n              if (metadata[field] && typeof metadata[field] === \"string\") {\n                const content = (metadata[field] as string).trim();\n                if (content.length > 0) {\n                  text = content;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // If we found content in metadata, use it and return early\n        if (html || text) {\n          // Update database with extracted content\n          if ((html || text) && supabase) {\n            const { error: updateError } = await supabase\n              .from(\"communications\")\n              .update({\n                body: text || \"\",\n                body_html: html,\n              })\n              .eq(\"id\", emailId)\n              .eq(\"company_id\", companyId);\n\n            if (updateError) {\n              console.warn(\"⚠️  Failed to update email content in database:\", updateError.message);\n            }\n          }\n          return { success: true, html, text };\n        } else {\n          // No content found in metadata\n          return {\n            success: false,\n            error: \"No email content available in metadata\"\n          };\n        }\n      } else {\n        // No metadata at all, can't fetch content\n        return { success: false, error: \"No email metadata available\" };\n      }\n    }\n\n    // Update the database with the content\n    // Try to update, but don't fail if the email doesn't exist - we still return the content\n    if (supabase) {\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update({\n          body: text || \"\",\n          body_html: html,\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      if (updateError) {\n        console.warn(\"⚠️  Failed to update email content in database (this is OK, content still returned):\", updateError.message);\n      }\n    }\n\n    return { success: true, html, text };\n  } catch (error) {\n    console.error(\"Error fetching email content:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Sync inbound email routes from database to Resend\n * Creates routes in Resend that don't have a resend_route_id\n */\nexport async function syncInboundRoutesToResendAction(): Promise<{\n  success: boolean;\n  synced: number;\n  errors: string[];\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { createInboundRoute } = await import(\"@/lib/email/resend-domains\");\n    const { createServiceSupabaseClient } = await import(\"@/lib/supabase/service-client\");\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, synced: 0, errors: [\"Database connection failed\"] };\n    }\n\n    const serviceSupabase = await createServiceSupabaseClient();\n    if (!serviceSupabase) {\n      return { success: false, synced: 0, errors: [\"Service database connection failed\"] };\n    }\n\n    // Get all routes that don't have a resend_route_id\n    // Note: This table may not be in the type definitions, so we use type assertion\n    const { data: routes, error } = await (serviceSupabase\n      .from(\"communication_email_inbound_routes\" as any)\n      .select(\"id, company_id, route_address, name, enabled\")\n      .is(\"resend_route_id\", null)\n      .eq(\"enabled\", true) as any);\n\n    if (error) {\n      console.error(\"Failed to fetch routes:\", error);\n      return { success: false, synced: 0, errors: [error.message] };\n    }\n\n    if (!routes || routes.length === 0) {\n      return { success: true, synced: 0, errors: [] };\n    }\n\n    // Construct webhook URL\n    let webhookUrl = process.env.NEXT_PUBLIC_SITE_URL;\n    if (!webhookUrl && process.env.VERCEL_URL) {\n      webhookUrl = `https://${process.env.VERCEL_URL}`;\n    }\n    if (!webhookUrl) {\n      return { success: false, synced: 0, errors: [\"Webhook URL not configured. Set NEXT_PUBLIC_SITE_URL or VERCEL_URL\"] };\n    }\n    webhookUrl = `${webhookUrl}/api/webhooks/resend`;\n\n    const errors: string[] = [];\n    let synced = 0;\n\n    for (const route of (routes || []) as Array<{ id: string; company_id: string; route_address: string; name: string | null; enabled: boolean }>) {\n      try {\n        // Handle catch-all routes (e.g., @biezru.resend.app)\n        // Resend doesn't support true catch-all, so we'll create a route for the domain\n        // For now, we'll skip catch-all routes and handle them differently\n        if (route.route_address.startsWith(\"@\")) {\n          errors.push(`Catch-all routes (${route.route_address}) need to be configured manually in Resend dashboard`);\n          continue;\n        }\n\n        // Create route in Resend\n        const result = await createInboundRoute({\n          name: route.name || `Route for ${route.route_address}`,\n          recipients: [route.route_address],\n          url: webhookUrl,\n        });\n\n        if (!result.success) {\n          console.error(`❌ Failed to create Resend route for ${route.route_address}:`, result.error);\n          errors.push(`${route.route_address}: ${result.error}`);\n          continue;\n        }\n\n        // Update database with resend_route_id\n        const { error: updateError } = await (serviceSupabase\n          .from(\"communication_email_inbound_routes\" as any)\n          .update({\n            resend_route_id: result.data.id,\n            signing_secret: result.data.secret || null,\n            last_synced_at: new Date().toISOString(),\n          })\n          .eq(\"id\", route.id) as any);\n\n        if (updateError) {\n          console.error(`❌ Failed to update route ${route.route_address}:`, updateError);\n          errors.push(`${route.route_address}: Database update failed`);\n          continue;\n        }\n\n        synced++;\n      } catch (error) {\n        console.error(`❌ Error syncing route ${route.route_address}:`, error);\n        errors.push(`${route.route_address}: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      synced,\n      errors,\n    };\n  } catch (error) {\n    console.error(\"Error syncing inbound routes:\", error);\n    return {\n      success: false,\n      synced: 0,\n      errors: [error instanceof Error ? error.message : \"Unknown error\"],\n    };\n  }\n}\n\n/**\n * Archive an email\n */\nexport async function archiveEmailAction(emailId: string): Promise<{ success: boolean; error?: string }> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const { error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n    \n    if (error) {\n      return { success: false, error: error.message };\n    }\n    \n    return { success: true };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk archive multiple emails by their IDs\n */\nexport async function bulkArchiveEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  archived: number;\n  error?: string\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, archived: 0, error: \"No email IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, archived: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, archived: 0, error: error.message };\n    }\n\n    const archivedCount = data?.length ?? 0;\n    return { success: true, archived: archivedCount };\n  } catch (error) {\n    return { success: false, archived: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Archive all emails in a folder\n */\nexport async function archiveAllEmailsAction(folder?: string): Promise<{ \n  success: boolean; \n  archived: number;\n  error?: string \n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n    \n    const result = await archiveAllEmails(companyId, folder);\n    \n    if (!result.success) {\n      return { success: false, archived: 0, error: result.error };\n    }\n    \n    return { success: true, archived: result.count };\n  } catch (error) {\n    return {\n      success: false,\n      archived: 0,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Get email folder counts for the active company\n * Returns count of emails in each folder (inbox, sent, drafts, etc.)\n */\nexport async function getEmailFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    all: number;\n    inbox: number;\n    drafts: number;\n    sent: number;\n    archive: number;\n    snoozed: number;\n    spam: number;\n    trash: number;\n    starred: number;\n    [key: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get counts for each folder type using parallel queries\n    // All counts show UNREAD emails only (read_at IS NULL)\n    const [\n      allResult,\n      inboxResult,\n      draftsResult,\n      sentResult,\n      archiveResult,\n      snoozedResult,\n      spamResult,\n      trashResult,\n      starredResult\n    ] = await Promise.all([\n      // All Mail: all non-deleted, unread emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Inbox: inbound, not archived, not deleted, not draft, not spam, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\")\n        .or(\"category.is.null,category.neq.spam\")\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n\n      // Drafts - always count all drafts (read_at not relevant for drafts)\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"status\", \"draft\")\n        .is(\"deleted_at\", null),\n\n      // Sent: outbound, not archived, not deleted, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\"),\n\n      // Archive - unread archived emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"is_archived\", true)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Snoozed - unread snoozed emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"snoozed_until\", \"is\", null)\n        .gt(\"snoozed_until\", new Date().toISOString())\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Spam - fetch category, tags, and read_at to count unread spam\n      supabase\n        .from(\"communications\")\n        .select(\"category, tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Trash - unread deleted emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"deleted_at\", \"is\", null)\n        .is(\"read_at\", null),\n\n      // Starred - fetch tags and read_at, count unread starred in memory\n      supabase\n        .from(\"communications\")\n        .select(\"tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n    ]);\n\n    // Count spam emails in memory (category=spam OR spam tag)\n    const spamCount = (spamResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      const hasSpamTag = Array.isArray(tags) && tags.includes(\"spam\");\n      return email.category === \"spam\" || hasSpamTag;\n    }).length;\n\n    // Count starred emails in memory\n    const starredCount = (starredResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      return Array.isArray(tags) && tags.includes(\"starred\");\n    }).length;\n\n    return {\n      success: true,\n      counts: {\n        all: allResult.count ?? 0,\n        inbox: inboxResult.count ?? 0,\n        drafts: draftsResult.count ?? 0,\n        sent: sentResult.count ?? 0,\n        archive: archiveResult.count ?? 0,\n        snoozed: snoozedResult.count ?? 0,\n        spam: spamCount,\n        trash: trashResult.count ?? 0,\n        starred: starredCount,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting email folder counts:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Toggle star status on an email\n * Adds or removes \"starred\" tag from the email's tags array\n */\nexport async function toggleStarEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isStarred?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlyStarred = currentTags.includes(\"starred\");\n\n    // Toggle the starred tag\n    const newTags = isCurrentlyStarred\n      ? currentTags.filter(tag => tag !== \"starred\")\n      : [...currentTags, \"starred\"];\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ tags: newTags.length > 0 ? newTags : null })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isStarred: !isCurrentlyStarred };\n  } catch (error) {\n    console.error(\"Error toggling star on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Toggle spam status on an email\n * Adds or removes \"spam\" tag and updates category field\n */\nexport async function toggleSpamEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isSpam?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags and category\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags, category\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlySpam = currentTags.includes(\"spam\") || email?.category === \"spam\";\n\n    // Toggle the spam tag and category\n    const newTags = isCurrentlySpam\n      ? currentTags.filter(tag => tag !== \"spam\")\n      : [...currentTags, \"spam\"];\n\n    const newCategory = isCurrentlySpam ? null : \"spam\";\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        tags: newTags.length > 0 ? newTags : null,\n        category: newCategory\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isSpam: !isCurrentlySpam };\n  } catch (error) {\n    console.error(\"Error toggling spam on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Snooze an email until a specific time\n * The email will reappear in inbox after the snooze time\n */\nexport async function snoozeEmailAction(\n  emailId: string,\n  snoozeUntil: string | null\n): Promise<{\n  success: boolean;\n  snoozedUntil?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Update the snoozed_until field\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ snoozed_until: snoozeUntil })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, snoozedUntil: snoozeUntil };\n  } catch (error) {\n    console.error(\"Error snoozing email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Unsnooze an email (remove snooze time)\n */\nexport async function unsnoozeEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  return snoozeEmailAction(emailId, null);\n}\n\n/**\n * Bulk mark emails as read or unread\n */\nexport async function bulkMarkReadUnreadAction(\n  emailIds: string[],\n  markAsRead: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ read_at: markAsRead ? new Date().toISOString() : null })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, updated: 0, error: error.message };\n    }\n\n    // Dispatch event to refresh counts\n    return { success: true, updated: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk marking emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk toggle star on emails\n */\nexport async function bulkStarEmailsAction(\n  emailIds: string[],\n  addStar: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Group emails by what changes need to be made\n    const toUpdate: Array<{ id: string; newTags: string[] | null }> = [];\n\n    for (const email of emails) {\n      const currentTags = (email.tags as string[]) || [];\n      const hasStarred = currentTags.includes(\"starred\");\n\n      let newTags: string[];\n      if (addStar && !hasStarred) {\n        newTags = [...currentTags, \"starred\"];\n      } else if (!addStar && hasStarred) {\n        newTags = currentTags.filter((t) => t !== \"starred\");\n      } else {\n        continue; // No change needed\n      }\n\n      toUpdate.push({ id: email.id, newTags: newTags.length > 0 ? newTags : null });\n    }\n\n    if (toUpdate.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      toUpdate.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const updatedCount = results.filter((r) => !r.error).length;\n    return { success: true, updated: updatedCount };\n  } catch (error) {\n    console.error(\"Error bulk starring emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk delete emails (move to trash)\n */\nexport async function bulkDeleteEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  deleted: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, deleted: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, deleted: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, deleted: 0, error: \"Database connection failed\" };\n    }\n\n    // Soft delete by setting deleted_at\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ deleted_at: new Date().toISOString() })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, deleted: 0, error: error.message };\n    }\n\n    return { success: true, deleted: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk deleting emails:\", error);\n    return { success: false, deleted: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk move emails to spam\n */\nexport async function bulkMoveToSpamAction(emailIds: string[]): Promise<{\n  success: boolean;\n  moved: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, moved: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, moved: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, moved: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, moved: 0 };\n    }\n\n    // Prepare updates with new tags\n    const updates = emails.map((email) => {\n      const currentTags = (email.tags as string[]) || [];\n      const newTags = currentTags.includes(\"spam\")\n        ? currentTags\n        : [...currentTags, \"spam\"];\n      return { id: email.id, newTags };\n    });\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      updates.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ category: \"spam\", tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const movedCount = results.filter((r) => !r.error).length;\n    return { success: true, moved: movedCount };\n  } catch (error) {\n    console.error(\"Error moving emails to spam:\", error);\n    return { success: false, moved: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// DRAFT ACTIONS\n// ============================================================================\n\nconst saveDraftSchema = z.object({\n  id: z.string().uuid().optional(), // If provided, update existing draft\n  to: z.array(z.string().email()).optional().default([]),\n  cc: z.array(z.string().email()).optional().default([]),\n  bcc: z.array(z.string().email()).optional().default([]),\n  subject: z.string().optional().default(\"\"),\n  body: z.string().optional().default(\"\"),\n  bodyHtml: z.string().optional(),\n  customerId: z.string().uuid().optional(),\n  attachments: z.array(z.object({\n    filename: z.string(),\n    content: z.string(),\n    contentType: z.string().optional(),\n  })).optional(),\n});\n\nexport type SaveDraftInput = z.infer<typeof saveDraftSchema>;\n\n/**\n * Save or update an email draft\n * If id is provided, updates existing draft; otherwise creates a new one\n */\nexport async function saveDraftAction(input: SaveDraftInput): Promise<{\n  success: boolean;\n  draftId?: string;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const parseResult = saveDraftSchema.safeParse(input);\n    if (!parseResult.success) {\n      return { success: false, error: `Invalid input: ${parseResult.error.message}` };\n    }\n\n    const { id, to, cc, bcc, subject, body, bodyHtml, customerId, attachments } = parseResult.data;\n\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the company's default email address for from_address\n    const { data: companySettings } = await supabase\n      .from(\"company_communication_settings\")\n      .select(\"email_from_address, email_from_name\")\n      .eq(\"company_id\", companyId)\n      .single();\n\n    const fromAddress = companySettings?.email_from_address || \"noreply@example.com\";\n    const fromName = companySettings?.email_from_name || \"Draft\";\n\n    const draftData = {\n      company_id: companyId,\n      customer_id: customerId || null,\n      type: \"email\" as const,\n      direction: \"outbound\" as const,\n      from_address: fromAddress,\n      from_name: fromName,\n      to_address: to.length > 0 ? to.join(\", \") : \"draft@placeholder.local\",\n      cc_address: cc.length > 0 ? cc.join(\", \") : null,\n      bcc_address: bcc.length > 0 ? bcc.join(\", \") : null,\n      subject: subject || \"(No subject)\",\n      body: body || \"\",\n      body_html: bodyHtml || null,\n      attachments: attachments && attachments.length > 0 ? attachments : null,\n      attachment_count: attachments?.length || 0,\n      status: \"draft\" as const,\n      is_automated: false,\n      is_internal: false,\n      is_archived: false,\n      is_thread_starter: true,\n      priority: \"normal\" as const,\n      updated_at: new Date().toISOString(),\n    };\n\n    if (id) {\n      // Update existing draft\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update(draftData)\n        .eq(\"id\", id)\n        .eq(\"company_id\", companyId)\n        .eq(\"status\", \"draft\");\n\n      if (updateError) {\n        console.error(\"Error updating draft:\", updateError);\n        return { success: false, error: updateError.message };\n      }\n\n      return { success: true, draftId: id };\n    } else {\n      // Create new draft\n      const { data: newDraft, error: insertError } = await supabase\n        .from(\"communications\")\n        .insert({\n          ...draftData,\n          created_at: new Date().toISOString(),\n        })\n        .select(\"id\")\n        .single();\n\n      if (insertError) {\n        console.error(\"Error creating draft:\", insertError);\n        return { success: false, error: insertError.message };\n      }\n\n      return { success: true, draftId: newDraft.id };\n    }\n  } catch (error) {\n    console.error(\"Error saving draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Get a draft by ID\n */\nexport async function getDraftAction(draftId: string): Promise<{\n  success: boolean;\n  draft?: {\n    id: string;\n    to: string[];\n    cc: string[];\n    bcc: string[];\n    subject: string;\n    body: string;\n    bodyHtml?: string | null;\n    customerId?: string | null;\n    attachments?: Array<{ filename: string; content: string; contentType?: string }> | null;\n    updatedAt: string;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const { data: draft, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"id, to_address, cc_address, bcc_address, subject, body, body_html, customer_id, attachments, updated_at\")\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!draft) {\n      return { success: false, error: \"Draft not found\" };\n    }\n\n    // Parse addresses from comma-separated strings to arrays\n    const parseAddresses = (addr: string | null): string[] => {\n      if (!addr || addr === \"draft@placeholder.local\") return [];\n      return addr.split(\",\").map(a => a.trim()).filter(Boolean);\n    };\n\n    return {\n      success: true,\n      draft: {\n        id: draft.id,\n        to: parseAddresses(draft.to_address),\n        cc: parseAddresses(draft.cc_address),\n        bcc: parseAddresses(draft.bcc_address),\n        subject: draft.subject === \"(No subject)\" ? \"\" : (draft.subject || \"\"),\n        body: draft.body || \"\",\n        bodyHtml: draft.body_html,\n        customerId: draft.customer_id,\n        attachments: draft.attachments as Array<{ filename: string; content: string; contentType?: string }> | null,\n        updatedAt: draft.updated_at,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Delete a draft\n */\nexport async function deleteDraftAction(draftId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Hard delete drafts (they don't need to go to trash)\n    const { error: deleteError } = await supabase\n      .from(\"communications\")\n      .delete()\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\");\n\n    if (deleteError) {\n      return { success: false, error: deleteError.message };\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// RETRY ACTIONS\n// ============================================================================\n\n/**\n * Retry sending a failed email\n * Fetches the failed email, resets its status, and attempts to resend\n */\nexport async function retryFailedEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const { sendEmail } = await import(\"@/lib/email/email-sender\");\n    const { PlainTextEmail } = await import(\"@/emails/plain-text-email\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the failed email\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"*\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .eq(\"status\", \"failed\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!email) {\n      return { success: false, error: \"Failed email not found\" };\n    }\n\n    // Reset status to queued\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        status: \"queued\",\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    if (updateError) {\n      return { success: false, error: `Failed to reset email status: ${updateError.message}` };\n    }\n\n    // Parse recipients\n    const parseAddresses = (addr: string | null): string | string[] => {\n      if (!addr) return [];\n      const addresses = addr.split(\",\").map(a => a.trim()).filter(Boolean);\n      return addresses.length === 1 ? addresses[0] : addresses;\n    };\n\n    const to = parseAddresses(email.to_address);\n    const cc = parseAddresses(email.cc_address);\n    const bcc = parseAddresses(email.bcc_address);\n\n    // Get attachments from metadata if stored (for scheduled emails)\n    const metadata = email.provider_metadata as Record<string, unknown> | null;\n    const attachments = metadata?.scheduled_attachments as Array<{\n      filename: string;\n      content: string;\n      contentType?: string;\n    }> | undefined;\n\n    // Attempt to resend\n    const sendResult = await sendEmail({\n      to,\n      subject: email.subject || \"(No subject)\",\n      template: PlainTextEmail({ message: email.body || \"\" }),\n      templateType: \"generic\" as any,\n      companyId,\n      communicationId: emailId,\n      cc: cc.length > 0 ? cc : undefined,\n      bcc: bcc.length > 0 ? bcc : undefined,\n      attachments,\n    });\n\n    if (!sendResult.success) {\n      // Update status back to failed\n      await supabase\n        .from(\"communications\")\n        .update({\n          status: \"failed\",\n          failure_reason: sendResult.error || \"Email send failed on retry\",\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      return {\n        success: false,\n        error: sendResult.error || \"Failed to send email on retry\",\n      };\n    }\n\n    // Update status to sent\n    await supabase\n      .from(\"communications\")\n      .update({\n        status: \"sent\",\n        sent_at: new Date().toISOString(),\n        provider_message_id: sendResult.data?.id || null,\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error retrying failed email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IA6qBsB,6BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/email-folders.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { z } from \"zod\";\n\nconst createFolderSchema = z.object({\n\tname: z.string().min(1).max(100),\n\tdescription: z.string().max(500).optional(),\n\tcolor: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),\n\ticon: z.string().optional(),\n});\n\nconst updateFolderSchema = createFolderSchema.partial().extend({\n\tid: z.string().uuid(),\n\tsort_order: z.number().int().optional(),\n});\n\nconst deleteFolderSchema = z.object({\n\tid: z.string().uuid(),\n});\n\nexport type EmailFolder = {\n\tid: string;\n\tcompany_id: string;\n\tname: string;\n\tslug: string;\n\tdescription: string | null;\n\tcolor: string | null;\n\ticon: string | null;\n\tsort_order: number;\n\tis_system: boolean;\n\tis_active: boolean;\n\tcreated_by: string | null;\n\tcreated_at: string;\n\tupdated_at: string;\n\tdeleted_at: string | null;\n};\n\n/**\n * Get all email folders for the active company\n */\nexport async function getEmailFoldersAction(): Promise<{\n\tsuccess: boolean;\n\tfolders?: EmailFolder[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.eq(\"is_active\", true)\n\t\t\t.order(\"sort_order\", { ascending: true })\n\t\t\t.order(\"name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folders: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new email folder\n */\nexport async function createEmailFolderAction(\n\tinput: z.infer<typeof createFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\tfolder?: EmailFolder;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = createFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data: { user } } = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Generate slug from name\n\t\tconst slug = validated.name\n\t\t\t.toLowerCase()\n\t\t\t.trim()\n\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t.replace(/^-+|-+$/g, \"\");\n\n\t\t// Check if slug already exists\n\t\tconst { data: existing } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"slug\", slug)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (existing) {\n\t\t\treturn { success: false, error: \"A folder with this name already exists\" };\n\t\t}\n\n\t\t// Get max sort_order\n\t\tconst { data: maxOrder } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"sort_order\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"sort_order\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tname: validated.name,\n\t\t\t\tslug,\n\t\t\t\tdescription: validated.description || null,\n\t\t\t\tcolor: validated.color || null,\n\t\t\t\ticon: validated.icon || null,\n\t\t\t\tsort_order: (maxOrder?.sort_order || 0) + 1,\n\t\t\t\tcreated_by: user.id,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folder: data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Update an email folder\n * @deprecated Unused\n */\nasync function updateEmailFolderAction(\n\tinput: z.infer<typeof updateFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\tfolder?: EmailFolder;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = updateFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\t// Check folder exists and belongs to company\n\t\tconst { data: existing, error: fetchError } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id, is_system\")\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !existing) {\n\t\t\treturn { success: false, error: \"Folder not found\" };\n\t\t}\n\n\t\tif (existing.is_system) {\n\t\t\treturn { success: false, error: \"Cannot update system folders\" };\n\t\t}\n\n\t\t// If name is being updated, regenerate slug\n\t\tconst updateData: Record<string, unknown> = {};\n\t\tif (validated.name) {\n\t\t\tupdateData.name = validated.name;\n\t\t\tupdateData.slug = validated.name\n\t\t\t\t.toLowerCase()\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-+|-+$/g, \"\");\n\t\t}\n\t\tif (validated.description !== undefined) updateData.description = validated.description;\n\t\tif (validated.color !== undefined) updateData.color = validated.color;\n\t\tif (validated.icon !== undefined) updateData.icon = validated.icon;\n\t\tif (validated.sort_order !== undefined) updateData.sort_order = validated.sort_order;\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folder: data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Delete an email folder (soft delete)\n */\nexport async function deleteEmailFolderAction(\n\tinput: z.infer<typeof deleteFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = deleteFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data: { user } } = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Check folder exists and belongs to company\n\t\tconst { data: existing, error: fetchError } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id, is_system\")\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !existing) {\n\t\t\treturn { success: false, error: \"Folder not found\" };\n\t\t}\n\n\t\tif (existing.is_system) {\n\t\t\treturn { success: false, error: \"Cannot delete system folders\" };\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tis_active: false,\n\t\t\t})\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n"],"names":[],"mappings":";;;;;;;IA0CsB,wBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/email-folders.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { z } from \"zod\";\n\nconst createFolderSchema = z.object({\n\tname: z.string().min(1).max(100),\n\tdescription: z.string().max(500).optional(),\n\tcolor: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),\n\ticon: z.string().optional(),\n});\n\nconst updateFolderSchema = createFolderSchema.partial().extend({\n\tid: z.string().uuid(),\n\tsort_order: z.number().int().optional(),\n});\n\nconst deleteFolderSchema = z.object({\n\tid: z.string().uuid(),\n});\n\nexport type EmailFolder = {\n\tid: string;\n\tcompany_id: string;\n\tname: string;\n\tslug: string;\n\tdescription: string | null;\n\tcolor: string | null;\n\ticon: string | null;\n\tsort_order: number;\n\tis_system: boolean;\n\tis_active: boolean;\n\tcreated_by: string | null;\n\tcreated_at: string;\n\tupdated_at: string;\n\tdeleted_at: string | null;\n};\n\n/**\n * Get all email folders for the active company\n */\nexport async function getEmailFoldersAction(): Promise<{\n\tsuccess: boolean;\n\tfolders?: EmailFolder[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.eq(\"is_active\", true)\n\t\t\t.order(\"sort_order\", { ascending: true })\n\t\t\t.order(\"name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folders: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new email folder\n */\nexport async function createEmailFolderAction(\n\tinput: z.infer<typeof createFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\tfolder?: EmailFolder;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = createFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data: { user } } = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Generate slug from name\n\t\tconst slug = validated.name\n\t\t\t.toLowerCase()\n\t\t\t.trim()\n\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t.replace(/^-+|-+$/g, \"\");\n\n\t\t// Check if slug already exists\n\t\tconst { data: existing } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"slug\", slug)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (existing) {\n\t\t\treturn { success: false, error: \"A folder with this name already exists\" };\n\t\t}\n\n\t\t// Get max sort_order\n\t\tconst { data: maxOrder } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"sort_order\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"sort_order\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tname: validated.name,\n\t\t\t\tslug,\n\t\t\t\tdescription: validated.description || null,\n\t\t\t\tcolor: validated.color || null,\n\t\t\t\ticon: validated.icon || null,\n\t\t\t\tsort_order: (maxOrder?.sort_order || 0) + 1,\n\t\t\t\tcreated_by: user.id,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folder: data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Update an email folder\n * @deprecated Unused\n */\nasync function updateEmailFolderAction(\n\tinput: z.infer<typeof updateFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\tfolder?: EmailFolder;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = updateFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\t// Check folder exists and belongs to company\n\t\tconst { data: existing, error: fetchError } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id, is_system\")\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !existing) {\n\t\t\treturn { success: false, error: \"Folder not found\" };\n\t\t}\n\n\t\tif (existing.is_system) {\n\t\t\treturn { success: false, error: \"Cannot update system folders\" };\n\t\t}\n\n\t\t// If name is being updated, regenerate slug\n\t\tconst updateData: Record<string, unknown> = {};\n\t\tif (validated.name) {\n\t\t\tupdateData.name = validated.name;\n\t\t\tupdateData.slug = validated.name\n\t\t\t\t.toLowerCase()\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-+|-+$/g, \"\");\n\t\t}\n\t\tif (validated.description !== undefined) updateData.description = validated.description;\n\t\tif (validated.color !== undefined) updateData.color = validated.color;\n\t\tif (validated.icon !== undefined) updateData.icon = validated.icon;\n\t\tif (validated.sort_order !== undefined) updateData.sort_order = validated.sort_order;\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, folder: data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Delete an email folder (soft delete)\n */\nexport async function deleteEmailFolderAction(\n\tinput: z.infer<typeof deleteFolderSchema>\n): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst validated = deleteFolderSchema.parse(input);\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst { data: { user } } = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Check folder exists and belongs to company\n\t\tconst { data: existing, error: fetchError } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.select(\"id, is_system\")\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !existing) {\n\t\t\treturn { success: false, error: \"Folder not found\" };\n\t\t}\n\n\t\tif (existing.is_system) {\n\t\t\treturn { success: false, error: \"Cannot delete system folders\" };\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error } = await supabase\n\t\t\t.from(\"email_folders\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tis_active: false,\n\t\t\t})\n\t\t\t.eq(\"id\", validated.id)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \"),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n"],"names":[],"mappings":";;;;;;;IAgQsB,0BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/customers.ts"],"sourcesContent":["/**\n * Customer Management Server Actions\n *\n * Comprehensive customer relationship management with:\n * - Customer CRUD operations\n * - Customer portal invitation and access\n * - Customer metrics tracking (revenue, jobs, invoices)\n * - Communication preferences\n * - Soft delete/archive support\n * - Customer search and filtering\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { geocodeAddressSilent } from \"@/lib/services/geocoding\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport PortalInvitationEmail from \"../../emails/templates/customer/portal-invitation\";\n\n// ============================================================================\n// VALIDATION SCHEMAS\n// ============================================================================\n\nconst CUSTOMER_NAME_MAX_LENGTH = 100;\nconst CUSTOMER_COMPANY_MAX_LENGTH = 200;\nconst CUSTOMER_PHONE_MAX_LENGTH = 20;\nconst CUSTOMER_ADDRESS_MAX_LENGTH = 200;\nconst CUSTOMER_ADDRESS2_MAX_LENGTH = 100;\nconst CUSTOMER_CITY_MAX_LENGTH = 100;\nconst CUSTOMER_STATE_MAX_LENGTH = 50;\n\n// HTTP Status codes\nconst HTTP_STATUS_FORBIDDEN = 403;\n\n// Search defaults\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst CUSTOMER_ZIP_MAX_LENGTH = 20;\nconst CUSTOMER_COUNTRY_MAX_LENGTH = 50;\nconst CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH = 50;\nconst CENTS_PER_DOLLAR = 100;\n\nfunction requireSiteUrl(): string {\n\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\tif (!siteUrl) {\n\t\tthrow new ActionError(\n\t\t\t\"NEXT_PUBLIC_SITE_URL is not configured\",\n\t\t\tERROR_CODES.INTERNAL_SERVER_ERROR,\n\t\t);\n\t}\n\treturn siteUrl.replace(/\\/$/, \"\");\n}\n\nconst customerSchema = z.object({\n\ttype: z\n\t\t.enum([\"residential\", \"commercial\", \"industrial\"])\n\t\t.default(\"residential\"),\n\tfirstName: z\n\t\t.string()\n\t\t.min(1, \"First name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tlastName: z\n\t\t.string()\n\t\t.min(1, \"Last name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tcompanyName: z.string().max(CUSTOMER_COMPANY_MAX_LENGTH).optional(),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z.string().min(1, \"Phone is required\").max(CUSTOMER_PHONE_MAX_LENGTH),\n\tsecondaryPhone: z.string().max(CUSTOMER_PHONE_MAX_LENGTH).optional(),\n\taddress: z.string().max(CUSTOMER_ADDRESS_MAX_LENGTH).optional(),\n\taddress2: z.string().max(CUSTOMER_ADDRESS2_MAX_LENGTH).optional(),\n\tcity: z.string().max(CUSTOMER_CITY_MAX_LENGTH).optional(),\n\tstate: z.string().max(CUSTOMER_STATE_MAX_LENGTH).optional(),\n\tzipCode: z.string().max(CUSTOMER_ZIP_MAX_LENGTH).optional(),\n\tcountry: z.string().max(CUSTOMER_COUNTRY_MAX_LENGTH).default(\"USA\"),\n\tsource: z\n\t\t.enum([\"referral\", \"google\", \"facebook\", \"direct\", \"yelp\", \"other\"])\n\t\t.optional(),\n\treferredBy: z.string().uuid().optional().nullable(),\n\tpreferredContactMethod: z.enum([\"email\", \"phone\", \"sms\"]).default(\"email\"),\n\tpreferredTechnician: z.string().uuid().optional().nullable(),\n\tbillingEmail: z.string().email().optional().nullable(),\n\tpaymentTerms: z\n\t\t.enum([\"due_on_receipt\", \"net_15\", \"net_30\", \"net_60\"])\n\t\t.default(\"due_on_receipt\"),\n\tcreditLimit: z.number().int().min(0).default(0), // In cents\n\ttaxExempt: z.boolean().default(false),\n\ttaxExemptNumber: z\n\t\t.string()\n\t\t.max(CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH)\n\t\t.optional(),\n\ttags: z.array(z.string()).optional(),\n\tnotes: z.string().optional(),\n\tinternalNotes: z.string().optional(),\n});\n\nconst communicationPreferencesSchema = z.object({\n\temail: z.boolean().default(true),\n\tsms: z.boolean().default(true),\n\tphone: z.boolean().default(true),\n\tmarketing: z.boolean().default(false),\n});\n\n// ============================================================================\n// CUSTOMER CRUD OPERATIONS\n// ============================================================================\n\n/**\n * Create a new customer with multiple contacts and properties\n */\nasync function createCustomer(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\t\tconst { contacts, properties, tags } =\n\t\t\tparseCustomerContactsPropertiesAndTags(formData);\n\t\tconst primaryContact = getPrimaryContactOrThrow(contacts);\n\t\tconst primaryProperty = getPrimaryProperty(properties);\n\n\t\tawait assertCustomerEmailNotDuplicate(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tprimaryContact.email,\n\t\t);\n\n\t\tconst customerType = formData.get(\"type\") || \"residential\";\n\t\tconst companyName = formData.get(\"companyName\");\n\t\tconst displayName = buildCustomerDisplayName(\n\t\t\tcustomerType,\n\t\t\tcompanyName,\n\t\t\tprimaryContact,\n\t\t);\n\n\t\tconst communicationPreferences = buildDefaultCommunicationPreferences();\n\t\tconst customerMetadata = buildCustomerMetadata(contacts);\n\n\t\tconst { lat: customerLat, lon: customerLon } =\n\t\t\tawait geocodePrimaryPropertyIfAvailable(primaryProperty);\n\n\t\tconst customer = await insertCustomerRecord(supabase, {\n\t\t\tcompanyId: teamMember.company_id,\n\t\t\tcustomerType,\n\t\t\tprimaryContact,\n\t\t\tcompanyNameValue: companyName,\n\t\t\tdisplayName,\n\t\t\tprimaryProperty,\n\t\t\tcustomerLat,\n\t\t\tcustomerLon,\n\t\t\tformData,\n\t\t\ttags,\n\t\t\tcommunicationPreferences,\n\t\t\tcustomerMetadata,\n\t\t});\n\n\t\tawait insertAdditionalPropertiesIfAny(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tcustomer.id,\n\t\t\tproperties,\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\treturn customer.id;\n\t});\n}\n\ntype ParsedCustomerContact = {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n\tphone: string;\n\trole: string;\n\tisPrimary: boolean;\n};\n\ntype ParsedCustomerProperty = {\n\tname: string;\n\taddress: string;\n\taddress2: string;\n\tcity: string;\n\tstate: string;\n\tzipCode: string;\n\tcountry: string;\n\tpropertyType: string;\n\tisPrimary: boolean;\n\tnotes: string;\n};\n\ntype ParsedCustomerFormCollections = {\n\tcontacts: ParsedCustomerContact[];\n\tproperties: ParsedCustomerProperty[];\n\ttags?: string[];\n};\n\nasync function requireCustomerCompanyMembership(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n) {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember;\n}\n\nfunction parseCustomerContactsPropertiesAndTags(\n\tformData: FormData,\n): ParsedCustomerFormCollections {\n\tconst contacts = parseContacts(formData.get(\"contacts\"));\n\tconst properties = parseProperties(formData.get(\"properties\"));\n\tconst tags = parseTagsField(formData.get(\"tags\"));\n\n\treturn { contacts, properties, tags };\n}\n\nfunction parseContacts(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerContact[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerContact[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid contacts data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseProperties(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerProperty[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerProperty[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid properties data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseTagsField(\n\tvalue: FormDataEntryValue | null,\n): string[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as string[];\n\t} catch {\n\t\treturn value.split(\",\").map((t) => t.trim());\n\t}\n}\n\nfunction getPrimaryContactOrThrow(\n\tcontacts: ParsedCustomerContact[],\n): ParsedCustomerContact {\n\tconst primaryContact = contacts.find((c) => c.isPrimary) || contacts[0];\n\tif (!primaryContact) {\n\t\tthrow new ActionError(\n\t\t\t\"At least one contact is required\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\treturn primaryContact;\n}\n\nfunction getPrimaryProperty(\n\tproperties: ParsedCustomerProperty[],\n): ParsedCustomerProperty | undefined {\n\treturn properties.find((p) => p.isPrimary) || properties[0];\n}\n\nasync function assertCustomerEmailNotDuplicate(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\temail: string,\n) {\n\tconst { data: existingEmail } = await supabase\n\t\t.from(\"customers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"email\", email)\n\t\t.is(\"deleted_at\", null)\n\t\t.single();\n\n\tif (existingEmail) {\n\t\tthrow new ActionError(\n\t\t\t\"A customer with this email already exists\",\n\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t);\n\t}\n}\n\nfunction buildCustomerDisplayName(\n\tcustomerType: FormDataEntryValue | null,\n\tcompanyNameValue: FormDataEntryValue | null,\n\tprimaryContact: ParsedCustomerContact,\n): string {\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\tif (customerType === \"commercial\" && companyName) {\n\t\treturn companyName;\n\t}\n\n\treturn `${primaryContact.firstName} ${primaryContact.lastName}`;\n}\n\nfunction buildDefaultCommunicationPreferences() {\n\treturn {\n\t\temail: true,\n\t\tsms: true,\n\t\tphone: true,\n\t\tmarketing: false,\n\t};\n}\n\nfunction buildCustomerMetadata(contacts: ParsedCustomerContact[]) {\n\treturn {\n\t\tcontacts: contacts.map((c) => ({\n\t\t\tfirstName: c.firstName,\n\t\t\tlastName: c.lastName,\n\t\t\temail: c.email,\n\t\t\tphone: c.phone,\n\t\t\trole: c.role,\n\t\t\tisPrimary: c.isPrimary,\n\t\t})),\n\t};\n}\n\nasync function geocodePrimaryPropertyIfAvailable(\n\tprimaryProperty: ParsedCustomerProperty | undefined,\n): Promise<{ lat: number | null; lon: number | null }> {\n\tif (\n\t\t!(\n\t\t\tprimaryProperty?.address &&\n\t\t\tprimaryProperty.city &&\n\t\t\tprimaryProperty.state &&\n\t\t\tprimaryProperty.zipCode\n\t\t)\n\t) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\tconst geocodeResult = await geocodeAddressSilent(\n\t\tprimaryProperty.address,\n\t\tprimaryProperty.city,\n\t\tprimaryProperty.state,\n\t\tprimaryProperty.zipCode,\n\t\tprimaryProperty.country || \"USA\",\n\t);\n\n\tif (!geocodeResult) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\treturn { lat: geocodeResult.lat, lon: geocodeResult.lon };\n}\n\ntype InsertCustomerParams = {\n\tcompanyId: string;\n\tcustomerType: FormDataEntryValue | null;\n\tprimaryContact: ParsedCustomerContact;\n\tcompanyNameValue: FormDataEntryValue | null;\n\tdisplayName: string;\n\tprimaryProperty?: ParsedCustomerProperty;\n\tcustomerLat: number | null;\n\tcustomerLon: number | null;\n\tformData: FormData;\n\ttags?: string[];\n\tcommunicationPreferences: {\n\t\temail: boolean;\n\t\tsms: boolean;\n\t\tphone: boolean;\n\t\tmarketing: boolean;\n\t};\n\tcustomerMetadata: Record<string, unknown>;\n};\n\nasync function insertCustomerRecord(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tparams: InsertCustomerParams,\n) {\n\tconst payload = buildCustomerInsertPayload(params);\n\n\tconst { data: customer, error: createError } = await supabase\n\t\t.from(\"customers\")\n\t\t.insert(payload)\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (createError || !customer) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(\"create customer\"),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn customer;\n}\n\nfunction buildCustomerInsertPayload(\n\tparams: InsertCustomerParams,\n): Record<string, unknown> {\n\tconst {\n\t\tcompanyId,\n\t\tcustomerType,\n\t\tprimaryContact,\n\t\tcompanyNameValue,\n\t\tdisplayName,\n\t\tprimaryProperty,\n\t\tcustomerLat,\n\t\tcustomerLon,\n\t\tformData,\n\t\ttags,\n\t\tcommunicationPreferences,\n\t\tcustomerMetadata,\n\t} = params;\n\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\ttype: String(customerType || \"residential\"),\n\t\tfirst_name: primaryContact.firstName,\n\t\tlast_name: primaryContact.lastName,\n\t\tcompany_name: companyName,\n\t\tdisplay_name: displayName,\n\t\temail: primaryContact.email,\n\t\tphone: primaryContact.phone,\n\t\tsecondary_phone: null,\n\t\taddress: primaryProperty?.address || null,\n\t\taddress2: primaryProperty?.address2 || null,\n\t\tcity: primaryProperty?.city || null,\n\t\tstate: primaryProperty?.state || null,\n\t\tzip_code: primaryProperty?.zipCode || null,\n\t\tcountry: primaryProperty?.country || \"USA\",\n\t\tlat: customerLat,\n\t\tlon: customerLon,\n\t\tsource: formData.get(\"source\") ? String(formData.get(\"source\")) : null,\n\t\treferred_by: formData.get(\"referredBy\")\n\t\t\t? String(formData.get(\"referredBy\"))\n\t\t\t: null,\n\t\tpreferred_contact_method:\n\t\t\tString(formData.get(\"preferredContactMethod\")) || \"email\",\n\t\tpreferred_technician: formData.get(\"preferredTechnician\")\n\t\t\t? String(formData.get(\"preferredTechnician\"))\n\t\t\t: null,\n\t\tbilling_email: formData.get(\"billingEmail\")\n\t\t\t? String(formData.get(\"billingEmail\"))\n\t\t\t: null,\n\t\tpayment_terms: String(formData.get(\"paymentTerms\")) || \"due_on_receipt\",\n\t\tcredit_limit: formData.get(\"creditLimit\")\n\t\t\t? Number(formData.get(\"creditLimit\")) * CENTS_PER_DOLLAR\n\t\t\t: 0,\n\t\ttax_exempt: formData.get(\"taxExempt\") === \"on\",\n\t\ttax_exempt_number: formData.get(\"taxExemptNumber\")\n\t\t\t? String(formData.get(\"taxExemptNumber\"))\n\t\t\t: null,\n\t\ttags: tags || null,\n\t\tcommunication_preferences: communicationPreferences,\n\t\tnotes: formData.get(\"notes\") ? String(formData.get(\"notes\")) : null,\n\t\tinternal_notes: formData.get(\"internalNotes\")\n\t\t\t? String(formData.get(\"internalNotes\"))\n\t\t\t: null,\n\t\tmetadata: customerMetadata,\n\t\tstatus: \"active\",\n\t\tportal_enabled: false,\n\t\ttotal_revenue: 0,\n\t\ttotal_jobs: 0,\n\t\ttotal_invoices: 0,\n\t\taverage_job_value: 0,\n\t\toutstanding_balance: 0,\n\t};\n}\n\nasync function insertAdditionalPropertiesIfAny(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\tcustomerId: string,\n\tproperties: ParsedCustomerProperty[],\n) {\n\tconst additionalProperties = properties.filter((p) => !p.isPrimary);\n\tif (additionalProperties.length === 0) {\n\t\treturn;\n\t}\n\n\tconst propertiesToInsert = await Promise.all(\n\t\tadditionalProperties.map(async (prop) => {\n\t\t\tlet propLat: number | null = null;\n\t\t\tlet propLon: number | null = null;\n\n\t\t\tif (prop.address && prop.city && prop.state && prop.zipCode) {\n\t\t\t\tconst geocodeResult = await geocodeAddressSilent(\n\t\t\t\t\tprop.address,\n\t\t\t\t\tprop.city,\n\t\t\t\t\tprop.state,\n\t\t\t\t\tprop.zipCode,\n\t\t\t\t\tprop.country || \"USA\",\n\t\t\t\t);\n\n\t\t\t\tif (geocodeResult) {\n\t\t\t\t\tpropLat = geocodeResult.lat;\n\t\t\t\t\tpropLon = geocodeResult.lon;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tname: prop.name || \"Additional Property\",\n\t\t\t\taddress: prop.address,\n\t\t\t\taddress2: prop.address2 || null,\n\t\t\t\tcity: prop.city,\n\t\t\t\tstate: prop.state,\n\t\t\t\tzip_code: prop.zipCode,\n\t\t\t\tcountry: prop.country || \"USA\",\n\t\t\t\tproperty_type: prop.propertyType || \"residential\",\n\t\t\t\tnotes: prop.notes || null,\n\t\t\t\tlat: propLat,\n\t\t\t\tlon: propLon,\n\t\t\t};\n\t\t}),\n\t);\n\n\tawait supabase.from(\"properties\").insert(propertiesToInsert);\n}\n\n/**\n * Update existing customer\n */\nasync function updateCustomer(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Parse tags if provided\n\t\tlet tags: string[] | undefined;\n\t\tconst tagsString = formData.get(\"tags\");\n\t\tif (tagsString && typeof tagsString === \"string\") {\n\t\t\ttry {\n\t\t\t\ttags = JSON.parse(tagsString);\n\t\t\t} catch {\n\t\t\t\ttags = tagsString.split(\",\").map((t) => t.trim());\n\t\t\t}\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = customerSchema.parse({\n\t\t\ttype: formData.get(\"type\") || \"residential\",\n\t\t\tfirstName: formData.get(\"firstName\"),\n\t\t\tlastName: formData.get(\"lastName\"),\n\t\t\tcompanyName: formData.get(\"companyName\") || undefined,\n\t\t\temail: formData.get(\"email\"),\n\t\t\tphone: formData.get(\"phone\"),\n\t\t\tsecondaryPhone: formData.get(\"secondaryPhone\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzipCode: formData.get(\"zipCode\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\tsource: formData.get(\"source\") || undefined,\n\t\t\treferredBy: formData.get(\"referredBy\") || null,\n\t\t\tpreferredContactMethod: formData.get(\"preferredContactMethod\") || \"email\",\n\t\t\tpreferredTechnician: formData.get(\"preferredTechnician\") || null,\n\t\t\tbillingEmail: formData.get(\"billingEmail\") || null,\n\t\t\tpaymentTerms: formData.get(\"paymentTerms\") || \"due_on_receipt\",\n\t\t\tcreditLimit: formData.get(\"creditLimit\")\n\t\t\t\t? Number(formData.get(\"creditLimit\"))\n\t\t\t\t: 0,\n\t\t\ttaxExempt: formData.get(\"taxExempt\") === \"true\",\n\t\t\ttaxExemptNumber: formData.get(\"taxExemptNumber\") || undefined,\n\t\t\ttags,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternalNotes: formData.get(\"internalNotes\") || undefined,\n\t\t});\n\n\t\t// Check if email already exists (excluding current customer)\n\t\tif (data.email !== customer.email) {\n\t\t\tconst { data: existingEmail } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"email\", data.email)\n\t\t\t\t.neq(\"id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (existingEmail) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"A customer with this email already exists\",\n\t\t\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Generate display name\n\t\tconst displayName =\n\t\t\tdata.type === \"commercial\" && data.companyName\n\t\t\t\t? data.companyName\n\t\t\t\t: `${data.firstName} ${data.lastName}`;\n\n\t\tconst companyName = data.companyName ? String(data.companyName) : null;\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttype: data.type,\n\t\t\t\tfirst_name: data.firstName,\n\t\t\t\tlast_name: data.lastName,\n\t\t\t\tcompany_name: companyName,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondaryPhone,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zipCode,\n\t\t\t\tcountry: data.country,\n\t\t\t\tsource: data.source,\n\t\t\t\treferred_by: data.referredBy,\n\t\t\t\tpreferred_contact_method: data.preferredContactMethod,\n\t\t\t\tpreferred_technician: data.preferredTechnician,\n\t\t\t\tbilling_email: data.billingEmail,\n\t\t\t\tpayment_terms: data.paymentTerms,\n\t\t\t\tcredit_limit: data.creditLimit,\n\t\t\t\ttax_exempt: data.taxExempt,\n\t\t\t\ttax_exempt_number: data.taxExemptNumber,\n\t\t\t\ttags: data.tags,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internalNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Delete customer (soft delete/archive)\n */\nexport async function deleteCustomer(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, outstanding_balance\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent deletion if customer has outstanding balance\n\t\tif (customer.outstanding_balance > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot delete customer with outstanding balance. Collect payment first.\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"delete customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t});\n}\n\n// ============================================================================\n// CUSTOMER STATUS & PREFERENCES\n// ============================================================================\n\n/**\n * Update customer status\n */\nasync function updateCustomerStatus(\n\tcustomerId: string,\n\tstatus: \"active\" | \"inactive\" | \"archived\" | \"blocked\",\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Update communication preferences\n */\nasync function updateCommunicationPreferences(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Validate input\n\t\tconst preferences = communicationPreferencesSchema.parse({\n\t\t\temail: formData.get(\"email\") === \"true\",\n\t\t\tsms: formData.get(\"sms\") === \"true\",\n\t\t\tphone: formData.get(\"phone\") === \"true\",\n\t\t\tmarketing: formData.get(\"marketing\") === \"true\",\n\t\t});\n\n\t\t// Update preferences\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ communication_preferences: preferences })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update communication preferences\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// CUSTOMER PORTAL\n// ============================================================================\n\n/**\n * Invite customer to portal\n * Sends an email with a secure token-based invitation link.\n */\nasync function inviteToPortal(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email, display_name, portal_enabled\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (customer.portal_enabled) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer is already invited to portal\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Generate secure portal invitation token\n\t\tconst inviteToken = Buffer.from(\n\t\t\t`${customerId}:${Date.now()}:${Math.random()}`,\n\t\t).toString(\"base64url\");\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tportal_enabled: true,\n\t\t\t\tportal_invited_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"invite customer to portal\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Send invitation email\n\t\tconst siteUrl = requireSiteUrl();\n\t\tconst portalUrl = `${siteUrl}/portal/setup?token=${inviteToken}`;\n\n\t\tconst emailResult = await sendEmail({\n\t\t\tto: customer.email,\n\t\t\tsubject: \"You've been invited to your Customer Portal\",\n\t\t\ttemplate: PortalInvitationEmail({\n\t\t\t\tcustomerName: customer.display_name,\n\t\t\t\tportalUrl,\n\t\t\t\texpiresInHours: 168, // 7 days\n\t\t\t\tsupportEmail: process.env.RESEND_FROM_EMAIL || \"support@thorbis.com\",\n\t\t\t\tsupportPhone: \"(555) 123-4567\",\n\t\t\t}),\n\t\t\ttemplateType: EmailTemplate.PORTAL_INVITATION,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treturn;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Revoke portal access\n */\nasync function revokePortalAccess(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Revoke access\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ portal_enabled: false })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"revoke portal access\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// SEARCH & REPORTING\n// ============================================================================\n\n/**\n * Get customer by phone number\n * Used for incoming call lookups\n */\nexport async function getCustomerByPhone(\n\tphoneNumber: string,\n\tcompanyId: string,\n): Promise<ActionResult<unknown>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Normalize phone number (remove formatting)\n\t\tconst normalizedPhone = phoneNumber.replace(/\\D/g, \"\");\n\n\t\t// Search by primary phone or secondary phone\n\t\tconst { data: customer, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        properties:properties(*)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(\n\t\t\t\t`phone.eq.${phoneNumber},phone.eq.${normalizedPhone},secondary_phone.eq.${phoneNumber},secondary_phone.eq.${normalizedPhone}`,\n\t\t\t)\n\t\t\t.single();\n\n\t\tif (error && error.code !== \"PGRST116\") {\n\t\t\t// PGRST116 = no rows found\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customer || null;\n\t});\n}\n\n/**\n * Search customers by name, email, phone, or company\n */\nexport async function searchCustomers(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the active company ID helper (same as getAllCustomers)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\t// Searches across: first_name, last_name, display_name, email, phone,\n\t\t// secondary_phone, company_name, address, city, state\n\t\t// Returns results ordered by relevance (weighted: name > contact > address)\n\t\tconst { searchCustomersFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst customers = await searchCustomersFullText(\n\t\t\tsupabase,\n\t\t\tactiveCompanyId,\n\t\t\tsearchTerm,\n\t\t\t{\n\t\t\t\tlimit: options?.limit || DEFAULT_SEARCH_LIMIT,\n\t\t\t\toffset: options?.offset || 0,\n\t\t\t},\n\t\t);\n\n\t\treturn customers;\n\t});\n}\n\n/**\n * Get top customers by revenue\n */\nasync function getTopCustomers(\n\tlimit = 10,\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch top customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get customers with outstanding balance\n */\ntype CustomerWithBalance = {\n\tid: string;\n\tdisplay_name: string;\n\tbalance: number;\n};\n\nasync function getCustomersWithBalance(): Promise<\n\tActionResult<CustomerWithBalance[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gt(\"outstanding_balance\", 0)\n\t\t\t.order(\"outstanding_balance\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers with balance\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\ntype CustomerRecord = {\n\tid: string;\n\tcompany_id: string;\n\ttype: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\tcompany_name?: string | null;\n\temail: string;\n\tphone: string;\n\tsecondary_phone?: string;\n\taddress?: string;\n\taddress2?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip_code?: string;\n\tstatus: string;\n\ttotal_revenue?: number;\n\ttotal_jobs?: number;\n\ttotal_invoices?: number;\n\toutstanding_balance?: number;\n\tlast_job_date?: string;\n\tnext_scheduled_job?: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tarchived_at?: string | null;\n\tdeleted_at?: string | null;\n};\n\n/**\n * Get customers for phone dialer (lightweight, no enrichment)\n *\n * PERFORMANCE: Returns only basic contact info needed for dialer.\n * Use this instead of getAllCustomers() in AppHeader to avoid N+1 queries.\n *\n * Expected: 50-100ms (single query)\n * vs getAllCustomers(): 1200-2000ms (151 queries with enrichment)\n */\nexport async function getCustomersForDialer(): Promise<\n\tActionResult<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tfirst_name: string | null;\n\t\t\tlast_name: string | null;\n\t\t\tdisplay_name: string | null;\n\t\t\temail: string | null;\n\t\t\tphone: string | null;\n\t\t\tsecondary_phone?: string | null;\n\t\t\tcompany_name: string | null;\n\t\t\taddress: string | null;\n\t\t\taddress2: string | null;\n\t\t\tcity: string | null;\n\t\t\tstate: string | null;\n\t\t\tzip_code: string | null;\n\t\t}>\n\t>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Single lightweight query - no joins, no enrichment\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t\"id, first_name, last_name, display_name, email, phone, secondary_phone, company_name, address, address2, city, state, zip_code\",\n\t\t\t)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get all customers for the current company (WITH ENRICHMENT)\n *\n * WARNING: This function does 151 database queries for 50 customers (N+1 pattern).\n * Expected time: 1200-2000ms\n *\n * DO NOT use in AppHeader or other frequently rendered components.\n * Use getCustomersForDialer() instead for lightweight contact info.\n *\n * Only use this on dedicated customer list pages where the enriched data is needed.\n */\nasync function getAllCustomers(): Promise<\n\tActionResult<CustomerRecord[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID (from cookie or first available)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\n\t\tconst FORBIDDEN_STATUS_CODE = 403;\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Use RPC function instead of N+1 queries\n\t\t// BEFORE: 151 queries for 50 customers (1 base + 50 × 3 queries each)\n\t\t// AFTER: 1 RPC call with efficient LATERAL joins\n\t\t// Performance gain: 5-10 seconds faster\n\n\t\t// Note: customers variable contains the base customer data from above query\n\t\t// We replace the enrichment logic with a single RPC call\n\t\tconst { data: enrichedData, error: enrichError } = await supabase.rpc(\n\t\t\t\"get_enriched_customers_rpc\",\n\t\t\t{\n\t\t\t\tp_company_id: activeCompanyId,\n\t\t\t},\n\t\t);\n\n\t\tif (enrichError) {\n\t\t\t// Fallback to base customers if enrichment fails\n\t\t\tconsole.error(\"Failed to enrich customers:\", enrichError);\n\t\t\treturn customers as CustomerRecord[];\n\t\t}\n\n\t\t// Merge enriched data with base customer data\n\t\tconst enrichedCustomers = (enrichedData || []).map((customer: any) => ({\n\t\t\t...customer,\n\t\t\t// Override total_jobs and total_revenue with fresh aggregated values\n\t\t\ttotal_jobs: customer.enriched_total_jobs || customer.total_jobs || 0,\n\t\t\ttotal_revenue:\n\t\t\t\tcustomer.enriched_total_revenue || customer.total_revenue || 0,\n\t\t}));\n\n\t\treturn enrichedCustomers as CustomerRecord[];\n\t});\n}\n\n/**\n * Update customer page content (Novel/Tiptap JSON)\n *\n * Saves the customer's editable page layout and content\n * Used by the Novel editor for auto-save functionality\n */\nasync function updateCustomerPageContent(\n\tcustomerId: string,\n\tpageContent: Record<string, unknown>,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"customer\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update page content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tpage_content: pageContent,\n\t\t\t\tcontent_updated_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer page\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAwoCsB,kBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/vendors.ts"],"sourcesContent":["/**\n * Vendors Server Actions\n *\n * Handles vendor management with CRUD operations, search, and vendor selection.\n */\n\n\"use server\";\n\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport { revalidatePath } from \"next/cache\";\n\n// Regex constants\nconst VENDOR_NUMBER_REGEX = /VND-\\d{4}-(\\d+)/;\n\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n    type VendorUpdate,\n    vendorInsertSchema,\n    vendorUpdateSchema,\n} from \"@/lib/validations/database-schemas\";\n\n/**\n * Generate unique vendor number\n */\nasync function generateVendorNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\tconst { data: latestVendor } = await supabase\n\t\t.from(\"vendors\")\n\t\t.select(\"vendor_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.is(\"deleted_at\", null)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestVendor) {\n\t\treturn `VND-${new Date().getFullYear()}-001`;\n\t}\n\n\tconst match = latestVendor.vendor_number.match(VENDOR_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `VND-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\treturn `VND-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Create a new vendor\n */\nasync function createVendor(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Generate vendor number if not provided\n\t\tconst vendorNumber =\n\t\t\tformData.get(\"vendor_number\")?.toString() ||\n\t\t\t(await generateVendorNumber(supabase, teamMember.company_id));\n\n\t\t// Validate input\n\t\tconst data = vendorInsertSchema.parse({\n\t\t\tcompany_id: teamMember.company_id,\n\t\t\tname: formData.get(\"name\"),\n\t\t\tdisplay_name: formData.get(\"display_name\") || formData.get(\"name\"),\n\t\t\tvendor_number: vendorNumber,\n\t\t\temail: formData.get(\"email\") || undefined,\n\t\t\tphone: formData.get(\"phone\") || undefined,\n\t\t\tsecondary_phone: formData.get(\"secondary_phone\") || undefined,\n\t\t\twebsite: formData.get(\"website\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzip_code: formData.get(\"zip_code\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\ttax_id: formData.get(\"tax_id\") || undefined,\n\t\t\tpayment_terms: formData.get(\"payment_terms\") || \"net_30\",\n\t\t\tcredit_limit: formData.get(\"credit_limit\")\n\t\t\t\t? Number.parseInt(formData.get(\"credit_limit\") as string, 10) * 100\n\t\t\t\t: 0,\n\t\t\tpreferred_payment_method:\n\t\t\t\tformData.get(\"preferred_payment_method\") || undefined,\n\t\t\tcategory: formData.get(\"category\") || undefined,\n\t\t\ttags: formData.get(\"tags\")\n\t\t\t\t? JSON.parse(formData.get(\"tags\") as string)\n\t\t\t\t: undefined,\n\t\t\tstatus: formData.get(\"status\") || \"active\",\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternal_notes: formData.get(\"internal_notes\") || undefined,\n\t\t\tcustom_fields: formData.get(\"custom_fields\")\n\t\t\t\t? JSON.parse(formData.get(\"custom_fields\") as string)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Check if vendor number already exists\n\t\tconst { data: existingVendor } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"vendor_number\", data.vendor_number)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (existingVendor) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Vendor number already exists\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Insert vendor\n\t\tconst { data: vendor, error } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: data.company_id,\n\t\t\t\tname: data.name,\n\t\t\t\tdisplay_name: data.display_name,\n\t\t\t\tvendor_number: data.vendor_number,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondary_phone,\n\t\t\t\twebsite: data.website,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zip_code,\n\t\t\t\tcountry: data.country,\n\t\t\t\ttax_id: data.tax_id,\n\t\t\t\tpayment_terms: data.payment_terms,\n\t\t\t\tcredit_limit: data.credit_limit,\n\t\t\t\tpreferred_payment_method: data.preferred_payment_method,\n\t\t\t\tcategory: data.category,\n\t\t\t\ttags: data.tags || [],\n\t\t\t\tstatus: data.status,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internal_notes,\n\t\t\t\tcustom_fields: data.custom_fields || {},\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to create vendor\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(vendor, \"Vendor\");\n\n\t\trevalidatePath(\"/dashboard/inventory/vendors\");\n\t\trevalidatePath(`/dashboard/inventory/vendors/${vendor.id}`);\n\n\t\treturn vendor.id;\n\t});\n}\n\n/**\n * Update an existing vendor\n */\nexport async function updateVendor(\n\tvendorId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify vendor exists and belongs to company\n\t\tconst { data: existingVendor } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"id, company_id, vendor_number\")\n\t\t\t.eq(\"id\", vendorId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(existingVendor, \"Vendor\");\n\n\t\tif (existingVendor.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"vendor\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build update object from form data\n\t\tconst updateData: Partial<VendorUpdate> = {};\n\n\t\tif (formData.has(\"name\")) {\n\t\t\tupdateData.name = formData.get(\"name\") as string;\n\t\t}\n\t\tif (formData.has(\"display_name\")) {\n\t\t\tupdateData.display_name = formData.get(\"display_name\") as string;\n\t\t}\n\t\tif (formData.has(\"vendor_number\")) {\n\t\t\tupdateData.vendor_number = formData.get(\"vendor_number\") as string;\n\t\t}\n\t\tif (formData.has(\"email\")) {\n\t\t\tupdateData.email = (formData.get(\"email\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"phone\")) {\n\t\t\tupdateData.phone = (formData.get(\"phone\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"secondary_phone\")) {\n\t\t\tupdateData.secondary_phone =\n\t\t\t\t(formData.get(\"secondary_phone\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"website\")) {\n\t\t\tupdateData.website = (formData.get(\"website\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"address\")) {\n\t\t\tupdateData.address = (formData.get(\"address\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"address2\")) {\n\t\t\tupdateData.address2 = (formData.get(\"address2\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"city\")) {\n\t\t\tupdateData.city = (formData.get(\"city\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"state\")) {\n\t\t\tupdateData.state = (formData.get(\"state\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"zip_code\")) {\n\t\t\tupdateData.zip_code = (formData.get(\"zip_code\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"country\")) {\n\t\t\tupdateData.country = formData.get(\"country\") as string;\n\t\t}\n\t\tif (formData.has(\"tax_id\")) {\n\t\t\tupdateData.tax_id = (formData.get(\"tax_id\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"payment_terms\")) {\n\t\t\tupdateData.payment_terms = formData.get(\"payment_terms\") as any;\n\t\t}\n\t\tif (formData.has(\"credit_limit\")) {\n\t\t\tupdateData.credit_limit =\n\t\t\t\tNumber.parseInt(formData.get(\"credit_limit\") as string, 10) * 100;\n\t\t}\n\t\tif (formData.has(\"preferred_payment_method\")) {\n\t\t\tupdateData.preferred_payment_method = formData.get(\n\t\t\t\t\"preferred_payment_method\",\n\t\t\t) as any;\n\t\t}\n\t\tif (formData.has(\"category\")) {\n\t\t\tupdateData.category = formData.get(\"category\") as any;\n\t\t}\n\t\tif (formData.has(\"tags\")) {\n\t\t\tupdateData.tags = JSON.parse(formData.get(\"tags\") as string);\n\t\t}\n\t\tif (formData.has(\"status\")) {\n\t\t\tupdateData.status = formData.get(\"status\") as \"active\" | \"inactive\";\n\t\t}\n\t\tif (formData.has(\"notes\")) {\n\t\t\tupdateData.notes = (formData.get(\"notes\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"internal_notes\")) {\n\t\t\tupdateData.internal_notes =\n\t\t\t\t(formData.get(\"internal_notes\") as string) || undefined;\n\t\t}\n\t\tif (formData.has(\"custom_fields\")) {\n\t\t\tupdateData.custom_fields = JSON.parse(\n\t\t\t\tformData.get(\"custom_fields\") as string,\n\t\t\t);\n\t\t}\n\n\t\t// Validate update data\n\t\tconst validated = vendorUpdateSchema.parse(updateData);\n\n\t\t// Check vendor number uniqueness if changed\n\t\tif (\n\t\t\tvalidated.vendor_number &&\n\t\t\tvalidated.vendor_number !== existingVendor.vendor_number\n\t\t) {\n\t\t\tconst { data: duplicate } = await supabase\n\t\t\t\t.from(\"vendors\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"vendor_number\", validated.vendor_number)\n\t\t\t\t.neq(\"id\", vendorId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (duplicate) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Vendor number already exists\",\n\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update vendor\n\t\tconst { error } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.update(validated)\n\t\t\t.eq(\"id\", vendorId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to update vendor\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/inventory/vendors\");\n\t\trevalidatePath(`/dashboard/inventory/vendors/${vendorId}`);\n\t});\n}\n\n/**\n * Delete (soft delete) a vendor\n */\nasync function deleteVendor(\n\tvendorId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify vendor exists and belongs to company\n\t\tconst { data: vendor } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", vendorId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(vendor, \"Vendor\");\n\n\t\tif (vendor.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"vendor\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete vendor\n\t\tconst { error } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", vendorId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to delete vendor\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/inventory/vendors\");\n\t});\n}\n\n/**\n * Get a single vendor by ID\n */\nasync function getVendor(vendorId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: vendor, error } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", vendorId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to fetch vendor\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(vendor, \"Vendor\");\n\n\t\treturn vendor;\n\t});\n}\n\n/**\n * List all vendors for the company\n */\nasync function listVendors(options?: {\n\tstatus?: \"active\" | \"inactive\";\n\tcategory?: string;\n\tsearch?: string;\n}): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tlet query = supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"name\", { ascending: true });\n\n\t\tif (options?.status) {\n\t\t\tquery = query.eq(\"status\", options.status);\n\t\t}\n\n\t\tif (options?.category) {\n\t\t\tquery = query.eq(\"category\", options.category);\n\t\t}\n\n\t\tif (options?.search) {\n\t\t\tquery = query.or(\n\t\t\t\t`name.ilike.%${options.search}%,display_name.ilike.%${options.search}%,vendor_number.ilike.%${options.search}%,email.ilike.%${options.search}%`,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: vendors, error } = await query;\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to fetch vendors\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn vendors || [];\n\t});\n}\n\n/**\n * Search vendors by query string\n */\nexport async function searchVendors(\n\tquery: string,\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the same approach as searchCustomers\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\t\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: vendors, error } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"id, name, display_name, vendor_number, email, phone, status\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.or(\n\t\t\t\t`name.ilike.%${query}%,display_name.ilike.%${query}%,vendor_number.ilike.%${query}%,email.ilike.%${query}%`,\n\t\t\t)\n\t\t\t.limit(20);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to search vendors\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn vendors || [];\n\t});\n}\n\n/**\n * Link a purchase order to a vendor\n */\nexport async function linkPurchaseOrderToVendor(\n\tpurchaseOrderId: string,\n\tvendorId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify purchase order exists and belongs to company\n\t\tconst { data: po } = await supabase\n\t\t\t.from(\"purchase_orders\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", purchaseOrderId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(po, \"Purchase Order\");\n\n\t\tif (po.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"purchase order\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify vendor exists and belongs to company\n\t\tconst { data: vendor } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", vendorId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(vendor, \"Vendor\");\n\n\t\tif (vendor.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"vendor\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Link purchase order to vendor\n\t\tconst { error } = await supabase\n\t\t\t.from(\"purchase_orders\")\n\t\t\t.update({ vendor_id: vendorId })\n\t\t\t.eq(\"id\", purchaseOrderId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to link purchase order\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/vendors\");\n\t\trevalidatePath(`/dashboard/work/vendors/${vendorId}`);\n\t\trevalidatePath(\"/dashboard/work/purchase-orders\");\n\t\trevalidatePath(`/dashboard/work/purchase-orders/${purchaseOrderId}`);\n\t});\n}\n\n/**\n * Archive a vendor (soft delete)\n */\nexport async function archiveVendor(\n\tvendorId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", vendorId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/vendors\");\n\t\treturn { success: true };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"Failed to archive vendor\" };\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAikBsB,gBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/sms-actions.ts"],"sourcesContent":["\"use server\";\n\nimport {\n    getCompanySms,\n    getSmsById,\n    markSmsAsRead,\n    markSmsConversationAsRead,\n    type CompanySms,\n} from \"@/lib/communication/sms-service\";\nimport { z } from \"zod\";\n\nconst getSmsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  folder: z.enum([\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst markSmsReadSchema = z.object({\n  smsId: z.string().min(1),\n});\n\nexport type GetSmsInput = z.infer<typeof getSmsSchema>;\nexport type MarkSmsReadInput = z.infer<typeof markSmsReadSchema>;\n\n// Re-export SMS types from sms-service\nexport type { CompanySms };\n\nexport type GetSmsResult = Awaited<ReturnType<typeof getCompanySms>>;\n\n/**\n * Get SMS messages for the active company\n */\nexport async function getSmsAction(\n  input: GetSmsInput\n): Promise<GetSmsResult> {\n  try {\n    const parseResult = getSmsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      throw new Error(`Invalid input parameters: ${parseResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getCompanySms(companyId, validatedInput);\n  } catch (error) {\n    console.error(\"❌ getSmsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get a specific SMS by ID\n */\nexport async function getSmsByIdAction(smsId: string): Promise<{\n  success: boolean;\n  sms?: CompanySms;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const sms = await getSmsById(companyId, smsId);\n    \n    if (!sms) {\n      return { success: false, error: \"SMS not found\" };\n    }\n\n    return { success: true, sms };\n  } catch (error) {\n    console.error(\"Error getting SMS by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an SMS as read\n */\nexport async function markSmsAsReadAction(\n  input: MarkSmsReadInput\n): Promise<boolean> {\n  try {\n    const validatedInput = markSmsReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"Invalid input parameters\");\n    }\n\n    return await markSmsAsRead(companyId, validatedInput.smsId);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsReadAction(phoneNumber: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const success = await markSmsConversationAsRead(companyId, phoneNumber);\n    return { success };\n  } catch (error) {\n    console.error(\"Error marking SMS conversation as read:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS conversation thread by phone number\n */\nexport async function getSmsConversationAction(phoneNumber: string): Promise<{\n  success: boolean;\n  messages?: CompanySms[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getSmsConversation } = await import(\"@/lib/sms/sms-service\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const messages = await getSmsConversation(companyId, phoneNumber);\n    return { success: true, messages };\n  } catch (error) {\n    console.error(\"Error fetching SMS conversation:\", error);\n    // Handle cookies() error gracefully\n    if (error instanceof Error && error.message.includes(\"cookies\")) {\n      return {\n        success: false,\n        error: \"Request context not available. Please refresh the page.\",\n      };\n    }\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS folder counts\n */\nexport async function getSmsFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    inbox: number;\n    sent: number;\n    archive: number;\n    trash: number;\n    [label: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const baseQuery = supabase\n      .from(\"communications\")\n      .select(\"*\", { count: \"exact\", head: true })\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"sms\");\n    \n    // Get counts for each folder\n    const [inboxResult, sentResult, archiveResult, trashResult] = await Promise.all([\n      // Inbox\n      baseQuery\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n      // Sent\n      baseQuery\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null),\n      // Archive\n      baseQuery.eq(\"is_archived\", true).is(\"deleted_at\", null),\n      // Trash\n      baseQuery.not(\"deleted_at\", \"is\", null),\n    ]);\n    \n    const counts = {\n      inbox: inboxResult.count || 0,\n      sent: sentResult.count || 0,\n      archive: archiveResult.count || 0,\n      trash: trashResult.count || 0,\n    };\n    \n    return { success: true, counts };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Upload SMS attachments to storage\n */\nexport async function uploadSmsAttachments(\n  files: File[]\n): Promise<{\n  success: boolean;\n  urls?: string[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const supabase = await createClient();\n    \n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const urls: string[] = [];\n    \n      // Upload each file to Supabase Storage\n      // Use company-files bucket which has proper RLS policies for company members\n      for (const file of files) {\n        const fileExt = file.name.split('.').pop();\n        const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;\n        // Path structure: companyId must be at index [0] for RLS policy (matches document-manager pattern)\n        // Format: companyId/folder/filename (storage.foldername(name))[0] = companyId\n        const filePath = `${companyId}/sms-attachments/${fileName}`;\n        \n        // Convert file to array buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const { data, error: uploadError } = await supabase.storage\n          .from('company-files') // Use company-files bucket with proper RLS\n          .upload(filePath, arrayBuffer, {\n            contentType: file.type,\n            upsert: false,\n          });\n        \n        if (uploadError) {\n          console.error(\"Upload error:\", uploadError);\n          return { success: false, error: `Failed to upload ${file.name}: ${uploadError.message}` };\n        }\n        \n        // Get public URL (or signed URL for private bucket)\n        const { data: { publicUrl } } = supabase.storage\n          .from('company-files')\n          .getPublicUrl(filePath);\n        \n        urls.push(publicUrl);\n      }\n    \n    return { success: true, urls };\n  } catch (error) {\n    console.error(\"Error uploading SMS attachments:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * SMS Template Context Type\n * Data available for auto-filling SMS templates\n */\nexport type SmsTemplateContext = {\n  companyName?: string;\n  companyPhone?: string;\n  companyEmail?: string;\n};\n\n/**\n * Get company context for SMS templates\n * Returns company info for auto-filling template messages\n */\nexport async function getCompanyContextAction(): Promise<{\n  success: boolean;\n  context?: SmsTemplateContext;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { getActiveCompany } = await import(\"@/lib/auth/company-context\");\n\n    const company = await getActiveCompany();\n    if (!company) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    return {\n      success: true,\n      context: {\n        companyName: company.name,\n        companyPhone: company.phone || undefined,\n        companyEmail: company.email || undefined,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting company context:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;IA0LsB,2BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}}]
}