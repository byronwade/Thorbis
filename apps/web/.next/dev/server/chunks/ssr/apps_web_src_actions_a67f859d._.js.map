{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/notifications.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA4YsB,qBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/notifications.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA8TsB,gBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/notifications.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAqRsB,aAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/telnyx.ts"],"sourcesContent":["/**\n * Telnyx Server Actions\n *\n * Server-side actions for Telnyx VoIP operations:\n * - Phone number management\n * - Call operations\n * - SMS operations\n * - Voicemail operations\n *\n * All actions include proper authentication and authorization checks.\n */\n\n\"use server\";\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { revalidatePath } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tanswerCall,\n\thangupCall,\n\tinitiateCall,\n\trejectCall,\n\tstartRecording,\n\tstopRecording,\n} from \"@/lib/telnyx/calls\";\nimport { TELNYX_CONFIG } from \"@/lib/telnyx/client\";\nimport {\n\tvalidateCallConfig,\n\tvalidateSmsConfig,\n} from \"@/lib/telnyx/config-validator\";\nimport { verifyConnection } from \"@/lib/telnyx/connection-setup\";\nimport { formatPhoneNumber, sendMMS, sendSMS } from \"@/lib/telnyx/messaging\";\nimport { verifyMessagingProfile } from \"@/lib/telnyx/messaging-profile-setup\";\nimport {\n\ttype NumberFeature,\n\ttype NumberType,\n\tpurchaseNumber,\n\treleaseNumber,\n\tsearchAvailableNumbers,\n} from \"@/lib/telnyx/numbers\";\nimport {\n\tverifySmsCapability,\n\tverifyVoiceCapability,\n} from \"@/lib/telnyx/phone-number-setup\";\nimport {\n\ttype CompanyTelnyxSettingsRow,\n\tensureCompanyTelnyxSetup,\n\tfetchCompanyTelnyxSettings,\n} from \"@/lib/telnyx/provision-company\";\nimport type { Database, Json } from \"@/types/supabase\";\nimport { ensureMessagingCampaign } from \"./messaging-branding\";\n\ntype TypedSupabaseClient = SupabaseClient<Database>;\n\nfunction normalizePhoneNumber(phoneNumber: string): string {\n\treturn formatPhoneNumber(phoneNumber);\n}\n\nfunction extractAreaCode(phoneNumber: string): string | null {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn digits.slice(1, 4);\n\t}\n\tif (digits.length === 10) {\n\t\treturn digits.slice(0, 3);\n\t}\n\treturn null;\n}\n\nconst DEFAULT_MESSAGING_PROFILE_ID =\n\tprocess.env.TELNYX_DEFAULT_MESSAGING_PROFILE_ID ||\n\tprocess.env.NEXT_PUBLIC_TELNYX_MESSAGING_PROFILE_ID ||\n\t\"\";\n\nconst DEFAULT_PHONE_NUMBER_FEATURES: Json = [\"voice\", \"sms\", \"mms\"];\n\nfunction formatDisplayPhoneNumber(phoneNumber: string): string {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\n\t}\n\tif (digits.length === 10) {\n\t\treturn `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n\t}\n\treturn phoneNumber;\n}\n\nasync function getCompanyTelnyxSettings(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string | null,\n): Promise<CompanyTelnyxSettingsRow | null> {\n\tif (!companyId) {\n\t\treturn null;\n\t}\n\n\tconst existing = await fetchCompanyTelnyxSettings(supabase, companyId);\n\tif (existing && existing.status === \"ready\") {\n\t\treturn existing;\n\t}\n\n\tconst provisionResult = await ensureCompanyTelnyxSetup({\n\t\tcompanyId,\n\t\tsupabase,\n\t});\n\n\tif (!provisionResult.success) {\n\t\treturn null;\n\t}\n\n\treturn provisionResult.settings ?? null;\n}\n\nfunction normalizeBaseUrl(url: string): string {\n\tconst trimmed = url.trim().replace(/\\/+$/, \"\");\n\tif (/^https?:\\/\\//i.test(trimmed)) {\n\t\tif (/^http:\\/\\//i.test(trimmed) && !isLocalUrl(trimmed)) {\n\t\t\treturn trimmed.replace(/^http:\\/\\//i, \"https://\");\n\t\t}\n\t\treturn trimmed;\n\t}\n\treturn `https://${trimmed}`;\n}\n\nfunction isLocalUrl(url: string): boolean {\n\tconst lowered = url.toLowerCase();\n\treturn (\n\t\tlowered.includes(\"localhost\") ||\n\t\tlowered.includes(\"127.0.0.1\") ||\n\t\tlowered.includes(\"0.0.0.0\") ||\n\t\tlowered.endsWith(\".local\") ||\n\t\tlowered.includes(\"://local\")\n\t);\n}\n\nfunction shouldUseUrl(url: string): boolean {\n\tif (!url) {\n\t\treturn false;\n\t}\n\tconst trimmed = url.trim();\n\tif (!trimmed) {\n\t\treturn false;\n\t}\n\tconst isHostedProduction =\n\t\t(process.env.VERCEL === \"1\" && process.env.VERCEL_ENV === \"production\") ||\n\t\tprocess.env.DEPLOYMENT_ENV === \"production\";\n\n\tif (isHostedProduction && isLocalUrl(trimmed)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nasync function getBaseAppUrl(): Promise<string | undefined> {\n\tconst candidates = [\n\t\tprocess.env.NEXT_PUBLIC_SITE_URL,\n\t\tprocess.env.SITE_URL,\n\t\tprocess.env.NEXT_PUBLIC_APP_URL,\n\t\tprocess.env.APP_URL,\n\t];\n\tfor (const candidate of candidates) {\n\t\tif (candidate && shouldUseUrl(candidate)) {\n\t\t\treturn normalizeBaseUrl(candidate);\n\t\t}\n\t}\n\n\tconst vercelUrl = process.env.VERCEL_URL;\n\tif (vercelUrl && shouldUseUrl(vercelUrl)) {\n\t\treturn normalizeBaseUrl(\n\t\t\tvercelUrl.startsWith(\"http\") ? vercelUrl : `https://${vercelUrl}`,\n\t\t);\n\t}\n\n\ttry {\n\t\tconst hdrs = await headers();\n\t\tconst origin = hdrs.get(\"origin\");\n\t\tif (origin && shouldUseUrl(origin)) {\n\t\t\treturn normalizeBaseUrl(origin);\n\t\t}\n\t\tconst host = hdrs.get(\"host\");\n\t\tif (host && shouldUseUrl(host)) {\n\t\t\tconst protocol = host.includes(\"localhost\") ? \"http\" : \"https\";\n\t\t\treturn normalizeBaseUrl(`${protocol}://${host}`);\n\t\t}\n\t} catch {\n\t\t// headers() not available outside of a request context\n\t}\n\n\treturn undefined;\n}\n\nasync function buildAbsoluteUrl(path: string): Promise<string | undefined> {\n\tconst base = await getBaseAppUrl();\n\tif (!base) {\n\t\treturn undefined;\n\t}\n\tconst normalizedPath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${base}${normalizedPath}`;\n}\n\nasync function getTelnyxWebhookUrl(\n\tcompanyId?: string,\n): Promise<string | undefined> {\n\tif (companyId) {\n\t\treturn buildAbsoluteUrl(`/api/webhooks/telnyx?company=${companyId}`);\n\t}\n\treturn buildAbsoluteUrl(\"/api/webhooks/telnyx\");\n}\n\nasync function getPhoneNumberId(\n\tsupabase: TypedSupabaseClient,\n\tphoneNumber: string,\n): Promise<string | null> {\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"phone_number\", normalized)\n\t\t.is(\"deleted_at\", null)\n\t\t.maybeSingle();\n\n\treturn data?.id ?? null;\n}\n\nasync function ensurePhoneNumberRecordExists(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\tphoneNumber: string | null,\n): Promise<void> {\n\tif (!phoneNumber) {\n\t\treturn;\n\t}\n\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"phone_number\", normalized)\n\t\t.limit(1);\n\n\tif (data && data.length > 0) {\n\t\treturn;\n\t}\n\n\tawait supabase.from(\"phone_numbers\").insert({\n\t\tcompany_id: companyId,\n\t\tphone_number: normalized,\n\t\tformatted_number: formatDisplayPhoneNumber(normalized),\n\t\tcountry_code: \"US\",\n\t\tarea_code: extractAreaCode(normalized),\n\t\tnumber_type: \"local\",\n\t\tstatus: \"active\",\n\t\tfeatures: DEFAULT_PHONE_NUMBER_FEATURES,\n\t});\n}\n\nasync function resolveOutboundPhoneNumber(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\texplicitFrom?: string | null,\n\tdefaultNumber?: string | null,\n): Promise<string | null> {\n\tif (explicitFrom) {\n\t\treturn normalizePhoneNumber(explicitFrom);\n\t}\n\n\tconst normalizedDefault = defaultNumber\n\t\t? normalizePhoneNumber(defaultNumber)\n\t\t: null;\n\n\ttry {\n\t\tconst { data } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number, number_type\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (data && data.length > 0) {\n\t\t\tconst tollFree = data.find((n) => n.number_type === \"toll-free\");\n\t\t\tif (tollFree) {\n\t\t\t\treturn normalizePhoneNumber(tollFree.phone_number);\n\t\t\t}\n\n\t\t\tif (normalizedDefault) {\n\t\t\t\tconst defaultExists = data.some(\n\t\t\t\t\t(n) => normalizePhoneNumber(n.phone_number) === normalizedDefault,\n\t\t\t\t);\n\t\t\t\tif (defaultExists) {\n\t\t\t\t\treturn normalizedDefault;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn normalizePhoneNumber(data[0].phone_number);\n\t\t}\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"Failed to load company phone numbers for outbound selection:\",\n\t\t\terror,\n\t\t);\n\t}\n\n\treturn normalizedDefault;\n}\n\nasync function mergeProviderMetadata(\n\tsupabase: TypedSupabaseClient,\n\tcommunicationId: string,\n\tpatch: Record<string, Json>,\n): Promise<void> {\n\tconst { data } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"provider_metadata\")\n\t\t.eq(\"id\", communicationId)\n\t\t.maybeSingle();\n\n\tconst currentMetadata =\n\t\t(data?.provider_metadata as Record<string, Json> | null) ?? {};\n\tconst mergedMetadata: Record<string, Json> = {\n\t\t...currentMetadata,\n\t\t...patch,\n\t};\n\n\tawait supabase\n\t\t.from(\"communications\")\n\t\t.update({\n\t\t\tprovider_metadata: mergedMetadata,\n\t\t})\n\t\t.eq(\"id\", communicationId);\n}\n\n// =====================================================================================\n// PHONE NUMBER MANAGEMENT ACTIONS\n// =====================================================================================\n\n/**\n * Search for available phone numbers to purchase\n */\nexport async function searchPhoneNumbers(params: {\n\tareaCode?: string;\n\tnumberType?: NumberType;\n\tfeatures?: NumberFeature[];\n\tlimit?: number;\n}) {\n\ttry {\n\t\tconst result = await searchAvailableNumbers({\n\t\t\tcountryCode: \"US\",\n\t\t\tareaCode: params.areaCode,\n\t\t\tnumberType: params.numberType,\n\t\t\tfeatures: params.features,\n\t\t\tlimit: params.limit || 10,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to search phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Purchase a phone number and associate it with the current company\n */\nexport async function purchasePhoneNumber(params: {\n\tphoneNumber: string;\n\tcompanyId: string;\n\tbillingGroupId?: string;\n}) {\n\ttry {\n\t\t// Validate configuration\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tconst callConfig = validateCallConfig();\n\t\tif (!smsConfig.valid || !callConfig.valid) {\n\t\t\tlet errorMessage =\n\t\t\t\t\"Telnyx configuration is incomplete. Please configure all required environment variables.\";\n\n\t\t\t// If we have a suggested profile ID, include it in the error\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} to use it.`;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst normalizedPhoneNumber = normalizePhoneNumber(params.phoneNumber);\n\t\tconst formattedNumber = formatDisplayPhoneNumber(normalizedPhoneNumber);\n\t\tconst areaCode = extractAreaCode(normalizedPhoneNumber);\n\n\t\t// Purchase number from Telnyx\n\t\tconst messagingProfileId = DEFAULT_MESSAGING_PROFILE_ID || undefined;\n\n\t\tconst result = await purchaseNumber({\n\t\t\tphoneNumber: normalizedPhoneNumber,\n\t\t\tconnectionId: TELNYX_CONFIG.connectionId,\n\t\t\tmessagingProfileId,\n\t\t\tbillingGroupId: params.billingGroupId,\n\t\t\tcustomerReference: `company_${params.companyId}`,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Store in database\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\ttelnyx_phone_number_id: result.orderId,\n\t\t\t\ttelnyx_connection_id: TELNYX_CONFIG.connectionId,\n\t\t\t\tphone_number: normalizedPhoneNumber,\n\t\t\t\tformatted_number: formattedNumber,\n\t\t\t\tcountry_code: \"US\",\n\t\t\t\tarea_code: areaCode,\n\t\t\t\tnumber_type: \"local\",\n\t\t\t\tfeatures: [\"voice\", \"sms\"],\n\t\t\t\tstatus: \"pending\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\ttry {\n\t\t\tawait ensureMessagingCampaign(\n\t\t\t\tparams.companyId,\n\t\t\t\t{ id: data.id, e164: normalizedPhoneNumber },\n\t\t\t\t{ supabase },\n\t\t\t);\n\t\t} catch (_campaignError) {}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to purchase phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Get all phone numbers for a company\n */\nexport async function getCompanyPhoneNumbers(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Update phone number configuration\n */\nasync function updatePhoneNumber(params: {\n\tphoneNumberId: string;\n\troutingRuleId?: string;\n\tforwardToNumber?: string;\n\tvoicemailEnabled?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tcall_routing_rule_id: params.routingRuleId,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tvoicemail_enabled: params.voicemailEnabled,\n\t\t\t})\n\t\t\t.eq(\"id\", params.phoneNumberId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Release (delete) a phone number\n */\nasync function deletePhoneNumber(phoneNumberId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get phone number details\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", phoneNumberId)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) {\n\t\t\treturn { success: false, error: \"Phone number not found\" };\n\t\t}\n\n\t\t// Release from Telnyx if we have the ID\n\t\tif (phoneNumber.telnyx_phone_number_id) {\n\t\t\tawait releaseNumber(phoneNumber.telnyx_phone_number_id);\n\t\t}\n\n\t\t// Soft delete in database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tstatus: \"deleted\",\n\t\t\t})\n\t\t\t.eq(\"id\", phoneNumberId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete phone number\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Initiate an outbound call\n */\nexport async function makeCall(params: {\n\tto: string;\n\tfrom: string;\n\tcompanyId: string;\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconsole.log(\" makeCall called with params:\", params);\n\n\t\tconst callConfig = validateCallConfig();\n\t\tconsole.log(\" Call config validation:\", callConfig);\n\t\tif (!callConfig.valid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: callConfig.error || \"Call configuration is invalid\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t);\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tconst connectionOverride =\n\t\t\tcompanySettings?.call_control_application_id ||\n\t\t\tTELNYX_CONFIG.connectionId;\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tif (!connectionOverride) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"No Telnyx connection configured for this company.\",\n\t\t\t};\n\t\t}\n\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\n\t\t// TEMP: Skip connection verification - Level 2 required for API access\n\t\t// const connectionStatus = await verifyConnection(connectionOverride);\n\t\t// if (connectionStatus.needsFix) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror: `Connection configuration issue: ${connectionStatus.issues.join(\", \")}. Run fixConnection() to auto-fix.`,\n\t\t// \t};\n\t\t// }\n\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\t// TEMP: Skip voice capability check - Level 2 required for API access\n\t\t// const voiceCapability = await verifyVoiceCapability(fromAddress);\n\t\t// if (!voiceCapability.hasVoice) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror:\n\t\t// \t\t\tvoiceCapability.error || \"Phone number does not support voice calls\",\n\t\t// \t};\n\t\t// }\n\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl(params.companyId);\n\t\tconsole.log(\" Webhook URL:\", telnyxWebhookUrl);\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\" Initiating call:\", {\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\tconst result = await initiateCall({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t\tansweringMachineDetection: \"premium\",\n\t\t});\n\n\t\tconsole.log(\" Telnyx API response:\", result);\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"phone\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: \"\",\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_call_control_id: result.callControlId,\n\t\t\t\ttelnyx_call_session_id: result.callSessionId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconsole.log(\" Call created successfully:\", {\n\t\t\tcallControlId: result.callControlId,\n\t\t\tcommunicationId: data.id,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcallControlId: result.callControlId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\" makeCall error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to make call\",\n\t\t};\n\t}\n}\n\n/**\n * Answer an incoming call\n/**\n * Answer an incoming call\n */\nasync function acceptCall(callControlId: string) {\n\ttry {\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl();\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconst result = await answerCall({\n\t\t\tcallControlId,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to answer call\",\n\t\t};\n\t}\n}\n\n/**\n * Reject an incoming call\n */\nasync function declineCall(callControlId: string) {\n\ttry {\n\t\tconst result = await rejectCall({\n\t\t\tcallControlId,\n\t\t\tcause: \"CALL_REJECTED\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to reject call\",\n\t\t};\n\t}\n}\n\n/**\n * End an active call\n */\nasync function endCall(callControlId: string) {\n\ttry {\n\t\tconst result = await hangupCall({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to end call\",\n\t\t};\n\t}\n}\n\n/**\n * Start recording a call\n */\nexport async function startCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await startRecording({\n\t\t\tcallControlId,\n\t\t\tformat: \"mp3\",\n\t\t\tchannels: \"single\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to start recording\",\n\t\t};\n\t}\n}\n\n/**\n * Stop recording a call\n */\nexport async function stopCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await stopRecording({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to stop recording\",\n\t\t};\n\t}\n}\n\n/**\n * Transfer an active call to another number\n */\nexport async function transferActiveCall(params: {\n\tcallControlId: string;\n\tto: string;\n\tfrom: string;\n}) {\n\ttry {\n\t\tconst { transferCall } = await import(\"@/lib/telnyx/calls\");\n\t\tconst result = await transferCall({\n\t\t\tcallControlId: params.callControlId,\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to transfer call\",\n\t\t};\n\t}\n}\n\n/**\n * Transcribe a call recording using AssemblyAI\n *\n * Submits the recording URL to AssemblyAI for post-call transcription.\n * AssemblyAI will process the audio and send the transcript via webhook.\n *\n * @param recordingUrl - URL of the call recording (from Telnyx)\n * @param communicationId - Database ID of the communication record\n * @returns Success/error response with transcription job ID\n */\nexport async function transcribeCallRecording(params: {\n\trecordingUrl: string;\n\tcommunicationId: string;\n}) {\n\ttry {\n\t\tconst { submitTranscription } = await import(\"@/lib/assemblyai/client\");\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst webhookUrl = await buildAbsoluteUrl(\"/api/webhooks/assemblyai\");\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL.\",\n\t\t\t};\n\t\t}\n\n\t\t// Submit to AssemblyAI\n\t\tconst result = await submitTranscription({\n\t\t\taudio_url: params.recordingUrl,\n\t\t\tspeaker_labels: true, // Enable speaker diarization\n\t\t\twebhook_url: webhookUrl,\n\t\t});\n\n\t\tif (!(result.success && result.data)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error || \"Failed to submit transcription\",\n\t\t\t};\n\t\t}\n\n\t\t// Store transcription job ID in database\n\t\tawait mergeProviderMetadata(supabase, params.communicationId, {\n\t\t\tassemblyai_transcription_id: result.data.id,\n\t\t\tassemblyai_status: result.data.status,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttranscriptionId: result.data.id,\n\t\t\tstatus: result.data.status,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to transcribe recording\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// SMS OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Send an SMS message\n */\nexport async function sendTextMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext: string;\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tconsole.error(\" Supabase client unavailable\");\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\" SMS Send Request:\", {\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t\tcompanyId,\n\t\t});\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\tconsole.error(\" Company settings not found\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify the company's onboarding is complete and try again.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Company settings loaded:\", {\n\t\t\tmessagingProfileId: companySettings.messaging_profile_id,\n\t\t\tdefaultNumber: companySettings.default_outbound_number,\n\t\t});\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings?.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or provision company-specific settings.`;\n\t\t\t}\n\t\t\tconsole.error(\" SMS config invalid:\", errorMessage);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS config valid\");\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings?.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\tconsole.error(\" No messaging profile ID\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending SMS.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Using messaging profile:\", messagingProfileId);\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t\" Messaging profile needs fix:\",\n\t\t\t\t\tmessagingProfileStatus.issues,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconsole.log(\" Messaging profile verified\");\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\tconsole.error(\" No from number available\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\t\tconsole.log(\" Phone numbers normalized:\", {\n\t\t\tfrom: fromAddress,\n\t\t\tto: toAddress,\n\t\t});\n\n\t\t// Verify phone number has SMS capability\n\t\tconsole.log(\" Verifying SMS capability for:\", fromAddress);\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\tconsole.error(\" SMS capability check failed:\", smsCapability.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS capability verified\");\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\tconsole.error(\" No webhook URL\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Webhook URL:\", webhookUrl);\n\n\t\t// Send SMS via Telnyx\n\t\tconsole.log(\" Sending SMS via Telnyx API...\");\n\t\tconst result = await sendSMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\tconsole.error(\" Telnyx API failed:\", result.error);\n\n\t\t\t// Check if error is 10DLC registration required\n\t\t\tif (\n\t\t\t\tresult.error &&\n\t\t\t\t(result.error.includes(\"10DLC\") ||\n\t\t\t\t\tresult.error.includes(\"Not 10DLC registered\") ||\n\t\t\t\t\tresult.error.includes(\"A2P\"))\n\t\t\t) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\" Detected 10DLC registration required, attempting auto-registration...\",\n\t\t\t\t);\n\n\t\t\t\t// Import 10DLC registration function\n\t\t\t\tconst { registerCompanyFor10DLC } = await import(\n\t\t\t\t\t\"@/actions/ten-dlc-registration\"\n\t\t\t\t);\n\n\t\t\t\tconst registrationResult = await registerCompanyFor10DLC(\n\t\t\t\t\tcompanyId,\n\t\t\t\t);\n\n\t\t\t\tif (registrationResult.success) {\n\t\t\t\t\tconsole.log(\" 10DLC registration successful, retrying SMS send...\");\n\n\t\t\t\t\t// Retry the SMS send now that 10DLC is registered\n\t\t\t\t\tconst retryResult = await sendSMS({\n\t\t\t\t\t\tto: toAddress,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\ttext: params.text,\n\t\t\t\t\t\twebhookUrl,\n\t\t\t\t\t\tmessagingProfileId,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!retryResult.success) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\terror: `10DLC registration completed but SMS still failed: ${retryResult.error}. The campaign may need additional approval time.`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update result with retry success\n\t\t\t\t\tresult.success = true;\n\t\t\t\t\tresult.messageId = retryResult.messageId;\n\t\t\t\t\tconsole.log(\" SMS retry successful after 10DLC registration\");\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: `10DLC registration failed: ${registrationResult.error}. Original error: ${result.error}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tconsole.log(\" Telnyx API success:\", result.messageId);\n\n\t\t// Create communication record\n\t\tconsole.log(\" Creating communication record in database...\");\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"SMS send error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\ttype: typeof error,\n\t\t\tstringified: JSON.stringify(error, null, 2),\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to send SMS: ${String(error)}`,\n\t\t};\n\t}\n}\n\n/**\n * Send an MMS message with media\n */\nexport async function sendMMSMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext?: string;\n\tmediaUrls: string[];\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify onboarding is complete.\",\n\t\t\t};\n\t\t}\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or reprovision the company.`;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending MMS.\",\n\t\t\t};\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS/MMS\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await sendMMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\tmediaUrls: params.mediaUrls,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text || \"\",\n\t\t\t\tattachments: params.mediaUrls.map((url) => ({ url, type: \"image\" })),\n\t\t\t\tattachment_count: params.mediaUrls.length,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to send MMS\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// WEBRTC OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Generate WebRTC credentials for browser calling\n */\nexport async function getWebRTCCredentials() {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: userError,\n\t\t} = await supabase.auth.getUser();\n\t\tif (userError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User not authenticated\",\n\t\t\t};\n\t\t}\n\n\t\t// OPTION 1: Use static credentials from environment (recommended for production)\n\t\tconst staticUsername = process.env.TELNYX_WEBRTC_USERNAME;\n\t\tconst staticPassword = process.env.TELNYX_WEBRTC_PASSWORD;\n\n\t\tif (staticUsername && staticPassword) {\n\t\t\tconst credential = {\n\t\t\t\tusername: staticUsername,\n\t\t\t\tpassword: staticPassword,\n\t\t\t\texpires_at: Date.now() + 86_400 * 1000, // 24 hours from now\n\t\t\t\trealm: \"sip.telnyx.com\",\n\t\t\t\tsip_uri: `sip:${staticUsername}@sip.telnyx.com`,\n\t\t\t\tstun_servers: [\n\t\t\t\t\t\"stun:stun.telnyx.com:3478\",\n\t\t\t\t\t\"stun:stun.telnyx.com:3479\",\n\t\t\t\t],\n\t\t\t\tturn_servers: [\n\t\t\t\t\t{\n\t\t\t\t\t\turls: [\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=udp\",\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=tcp\",\n\t\t\t\t\t\t],\n\t\t\t\t\t\tusername: staticUsername,\n\t\t\t\t\t\tcredential: staticPassword,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tcredential,\n\t\t\t};\n\t\t}\n\n\t\tconst { generateWebRTCToken } = await import(\"@/lib/telnyx/webrtc\");\n\t\tconst result = await generateWebRTCToken({\n\t\t\tusername: user.email || user.id,\n\t\t\tttl: 86_400, // 24 hours\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcredential: result.credential,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get WebRTC credentials\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// VOICEMAIL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Get all voicemails for a company\n */\nasync function getVoicemails(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        customer:customers(id, first_name, last_name, email, phone),\n        phone_number:phone_numbers(phone_number, formatted_number)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"received_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get voicemails\",\n\t\t};\n\t}\n}\n\n/**\n * Mark voicemail as read\n */\nasync function markVoicemailAsRead(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tis_read: true,\n\t\t\t\tread_at: new Date().toISOString(),\n\t\t\t\tread_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to mark voicemail as read\",\n\t\t};\n\t}\n}\n\n/**\n * Delete voicemail\n */\nasync function deleteVoicemail(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to delete voicemail\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL ROUTING RULES ACTIONS\n// =====================================================================================\n\n/**\n * Get all call routing rules for a company\n */\nexport async function getCallRoutingRules(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        created_by_user:users!call_routing_rules_created_by_fkey(id, name, email),\n        forward_to_user:users!call_routing_rules_forward_to_user_id_fkey(id, name, email)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"priority\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get call routing rules\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new call routing rule\n */\nasync function createCallRoutingRule(params: {\n\tcompanyId: string;\n\tuserId: string;\n\tname: string;\n\tdescription?: string;\n\troutingType:\n\t\t| \"direct\"\n\t\t| \"round_robin\"\n\t\t| \"ivr\"\n\t\t| \"business_hours\"\n\t\t| \"conditional\";\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\tcreated_by: params.userId,\n\t\t\t\tname: params.name,\n\t\t\t\tdescription: params.description,\n\t\t\t\trouting_type: params.routingType,\n\t\t\t\tpriority: params.priority || 0,\n\t\t\t\tbusiness_hours: params.businessHours,\n\t\t\t\ttimezone: params.timezone || \"America/Los_Angeles\",\n\t\t\t\tafter_hours_action: params.afterHoursAction,\n\t\t\t\tafter_hours_forward_to: params.afterHoursForwardTo,\n\t\t\t\tteam_members: params.teamMembers,\n\t\t\t\tring_timeout: params.ringTimeout || 20,\n\t\t\t\tivr_menu: params.ivrMenu,\n\t\t\t\tivr_greeting_url: params.ivrGreetingUrl,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tforward_to_user_id: params.forwardToUserId,\n\t\t\t\tenable_voicemail: params.enableVoicemail !== false,\n\t\t\t\tvoicemail_greeting_url: params.voicemailGreetingUrl,\n\t\t\t\tvoicemail_transcription_enabled:\n\t\t\t\t\tparams.voicemailTranscriptionEnabled !== false,\n\t\t\t\tvoicemail_email_notifications:\n\t\t\t\t\tparams.voicemailEmailNotifications !== false,\n\t\t\t\trecord_calls: params.recordCalls,\n\t\t\t\tis_active: true,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to create call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Update an existing call routing rule\n */\nexport async function updateCallRoutingRule(params: {\n\truleId: string;\n\tname?: string;\n\tdescription?: string;\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n\tisActive?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst updateData: Record<string, unknown> = {};\n\n\t\tif (params.name !== undefined) {\n\t\t\tupdateData.name = params.name;\n\t\t}\n\t\tif (params.description !== undefined) {\n\t\t\tupdateData.description = params.description;\n\t\t}\n\t\tif (params.priority !== undefined) {\n\t\t\tupdateData.priority = params.priority;\n\t\t}\n\t\tif (params.businessHours !== undefined) {\n\t\t\tupdateData.business_hours = params.businessHours;\n\t\t}\n\t\tif (params.timezone !== undefined) {\n\t\t\tupdateData.timezone = params.timezone;\n\t\t}\n\t\tif (params.afterHoursAction !== undefined) {\n\t\t\tupdateData.after_hours_action = params.afterHoursAction;\n\t\t}\n\t\tif (params.afterHoursForwardTo !== undefined) {\n\t\t\tupdateData.after_hours_forward_to = params.afterHoursForwardTo;\n\t\t}\n\t\tif (params.teamMembers !== undefined) {\n\t\t\tupdateData.team_members = params.teamMembers;\n\t\t}\n\t\tif (params.ringTimeout !== undefined) {\n\t\t\tupdateData.ring_timeout = params.ringTimeout;\n\t\t}\n\t\tif (params.ivrMenu !== undefined) {\n\t\t\tupdateData.ivr_menu = params.ivrMenu;\n\t\t}\n\t\tif (params.ivrGreetingUrl !== undefined) {\n\t\t\tupdateData.ivr_greeting_url = params.ivrGreetingUrl;\n\t\t}\n\t\tif (params.forwardToNumber !== undefined) {\n\t\t\tupdateData.forward_to_number = params.forwardToNumber;\n\t\t}\n\t\tif (params.forwardToUserId !== undefined) {\n\t\t\tupdateData.forward_to_user_id = params.forwardToUserId;\n\t\t}\n\t\tif (params.enableVoicemail !== undefined) {\n\t\t\tupdateData.enable_voicemail = params.enableVoicemail;\n\t\t}\n\t\tif (params.voicemailGreetingUrl !== undefined) {\n\t\t\tupdateData.voicemail_greeting_url = params.voicemailGreetingUrl;\n\t\t}\n\t\tif (params.voicemailTranscriptionEnabled !== undefined) {\n\t\t\tupdateData.voicemail_transcription_enabled =\n\t\t\t\tparams.voicemailTranscriptionEnabled;\n\t\t}\n\t\tif (params.voicemailEmailNotifications !== undefined) {\n\t\t\tupdateData.voicemail_email_notifications =\n\t\t\t\tparams.voicemailEmailNotifications;\n\t\t}\n\t\tif (params.recordCalls !== undefined) {\n\t\t\tupdateData.record_calls = params.recordCalls;\n\t\t}\n\t\tif (params.isActive !== undefined) {\n\t\t\tupdateData.is_active = params.isActive;\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", params.ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a call routing rule\n */\nexport async function deleteCallRoutingRule(ruleId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", ruleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Toggle call routing rule active status\n */\nexport async function toggleCallRoutingRule(ruleId: string, isActive: boolean) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({ is_active: isActive })\n\t\t\t.eq(\"id\", ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to toggle call routing rule\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// PHONE NUMBER USAGE STATISTICS ACTIONS\n// =====================================================================================\n\n/**\n * Get usage statistics for a phone number\n */\nasync function getPhoneNumberUsageStats(\n\tphoneNumberId: string,\n\tdays = 30,\n) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get call statistics\n\t\tconst { data: callStats, error: callError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"type\", \"phone\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (callError) {\n\t\t\tthrow callError;\n\t\t}\n\n\t\t// Get SMS statistics\n\t\tconst { data: smsStats, error: smsError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, created_at\")\n\t\t\t.eq(\"type\", \"sms\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (smsError) {\n\t\t\tthrow smsError;\n\t\t}\n\n\t\t// Calculate aggregates\n\t\tconst calls = callStats || [];\n\t\tconst sms = smsStats || [];\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats([...calls, ...sms], days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Get company-wide usage statistics\n */\nasync function getCompanyUsageStats(companyId: string, days = 30) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get all communications for the company\n\t\tconst { data: communications, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.in(\"type\", [\"phone\", \"sms\"])\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst items = communications || [];\n\t\tconst calls = items.filter((i) => i.type === \"phone\");\n\t\tconst sms = items.filter((i) => i.type === \"sms\");\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\taverageCallDuration:\n\t\t\t\t\tcalls.length > 0 ? totalCallDuration / calls.length : 0,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats(items, days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Helper function to aggregate daily statistics\n */\nfunction aggregateDailyStats(\n\titems: Array<{ created_at: string; type: string; call_duration?: number }>,\n\tdays: number,\n) {\n\tconst dailyStats: Record<\n\t\tstring,\n\t\t{ date: string; calls: number; sms: number; duration: number }\n\t> = {};\n\n\t// Initialize all days\n\tfor (let i = 0; i < days; i++) {\n\t\tconst date = new Date();\n\t\tdate.setDate(date.getDate() - i);\n\t\tconst dateStr = date.toISOString().split(\"T\")[0];\n\t\tdailyStats[dateStr] = { date: dateStr, calls: 0, sms: 0, duration: 0 };\n\t}\n\n\t// Aggregate data\n\titems.forEach((item) => {\n\t\tconst dateStr = item.created_at.split(\"T\")[0];\n\t\tif (dailyStats[dateStr]) {\n\t\t\tif (item.type === \"phone\") {\n\t\t\t\tdailyStats[dateStr].calls += 1;\n\t\t\t\tdailyStats[dateStr].duration += item.call_duration || 0;\n\t\t\t} else if (item.type === \"sms\") {\n\t\t\t\tdailyStats[dateStr].sms += 1;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Object.values(dailyStats).sort((a, b) => a.date.localeCompare(b.date));\n}\n"],"names":[],"mappings":";;;;;;;IA6lBsB,WAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/telnyx.ts"],"sourcesContent":["/**\n * Telnyx Server Actions\n *\n * Server-side actions for Telnyx VoIP operations:\n * - Phone number management\n * - Call operations\n * - SMS operations\n * - Voicemail operations\n *\n * All actions include proper authentication and authorization checks.\n */\n\n\"use server\";\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { revalidatePath } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tanswerCall,\n\thangupCall,\n\tinitiateCall,\n\trejectCall,\n\tstartRecording,\n\tstopRecording,\n} from \"@/lib/telnyx/calls\";\nimport { TELNYX_CONFIG } from \"@/lib/telnyx/client\";\nimport {\n\tvalidateCallConfig,\n\tvalidateSmsConfig,\n} from \"@/lib/telnyx/config-validator\";\nimport { verifyConnection } from \"@/lib/telnyx/connection-setup\";\nimport { formatPhoneNumber, sendMMS, sendSMS } from \"@/lib/telnyx/messaging\";\nimport { verifyMessagingProfile } from \"@/lib/telnyx/messaging-profile-setup\";\nimport {\n\ttype NumberFeature,\n\ttype NumberType,\n\tpurchaseNumber,\n\treleaseNumber,\n\tsearchAvailableNumbers,\n} from \"@/lib/telnyx/numbers\";\nimport {\n\tverifySmsCapability,\n\tverifyVoiceCapability,\n} from \"@/lib/telnyx/phone-number-setup\";\nimport {\n\ttype CompanyTelnyxSettingsRow,\n\tensureCompanyTelnyxSetup,\n\tfetchCompanyTelnyxSettings,\n} from \"@/lib/telnyx/provision-company\";\nimport type { Database, Json } from \"@/types/supabase\";\nimport { ensureMessagingCampaign } from \"./messaging-branding\";\n\ntype TypedSupabaseClient = SupabaseClient<Database>;\n\nfunction normalizePhoneNumber(phoneNumber: string): string {\n\treturn formatPhoneNumber(phoneNumber);\n}\n\nfunction extractAreaCode(phoneNumber: string): string | null {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn digits.slice(1, 4);\n\t}\n\tif (digits.length === 10) {\n\t\treturn digits.slice(0, 3);\n\t}\n\treturn null;\n}\n\nconst DEFAULT_MESSAGING_PROFILE_ID =\n\tprocess.env.TELNYX_DEFAULT_MESSAGING_PROFILE_ID ||\n\tprocess.env.NEXT_PUBLIC_TELNYX_MESSAGING_PROFILE_ID ||\n\t\"\";\n\nconst DEFAULT_PHONE_NUMBER_FEATURES: Json = [\"voice\", \"sms\", \"mms\"];\n\nfunction formatDisplayPhoneNumber(phoneNumber: string): string {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\n\t}\n\tif (digits.length === 10) {\n\t\treturn `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n\t}\n\treturn phoneNumber;\n}\n\nasync function getCompanyTelnyxSettings(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string | null,\n): Promise<CompanyTelnyxSettingsRow | null> {\n\tif (!companyId) {\n\t\treturn null;\n\t}\n\n\tconst existing = await fetchCompanyTelnyxSettings(supabase, companyId);\n\tif (existing && existing.status === \"ready\") {\n\t\treturn existing;\n\t}\n\n\tconst provisionResult = await ensureCompanyTelnyxSetup({\n\t\tcompanyId,\n\t\tsupabase,\n\t});\n\n\tif (!provisionResult.success) {\n\t\treturn null;\n\t}\n\n\treturn provisionResult.settings ?? null;\n}\n\nfunction normalizeBaseUrl(url: string): string {\n\tconst trimmed = url.trim().replace(/\\/+$/, \"\");\n\tif (/^https?:\\/\\//i.test(trimmed)) {\n\t\tif (/^http:\\/\\//i.test(trimmed) && !isLocalUrl(trimmed)) {\n\t\t\treturn trimmed.replace(/^http:\\/\\//i, \"https://\");\n\t\t}\n\t\treturn trimmed;\n\t}\n\treturn `https://${trimmed}`;\n}\n\nfunction isLocalUrl(url: string): boolean {\n\tconst lowered = url.toLowerCase();\n\treturn (\n\t\tlowered.includes(\"localhost\") ||\n\t\tlowered.includes(\"127.0.0.1\") ||\n\t\tlowered.includes(\"0.0.0.0\") ||\n\t\tlowered.endsWith(\".local\") ||\n\t\tlowered.includes(\"://local\")\n\t);\n}\n\nfunction shouldUseUrl(url: string): boolean {\n\tif (!url) {\n\t\treturn false;\n\t}\n\tconst trimmed = url.trim();\n\tif (!trimmed) {\n\t\treturn false;\n\t}\n\tconst isHostedProduction =\n\t\t(process.env.VERCEL === \"1\" && process.env.VERCEL_ENV === \"production\") ||\n\t\tprocess.env.DEPLOYMENT_ENV === \"production\";\n\n\tif (isHostedProduction && isLocalUrl(trimmed)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nasync function getBaseAppUrl(): Promise<string | undefined> {\n\tconst candidates = [\n\t\tprocess.env.NEXT_PUBLIC_SITE_URL,\n\t\tprocess.env.SITE_URL,\n\t\tprocess.env.NEXT_PUBLIC_APP_URL,\n\t\tprocess.env.APP_URL,\n\t];\n\tfor (const candidate of candidates) {\n\t\tif (candidate && shouldUseUrl(candidate)) {\n\t\t\treturn normalizeBaseUrl(candidate);\n\t\t}\n\t}\n\n\tconst vercelUrl = process.env.VERCEL_URL;\n\tif (vercelUrl && shouldUseUrl(vercelUrl)) {\n\t\treturn normalizeBaseUrl(\n\t\t\tvercelUrl.startsWith(\"http\") ? vercelUrl : `https://${vercelUrl}`,\n\t\t);\n\t}\n\n\ttry {\n\t\tconst hdrs = await headers();\n\t\tconst origin = hdrs.get(\"origin\");\n\t\tif (origin && shouldUseUrl(origin)) {\n\t\t\treturn normalizeBaseUrl(origin);\n\t\t}\n\t\tconst host = hdrs.get(\"host\");\n\t\tif (host && shouldUseUrl(host)) {\n\t\t\tconst protocol = host.includes(\"localhost\") ? \"http\" : \"https\";\n\t\t\treturn normalizeBaseUrl(`${protocol}://${host}`);\n\t\t}\n\t} catch {\n\t\t// headers() not available outside of a request context\n\t}\n\n\treturn undefined;\n}\n\nasync function buildAbsoluteUrl(path: string): Promise<string | undefined> {\n\tconst base = await getBaseAppUrl();\n\tif (!base) {\n\t\treturn undefined;\n\t}\n\tconst normalizedPath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${base}${normalizedPath}`;\n}\n\nasync function getTelnyxWebhookUrl(\n\tcompanyId?: string,\n): Promise<string | undefined> {\n\tif (companyId) {\n\t\treturn buildAbsoluteUrl(`/api/webhooks/telnyx?company=${companyId}`);\n\t}\n\treturn buildAbsoluteUrl(\"/api/webhooks/telnyx\");\n}\n\nasync function getPhoneNumberId(\n\tsupabase: TypedSupabaseClient,\n\tphoneNumber: string,\n): Promise<string | null> {\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"phone_number\", normalized)\n\t\t.is(\"deleted_at\", null)\n\t\t.maybeSingle();\n\n\treturn data?.id ?? null;\n}\n\nasync function ensurePhoneNumberRecordExists(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\tphoneNumber: string | null,\n): Promise<void> {\n\tif (!phoneNumber) {\n\t\treturn;\n\t}\n\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"phone_number\", normalized)\n\t\t.limit(1);\n\n\tif (data && data.length > 0) {\n\t\treturn;\n\t}\n\n\tawait supabase.from(\"phone_numbers\").insert({\n\t\tcompany_id: companyId,\n\t\tphone_number: normalized,\n\t\tformatted_number: formatDisplayPhoneNumber(normalized),\n\t\tcountry_code: \"US\",\n\t\tarea_code: extractAreaCode(normalized),\n\t\tnumber_type: \"local\",\n\t\tstatus: \"active\",\n\t\tfeatures: DEFAULT_PHONE_NUMBER_FEATURES,\n\t});\n}\n\nasync function resolveOutboundPhoneNumber(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\texplicitFrom?: string | null,\n\tdefaultNumber?: string | null,\n): Promise<string | null> {\n\tif (explicitFrom) {\n\t\treturn normalizePhoneNumber(explicitFrom);\n\t}\n\n\tconst normalizedDefault = defaultNumber\n\t\t? normalizePhoneNumber(defaultNumber)\n\t\t: null;\n\n\ttry {\n\t\tconst { data } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number, number_type\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (data && data.length > 0) {\n\t\t\tconst tollFree = data.find((n) => n.number_type === \"toll-free\");\n\t\t\tif (tollFree) {\n\t\t\t\treturn normalizePhoneNumber(tollFree.phone_number);\n\t\t\t}\n\n\t\t\tif (normalizedDefault) {\n\t\t\t\tconst defaultExists = data.some(\n\t\t\t\t\t(n) => normalizePhoneNumber(n.phone_number) === normalizedDefault,\n\t\t\t\t);\n\t\t\t\tif (defaultExists) {\n\t\t\t\t\treturn normalizedDefault;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn normalizePhoneNumber(data[0].phone_number);\n\t\t}\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"Failed to load company phone numbers for outbound selection:\",\n\t\t\terror,\n\t\t);\n\t}\n\n\treturn normalizedDefault;\n}\n\nasync function mergeProviderMetadata(\n\tsupabase: TypedSupabaseClient,\n\tcommunicationId: string,\n\tpatch: Record<string, Json>,\n): Promise<void> {\n\tconst { data } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"provider_metadata\")\n\t\t.eq(\"id\", communicationId)\n\t\t.maybeSingle();\n\n\tconst currentMetadata =\n\t\t(data?.provider_metadata as Record<string, Json> | null) ?? {};\n\tconst mergedMetadata: Record<string, Json> = {\n\t\t...currentMetadata,\n\t\t...patch,\n\t};\n\n\tawait supabase\n\t\t.from(\"communications\")\n\t\t.update({\n\t\t\tprovider_metadata: mergedMetadata,\n\t\t})\n\t\t.eq(\"id\", communicationId);\n}\n\n// =====================================================================================\n// PHONE NUMBER MANAGEMENT ACTIONS\n// =====================================================================================\n\n/**\n * Search for available phone numbers to purchase\n */\nexport async function searchPhoneNumbers(params: {\n\tareaCode?: string;\n\tnumberType?: NumberType;\n\tfeatures?: NumberFeature[];\n\tlimit?: number;\n}) {\n\ttry {\n\t\tconst result = await searchAvailableNumbers({\n\t\t\tcountryCode: \"US\",\n\t\t\tareaCode: params.areaCode,\n\t\t\tnumberType: params.numberType,\n\t\t\tfeatures: params.features,\n\t\t\tlimit: params.limit || 10,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to search phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Purchase a phone number and associate it with the current company\n */\nexport async function purchasePhoneNumber(params: {\n\tphoneNumber: string;\n\tcompanyId: string;\n\tbillingGroupId?: string;\n}) {\n\ttry {\n\t\t// Validate configuration\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tconst callConfig = validateCallConfig();\n\t\tif (!smsConfig.valid || !callConfig.valid) {\n\t\t\tlet errorMessage =\n\t\t\t\t\"Telnyx configuration is incomplete. Please configure all required environment variables.\";\n\n\t\t\t// If we have a suggested profile ID, include it in the error\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} to use it.`;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst normalizedPhoneNumber = normalizePhoneNumber(params.phoneNumber);\n\t\tconst formattedNumber = formatDisplayPhoneNumber(normalizedPhoneNumber);\n\t\tconst areaCode = extractAreaCode(normalizedPhoneNumber);\n\n\t\t// Purchase number from Telnyx\n\t\tconst messagingProfileId = DEFAULT_MESSAGING_PROFILE_ID || undefined;\n\n\t\tconst result = await purchaseNumber({\n\t\t\tphoneNumber: normalizedPhoneNumber,\n\t\t\tconnectionId: TELNYX_CONFIG.connectionId,\n\t\t\tmessagingProfileId,\n\t\t\tbillingGroupId: params.billingGroupId,\n\t\t\tcustomerReference: `company_${params.companyId}`,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Store in database\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\ttelnyx_phone_number_id: result.orderId,\n\t\t\t\ttelnyx_connection_id: TELNYX_CONFIG.connectionId,\n\t\t\t\tphone_number: normalizedPhoneNumber,\n\t\t\t\tformatted_number: formattedNumber,\n\t\t\t\tcountry_code: \"US\",\n\t\t\t\tarea_code: areaCode,\n\t\t\t\tnumber_type: \"local\",\n\t\t\t\tfeatures: [\"voice\", \"sms\"],\n\t\t\t\tstatus: \"pending\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\ttry {\n\t\t\tawait ensureMessagingCampaign(\n\t\t\t\tparams.companyId,\n\t\t\t\t{ id: data.id, e164: normalizedPhoneNumber },\n\t\t\t\t{ supabase },\n\t\t\t);\n\t\t} catch (_campaignError) {}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to purchase phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Get all phone numbers for a company\n */\nexport async function getCompanyPhoneNumbers(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Update phone number configuration\n */\nasync function updatePhoneNumber(params: {\n\tphoneNumberId: string;\n\troutingRuleId?: string;\n\tforwardToNumber?: string;\n\tvoicemailEnabled?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tcall_routing_rule_id: params.routingRuleId,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tvoicemail_enabled: params.voicemailEnabled,\n\t\t\t})\n\t\t\t.eq(\"id\", params.phoneNumberId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Release (delete) a phone number\n */\nasync function deletePhoneNumber(phoneNumberId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get phone number details\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", phoneNumberId)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) {\n\t\t\treturn { success: false, error: \"Phone number not found\" };\n\t\t}\n\n\t\t// Release from Telnyx if we have the ID\n\t\tif (phoneNumber.telnyx_phone_number_id) {\n\t\t\tawait releaseNumber(phoneNumber.telnyx_phone_number_id);\n\t\t}\n\n\t\t// Soft delete in database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tstatus: \"deleted\",\n\t\t\t})\n\t\t\t.eq(\"id\", phoneNumberId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete phone number\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Initiate an outbound call\n */\nexport async function makeCall(params: {\n\tto: string;\n\tfrom: string;\n\tcompanyId: string;\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconsole.log(\" makeCall called with params:\", params);\n\n\t\tconst callConfig = validateCallConfig();\n\t\tconsole.log(\" Call config validation:\", callConfig);\n\t\tif (!callConfig.valid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: callConfig.error || \"Call configuration is invalid\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t);\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tconst connectionOverride =\n\t\t\tcompanySettings?.call_control_application_id ||\n\t\t\tTELNYX_CONFIG.connectionId;\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tif (!connectionOverride) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"No Telnyx connection configured for this company.\",\n\t\t\t};\n\t\t}\n\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\n\t\t// TEMP: Skip connection verification - Level 2 required for API access\n\t\t// const connectionStatus = await verifyConnection(connectionOverride);\n\t\t// if (connectionStatus.needsFix) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror: `Connection configuration issue: ${connectionStatus.issues.join(\", \")}. Run fixConnection() to auto-fix.`,\n\t\t// \t};\n\t\t// }\n\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\t// TEMP: Skip voice capability check - Level 2 required for API access\n\t\t// const voiceCapability = await verifyVoiceCapability(fromAddress);\n\t\t// if (!voiceCapability.hasVoice) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror:\n\t\t// \t\t\tvoiceCapability.error || \"Phone number does not support voice calls\",\n\t\t// \t};\n\t\t// }\n\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl(params.companyId);\n\t\tconsole.log(\" Webhook URL:\", telnyxWebhookUrl);\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\" Initiating call:\", {\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\tconst result = await initiateCall({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t\tansweringMachineDetection: \"premium\",\n\t\t});\n\n\t\tconsole.log(\" Telnyx API response:\", result);\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"phone\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: \"\",\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_call_control_id: result.callControlId,\n\t\t\t\ttelnyx_call_session_id: result.callSessionId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconsole.log(\" Call created successfully:\", {\n\t\t\tcallControlId: result.callControlId,\n\t\t\tcommunicationId: data.id,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcallControlId: result.callControlId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\" makeCall error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to make call\",\n\t\t};\n\t}\n}\n\n/**\n * Answer an incoming call\n/**\n * Answer an incoming call\n */\nasync function acceptCall(callControlId: string) {\n\ttry {\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl();\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconst result = await answerCall({\n\t\t\tcallControlId,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to answer call\",\n\t\t};\n\t}\n}\n\n/**\n * Reject an incoming call\n */\nasync function declineCall(callControlId: string) {\n\ttry {\n\t\tconst result = await rejectCall({\n\t\t\tcallControlId,\n\t\t\tcause: \"CALL_REJECTED\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to reject call\",\n\t\t};\n\t}\n}\n\n/**\n * End an active call\n */\nasync function endCall(callControlId: string) {\n\ttry {\n\t\tconst result = await hangupCall({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to end call\",\n\t\t};\n\t}\n}\n\n/**\n * Start recording a call\n */\nexport async function startCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await startRecording({\n\t\t\tcallControlId,\n\t\t\tformat: \"mp3\",\n\t\t\tchannels: \"single\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to start recording\",\n\t\t};\n\t}\n}\n\n/**\n * Stop recording a call\n */\nexport async function stopCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await stopRecording({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to stop recording\",\n\t\t};\n\t}\n}\n\n/**\n * Transfer an active call to another number\n */\nexport async function transferActiveCall(params: {\n\tcallControlId: string;\n\tto: string;\n\tfrom: string;\n}) {\n\ttry {\n\t\tconst { transferCall } = await import(\"@/lib/telnyx/calls\");\n\t\tconst result = await transferCall({\n\t\t\tcallControlId: params.callControlId,\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to transfer call\",\n\t\t};\n\t}\n}\n\n/**\n * Transcribe a call recording using AssemblyAI\n *\n * Submits the recording URL to AssemblyAI for post-call transcription.\n * AssemblyAI will process the audio and send the transcript via webhook.\n *\n * @param recordingUrl - URL of the call recording (from Telnyx)\n * @param communicationId - Database ID of the communication record\n * @returns Success/error response with transcription job ID\n */\nexport async function transcribeCallRecording(params: {\n\trecordingUrl: string;\n\tcommunicationId: string;\n}) {\n\ttry {\n\t\tconst { submitTranscription } = await import(\"@/lib/assemblyai/client\");\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst webhookUrl = await buildAbsoluteUrl(\"/api/webhooks/assemblyai\");\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL.\",\n\t\t\t};\n\t\t}\n\n\t\t// Submit to AssemblyAI\n\t\tconst result = await submitTranscription({\n\t\t\taudio_url: params.recordingUrl,\n\t\t\tspeaker_labels: true, // Enable speaker diarization\n\t\t\twebhook_url: webhookUrl,\n\t\t});\n\n\t\tif (!(result.success && result.data)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error || \"Failed to submit transcription\",\n\t\t\t};\n\t\t}\n\n\t\t// Store transcription job ID in database\n\t\tawait mergeProviderMetadata(supabase, params.communicationId, {\n\t\t\tassemblyai_transcription_id: result.data.id,\n\t\t\tassemblyai_status: result.data.status,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttranscriptionId: result.data.id,\n\t\t\tstatus: result.data.status,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to transcribe recording\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// SMS OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Send an SMS message\n */\nexport async function sendTextMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext: string;\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tconsole.error(\" Supabase client unavailable\");\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\" SMS Send Request:\", {\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t\tcompanyId,\n\t\t});\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\tconsole.error(\" Company settings not found\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify the company's onboarding is complete and try again.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Company settings loaded:\", {\n\t\t\tmessagingProfileId: companySettings.messaging_profile_id,\n\t\t\tdefaultNumber: companySettings.default_outbound_number,\n\t\t});\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings?.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or provision company-specific settings.`;\n\t\t\t}\n\t\t\tconsole.error(\" SMS config invalid:\", errorMessage);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS config valid\");\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings?.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\tconsole.error(\" No messaging profile ID\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending SMS.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Using messaging profile:\", messagingProfileId);\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t\" Messaging profile needs fix:\",\n\t\t\t\t\tmessagingProfileStatus.issues,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconsole.log(\" Messaging profile verified\");\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\tconsole.error(\" No from number available\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\t\tconsole.log(\" Phone numbers normalized:\", {\n\t\t\tfrom: fromAddress,\n\t\t\tto: toAddress,\n\t\t});\n\n\t\t// Verify phone number has SMS capability\n\t\tconsole.log(\" Verifying SMS capability for:\", fromAddress);\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\tconsole.error(\" SMS capability check failed:\", smsCapability.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS capability verified\");\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\tconsole.error(\" No webhook URL\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Webhook URL:\", webhookUrl);\n\n\t\t// Send SMS via Telnyx\n\t\tconsole.log(\" Sending SMS via Telnyx API...\");\n\t\tconst result = await sendSMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\tconsole.error(\" Telnyx API failed:\", result.error);\n\n\t\t\t// Check if error is 10DLC registration required\n\t\t\tif (\n\t\t\t\tresult.error &&\n\t\t\t\t(result.error.includes(\"10DLC\") ||\n\t\t\t\t\tresult.error.includes(\"Not 10DLC registered\") ||\n\t\t\t\t\tresult.error.includes(\"A2P\"))\n\t\t\t) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\" Detected 10DLC registration required, attempting auto-registration...\",\n\t\t\t\t);\n\n\t\t\t\t// Import 10DLC registration function\n\t\t\t\tconst { registerCompanyFor10DLC } = await import(\n\t\t\t\t\t\"@/actions/ten-dlc-registration\"\n\t\t\t\t);\n\n\t\t\t\tconst registrationResult = await registerCompanyFor10DLC(\n\t\t\t\t\tcompanyId,\n\t\t\t\t);\n\n\t\t\t\tif (registrationResult.success) {\n\t\t\t\t\tconsole.log(\" 10DLC registration successful, retrying SMS send...\");\n\n\t\t\t\t\t// Retry the SMS send now that 10DLC is registered\n\t\t\t\t\tconst retryResult = await sendSMS({\n\t\t\t\t\t\tto: toAddress,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\ttext: params.text,\n\t\t\t\t\t\twebhookUrl,\n\t\t\t\t\t\tmessagingProfileId,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!retryResult.success) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\terror: `10DLC registration completed but SMS still failed: ${retryResult.error}. The campaign may need additional approval time.`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update result with retry success\n\t\t\t\t\tresult.success = true;\n\t\t\t\t\tresult.messageId = retryResult.messageId;\n\t\t\t\t\tconsole.log(\" SMS retry successful after 10DLC registration\");\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: `10DLC registration failed: ${registrationResult.error}. Original error: ${result.error}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tconsole.log(\" Telnyx API success:\", result.messageId);\n\n\t\t// Create communication record\n\t\tconsole.log(\" Creating communication record in database...\");\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"SMS send error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\ttype: typeof error,\n\t\t\tstringified: JSON.stringify(error, null, 2),\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to send SMS: ${String(error)}`,\n\t\t};\n\t}\n}\n\n/**\n * Send an MMS message with media\n */\nexport async function sendMMSMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext?: string;\n\tmediaUrls: string[];\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify onboarding is complete.\",\n\t\t\t};\n\t\t}\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or reprovision the company.`;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending MMS.\",\n\t\t\t};\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS/MMS\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await sendMMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\tmediaUrls: params.mediaUrls,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text || \"\",\n\t\t\t\tattachments: params.mediaUrls.map((url) => ({ url, type: \"image\" })),\n\t\t\t\tattachment_count: params.mediaUrls.length,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to send MMS\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// WEBRTC OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Generate WebRTC credentials for browser calling\n */\nexport async function getWebRTCCredentials() {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: userError,\n\t\t} = await supabase.auth.getUser();\n\t\tif (userError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User not authenticated\",\n\t\t\t};\n\t\t}\n\n\t\t// OPTION 1: Use static credentials from environment (recommended for production)\n\t\tconst staticUsername = process.env.TELNYX_WEBRTC_USERNAME;\n\t\tconst staticPassword = process.env.TELNYX_WEBRTC_PASSWORD;\n\n\t\tif (staticUsername && staticPassword) {\n\t\t\tconst credential = {\n\t\t\t\tusername: staticUsername,\n\t\t\t\tpassword: staticPassword,\n\t\t\t\texpires_at: Date.now() + 86_400 * 1000, // 24 hours from now\n\t\t\t\trealm: \"sip.telnyx.com\",\n\t\t\t\tsip_uri: `sip:${staticUsername}@sip.telnyx.com`,\n\t\t\t\tstun_servers: [\n\t\t\t\t\t\"stun:stun.telnyx.com:3478\",\n\t\t\t\t\t\"stun:stun.telnyx.com:3479\",\n\t\t\t\t],\n\t\t\t\tturn_servers: [\n\t\t\t\t\t{\n\t\t\t\t\t\turls: [\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=udp\",\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=tcp\",\n\t\t\t\t\t\t],\n\t\t\t\t\t\tusername: staticUsername,\n\t\t\t\t\t\tcredential: staticPassword,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tcredential,\n\t\t\t};\n\t\t}\n\n\t\tconst { generateWebRTCToken } = await import(\"@/lib/telnyx/webrtc\");\n\t\tconst result = await generateWebRTCToken({\n\t\t\tusername: user.email || user.id,\n\t\t\tttl: 86_400, // 24 hours\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcredential: result.credential,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get WebRTC credentials\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// VOICEMAIL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Get all voicemails for a company\n */\nasync function getVoicemails(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        customer:customers(id, first_name, last_name, email, phone),\n        phone_number:phone_numbers(phone_number, formatted_number)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"received_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get voicemails\",\n\t\t};\n\t}\n}\n\n/**\n * Mark voicemail as read\n */\nasync function markVoicemailAsRead(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tis_read: true,\n\t\t\t\tread_at: new Date().toISOString(),\n\t\t\t\tread_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to mark voicemail as read\",\n\t\t};\n\t}\n}\n\n/**\n * Delete voicemail\n */\nasync function deleteVoicemail(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to delete voicemail\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL ROUTING RULES ACTIONS\n// =====================================================================================\n\n/**\n * Get all call routing rules for a company\n */\nexport async function getCallRoutingRules(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        created_by_user:users!call_routing_rules_created_by_fkey(id, name, email),\n        forward_to_user:users!call_routing_rules_forward_to_user_id_fkey(id, name, email)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"priority\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get call routing rules\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new call routing rule\n */\nasync function createCallRoutingRule(params: {\n\tcompanyId: string;\n\tuserId: string;\n\tname: string;\n\tdescription?: string;\n\troutingType:\n\t\t| \"direct\"\n\t\t| \"round_robin\"\n\t\t| \"ivr\"\n\t\t| \"business_hours\"\n\t\t| \"conditional\";\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\tcreated_by: params.userId,\n\t\t\t\tname: params.name,\n\t\t\t\tdescription: params.description,\n\t\t\t\trouting_type: params.routingType,\n\t\t\t\tpriority: params.priority || 0,\n\t\t\t\tbusiness_hours: params.businessHours,\n\t\t\t\ttimezone: params.timezone || \"America/Los_Angeles\",\n\t\t\t\tafter_hours_action: params.afterHoursAction,\n\t\t\t\tafter_hours_forward_to: params.afterHoursForwardTo,\n\t\t\t\tteam_members: params.teamMembers,\n\t\t\t\tring_timeout: params.ringTimeout || 20,\n\t\t\t\tivr_menu: params.ivrMenu,\n\t\t\t\tivr_greeting_url: params.ivrGreetingUrl,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tforward_to_user_id: params.forwardToUserId,\n\t\t\t\tenable_voicemail: params.enableVoicemail !== false,\n\t\t\t\tvoicemail_greeting_url: params.voicemailGreetingUrl,\n\t\t\t\tvoicemail_transcription_enabled:\n\t\t\t\t\tparams.voicemailTranscriptionEnabled !== false,\n\t\t\t\tvoicemail_email_notifications:\n\t\t\t\t\tparams.voicemailEmailNotifications !== false,\n\t\t\t\trecord_calls: params.recordCalls,\n\t\t\t\tis_active: true,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to create call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Update an existing call routing rule\n */\nexport async function updateCallRoutingRule(params: {\n\truleId: string;\n\tname?: string;\n\tdescription?: string;\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n\tisActive?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst updateData: Record<string, unknown> = {};\n\n\t\tif (params.name !== undefined) {\n\t\t\tupdateData.name = params.name;\n\t\t}\n\t\tif (params.description !== undefined) {\n\t\t\tupdateData.description = params.description;\n\t\t}\n\t\tif (params.priority !== undefined) {\n\t\t\tupdateData.priority = params.priority;\n\t\t}\n\t\tif (params.businessHours !== undefined) {\n\t\t\tupdateData.business_hours = params.businessHours;\n\t\t}\n\t\tif (params.timezone !== undefined) {\n\t\t\tupdateData.timezone = params.timezone;\n\t\t}\n\t\tif (params.afterHoursAction !== undefined) {\n\t\t\tupdateData.after_hours_action = params.afterHoursAction;\n\t\t}\n\t\tif (params.afterHoursForwardTo !== undefined) {\n\t\t\tupdateData.after_hours_forward_to = params.afterHoursForwardTo;\n\t\t}\n\t\tif (params.teamMembers !== undefined) {\n\t\t\tupdateData.team_members = params.teamMembers;\n\t\t}\n\t\tif (params.ringTimeout !== undefined) {\n\t\t\tupdateData.ring_timeout = params.ringTimeout;\n\t\t}\n\t\tif (params.ivrMenu !== undefined) {\n\t\t\tupdateData.ivr_menu = params.ivrMenu;\n\t\t}\n\t\tif (params.ivrGreetingUrl !== undefined) {\n\t\t\tupdateData.ivr_greeting_url = params.ivrGreetingUrl;\n\t\t}\n\t\tif (params.forwardToNumber !== undefined) {\n\t\t\tupdateData.forward_to_number = params.forwardToNumber;\n\t\t}\n\t\tif (params.forwardToUserId !== undefined) {\n\t\t\tupdateData.forward_to_user_id = params.forwardToUserId;\n\t\t}\n\t\tif (params.enableVoicemail !== undefined) {\n\t\t\tupdateData.enable_voicemail = params.enableVoicemail;\n\t\t}\n\t\tif (params.voicemailGreetingUrl !== undefined) {\n\t\t\tupdateData.voicemail_greeting_url = params.voicemailGreetingUrl;\n\t\t}\n\t\tif (params.voicemailTranscriptionEnabled !== undefined) {\n\t\t\tupdateData.voicemail_transcription_enabled =\n\t\t\t\tparams.voicemailTranscriptionEnabled;\n\t\t}\n\t\tif (params.voicemailEmailNotifications !== undefined) {\n\t\t\tupdateData.voicemail_email_notifications =\n\t\t\t\tparams.voicemailEmailNotifications;\n\t\t}\n\t\tif (params.recordCalls !== undefined) {\n\t\t\tupdateData.record_calls = params.recordCalls;\n\t\t}\n\t\tif (params.isActive !== undefined) {\n\t\t\tupdateData.is_active = params.isActive;\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", params.ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a call routing rule\n */\nexport async function deleteCallRoutingRule(ruleId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", ruleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Toggle call routing rule active status\n */\nexport async function toggleCallRoutingRule(ruleId: string, isActive: boolean) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({ is_active: isActive })\n\t\t\t.eq(\"id\", ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to toggle call routing rule\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// PHONE NUMBER USAGE STATISTICS ACTIONS\n// =====================================================================================\n\n/**\n * Get usage statistics for a phone number\n */\nasync function getPhoneNumberUsageStats(\n\tphoneNumberId: string,\n\tdays = 30,\n) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get call statistics\n\t\tconst { data: callStats, error: callError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"type\", \"phone\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (callError) {\n\t\t\tthrow callError;\n\t\t}\n\n\t\t// Get SMS statistics\n\t\tconst { data: smsStats, error: smsError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, created_at\")\n\t\t\t.eq(\"type\", \"sms\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (smsError) {\n\t\t\tthrow smsError;\n\t\t}\n\n\t\t// Calculate aggregates\n\t\tconst calls = callStats || [];\n\t\tconst sms = smsStats || [];\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats([...calls, ...sms], days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Get company-wide usage statistics\n */\nasync function getCompanyUsageStats(companyId: string, days = 30) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get all communications for the company\n\t\tconst { data: communications, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.in(\"type\", [\"phone\", \"sms\"])\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst items = communications || [];\n\t\tconst calls = items.filter((i) => i.type === \"phone\");\n\t\tconst sms = items.filter((i) => i.type === \"sms\");\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\taverageCallDuration:\n\t\t\t\t\tcalls.length > 0 ? totalCallDuration / calls.length : 0,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats(items, days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Helper function to aggregate daily statistics\n */\nfunction aggregateDailyStats(\n\titems: Array<{ created_at: string; type: string; call_duration?: number }>,\n\tdays: number,\n) {\n\tconst dailyStats: Record<\n\t\tstring,\n\t\t{ date: string; calls: number; sms: number; duration: number }\n\t> = {};\n\n\t// Initialize all days\n\tfor (let i = 0; i < days; i++) {\n\t\tconst date = new Date();\n\t\tdate.setDate(date.getDate() - i);\n\t\tconst dateStr = date.toISOString().split(\"T\")[0];\n\t\tdailyStats[dateStr] = { date: dateStr, calls: 0, sms: 0, duration: 0 };\n\t}\n\n\t// Aggregate data\n\titems.forEach((item) => {\n\t\tconst dateStr = item.created_at.split(\"T\")[0];\n\t\tif (dailyStats[dateStr]) {\n\t\t\tif (item.type === \"phone\") {\n\t\t\t\tdailyStats[dateStr].calls += 1;\n\t\t\t\tdailyStats[dateStr].duration += item.call_duration || 0;\n\t\t\t} else if (item.type === \"sms\") {\n\t\t\t\tdailyStats[dateStr].sms += 1;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Object.values(dailyStats).sort((a, b) => a.date.localeCompare(b.date));\n}\n"],"names":[],"mappings":";;;;;;;IAk5CsB,uBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { AuthApiError, AuthUnknownError } from \"@supabase/supabase-js\";\nimport { Buffer } from \"node:buffer\";\nimport { extname } from \"node:path\";\n// import { checkBotId } from \"botid/server\";\nimport { clearActiveCompany } from \"@/lib/auth/company-context\";\nimport {\n    createEmailVerificationToken,\n    verifyAndConsumeToken,\n} from \"@/lib/auth/tokens\";\nimport { emailConfig } from \"@/lib/email/resend-client\";\nimport { clearCSRFToken } from \"@/lib/security/csrf\";\nimport {\n    authRateLimiter,\n    checkRateLimit,\n    passwordResetRateLimiter,\n    RateLimitError,\n} from \"@/lib/security/rate-limit\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n    createServiceSupabaseClient,\n    type ServiceSupabaseClient,\n} from \"@/lib/supabase/service-client\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { z } from \"zod\";\nimport {\n    sendEmailVerification,\n    sendPasswordChanged,\n    sendWelcomeEmail,\n} from \"./emails\";\n\nconst NAME_MIN_LENGTH = 2;\nconst NAME_MAX_LENGTH = 100;\nconst COMPANY_NAME_MIN_LENGTH = 2;\nconst COMPANY_NAME_MAX_LENGTH = 200;\nconst PHONE_MIN_DIGITS = 10;\nconst PASSWORD_MIN_LENGTH = 8;\nconst PASSWORD_MAX_LENGTH = 100;\nconst CONFIRMATION_TOKEN_TTL_HOURS = 24;\nconst COUNTRY_CODE_US = \"1\";\nconst NATIONAL_NUMBER_DIGITS = 10;\nconst EXTENDED_US_NUMBER_DIGITS = 11;\nconst BYTES_PER_KILOBYTE = 1024;\nconst BYTES_PER_MEGABYTE = BYTES_PER_KILOBYTE * BYTES_PER_KILOBYTE;\nconst AVATAR_SIZE_LIMIT_MB = 5;\nconst MAX_AVATAR_FILE_SIZE = AVATAR_SIZE_LIMIT_MB * BYTES_PER_MEGABYTE;\n\n/**\n * Authentication Server Actions - Supabase Auth + Resend Email Integration\n *\n * Performance optimizations:\n * - Server Actions for secure authentication\n * - Supabase Auth handles password hashing and session management\n * - Custom emails via Resend with branded templates\n * - Zod validation for input sanitization\n * - Proper error handling with user-friendly messages\n */\n\n// Validation Schemas\nconst signUpSchema = z.object({\n\tname: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(NAME_MIN_LENGTH, \"Name must be at least 2 characters\")\n\t\t.max(NAME_MAX_LENGTH, \"Name is too long\"),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(PHONE_MIN_DIGITS, \"Phone number is required\")\n\t\t.refine(\n\t\t\t(value) => value.replace(/\\D/g, \"\").length >= PHONE_MIN_DIGITS,\n\t\t\t\"Enter a valid phone number\",\n\t\t),\n\tpassword: z\n\t\t.string()\n\t\t.min(PASSWORD_MIN_LENGTH, \"Password must be at least 8 characters\")\n\t\t.max(PASSWORD_MAX_LENGTH, \"Password is too long\")\n\t\t.regex(\n\t\t\t/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/,\n\t\t\t\"Password must contain uppercase, lowercase, and number\",\n\t\t),\n\tcompanyName: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(COMPANY_NAME_MIN_LENGTH, \"Company name must be at least 2 characters\")\n\t\t.max(COMPANY_NAME_MAX_LENGTH, \"Company name is too long\")\n\t\t.optional(),\n\tterms: z\n\t\t.boolean()\n\t\t.refine((val) => val === true, \"You must accept the terms and conditions\"),\n});\n\nconst signInSchema = z.object({\n\temail: z.string().email(\"Invalid email address\"),\n\tpassword: z.string().min(1, \"Password is required\"),\n});\n\nconst forgotPasswordSchema = z.object({\n\temail: z.string().email(\"Invalid email address\"),\n});\n\nconst resetPasswordSchema = z\n\t.object({\n\t\tpassword: z\n\t\t\t.string()\n\t\t\t.min(PASSWORD_MIN_LENGTH, \"Password must be at least 8 characters\")\n\t\t\t.max(PASSWORD_MAX_LENGTH, \"Password is too long\")\n\t\t\t.regex(\n\t\t\t\t/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/,\n\t\t\t\t\"Password must contain uppercase, lowercase, and number\",\n\t\t\t),\n\t\tconfirmPassword: z.string(),\n\t})\n\t.refine((data) => data.password === data.confirmPassword, {\n\t\tmessage: \"Passwords don't match\",\n\t\tpath: [\"confirmPassword\"],\n\t});\n\nconst AVATAR_STORAGE_BUCKET = \"avatars\";\nconst SUPABASE_RATE_LIMIT_MAX_RETRIES = 3;\nconst SUPABASE_RATE_LIMIT_BACKOFF_MS = 200;\n\nconst delay = (ms: number) =>\n\tnew Promise((resolve) => {\n\t\tsetTimeout(resolve, ms);\n\t});\n\nconst withSupabaseRateLimitRetry = async <T extends { error?: unknown }>(\n\toperation: () => Promise<T>,\n): Promise<T> => {\n\tfor (\n\t\tlet attempt = 1;\n\t\tattempt <= SUPABASE_RATE_LIMIT_MAX_RETRIES;\n\t\tattempt += 1\n\t) {\n\t\ttry {\n\t\t\tconst result = await operation();\n\n\t\t\tif (\n\t\t\t\tresult &&\n\t\t\t\ttypeof result === \"object\" &&\n\t\t\t\t\"error\" in result &&\n\t\t\t\tresult.error instanceof AuthApiError &&\n\t\t\t\tresult.error.code === \"over_request_rate_limit\"\n\t\t\t) {\n\t\t\t\tif (attempt === SUPABASE_RATE_LIMIT_MAX_RETRIES) {\n\t\t\t\t\tthrow result.error;\n\t\t\t\t}\n\n\t\t\t\tawait delay(SUPABASE_RATE_LIMIT_BACKOFF_MS * attempt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror instanceof AuthApiError &&\n\t\t\t\terror.code === \"over_request_rate_limit\" &&\n\t\t\t\tattempt < SUPABASE_RATE_LIMIT_MAX_RETRIES\n\t\t\t) {\n\t\t\t\tawait delay(SUPABASE_RATE_LIMIT_BACKOFF_MS * attempt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tthrow new Error(\"Supabase auth operation failed after retries\");\n};\n\ntype SignUpFormInput = z.infer<typeof signUpSchema>;\n\ntype SupabaseBrowserClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nfunction normalizePhoneNumber(input: string): string {\n\tconst trimmed = input.trim();\n\tconst digitsOnly = trimmed.replace(/\\D/g, \"\");\n\n\tif (!digitsOnly) {\n\t\treturn trimmed;\n\t}\n\n\tif (trimmed.startsWith(\"+\")) {\n\t\treturn `+${digitsOnly}`;\n\t}\n\n\tif (\n\t\tdigitsOnly.length === EXTENDED_US_NUMBER_DIGITS &&\n\t\tdigitsOnly.startsWith(COUNTRY_CODE_US)\n\t) {\n\t\treturn `+${digitsOnly}`;\n\t}\n\n\tif (digitsOnly.length === NATIONAL_NUMBER_DIGITS) {\n\t\treturn `+${COUNTRY_CODE_US}${digitsOnly}`;\n\t}\n\n\treturn `+${digitsOnly}`;\n}\n\nconst reportAuthIssue = (_message: string, _error?: unknown) => {\n\t// TODO: Integrate structured logging/monitoring\n};\n\nconst getMetadataString = (\n\tmetadata: unknown,\n\tkey: string,\n): string | undefined => {\n\tif (metadata && typeof metadata === \"object\") {\n\t\tconst value = (metadata as Record<string, unknown>)[key];\n\t\tif (typeof value === \"string\") {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn;\n};\n\nasync function uploadAvatarForNewUser(\n\tsupabase: ServiceSupabaseClient,\n\tfile: File,\n\tuserId: string,\n): Promise<string | null> {\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\tif (!file.type.startsWith(\"image/\")) {\n\t\tthrow new Error(\"Avatar must be an image\");\n\t}\n\n\tif (file.size > MAX_AVATAR_FILE_SIZE) {\n\t\tthrow new Error(`Avatar must be smaller than ${AVATAR_SIZE_LIMIT_MB}MB`);\n\t}\n\n\tconst arrayBuffer = await file.arrayBuffer();\n\tconst extension = extname(file.name) || \".jpg\";\n\tconst filePath = `${userId}/profile${extension}`;\n\n\tconst { error: uploadError } = await supabase.storage\n\t\t.from(AVATAR_STORAGE_BUCKET)\n\t\t.upload(filePath, Buffer.from(arrayBuffer), {\n\t\t\tcacheControl: \"3600\",\n\t\t\tcontentType: file.type || \"image/jpeg\",\n\t\t\tupsert: true,\n\t\t});\n\n\tif (uploadError) {\n\t\tthrow new Error(uploadError.message);\n\t}\n\n\tconst {\n\t\tdata: { publicUrl },\n\t} = supabase.storage.from(AVATAR_STORAGE_BUCKET).getPublicUrl(filePath);\n\n\treturn publicUrl;\n}\n\nconst createServiceClientLoader = () => {\n\tlet client: ServiceSupabaseClient | null = null;\n\treturn async () => {\n\t\tif (client) {\n\t\t\treturn client;\n\t\t}\n\t\tclient = await createServiceSupabaseClient();\n\t\treturn client;\n\t};\n};\n\ntype ParsedSignUpForm = {\n\tvalidated: SignUpFormInput;\n\tnormalizedPhone: string;\n\tcompanyName?: string;\n\tavatarFile: File | null;\n};\n\nconst parseSignUpFormData = (formData: FormData): ParsedSignUpForm => {\n\tconst companyNameEntry = formData.get(\"companyName\");\n\tconst normalizedCompanyName =\n\t\ttypeof companyNameEntry === \"string\" && companyNameEntry.trim().length > 0\n\t\t\t? companyNameEntry\n\t\t\t: undefined;\n\n\tconst rawData = {\n\t\tname: (formData.get(\"name\") as string) ?? \"\",\n\t\temail: (formData.get(\"email\") as string) ?? \"\",\n\t\tphone: (formData.get(\"phone\") as string) ?? \"\",\n\t\tpassword: (formData.get(\"password\") as string) ?? \"\",\n\t\tcompanyName: normalizedCompanyName,\n\t\tterms: formData.get(\"terms\") === \"on\" || formData.get(\"terms\") === \"true\",\n\t};\n\n\tconst validated = signUpSchema.parse(rawData);\n\tconst avatarEntry = formData.get(\"avatar\");\n\tconst avatarFile =\n\t\tavatarEntry instanceof File && avatarEntry.size > 0 ? avatarEntry : null;\n\n\treturn {\n\t\tvalidated,\n\t\tnormalizedPhone: normalizePhoneNumber(validated.phone),\n\t\tcompanyName: validated.companyName?.trim() || undefined,\n\t\tavatarFile,\n\t};\n};\n\nconst requireSupabaseBrowserClient =\n\tasync (): Promise<SupabaseBrowserClient> => {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Authentication service is not configured. Please check your environment variables.\",\n\t\t\t);\n\t\t}\n\n\t\treturn supabase as SupabaseBrowserClient;\n\t};\n\ntype RegisterSupabaseUserParams = {\n\tsupabase: SupabaseBrowserClient;\n\tvalidated: SignUpFormInput;\n\tnormalizedPhone: string;\n\tcompanyName?: string;\n};\n\nconst registerSupabaseUser = async ({\n\tsupabase,\n\tvalidated,\n\tnormalizedPhone,\n\tcompanyName,\n}: RegisterSupabaseUserParams) => {\n\tconst { data, error } = await withSupabaseRateLimitRetry(() =>\n\t\tsupabase.auth.signUp({\n\t\t\temail: validated.email,\n\t\t\tpassword: validated.password,\n\t\t\toptions: {\n\t\t\t\tdata: {\n\t\t\t\t\tname: validated.name,\n\t\t\t\t\tphone: normalizedPhone,\n\t\t\t\t\tcompanyName: companyName ?? null,\n\t\t\t\t},\n\t\t\t\temailRedirectTo: `${emailConfig.siteUrl}/auth/callback`,\n\t\t\t},\n\t\t}),\n\t);\n\n\tif (error) {\n\t\tthrow new Error(error.message);\n\t}\n\n\tif (!data.user) {\n\t\tthrow new Error(\"Failed to create user account\");\n\t}\n\n\treturn data;\n};\n\ntype SyncSignUpProfileParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tnormalizedPhone: string;\n\tname: string;\n\tcompanyName?: string;\n\tavatarFile: File | null;\n};\n\nconst syncSignUpProfile = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tnormalizedPhone,\n\tname,\n\tcompanyName,\n\tavatarFile,\n}: SyncSignUpProfileParams) => {\n\tlet avatarUrl: string | null = null;\n\n\tif (avatarFile) {\n\t\ttry {\n\t\t\tconst adminClient = await ensureServiceSupabase();\n\t\t\tavatarUrl = await uploadAvatarForNewUser(adminClient, avatarFile, userId);\n\t\t} catch (avatarUploadError) {\n\t\t\treportAuthIssue(\"Avatar upload failed\", avatarUploadError);\n\t\t}\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tconst updatePayload: Record<string, string | null> = {\n\t\t\tphone: normalizedPhone,\n\t\t};\n\n\t\tif (avatarUrl) {\n\t\t\tupdatePayload.avatar_url = avatarUrl;\n\t\t}\n\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tawait adminClient.from(\"profiles\").update(updatePayload).eq(\"id\", userId);\n\t} catch (profileUpdateError) {\n\t\treportAuthIssue(\"Failed to update user profile\", profileUpdateError);\n\t}\n\n\tif (!avatarUrl) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tawait adminClient.auth.admin.updateUserById(userId, {\n\t\t\tuser_metadata: {\n\t\t\t\tname,\n\t\t\t\tphone: normalizedPhone,\n\t\t\t\tcompanyName: companyName ?? null,\n\t\t\t\tavatarUrl,\n\t\t\t},\n\t\t});\n\t} catch (metadataError) {\n\t\treportAuthIssue(\"Failed to sync avatar metadata\", metadataError);\n\t}\n};\n\ntype PostSignUpEmailParams = {\n\temail: string;\n\tname: string;\n\trequiresConfirmation: boolean;\n\tuserId: string;\n};\n\nconst handlePostSignUpEmails = async ({\n\temail,\n\tname,\n\trequiresConfirmation,\n\tuserId,\n}: PostSignUpEmailParams): Promise<AuthActionResult | null> => {\n\tif (requiresConfirmation) {\n\t\tconst { token, expiresAt } = await createEmailVerificationToken(\n\t\t\temail,\n\t\t\tuserId,\n\t\t\tCONFIRMATION_TOKEN_TTL_HOURS,\n\t\t);\n\n\t\tconst verificationUrl = `${emailConfig.siteUrl}/auth/verify-email?token=${token}`;\n\t\tconst verificationResult = await sendEmailVerification(email, {\n\t\t\tname,\n\t\t\tverificationUrl,\n\t\t});\n\n\t\tif (!verificationResult.success) {\n\t\t\treportAuthIssue(\n\t\t\t\t\"Failed to send verification email\",\n\t\t\t\tverificationResult.error,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\trequiresEmailConfirmation: true,\n\t\t\t\tmessage:\n\t\t\t\t\t\"Account created! Please check your email to verify your account.\",\n\t\t\t\texpiresAt: expiresAt.toISOString(),\n\t\t\t},\n\t\t};\n\t}\n\n\tconst emailResult = await sendWelcomeEmail(email, {\n\t\tname,\n\t\tloginUrl: `${emailConfig.siteUrl}/welcome`,\n\t});\n\n\tif (!emailResult.success) {\n\t\treportAuthIssue(\"Failed to send welcome email\", emailResult.error);\n\t}\n\n\treturn null;\n};\n\nconst normalizeOptionalPhone = (phone: string | null): string | null => {\n\tif (!phone) {\n\t\treturn null;\n\t}\n\n\tconst digitsOnly = phone.replace(/\\D/g, \"\");\n\tif (digitsOnly.length < PHONE_MIN_DIGITS) {\n\t\tthrow new Error(\n\t\t\t\"Please enter a valid phone number with at least 10 digits.\",\n\t\t);\n\t}\n\n\treturn normalizePhoneNumber(phone);\n};\n\ntype CompleteProfileForm = {\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarFile: File | null;\n};\n\nconst parseCompleteProfileForm = (formData: FormData): CompleteProfileForm => {\n\tconst avatarEntry = formData.get(\"avatar\");\n\tconst avatarFile =\n\t\tavatarEntry instanceof File && avatarEntry.size > 0 ? avatarEntry : null;\n\n\tconst name = (formData.get(\"name\") as string | null) ?? null;\n\tconst phone = (formData.get(\"phone\") as string | null) ?? null;\n\n\treturn {\n\t\tname,\n\t\tnormalizedPhone: normalizeOptionalPhone(phone),\n\t\tavatarFile,\n\t};\n};\n\nconst requireAuthenticatedUser = async (supabase: SupabaseBrowserClient) => {\n\tconst {\n\t\tdata: { user },\n\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\tif (!user) {\n\t\tthrow new Error(\"You must be signed in to complete your profile.\");\n\t}\n\n\treturn user;\n};\n\ntype UpdateCompleteProfileRecordsParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarFile: File | null;\n\texistingAvatar: string | null;\n\texistingMetadata?: Record<string, unknown>;\n};\n\nconst uploadAvatarWithFallback = async ({\n\tensureServiceSupabase,\n\tavatarFile,\n\tuserId,\n\tfallbackAvatar,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tavatarFile: File | null;\n\tuserId: string;\n\tfallbackAvatar: string | null;\n}): Promise<string | null> => {\n\tif (!avatarFile) {\n\t\treturn fallbackAvatar;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\treturn await uploadAvatarForNewUser(adminClient, avatarFile, userId);\n\t} catch (avatarUploadError) {\n\t\treportAuthIssue(\"Avatar upload failed\", avatarUploadError);\n\t\treturn fallbackAvatar;\n\t}\n};\n\nconst updateUserTableRecord = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarUrl,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarUrl: string | null;\n}): Promise<AuthActionResult | null> => {\n\tconst updatePayload: Record<string, string | null> = {};\n\n\tif (name) {\n\t\tupdatePayload.name = name;\n\t}\n\tif (normalizedPhone) {\n\t\tupdatePayload.phone = normalizedPhone;\n\t}\n\tif (avatarUrl) {\n\t\tupdatePayload.avatar = avatarUrl;\n\t}\n\n\tif (Object.keys(updatePayload).length === 0) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tconst { error } = await adminClient\n\t\t\t.from(\"profiles\")\n\t\t\t.update({\n\t\t\t\tfull_name: name || undefined,\n\t\t\t\tphone: normalizedPhone || undefined,\n\t\t\t\tavatar_url: avatarUrl || undefined,\n\t\t\t})\n\t\t\t.eq(\"id\", userId);\n\n\t\tif (error) {\n\t\t\treportAuthIssue(\"Failed to update user profile\", error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Failed to update your profile: ${error.message}`,\n\t\t\t};\n\t\t}\n\t} catch (profileUpdateError) {\n\t\treportAuthIssue(\"Failed to update user profile\", profileUpdateError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Failed to update your profile. Please try again.\",\n\t\t};\n\t}\n\n\treturn null;\n};\n\nconst syncUserMetadataProfile = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarUrl,\n\texistingMetadata,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarUrl: string | null;\n\texistingMetadata?: Record<string, unknown>;\n}) => {\n\tconst hasMetadataChanges = Boolean(name || normalizedPhone || avatarUrl);\n\tif (!hasMetadataChanges) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tconst metadata: Record<string, string | null> = {\n\t\t\t...(existingMetadata as Record<string, string | null>),\n\t\t};\n\n\t\tif (name) {\n\t\t\tmetadata.name = name;\n\t\t}\n\t\tif (normalizedPhone) {\n\t\t\tmetadata.phone = normalizedPhone;\n\t\t}\n\t\tif (avatarUrl) {\n\t\t\tmetadata.avatarUrl = avatarUrl;\n\t\t}\n\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\n\t\tawait adminClient.auth.admin.updateUserById(userId, {\n\t\t\tuser_metadata: metadata,\n\t\t});\n\t} catch (metadataError) {\n\t\treportAuthIssue(\"Failed to sync user metadata\", metadataError);\n\t}\n};\n\nconst updateCompleteProfileRecords = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarFile,\n\texistingAvatar,\n\texistingMetadata,\n}: UpdateCompleteProfileRecordsParams): Promise<AuthActionResult | null> => {\n\tconst avatarUrl = await uploadAvatarWithFallback({\n\t\tensureServiceSupabase,\n\t\tavatarFile,\n\t\tuserId,\n\t\tfallbackAvatar: existingAvatar,\n\t});\n\n\tconst userUpdateResult = await updateUserTableRecord({\n\t\tensureServiceSupabase,\n\t\tuserId,\n\t\tname,\n\t\tnormalizedPhone,\n\t\tavatarUrl,\n\t});\n\n\tif (userUpdateResult) {\n\t\treturn userUpdateResult;\n\t}\n\n\tawait syncUserMetadataProfile({\n\t\tensureServiceSupabase,\n\t\tuserId,\n\t\tname,\n\t\tnormalizedPhone,\n\t\tavatarUrl,\n\t\texistingMetadata,\n\t});\n\n\treturn null;\n};\n\ntype ResolveProfileRedirectParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n};\n\nconst resolveProfileRedirectPath = async ({\n\tensureServiceSupabase,\n\tuserId,\n}: ResolveProfileRedirectParams): Promise<string> => {\n\tconst adminClient = await ensureServiceSupabase();\n\tif (!adminClient) {\n\t\tthrow new Error(\"Admin client not configured\");\n\t}\n\tconst { data: hasCompany } = await adminClient\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.eq(\"status\", \"active\")\n\t\t.limit(1)\n\t\t.maybeSingle();\n\n\treturn hasCompany ? \"/dashboard\" : \"/welcome\";\n};\n// Internal return type (not exported - Next.js 16 \"use server\" restriction)\ntype AuthActionResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tdata?: Record<string, unknown>;\n};\n\n/**\n * Sign Up - Create new user account with Supabase Auth + Custom Resend Email\n *\n * Features:\n * - Email/password authentication\n * - Custom welcome email via Resend with branded template\n * - Creates user profile in users table via database trigger\n * - Validates input with Zod\n * - Disables Supabase's built-in emails (using custom Resend templates instead)\n */\nexport async function signUp(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst parsedForm = parseSignUpFormData(formData);\n\n\t\tawait checkRateLimit(parsedForm.validated.email, authRateLimiter);\n\n\t\tconst supabase = await requireSupabaseBrowserClient();\n\t\tconst authResult = await registerSupabaseUser({\n\t\t\tsupabase,\n\t\t\tvalidated: parsedForm.validated,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tcompanyName: parsedForm.companyName,\n\t\t});\n\n\t\tconst userId = authResult.user?.id;\n\t\tif (!userId) {\n\t\t\tthrow new Error(\"Failed to create user account\");\n\t\t}\n\n\t\tconst ensureServiceSupabase = createServiceClientLoader();\n\t\tawait syncSignUpProfile({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tname: parsedForm.validated.name,\n\t\t\tcompanyName: parsedForm.companyName,\n\t\t\tavatarFile: parsedForm.avatarFile,\n\t\t});\n\n\t\tconst postSignUpResult = await handlePostSignUpEmails({\n\t\t\temail: parsedForm.validated.email,\n\t\t\tname: parsedForm.validated.name,\n\t\t\trequiresConfirmation: !authResult.session,\n\t\t\tuserId,\n\t\t});\n\n\t\tif (postSignUpResult) {\n\t\t\treturn postSignUpResult;\n\t\t}\n\n\t\t// Revalidate and redirect to onboarding\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/dashboard\");\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Re-throw redirect errors\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Complete Profile - Update missing user information after OAuth signup\n *\n * Features:\n * - Collects missing required fields (phone, name)\n * - Optional avatar upload\n * - Updates both auth metadata and public.users table\n * - Company name is collected during onboarding, not here\n */\nexport async function completeProfile(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await requireSupabaseBrowserClient();\n\t\tconst user = await requireAuthenticatedUser(supabase);\n\t\tconst parsedForm = parseCompleteProfileForm(formData);\n\t\tconst ensureServiceSupabase = createServiceClientLoader();\n\n\t\tconst profileUpdateResult = await updateCompleteProfileRecords({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId: user.id,\n\t\t\tname: parsedForm.name,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tavatarFile: parsedForm.avatarFile,\n\t\t\texistingAvatar:\n\t\t\t\tuser.user_metadata?.avatar_url || user.user_metadata?.picture || null,\n\t\t\texistingMetadata: user.user_metadata,\n\t\t});\n\n\t\tif (profileUpdateResult) {\n\t\t\treturn profileUpdateResult;\n\t\t}\n\n\t\tconst redirectPath = await resolveProfileRedirectPath({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId: user.id,\n\t\t}).catch((redirectError) => {\n\t\t\treportAuthIssue(\"Error checking company status\", redirectError);\n\t\t\treturn \"/welcome\";\n\t\t});\n\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(redirectPath);\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign In - Authenticate existing user with Supabase Auth\n *\n * Features:\n * - Email/password authentication\n * - Session management handled by Supabase\n * - Validates input with Zod\n * - Redirects to dashboard on success\n */\nexport async function signIn(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\temail: formData.get(\"email\") as string,\n\t\t\tpassword: formData.get(\"password\") as string,\n\t\t};\n\n\t\tconst validatedData = signInSchema.parse(rawData);\n\n\t\t// Rate limit sign-in attempts by email\n\t\ttry {\n\t\t\tawait checkRateLimit(validatedData.email, authRateLimiter);\n\t\t} catch (rateLimitError) {\n\t\t\tif (rateLimitError instanceof RateLimitError) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitError.message,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow rateLimitError;\n\t\t}\n\n\t\t// Create Supabase client\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Authentication service is not configured. Please check your environment variables.\",\n\t\t\t};\n\t\t}\n\n\t\t// Sign in with Supabase Auth\n\t\tconst { data, error: signInError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signInWithPassword({\n\t\t\t\temail: validatedData.email,\n\t\t\t\tpassword: validatedData.password,\n\t\t\t}),\n\t\t);\n\n\t\tif (signInError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: signInError.message,\n\t\t\t};\n\t\t}\n\n\t\tif (!data.session) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to create session. Please try again.\",\n\t\t\t};\n\t\t}\n\n\t\t// Revalidate and redirect to dashboard\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/dashboard\");\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\t// Handle AuthUnknownError (usually network/service issues)\n\t\tif (caughtError instanceof AuthUnknownError) {\n\t\t\tconsole.error(\"AuthUnknownError during sign in:\", caughtError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to connect to authentication service. Please check your internet connection and try again.\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\t// Log non-redirect errors for debugging\n\t\t\tconsole.error(\"Sign in error:\", caughtError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign Out - End user session\n *\n * Features:\n * - Clears Supabase session (cookie-based)\n * - Clears CSRF token cookie\n * - Clears active company cookie\n * - Revalidates all cached data\n * - Redirects to login page\n *\n * Security:\n * - Ensures all authentication and security cookies are removed\n * - Prevents session reuse or CSRF attacks after logout\n */\nexport async function signOut(): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Sign out from Supabase (clears auth cookies)\n\t\tconst { error: signOutError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signOut(),\n\t\t);\n\n\t\tif (signOutError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: signOutError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Clear all security-related cookies\n\t\tawait clearCSRFToken();\n\t\tawait clearActiveCompany();\n\n\t\t// Revalidate and redirect to login\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/login\");\n\t} catch (caughtError) {\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign In with OAuth - Authenticate with Google or other providers\n *\n * Features:\n * - OAuth provider authentication\n * - Handles both new signups and existing user logins automatically\n * - Supabase determines if user exists and signs them in or creates new account\n * - Redirects to provider login page\n * - After callback, checks if profile is complete (phone, name)\n */\nexport async function signInWithOAuth(\n\tprovider: \"google\" | \"facebook\",\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\t\tif (!siteUrl) {\n\t\t\tthrow new Error(\"NEXT_PUBLIC_SITE_URL is not configured\");\n\t\t}\n\n\t\tconst { data, error: oauthError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signInWithOAuth({\n\t\t\t\tprovider,\n\t\t\t\toptions: {\n\t\t\t\t\tredirectTo: `${siteUrl}/auth/callback`,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\tif (oauthError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: oauthError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Redirect to OAuth provider\n\t\tif (data.url) {\n\t\t\tredirect(data.url);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t} catch (caughtError) {\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Forgot Password - Send custom password reset email via Resend\n *\n * Features:\n * - Sends custom branded password reset email via Resend\n * - Secure token generation via Supabase\n * - Custom email template with security information\n */\nasync function forgotPassword(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst rawData = {\n\t\t\temail: formData.get(\"email\") as string,\n\t\t};\n\n\t\tconst validatedData = forgotPasswordSchema.parse(rawData);\n\n\t\t// Rate limit password reset requests by email (stricter limit)\n\t\ttry {\n\t\t\tawait checkRateLimit(validatedData.email, passwordResetRateLimiter);\n\t\t} catch (rateLimitError) {\n\t\t\tif (rateLimitError instanceof RateLimitError) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitError.message,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow rateLimitError;\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Generate password reset token via Supabase\n\t\tconst { error: resetPasswordError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.resetPasswordForEmail(validatedData.email, {\n\t\t\t\tredirectTo: `${emailConfig.siteUrl}/auth/reset-password`,\n\t\t\t}),\n\t\t);\n\n\t\tif (resetPasswordError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: resetPasswordError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Note: Supabase will send its own email with the reset link.\n\t\t// To use custom Resend email instead, you need to:\n\t\t// 1. Disable Supabase's password reset email in the dashboard\n\t\t// 2. Generate your own secure token\n\t\t// 3. Send custom email with that token\n\t\t// For now, we're using Supabase's reset flow but you can customize this\n\n\t\t// TODO: Replace with custom token generation + Resend email\n\t\t// For full custom implementation, see the commented code below:\n\t\t/*\n    const resetToken = generateSecureToken(); // Implement your own token generation\n    await storeResetToken(validatedData.email, resetToken); // Store in your database\n\n    await sendPasswordReset(validatedData.email, {\n      resetUrl: `${emailConfig.siteUrl}/auth/reset-password?token=${resetToken}`,\n      expiresInMinutes: 60,\n    });\n    */\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"Password reset email sent. Please check your inbox.\",\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to send reset email\",\n\t\t};\n\t}\n}\n\n/**\n * Reset Password - Update password with reset token + Send confirmation email\n *\n * Features:\n * - Updates user password\n * - Validates password strength\n * - Invalidates reset token after use\n * - Sends custom password changed confirmation via Resend\n */\nasync function resetPassword(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst rawData = {\n\t\t\tpassword: formData.get(\"password\") as string,\n\t\t\tconfirmPassword: formData.get(\"confirmPassword\") as string,\n\t\t};\n\n\t\tconst validatedData = resetPasswordSchema.parse(rawData);\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current user before updating password\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\t\tconst { error: updateUserError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.updateUser({\n\t\t\t\tpassword: validatedData.password,\n\t\t\t}),\n\t\t);\n\n\t\tif (updateUserError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: updateUserError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Send password changed confirmation email via Resend\n\t\tif (user?.email) {\n\t\t\tconst emailResult = await sendPasswordChanged(user.email, {\n\t\t\t\tname: user.user_metadata?.name || \"User\",\n\t\t\t\tchangedAt: new Date(),\n\t\t\t});\n\n\t\t\t// Log email send failure but don't block password reset\n\t\t\tif (!emailResult.success) {\n\t\t\t\treportAuthIssue(\n\t\t\t\t\t\"Failed to send password changed email\",\n\t\t\t\t\temailResult.error,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage:\n\t\t\t\t\t\"Password updated successfully. A confirmation email has been sent.\",\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to reset password\",\n\t\t};\n\t}\n}\n\n/**\n * Get Current User - Retrieve authenticated user data\n *\n * Features:\n * - Returns user session data\n * - Returns null if not authenticated\n * - Can be used in Server Components\n */\nasync function getCurrentUser() {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\t\treturn user;\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error getting current user\", caughtError);\n\t\treturn null;\n\t}\n}\n\n/**\n * Get Session - Retrieve current session\n *\n * Features:\n * - Returns session data including access token\n * - Returns null if no active session\n * - Can be used in Server Components\n */\nasync function getSession() {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { session },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getSession());\n\n\t\treturn session;\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error getting session\", caughtError);\n\t\treturn null;\n\t}\n}\n\n/**\n * Verify Email - Verify user's email with custom token\n *\n * Features:\n * - Validates custom verification token\n * - Updates Supabase user's email_confirmed_at\n * - One-time use tokens with expiration\n * - Sends welcome email after successful verification\n */\nexport async function verifyEmail(token: string): Promise<AuthActionResult> {\n\ttry {\n\t\t// Verify and consume the token\n\t\tconst tokenRecord = await verifyAndConsumeToken(\n\t\t\ttoken,\n\t\t\t\"email_verification\",\n\t\t);\n\n\t\tif (!tokenRecord) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Invalid or expired verification link. Please request a new one.\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Update Supabase user to mark email as verified\n\t\tif (tokenRecord.userId) {\n\t\t\t// Note: profiles table doesn't have email_verified field\n\t\t\t// Email verification is handled through auth.users.email_confirmed_at\n\t\t\t// which is set automatically by Supabase Auth\n\t\t\t// We don't need to manually update profiles table\n\n\t\t\t// Send welcome email after successful verification\n\t\t\tconst welcomeResult = await sendWelcomeEmail(tokenRecord.email, {\n\t\t\t\tname: getMetadataString(tokenRecord.metadata, \"name\") || \"User\",\n\t\t\t\tloginUrl: `${emailConfig.siteUrl}/login`,\n\t\t\t});\n\n\t\t\tif (!welcomeResult.success) {\n\t\t\t\treportAuthIssue(\"Failed to send welcome email\", welcomeResult.error);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"Email verified successfully! You can now sign in.\",\n\t\t\t\temail: tokenRecord.email,\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error verifying email\", caughtError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to verify email\",\n\t\t};\n\t}\n}\n\n/**\n * Resend Verification Email - Send a new verification email\n *\n * Features:\n * - Generates new verification token\n * - Deletes old tokens for the email\n * - Sends fresh verification email\n */\nasync function resendVerificationEmail(\n\temail: string,\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Check if user exists\n\t\tconst { data: userData } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"id, full_name, email\")\n\t\t\t.eq(\"email\", email)\n\t\t\t.single();\n\n\t\tif (!userData) {\n\t\t\t// Don't reveal if user exists or not for security\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t\"If an account exists with this email, a verification link has been sent.\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Generate new verification token\n\t\tconst { token, expiresAt } = await createEmailVerificationToken(\n\t\t\temail,\n\t\t\tuserData.id,\n\t\t\tCONFIRMATION_TOKEN_TTL_HOURS,\n\t\t);\n\n\t\t// Send verification email\n\t\tconst verificationUrl = `${emailConfig.siteUrl}/auth/verify-email?token=${token}`;\n\n\t\tconst emailResult = await sendEmailVerification(email, {\n\t\t\tname: userData.full_name || \"User\",\n\t\t\tverificationUrl,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treportAuthIssue(\"Failed to send verification email\", emailResult.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to send verification email. Please try again.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"A new verification link has been sent to your email.\",\n\t\t\t\texpiresAt: expiresAt.toISOString(),\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error resending verification email\", caughtError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to resend verification email\",\n\t\t};\n\t}\n}\n\n/**\n * Get Active Company ID Action\n *\n * Server action to get the currently active company ID for client components.\n */\nexport async function getCompanyIdAction(): Promise<{\n\tsuccess: boolean;\n\tcompanyId?: string;\n\terror?: string;\n}> {\n\t\"use server\";\n\n\ttry {\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\treturn { success: true, companyId };\n\t} catch (error) {\n\t\tconsole.error(\"Error getting company ID:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAigCsB,UAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/company-context.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Company Context Server Actions\n *\n * Server Actions for managing active company context.\n * Used by company switcher UI components.\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport {\n\tclearActiveCompany,\n\tgetActiveCompany,\n\tgetUserCompanies,\n\tsetActiveCompany,\n} from \"@/lib/auth/company-context\";\n\n/**\n * Action Result Type\n */\ntype ActionResult<T = void> =\n\t| {\n\t\t\tsuccess: true;\n\t\t\tdata?: T;\n\t\t\tmessage?: string;\n\t  }\n\t| {\n\t\t\tsuccess: false;\n\t\t\terror: string;\n\t  };\n\n/**\n * Switch Company\n *\n * Changes the user's active company context.\n * Revalidates the entire layout to update company-scoped data.\n *\n * @param companyId - Company ID to switch to\n * @returns ActionResult indicating success or failure\n */\nexport async function switchCompany(\n\tcompanyId: string,\n): Promise<ActionResult<void>> {\n\ttry {\n\t\tawait setActiveCompany(companyId);\n\n\t\t// Revalidate everything to ensure all company-scoped data is refreshed\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Company switched successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to switch company\",\n\t\t};\n\t}\n}\n\n/**\n * Clear Active Company\n *\n * Removes the active company context.\n * Useful for logout or company removal flows.\n *\n * @returns ActionResult indicating success or failure\n */\nasync function clearCompany(): Promise<ActionResult<void>> {\n\ttry {\n\t\tawait clearActiveCompany();\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Company context cleared\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to clear company context\",\n\t\t};\n\t}\n}\n\n/**\n * Get User's Companies\n *\n * Returns all companies the user has access to.\n * Useful for populating company switcher dropdowns.\n *\n * @returns ActionResult with array of companies\n */\nasync function getCompanies(): Promise<\n\tActionResult<Array<{ id: string; name: string; logo?: string | null }>>\n> {\n\ttry {\n\t\tconst companies = await getUserCompanies();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: companies,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to get companies\",\n\t\t};\n\t}\n}\n\n/**\n * Get Active Company Details\n *\n * Returns details about the currently active company.\n *\n * @returns ActionResult with company details or null\n */\nasync function getActiveCompanyDetails(): Promise<\n\tActionResult<{ id: string; name: string; logo?: string | null } | null>\n> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: company,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get active company\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAwCsB,gBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/user-status.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n/**\n * Update user status action\n * Allows users to change their availability status (online, available, busy)\n */\n\nexport type UserStatus = \"online\" | \"available\" | \"busy\";\n\nexport async function updateUserStatus(status: UserStatus) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Database connection failed\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unauthorized\",\n\t\t\t};\n\t\t}\n\n\t\t// Update user status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", user.id);\n\n\t\tif (updateError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update status\",\n\t\t\t};\n\t\t}\n\n\t\t// Revalidate all pages to reflect the new status\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tstatus,\n\t\t};\n\t} catch (_error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"An unexpected error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAYsB,mBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/email-actions.ts"],"sourcesContent":["\"use server\";\n\nimport {\n    archiveAllEmails,\n    getCompanyEmails,\n    getEmailById,\n    getEmailStats,\n    getEmailThreads,\n    markEmailAsRead,\n    type CompanyEmail,\n} from \"@/lib/email/email-service\";\nimport { z } from \"zod\";\n\nconst getEmailsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  inboxType: z.enum([\"personal\", \"company\"]).optional(),\n  folder: z.enum([\"inbox\", \"drafts\", \"sent\", \"archive\", \"snoozed\", \"spam\", \"trash\", \"bin\", \"starred\", \"all\"]).optional(),\n  category: z.enum([\"support\", \"sales\", \"billing\", \"general\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\", \"subject\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst getEmailThreadsSchema = z.object({\n  limit: z.number().min(1).max(50).optional().default(20),\n  offset: z.number().min(0).optional().default(0),\n  search: z.string().optional(),\n});\n\nconst markEmailReadSchema = z.object({\n  emailId: z.string().min(1),\n});\n\nexport type GetEmailsInput = z.infer<typeof getEmailsSchema>;\nexport type GetEmailThreadsInput = z.infer<typeof getEmailThreadsSchema>;\nexport type MarkEmailReadInput = z.infer<typeof markEmailReadSchema>;\n\n// Re-export email types from email-service\nexport type { CompanyEmail };\n\nexport type GetEmailsResult = Awaited<ReturnType<typeof getCompanyEmails>>;\nexport type GetEmailThreadsResult = Awaited<ReturnType<typeof getEmailThreads>>;\nexport type GetEmailStatsResult = Awaited<ReturnType<typeof getEmailStats>>;\n\n/**\n * Get emails for the active company\n */\nexport async function getEmailsAction(\n  input: GetEmailsInput\n): Promise<GetEmailsResult> {\n  try {\n    const parseResult = getEmailsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      console.error(\" Zod validation error:\", parseResult.error.issues);\n      throw new Error(`Invalid input parameters: ${parseResult.error.issues.map((e) => `${e.path.map(String).join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    // Convert null to undefined for search field\n    const sanitizedInput = {\n      ...validatedInput,\n      search: validatedInput.search ?? undefined,\n    };\n    return await getCompanyEmails(companyId, sanitizedInput);\n  } catch (error) {\n    console.error(\" getEmailsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get email threads for the active company\n */\nasync function getEmailThreadsAction(\n  input: GetEmailThreadsInput\n): Promise<GetEmailThreadsResult> {\n  try {\n    const validatedInput = getEmailThreadsSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailThreads(companyId, validatedInput);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Get a specific email by ID\n */\nexport async function getEmailByIdAction(emailId: string): Promise<{\n  success: boolean;\n  email?: CompanyEmail;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const email = await getEmailById(companyId, emailId);\n    \n    if (!email) {\n      return { success: false, error: \"Email not found\" };\n    }\n\n    return { success: true, email };\n  } catch (error) {\n    console.error(\"Error getting email by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an email as read\n */\nexport async function markEmailAsReadAction(\n  input: MarkEmailReadInput\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const validatedInput = markEmailReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const result = await markEmailAsRead(companyId, validatedInput.emailId);\n    if (!result) {\n      return { success: false, error: \"Failed to mark email as read - check server logs for details\" };\n    }\n    return { success: true };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, error: `Invalid input: ${error.issues.map((e: { message: string }) => e.message).join(\", \")}` };\n    }\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    console.error(\"Error marking email as read:\", error);\n    return { success: false, error: errorMessage };\n  }\n}\n\n/**\n * Get email statistics for the active company\n */\nasync function getEmailStatsAction(): Promise<GetEmailStatsResult> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailStats();\n  } catch (error) {\n    console.error(\"Error getting email stats:\", error);\n    return {\n      totalEmails: 0,\n      sentEmails: 0,\n      receivedEmails: 0,\n      unreadEmails: 0,\n      threadsCount: 0,\n    };\n  }\n}\n\n/**\n * Get total unread email count for the active company\n * Used for displaying notification badges in the header\n */\nexport async function getTotalUnreadCountAction(): Promise<{\n  success: boolean;\n  count?: number;\n  error?: string\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const stats = await getEmailStats();\n    return { success: true, count: stats.unreadEmails };\n  } catch (error) {\n    console.error(\"Error getting unread count:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Fetch email content from Resend API or update with provided content\n */\nexport async function fetchEmailContentAction(\n  emailId: string,\n  _resendEmailId?: string,\n  providedContent?: { html?: string | null; text?: string | null }\n): Promise<{\n  success: boolean;\n  html?: string | null;\n  text?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    let html: string | null = null;\n    let text: string | null = null;\n\n    // If content is provided directly, use it\n    if (providedContent) {\n      html = providedContent.html || null;\n      text = providedContent.text || null;\n    } else {\n      // First, try to get email from database to check for content in metadata\n      const { data: email, error: emailError } = await supabase\n        .from(\"communications\")\n        .select(\"provider_message_id, provider_metadata, body, body_html\")\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId)\n        .single();\n\n      if (emailError) {\n        // Don't return error for PGRST errors that might be expected\n        if (emailError.code === 'PGRST116') {\n          return { success: false, error: \"Email not found in database\" };\n        }\n        return { success: false, error: `Database error: ${emailError.message}` };\n      }\n\n      if (!email) {\n        return { success: false, error: \"Email not found in database\" };\n      }\n\n      // Check if email already has content stored\n      if (email.body_html || email.body) {\n        html = email.body_html || null;\n        text = email.body || null;\n      } else if (email.provider_metadata) {\n        // Try to extract content from provider_metadata\n        const metadata = email.provider_metadata as Record<string, unknown>;\n        \n        // PRIORITY 1: Check webhook_content first (webhook payload - most reliable source)\n        const webhookContent = metadata.webhook_content as Record<string, unknown> | undefined;\n        if (webhookContent) {\n          const htmlValue = webhookContent.html || webhookContent.body_html;\n          const textValue = webhookContent.text || webhookContent.body;\n          \n          if (htmlValue && typeof htmlValue === \"string\") {\n            const content = htmlValue.trim();\n            if (content.length > 0) {\n              html = content;\n            }\n          }\n          if (!html && textValue && typeof textValue === \"string\") {\n            const content = textValue.trim();\n            if (content.length > 0) {\n              text = content;\n            }\n          }\n        }\n\n        // PRIORITY 2: Check full_content (API response) if webhook didn't have content\n        if (!html && !text) {\n          const fullContent = metadata.full_content as Record<string, unknown> | undefined;\n          if (fullContent) {\n            const htmlFields = [\"html\", \"body_html\", \"bodyHtml\"];\n            const textFields = [\"text\", \"body\", \"plain_text\", \"plainText\"];\n\n            // Try HTML fields first\n            for (const field of htmlFields) {\n              if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                const content = (fullContent[field] as string).trim();\n                if (content.length > 0) {\n                  html = content;\n                  break;\n                }\n              }\n            }\n\n            // If no HTML, try text fields\n            if (!html) {\n              for (const field of textFields) {\n                if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                  const content = (fullContent[field] as string).trim();\n                  if (content.length > 0) {\n                    text = content;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // PRIORITY 3: Check top-level metadata.data for content (webhook payload structure)\n        if (!html && !text) {\n          const webhookData = metadata.data as Record<string, unknown> | undefined;\n          if (webhookData) {\n            const htmlValue = webhookData.html || webhookData.body_html;\n            const textValue = webhookData.text || webhookData.body;\n            \n            if (htmlValue && typeof htmlValue === \"string\") {\n              const content = htmlValue.trim();\n              if (content.length > 0) {\n                html = content;\n              }\n            }\n            if (!html && textValue && typeof textValue === \"string\") {\n              const content = textValue.trim();\n              if (content.length > 0) {\n                text = content;\n              }\n            }\n          }\n        }\n\n        // PRIORITY 4: Check top-level metadata fields directly\n        if (!html && !text) {\n          const htmlFields = [\"html\", \"body_html\"];\n          const textFields = [\"text\", \"body\"];\n          \n          for (const field of htmlFields) {\n            if (metadata[field] && typeof metadata[field] === \"string\") {\n              const content = (metadata[field] as string).trim();\n              if (content.length > 0) {\n                html = content;\n                break;\n              }\n            }\n          }\n          \n          if (!html) {\n            for (const field of textFields) {\n              if (metadata[field] && typeof metadata[field] === \"string\") {\n                const content = (metadata[field] as string).trim();\n                if (content.length > 0) {\n                  text = content;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // If we found content in metadata, use it and return early\n        if (html || text) {\n          // Update database with extracted content\n          if ((html || text) && supabase) {\n            const { error: updateError } = await supabase\n              .from(\"communications\")\n              .update({\n                body: text || \"\",\n                body_html: html,\n              })\n              .eq(\"id\", emailId)\n              .eq(\"company_id\", companyId);\n\n            if (updateError) {\n              console.warn(\"  Failed to update email content in database:\", updateError.message);\n            }\n          }\n          return { success: true, html, text };\n        } else {\n          // No content found in metadata\n          return {\n            success: false,\n            error: \"No email content available in metadata\"\n          };\n        }\n      } else {\n        // No metadata at all, can't fetch content\n        return { success: false, error: \"No email metadata available\" };\n      }\n    }\n\n    // Update the database with the content\n    // Try to update, but don't fail if the email doesn't exist - we still return the content\n    if (supabase) {\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update({\n          body: text || \"\",\n          body_html: html,\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      if (updateError) {\n        console.warn(\"  Failed to update email content in database (this is OK, content still returned):\", updateError.message);\n      }\n    }\n\n    return { success: true, html, text };\n  } catch (error) {\n    console.error(\"Error fetching email content:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Sync inbound email routes from database to Resend\n * Creates routes in Resend that don't have a resend_route_id\n */\nexport async function syncInboundRoutesToResendAction(): Promise<{\n  success: boolean;\n  synced: number;\n  errors: string[];\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { createInboundRoute } = await import(\"@/lib/email/resend-domains\");\n    const { createServiceSupabaseClient } = await import(\"@/lib/supabase/service-client\");\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, synced: 0, errors: [\"Database connection failed\"] };\n    }\n\n    const serviceSupabase = await createServiceSupabaseClient();\n    if (!serviceSupabase) {\n      return { success: false, synced: 0, errors: [\"Service database connection failed\"] };\n    }\n\n    // Get all routes that don't have a resend_route_id\n    // Note: This table may not be in the type definitions, so we use type assertion\n    const { data: routes, error } = await (serviceSupabase\n      .from(\"communication_email_inbound_routes\" as any)\n      .select(\"id, company_id, route_address, name, enabled\")\n      .is(\"resend_route_id\", null)\n      .eq(\"enabled\", true) as any);\n\n    if (error) {\n      console.error(\"Failed to fetch routes:\", error);\n      return { success: false, synced: 0, errors: [error.message] };\n    }\n\n    if (!routes || routes.length === 0) {\n      return { success: true, synced: 0, errors: [] };\n    }\n\n    // Construct webhook URL\n    let webhookUrl = process.env.NEXT_PUBLIC_SITE_URL;\n    if (!webhookUrl && process.env.VERCEL_URL) {\n      webhookUrl = `https://${process.env.VERCEL_URL}`;\n    }\n    if (!webhookUrl) {\n      return { success: false, synced: 0, errors: [\"Webhook URL not configured. Set NEXT_PUBLIC_SITE_URL or VERCEL_URL\"] };\n    }\n    webhookUrl = `${webhookUrl}/api/webhooks/resend`;\n\n    const errors: string[] = [];\n    let synced = 0;\n\n    for (const route of (routes || []) as Array<{ id: string; company_id: string; route_address: string; name: string | null; enabled: boolean }>) {\n      try {\n        // Handle catch-all routes (e.g., @biezru.resend.app)\n        // Resend doesn't support true catch-all, so we'll create a route for the domain\n        // For now, we'll skip catch-all routes and handle them differently\n        if (route.route_address.startsWith(\"@\")) {\n          errors.push(`Catch-all routes (${route.route_address}) need to be configured manually in Resend dashboard`);\n          continue;\n        }\n\n        // Create route in Resend\n        const result = await createInboundRoute({\n          name: route.name || `Route for ${route.route_address}`,\n          recipients: [route.route_address],\n          url: webhookUrl,\n        });\n\n        if (!result.success) {\n          console.error(` Failed to create Resend route for ${route.route_address}:`, result.error);\n          errors.push(`${route.route_address}: ${result.error}`);\n          continue;\n        }\n\n        // Update database with resend_route_id\n        const { error: updateError } = await (serviceSupabase\n          .from(\"communication_email_inbound_routes\" as any)\n          .update({\n            resend_route_id: result.data.id,\n            signing_secret: result.data.secret || null,\n            last_synced_at: new Date().toISOString(),\n          })\n          .eq(\"id\", route.id) as any);\n\n        if (updateError) {\n          console.error(` Failed to update route ${route.route_address}:`, updateError);\n          errors.push(`${route.route_address}: Database update failed`);\n          continue;\n        }\n\n        synced++;\n      } catch (error) {\n        console.error(` Error syncing route ${route.route_address}:`, error);\n        errors.push(`${route.route_address}: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      synced,\n      errors,\n    };\n  } catch (error) {\n    console.error(\"Error syncing inbound routes:\", error);\n    return {\n      success: false,\n      synced: 0,\n      errors: [error instanceof Error ? error.message : \"Unknown error\"],\n    };\n  }\n}\n\n/**\n * Archive an email\n */\nexport async function archiveEmailAction(emailId: string): Promise<{ success: boolean; error?: string }> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const { error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n    \n    if (error) {\n      return { success: false, error: error.message };\n    }\n    \n    return { success: true };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk archive multiple emails by their IDs\n */\nexport async function bulkArchiveEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  archived: number;\n  error?: string\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, archived: 0, error: \"No email IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, archived: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, archived: 0, error: error.message };\n    }\n\n    const archivedCount = data?.length ?? 0;\n    return { success: true, archived: archivedCount };\n  } catch (error) {\n    return { success: false, archived: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Archive all emails in a folder\n */\nexport async function archiveAllEmailsAction(folder?: string): Promise<{ \n  success: boolean; \n  archived: number;\n  error?: string \n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n    \n    const result = await archiveAllEmails(companyId, folder);\n    \n    if (!result.success) {\n      return { success: false, archived: 0, error: result.error };\n    }\n    \n    return { success: true, archived: result.count };\n  } catch (error) {\n    return {\n      success: false,\n      archived: 0,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Get email folder counts for the active company\n * Returns count of emails in each folder (inbox, sent, drafts, etc.)\n */\nexport async function getEmailFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    all: number;\n    inbox: number;\n    drafts: number;\n    sent: number;\n    archive: number;\n    snoozed: number;\n    spam: number;\n    trash: number;\n    starred: number;\n    [key: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get counts for each folder type using parallel queries\n    // All counts show UNREAD emails only (read_at IS NULL)\n    const [\n      allResult,\n      inboxResult,\n      draftsResult,\n      sentResult,\n      archiveResult,\n      snoozedResult,\n      spamResult,\n      trashResult,\n      starredResult\n    ] = await Promise.all([\n      // All Mail: all non-deleted, unread emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Inbox: inbound, not archived, not deleted, not draft, not spam, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\")\n        .or(\"category.is.null,category.neq.spam\")\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n\n      // Drafts - always count all drafts (read_at not relevant for drafts)\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"status\", \"draft\")\n        .is(\"deleted_at\", null),\n\n      // Sent: outbound, not archived, not deleted, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\"),\n\n      // Archive - unread archived emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"is_archived\", true)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Snoozed - unread snoozed emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"snoozed_until\", \"is\", null)\n        .gt(\"snoozed_until\", new Date().toISOString())\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Spam - fetch category, tags, and read_at to count unread spam\n      supabase\n        .from(\"communications\")\n        .select(\"category, tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Trash - unread deleted emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"deleted_at\", \"is\", null)\n        .is(\"read_at\", null),\n\n      // Starred - fetch tags and read_at, count unread starred in memory\n      supabase\n        .from(\"communications\")\n        .select(\"tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n    ]);\n\n    // Count spam emails in memory (category=spam OR spam tag)\n    const spamCount = (spamResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      const hasSpamTag = Array.isArray(tags) && tags.includes(\"spam\");\n      return email.category === \"spam\" || hasSpamTag;\n    }).length;\n\n    // Count starred emails in memory\n    const starredCount = (starredResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      return Array.isArray(tags) && tags.includes(\"starred\");\n    }).length;\n\n    return {\n      success: true,\n      counts: {\n        all: allResult.count ?? 0,\n        inbox: inboxResult.count ?? 0,\n        drafts: draftsResult.count ?? 0,\n        sent: sentResult.count ?? 0,\n        archive: archiveResult.count ?? 0,\n        snoozed: snoozedResult.count ?? 0,\n        spam: spamCount,\n        trash: trashResult.count ?? 0,\n        starred: starredCount,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting email folder counts:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Toggle star status on an email\n * Adds or removes \"starred\" tag from the email's tags array\n */\nexport async function toggleStarEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isStarred?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlyStarred = currentTags.includes(\"starred\");\n\n    // Toggle the starred tag\n    const newTags = isCurrentlyStarred\n      ? currentTags.filter(tag => tag !== \"starred\")\n      : [...currentTags, \"starred\"];\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ tags: newTags.length > 0 ? newTags : null })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isStarred: !isCurrentlyStarred };\n  } catch (error) {\n    console.error(\"Error toggling star on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Toggle spam status on an email\n * Adds or removes \"spam\" tag and updates category field\n */\nexport async function toggleSpamEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isSpam?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags and category\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags, category\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlySpam = currentTags.includes(\"spam\") || email?.category === \"spam\";\n\n    // Toggle the spam tag and category\n    const newTags = isCurrentlySpam\n      ? currentTags.filter(tag => tag !== \"spam\")\n      : [...currentTags, \"spam\"];\n\n    const newCategory = isCurrentlySpam ? null : \"spam\";\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        tags: newTags.length > 0 ? newTags : null,\n        category: newCategory\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isSpam: !isCurrentlySpam };\n  } catch (error) {\n    console.error(\"Error toggling spam on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Snooze an email until a specific time\n * The email will reappear in inbox after the snooze time\n */\nexport async function snoozeEmailAction(\n  emailId: string,\n  snoozeUntil: string | null\n): Promise<{\n  success: boolean;\n  snoozedUntil?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Update the snoozed_until field\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ snoozed_until: snoozeUntil })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, snoozedUntil: snoozeUntil };\n  } catch (error) {\n    console.error(\"Error snoozing email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Unsnooze an email (remove snooze time)\n */\nexport async function unsnoozeEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  return snoozeEmailAction(emailId, null);\n}\n\n/**\n * Bulk mark emails as read or unread\n */\nexport async function bulkMarkReadUnreadAction(\n  emailIds: string[],\n  markAsRead: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ read_at: markAsRead ? new Date().toISOString() : null })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, updated: 0, error: error.message };\n    }\n\n    // Dispatch event to refresh counts\n    return { success: true, updated: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk marking emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk toggle star on emails\n */\nexport async function bulkStarEmailsAction(\n  emailIds: string[],\n  addStar: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Group emails by what changes need to be made\n    const toUpdate: Array<{ id: string; newTags: string[] | null }> = [];\n\n    for (const email of emails) {\n      const currentTags = (email.tags as string[]) || [];\n      const hasStarred = currentTags.includes(\"starred\");\n\n      let newTags: string[];\n      if (addStar && !hasStarred) {\n        newTags = [...currentTags, \"starred\"];\n      } else if (!addStar && hasStarred) {\n        newTags = currentTags.filter((t) => t !== \"starred\");\n      } else {\n        continue; // No change needed\n      }\n\n      toUpdate.push({ id: email.id, newTags: newTags.length > 0 ? newTags : null });\n    }\n\n    if (toUpdate.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      toUpdate.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const updatedCount = results.filter((r) => !r.error).length;\n    return { success: true, updated: updatedCount };\n  } catch (error) {\n    console.error(\"Error bulk starring emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk delete emails (move to trash)\n */\nexport async function bulkDeleteEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  deleted: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, deleted: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, deleted: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, deleted: 0, error: \"Database connection failed\" };\n    }\n\n    // Soft delete by setting deleted_at\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ deleted_at: new Date().toISOString() })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, deleted: 0, error: error.message };\n    }\n\n    return { success: true, deleted: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk deleting emails:\", error);\n    return { success: false, deleted: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk move emails to spam\n */\nexport async function bulkMoveToSpamAction(emailIds: string[]): Promise<{\n  success: boolean;\n  moved: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, moved: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, moved: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, moved: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, moved: 0 };\n    }\n\n    // Prepare updates with new tags\n    const updates = emails.map((email) => {\n      const currentTags = (email.tags as string[]) || [];\n      const newTags = currentTags.includes(\"spam\")\n        ? currentTags\n        : [...currentTags, \"spam\"];\n      return { id: email.id, newTags };\n    });\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      updates.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ category: \"spam\", tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const movedCount = results.filter((r) => !r.error).length;\n    return { success: true, moved: movedCount };\n  } catch (error) {\n    console.error(\"Error moving emails to spam:\", error);\n    return { success: false, moved: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// DRAFT ACTIONS\n// ============================================================================\n\nconst saveDraftSchema = z.object({\n  id: z.string().uuid().optional(), // If provided, update existing draft\n  to: z.array(z.string().email()).optional().default([]),\n  cc: z.array(z.string().email()).optional().default([]),\n  bcc: z.array(z.string().email()).optional().default([]),\n  subject: z.string().optional().default(\"\"),\n  body: z.string().optional().default(\"\"),\n  bodyHtml: z.string().optional(),\n  customerId: z.string().uuid().optional(),\n  attachments: z.array(z.object({\n    filename: z.string(),\n    content: z.string(),\n    contentType: z.string().optional(),\n  })).optional(),\n});\n\nexport type SaveDraftInput = z.infer<typeof saveDraftSchema>;\n\n/**\n * Save or update an email draft\n * If id is provided, updates existing draft; otherwise creates a new one\n */\nexport async function saveDraftAction(input: SaveDraftInput): Promise<{\n  success: boolean;\n  draftId?: string;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const parseResult = saveDraftSchema.safeParse(input);\n    if (!parseResult.success) {\n      return { success: false, error: `Invalid input: ${parseResult.error.message}` };\n    }\n\n    const { id, to, cc, bcc, subject, body, bodyHtml, customerId, attachments } = parseResult.data;\n\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the company's default email address for from_address\n    const { data: companySettings } = await supabase\n      .from(\"company_communication_settings\")\n      .select(\"email_from_address, email_from_name\")\n      .eq(\"company_id\", companyId)\n      .single();\n\n    const fromAddress = companySettings?.email_from_address || \"noreply@example.com\";\n    const fromName = companySettings?.email_from_name || \"Draft\";\n\n    const draftData = {\n      company_id: companyId,\n      customer_id: customerId || null,\n      type: \"email\" as const,\n      direction: \"outbound\" as const,\n      from_address: fromAddress,\n      from_name: fromName,\n      to_address: to.length > 0 ? to.join(\", \") : \"draft@placeholder.local\",\n      cc_address: cc.length > 0 ? cc.join(\", \") : null,\n      bcc_address: bcc.length > 0 ? bcc.join(\", \") : null,\n      subject: subject || \"(No subject)\",\n      body: body || \"\",\n      body_html: bodyHtml || null,\n      attachments: attachments && attachments.length > 0 ? attachments : null,\n      attachment_count: attachments?.length || 0,\n      status: \"draft\" as const,\n      is_automated: false,\n      is_internal: false,\n      is_archived: false,\n      is_thread_starter: true,\n      priority: \"normal\" as const,\n      updated_at: new Date().toISOString(),\n    };\n\n    if (id) {\n      // Update existing draft\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update(draftData)\n        .eq(\"id\", id)\n        .eq(\"company_id\", companyId)\n        .eq(\"status\", \"draft\");\n\n      if (updateError) {\n        console.error(\"Error updating draft:\", updateError);\n        return { success: false, error: updateError.message };\n      }\n\n      return { success: true, draftId: id };\n    } else {\n      // Create new draft\n      const { data: newDraft, error: insertError } = await supabase\n        .from(\"communications\")\n        .insert({\n          ...draftData,\n          created_at: new Date().toISOString(),\n        })\n        .select(\"id\")\n        .single();\n\n      if (insertError) {\n        console.error(\"Error creating draft:\", insertError);\n        return { success: false, error: insertError.message };\n      }\n\n      return { success: true, draftId: newDraft.id };\n    }\n  } catch (error) {\n    console.error(\"Error saving draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Get a draft by ID\n */\nexport async function getDraftAction(draftId: string): Promise<{\n  success: boolean;\n  draft?: {\n    id: string;\n    to: string[];\n    cc: string[];\n    bcc: string[];\n    subject: string;\n    body: string;\n    bodyHtml?: string | null;\n    customerId?: string | null;\n    attachments?: Array<{ filename: string; content: string; contentType?: string }> | null;\n    updatedAt: string;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const { data: draft, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"id, to_address, cc_address, bcc_address, subject, body, body_html, customer_id, attachments, updated_at\")\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!draft) {\n      return { success: false, error: \"Draft not found\" };\n    }\n\n    // Parse addresses from comma-separated strings to arrays\n    const parseAddresses = (addr: string | null): string[] => {\n      if (!addr || addr === \"draft@placeholder.local\") return [];\n      return addr.split(\",\").map(a => a.trim()).filter(Boolean);\n    };\n\n    return {\n      success: true,\n      draft: {\n        id: draft.id,\n        to: parseAddresses(draft.to_address),\n        cc: parseAddresses(draft.cc_address),\n        bcc: parseAddresses(draft.bcc_address),\n        subject: draft.subject === \"(No subject)\" ? \"\" : (draft.subject || \"\"),\n        body: draft.body || \"\",\n        bodyHtml: draft.body_html,\n        customerId: draft.customer_id,\n        attachments: draft.attachments as Array<{ filename: string; content: string; contentType?: string }> | null,\n        updatedAt: draft.updated_at,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Delete a draft\n */\nexport async function deleteDraftAction(draftId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Hard delete drafts (they don't need to go to trash)\n    const { error: deleteError } = await supabase\n      .from(\"communications\")\n      .delete()\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\");\n\n    if (deleteError) {\n      return { success: false, error: deleteError.message };\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// RETRY ACTIONS\n// ============================================================================\n\n/**\n * Retry sending a failed email\n * Fetches the failed email, resets its status, and attempts to resend\n */\nexport async function retryFailedEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const { sendEmail } = await import(\"@/lib/email/email-sender\");\n    const { PlainTextEmail } = await import(\"@/emails/plain-text-email\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the failed email\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"*\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .eq(\"status\", \"failed\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!email) {\n      return { success: false, error: \"Failed email not found\" };\n    }\n\n    // Reset status to queued\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        status: \"queued\",\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    if (updateError) {\n      return { success: false, error: `Failed to reset email status: ${updateError.message}` };\n    }\n\n    // Parse recipients\n    const parseAddresses = (addr: string | null): string | string[] => {\n      if (!addr) return [];\n      const addresses = addr.split(\",\").map(a => a.trim()).filter(Boolean);\n      return addresses.length === 1 ? addresses[0] : addresses;\n    };\n\n    const to = parseAddresses(email.to_address);\n    const cc = parseAddresses(email.cc_address);\n    const bcc = parseAddresses(email.bcc_address);\n\n    // Get attachments from metadata if stored (for scheduled emails)\n    const metadata = email.provider_metadata as Record<string, unknown> | null;\n    const attachments = metadata?.scheduled_attachments as Array<{\n      filename: string;\n      content: string;\n      contentType?: string;\n    }> | undefined;\n\n    // Attempt to resend\n    const sendResult = await sendEmail({\n      to,\n      subject: email.subject || \"(No subject)\",\n      template: PlainTextEmail({ message: email.body || \"\" }),\n      templateType: \"generic\" as any,\n      companyId,\n      communicationId: emailId,\n      cc: cc.length > 0 ? cc : undefined,\n      bcc: bcc.length > 0 ? bcc : undefined,\n      attachments,\n    });\n\n    if (!sendResult.success) {\n      // Update status back to failed\n      await supabase\n        .from(\"communications\")\n        .update({\n          status: \"failed\",\n          failure_reason: sendResult.error || \"Email send failed on retry\",\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      return {\n        success: false,\n        error: sendResult.error || \"Failed to send email on retry\",\n      };\n    }\n\n    // Update status to sent\n    await supabase\n      .from(\"communications\")\n      .update({\n        status: \"sent\",\n        sent_at: new Date().toISOString(),\n        provider_message_id: sendResult.data?.id || null,\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error retrying failed email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IAoMsB,4BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/ai-approval.ts"],"sourcesContent":["/**\n * AI Action Approval Server Actions\n *\n * Server actions for owner-only approval of destructive AI actions.\n * These actions wrap the action-approval service for use in React components.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tapproveAction,\n\trejectAction,\n\tgetPendingActionsForCompany,\n\tgetPendingActionsForChat,\n\tgetPendingAction,\n\tisCompanyOwner,\n\texpireOldActions,\n\ttype PendingAction,\n} from \"@/lib/ai/action-approval\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type { PendingAction };\n\nexport interface ApprovalActionResult {\n\tsuccess: boolean;\n\terror?: string;\n\tactionId?: string;\n\ttoolName?: string;\n\ttoolArgs?: Record<string, unknown>;\n\t// Execution fields (for approval responses)\n\texecuted?: boolean;\n\texecutionResult?: unknown;\n\texecutionError?: string;\n}\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst approveActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n});\n\nconst rejectActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n\treason: z.string().max(500, \"Reason too long\").optional(),\n});\n\nconst getPendingActionsSchema = z.object({\n\tstatus: z.enum([\"pending\", \"approved\", \"rejected\", \"expired\"]).optional(),\n\tlimit: z.number().min(1).max(100).default(50),\n});\n\nconst getChatActionsSchema = z.object({\n\tchatId: z.string().uuid(\"Invalid chat ID\"),\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nasync function getAuthenticatedUserWithCompany() {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tassertAuthenticated(user?.id);\n\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id, role\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t403,\n\t\t);\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\trole: teamMember.role,\n\t};\n}\n\n// ============================================================================\n// Server Actions\n// ============================================================================\n\n/**\n * Approve a pending AI action - OWNER ONLY\n * This action will be executed immediately after approval\n */\nexport async function approveAIAction(\n\tinput: z.infer<typeof approveActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = approveActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner (double-check even though DB function enforces this)\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can approve destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the approval function (which calls the DB RPC)\n\t\tconst result = await approveAction(validated.actionId, userId);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to approve action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Automatically execute the approved action\n\t\tlet executionResult: { success: boolean; result?: unknown; error?: string } | null = null;\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`${process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\"}/api/ai/execute-approved`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tactionId: validated.actionId,\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t);\n\t\t\texecutionResult = await response.json();\n\t\t} catch (execError) {\n\t\t\tconsole.error(\"Failed to auto-execute approved action:\", execError);\n\t\t\t// Don't fail the approval - execution can be retried\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: result.actionId,\n\t\t\ttoolName: result.toolName,\n\t\t\ttoolArgs: result.toolArgs,\n\t\t\texecuted: executionResult?.success || false,\n\t\t\texecutionResult: executionResult?.result,\n\t\t\texecutionError: executionResult?.error,\n\t\t};\n\t});\n}\n\n/**\n * Reject a pending AI action - OWNER ONLY\n * The AI will not execute this action\n */\nexport async function rejectAIAction(\n\tinput: z.infer<typeof rejectActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = rejectActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can reject destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the rejection function\n\t\tconst result = await rejectAction(\n\t\t\tvalidated.actionId,\n\t\t\tuserId,\n\t\t\tvalidated.reason,\n\t\t);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to reject action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: validated.actionId,\n\t\t};\n\t});\n}\n\n/**\n * Get all pending actions for the current company\n * Used by the owner dashboard to review pending approvals\n */\nexport async function getCompanyPendingActions(\n\tinput?: z.infer<typeof getPendingActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = input ? getPendingActionsSchema.parse(input) : { limit: 50 };\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: validated.status,\n\t\t\tlimit: validated.limit,\n\t\t});\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get pending actions for a specific chat session\n * Used to show approval banners in the AI chat\n */\nexport async function getChatPendingActions(\n\tinput: z.infer<typeof getChatActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = getChatActionsSchema.parse(input);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions for the chat\n\t\tconst actions = await getPendingActionsForChat(companyId, validated.chatId);\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get a specific pending action by ID\n */\nexport async function getPendingActionById(\n\tactionId: string,\n): Promise<ActionResult<PendingAction | null>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = z.string().uuid(\"Invalid action ID\").parse(actionId);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\tconst action = await getPendingAction(companyId, validated);\n\t\treturn action;\n\t});\n}\n\n/**\n * Check if current user is a company owner\n * Used by UI to determine if approval buttons should be enabled\n */\nexport async function checkIsCompanyOwner(): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\t\tconst isOwner = await isCompanyOwner(companyId, userId);\n\t\treturn isOwner;\n\t});\n}\n\n/**\n * Get pending action counts for notifications\n */\nexport async function getPendingActionCounts(): Promise<\n\tActionResult<{\n\t\ttotal: number;\n\t\tbyRiskLevel: Record<string, number>;\n\t}>\n> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: \"pending\",\n\t\t\tlimit: 100,\n\t\t});\n\n\t\t// Group by risk level\n\t\tconst byRiskLevel: Record<string, number> = {\n\t\t\tlow: 0,\n\t\t\tmedium: 0,\n\t\t\thigh: 0,\n\t\t\tcritical: 0,\n\t\t};\n\n\t\tfor (const action of actions) {\n\t\t\tbyRiskLevel[action.riskLevel] = (byRiskLevel[action.riskLevel] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: actions.length,\n\t\t\tbyRiskLevel,\n\t\t};\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAwOsB,2BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/ai-approval.ts"],"sourcesContent":["/**\n * AI Action Approval Server Actions\n *\n * Server actions for owner-only approval of destructive AI actions.\n * These actions wrap the action-approval service for use in React components.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tapproveAction,\n\trejectAction,\n\tgetPendingActionsForCompany,\n\tgetPendingActionsForChat,\n\tgetPendingAction,\n\tisCompanyOwner,\n\texpireOldActions,\n\ttype PendingAction,\n} from \"@/lib/ai/action-approval\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type { PendingAction };\n\nexport interface ApprovalActionResult {\n\tsuccess: boolean;\n\terror?: string;\n\tactionId?: string;\n\ttoolName?: string;\n\ttoolArgs?: Record<string, unknown>;\n\t// Execution fields (for approval responses)\n\texecuted?: boolean;\n\texecutionResult?: unknown;\n\texecutionError?: string;\n}\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst approveActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n});\n\nconst rejectActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n\treason: z.string().max(500, \"Reason too long\").optional(),\n});\n\nconst getPendingActionsSchema = z.object({\n\tstatus: z.enum([\"pending\", \"approved\", \"rejected\", \"expired\"]).optional(),\n\tlimit: z.number().min(1).max(100).default(50),\n});\n\nconst getChatActionsSchema = z.object({\n\tchatId: z.string().uuid(\"Invalid chat ID\"),\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nasync function getAuthenticatedUserWithCompany() {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tassertAuthenticated(user?.id);\n\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id, role\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t403,\n\t\t);\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\trole: teamMember.role,\n\t};\n}\n\n// ============================================================================\n// Server Actions\n// ============================================================================\n\n/**\n * Approve a pending AI action - OWNER ONLY\n * This action will be executed immediately after approval\n */\nexport async function approveAIAction(\n\tinput: z.infer<typeof approveActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = approveActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner (double-check even though DB function enforces this)\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can approve destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the approval function (which calls the DB RPC)\n\t\tconst result = await approveAction(validated.actionId, userId);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to approve action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Automatically execute the approved action\n\t\tlet executionResult: { success: boolean; result?: unknown; error?: string } | null = null;\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`${process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\"}/api/ai/execute-approved`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tactionId: validated.actionId,\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t);\n\t\t\texecutionResult = await response.json();\n\t\t} catch (execError) {\n\t\t\tconsole.error(\"Failed to auto-execute approved action:\", execError);\n\t\t\t// Don't fail the approval - execution can be retried\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: result.actionId,\n\t\t\ttoolName: result.toolName,\n\t\t\ttoolArgs: result.toolArgs,\n\t\t\texecuted: executionResult?.success || false,\n\t\t\texecutionResult: executionResult?.result,\n\t\t\texecutionError: executionResult?.error,\n\t\t};\n\t});\n}\n\n/**\n * Reject a pending AI action - OWNER ONLY\n * The AI will not execute this action\n */\nexport async function rejectAIAction(\n\tinput: z.infer<typeof rejectActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = rejectActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can reject destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the rejection function\n\t\tconst result = await rejectAction(\n\t\t\tvalidated.actionId,\n\t\t\tuserId,\n\t\t\tvalidated.reason,\n\t\t);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to reject action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: validated.actionId,\n\t\t};\n\t});\n}\n\n/**\n * Get all pending actions for the current company\n * Used by the owner dashboard to review pending approvals\n */\nexport async function getCompanyPendingActions(\n\tinput?: z.infer<typeof getPendingActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = input ? getPendingActionsSchema.parse(input) : { limit: 50 };\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: validated.status,\n\t\t\tlimit: validated.limit,\n\t\t});\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get pending actions for a specific chat session\n * Used to show approval banners in the AI chat\n */\nexport async function getChatPendingActions(\n\tinput: z.infer<typeof getChatActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = getChatActionsSchema.parse(input);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions for the chat\n\t\tconst actions = await getPendingActionsForChat(companyId, validated.chatId);\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get a specific pending action by ID\n */\nexport async function getPendingActionById(\n\tactionId: string,\n): Promise<ActionResult<PendingAction | null>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = z.string().uuid(\"Invalid action ID\").parse(actionId);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\tconst action = await getPendingAction(companyId, validated);\n\t\treturn action;\n\t});\n}\n\n/**\n * Check if current user is a company owner\n * Used by UI to determine if approval buttons should be enabled\n */\nexport async function checkIsCompanyOwner(): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\t\tconst isOwner = await isCompanyOwner(companyId, userId);\n\t\treturn isOwner;\n\t});\n}\n\n/**\n * Get pending action counts for notifications\n */\nexport async function getPendingActionCounts(): Promise<\n\tActionResult<{\n\t\ttotal: number;\n\t\tbyRiskLevel: Record<string, number>;\n\t}>\n> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: \"pending\",\n\t\t\tlimit: 100,\n\t\t});\n\n\t\t// Group by risk level\n\t\tconst byRiskLevel: Record<string, number> = {\n\t\t\tlow: 0,\n\t\t\tmedium: 0,\n\t\t\thigh: 0,\n\t\t\tcritical: 0,\n\t\t};\n\n\t\tfor (const action of actions) {\n\t\t\tbyRiskLevel[action.riskLevel] = (byRiskLevel[action.riskLevel] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: actions.length,\n\t\t\tbyRiskLevel,\n\t\t};\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAoSsB,sBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/support-sessions.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Support Session Actions for Web App\n *\n * Customer-facing actions for managing support access requests.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface SupportSession {\n\tid: string;\n\tadmin_user_id: string;\n\tticket_id: string | null;\n\treason: string;\n\trequested_at: string;\n\trequested_permissions: string[];\n\tadmin_name?: string;\n\tadmin_email?: string;\n}\n\n/**\n * Get pending support session requests for the current company\n */\nexport async function getPendingSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id from team_members\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query admin database for pending sessions\n\t\t// Note: This requires admin database access - we'll use a service role query\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\")\n\t\t\t.order(\"requested_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching pending sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// TODO: Enrich with admin user details from admin database\n\t\t// For now, return sessions without admin details\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getPendingSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get active support sessions for the current company\n */\nexport async function getActiveSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query for active sessions\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        approved_at,\n        expires_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"approved_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching active sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getActiveSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Approve a support session request\n */\nexport async function approveSupportSessionRequest(sessionId: string, durationMinutes: number = 60): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company for this session\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Call admin database to approve session\n\t\t// TODO: This should be a secure RPC call to admin database\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"active\",\n\t\t\t\tapproved_at: new Date().toISOString(),\n\t\t\t\tapproved_by: user.id,\n\t\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error approving session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in approveSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Reject a support session request\n */\nexport async function rejectSupportSessionRequest(sessionId: string, reason?: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Update session status\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\trejected_at: new Date().toISOString(),\n\t\t\t\trejected_by: user.id,\n\t\t\t\trejection_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error rejecting session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in rejectSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * End an active support session (customer-initiated)\n */\nexport async function endActiveSupportSession(sessionId: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// End the session\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"ended\",\n\t\t\t\tended_at: new Date().toISOString(),\n\t\t\t\tended_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error ending session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in endActiveSupportSession:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAyBsB,4BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/support-sessions.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Support Session Actions for Web App\n *\n * Customer-facing actions for managing support access requests.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface SupportSession {\n\tid: string;\n\tadmin_user_id: string;\n\tticket_id: string | null;\n\treason: string;\n\trequested_at: string;\n\trequested_permissions: string[];\n\tadmin_name?: string;\n\tadmin_email?: string;\n}\n\n/**\n * Get pending support session requests for the current company\n */\nexport async function getPendingSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id from team_members\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query admin database for pending sessions\n\t\t// Note: This requires admin database access - we'll use a service role query\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\")\n\t\t\t.order(\"requested_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching pending sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// TODO: Enrich with admin user details from admin database\n\t\t// For now, return sessions without admin details\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getPendingSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get active support sessions for the current company\n */\nexport async function getActiveSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query for active sessions\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        approved_at,\n        expires_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"approved_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching active sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getActiveSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Approve a support session request\n */\nexport async function approveSupportSessionRequest(sessionId: string, durationMinutes: number = 60): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company for this session\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Call admin database to approve session\n\t\t// TODO: This should be a secure RPC call to admin database\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"active\",\n\t\t\t\tapproved_at: new Date().toISOString(),\n\t\t\t\tapproved_by: user.id,\n\t\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error approving session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in approveSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Reject a support session request\n */\nexport async function rejectSupportSessionRequest(sessionId: string, reason?: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Update session status\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\trejected_at: new Date().toISOString(),\n\t\t\t\trejected_by: user.id,\n\t\t\t\trejection_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error rejecting session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in rejectSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * End an active support session (customer-initiated)\n */\nexport async function endActiveSupportSession(sessionId: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// End the session\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"ended\",\n\t\t\t\tended_at: new Date().toISOString(),\n\t\t\t\tended_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error ending session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in endActiveSupportSession:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA2FsB,2BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/support-sessions.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Support Session Actions for Web App\n *\n * Customer-facing actions for managing support access requests.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface SupportSession {\n\tid: string;\n\tadmin_user_id: string;\n\tticket_id: string | null;\n\treason: string;\n\trequested_at: string;\n\trequested_permissions: string[];\n\tadmin_name?: string;\n\tadmin_email?: string;\n}\n\n/**\n * Get pending support session requests for the current company\n */\nexport async function getPendingSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id from team_members\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query admin database for pending sessions\n\t\t// Note: This requires admin database access - we'll use a service role query\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\")\n\t\t\t.order(\"requested_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching pending sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// TODO: Enrich with admin user details from admin database\n\t\t// For now, return sessions without admin details\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getPendingSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get active support sessions for the current company\n */\nexport async function getActiveSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query for active sessions\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        approved_at,\n        expires_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"approved_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching active sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getActiveSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Approve a support session request\n */\nexport async function approveSupportSessionRequest(sessionId: string, durationMinutes: number = 60): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company for this session\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Call admin database to approve session\n\t\t// TODO: This should be a secure RPC call to admin database\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"active\",\n\t\t\t\tapproved_at: new Date().toISOString(),\n\t\t\t\tapproved_by: user.id,\n\t\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error approving session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in approveSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Reject a support session request\n */\nexport async function rejectSupportSessionRequest(sessionId: string, reason?: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Update session status\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\trejected_at: new Date().toISOString(),\n\t\t\t\trejected_by: user.id,\n\t\t\t\trejection_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error rejecting session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in rejectSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * End an active support session (customer-initiated)\n */\nexport async function endActiveSupportSession(sessionId: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// End the session\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"ended\",\n\t\t\t\tended_at: new Date().toISOString(),\n\t\t\t\tended_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error ending session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in endActiveSupportSession:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA4JsB,+BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/support-sessions.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Support Session Actions for Web App\n *\n * Customer-facing actions for managing support access requests.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface SupportSession {\n\tid: string;\n\tadmin_user_id: string;\n\tticket_id: string | null;\n\treason: string;\n\trequested_at: string;\n\trequested_permissions: string[];\n\tadmin_name?: string;\n\tadmin_email?: string;\n}\n\n/**\n * Get pending support session requests for the current company\n */\nexport async function getPendingSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id from team_members\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query admin database for pending sessions\n\t\t// Note: This requires admin database access - we'll use a service role query\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\")\n\t\t\t.order(\"requested_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching pending sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// TODO: Enrich with admin user details from admin database\n\t\t// For now, return sessions without admin details\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getPendingSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get active support sessions for the current company\n */\nexport async function getActiveSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query for active sessions\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        approved_at,\n        expires_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"approved_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching active sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getActiveSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Approve a support session request\n */\nexport async function approveSupportSessionRequest(sessionId: string, durationMinutes: number = 60): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company for this session\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Call admin database to approve session\n\t\t// TODO: This should be a secure RPC call to admin database\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"active\",\n\t\t\t\tapproved_at: new Date().toISOString(),\n\t\t\t\tapproved_by: user.id,\n\t\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error approving session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in approveSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Reject a support session request\n */\nexport async function rejectSupportSessionRequest(sessionId: string, reason?: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Update session status\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\trejected_at: new Date().toISOString(),\n\t\t\t\trejected_by: user.id,\n\t\t\t\trejection_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error rejecting session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in rejectSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * End an active support session (customer-initiated)\n */\nexport async function endActiveSupportSession(sessionId: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// End the session\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"ended\",\n\t\t\t\tended_at: new Date().toISOString(),\n\t\t\t\tended_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error ending session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in endActiveSupportSession:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAwNsB,8BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/support-sessions.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Support Session Actions for Web App\n *\n * Customer-facing actions for managing support access requests.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface SupportSession {\n\tid: string;\n\tadmin_user_id: string;\n\tticket_id: string | null;\n\treason: string;\n\trequested_at: string;\n\trequested_permissions: string[];\n\tadmin_name?: string;\n\tadmin_email?: string;\n}\n\n/**\n * Get pending support session requests for the current company\n */\nexport async function getPendingSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id from team_members\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query admin database for pending sessions\n\t\t// Note: This requires admin database access - we'll use a service role query\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\")\n\t\t\t.order(\"requested_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching pending sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// TODO: Enrich with admin user details from admin database\n\t\t// For now, return sessions without admin details\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getPendingSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get active support sessions for the current company\n */\nexport async function getActiveSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query for active sessions\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        approved_at,\n        expires_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"approved_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching active sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getActiveSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Approve a support session request\n */\nexport async function approveSupportSessionRequest(sessionId: string, durationMinutes: number = 60): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company for this session\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Call admin database to approve session\n\t\t// TODO: This should be a secure RPC call to admin database\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"active\",\n\t\t\t\tapproved_at: new Date().toISOString(),\n\t\t\t\tapproved_by: user.id,\n\t\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error approving session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in approveSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Reject a support session request\n */\nexport async function rejectSupportSessionRequest(sessionId: string, reason?: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Update session status\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\trejected_at: new Date().toISOString(),\n\t\t\t\trejected_by: user.id,\n\t\t\t\trejection_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error rejecting session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in rejectSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * End an active support session (customer-initiated)\n */\nexport async function endActiveSupportSession(sessionId: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// End the session\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"ended\",\n\t\t\t\tended_at: new Date().toISOString(),\n\t\t\t\tended_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error ending session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in endActiveSupportSession:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAgRsB,0BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}}]
}