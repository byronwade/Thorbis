{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/dialer-store.ts"],"sourcesContent":["import { create } from \"zustand\";\n\n/**\n * Dialer Store - Manages phone dialer state\n *\n * Allows programmatic control of the phone dropdown:\n * - Open dialer with pre-filled phone number\n * - Pre-select customer\n * - Keyboard shortcuts support\n */\n\ninterface DialerState {\n\tisOpen: boolean;\n\tphoneNumber: string;\n\tcustomerId: string | null;\n\tcustomerName: string | null;\n}\n\ninterface DialerActions {\n\topenDialer: (\n\t\tphoneNumber?: string,\n\t\tcustomerId?: string,\n\t\tcustomerName?: string,\n\t) => void;\n\tcloseDialer: () => void;\n\tsetPhoneNumber: (phoneNumber: string) => void;\n\treset: () => void;\n}\n\nexport type DialerStore = DialerState & DialerActions;\n\nconst initialState: DialerState = {\n\tisOpen: false,\n\tphoneNumber: \"\",\n\tcustomerId: null,\n\tcustomerName: null,\n};\n\nexport const useDialerStore = create<DialerStore>((set) => ({\n\t...initialState,\n\n\topenDialer: (phoneNumber = \"\", customerId = null, customerName = null) =>\n\t\tset({\n\t\t\tisOpen: true,\n\t\t\tphoneNumber,\n\t\t\tcustomerId,\n\t\t\tcustomerName,\n\t\t}),\n\n\tcloseDialer: () =>\n\t\tset({\n\t\t\tisOpen: false,\n\t\t}),\n\n\tsetPhoneNumber: (phoneNumber) =>\n\t\tset({\n\t\t\tphoneNumber,\n\t\t}),\n\n\treset: () => set(initialState),\n}));\n"],"names":[],"mappings":";;;;AAAA;;AA+BA,MAAM,eAA4B;IACjC,QAAQ;IACR,aAAa;IACb,YAAY;IACZ,cAAc;AACf;AAEO,MAAM,iBAAiB,IAAA,4VAAM,EAAc,CAAC,MAAQ,CAAC;QAC3D,GAAG,YAAY;QAEf,YAAY,CAAC,cAAc,EAAE,EAAE,aAAa,IAAI,EAAE,eAAe,IAAI,GACpE,IAAI;gBACH,QAAQ;gBACR;gBACA;gBACA;YACD;QAED,aAAa,IACZ,IAAI;gBACH,QAAQ;YACT;QAED,gBAAgB,CAAC,cAChB,IAAI;gBACH;YACD;QAED,OAAO,IAAM,IAAI;IAClB,CAAC"}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/notification-events.ts"],"sourcesContent":["export const COMMUNICATION_MARK_AS_READ_EVENT = \"communication:mark-as-read\";\n\nexport type CommunicationMarkAsReadDetail = {\n\tnotificationId: string;\n};\n"],"names":[],"mappings":";;;;AAAO,MAAM,mCAAmC"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/notifications-store.ts"],"sourcesContent":["/**\n * Notifications Store - Zustand State Management\n *\n * Performance optimizations:\n * - Lightweight state management with Zustand (no provider wrapper)\n * - Selective subscriptions prevent unnecessary re-renders\n * - Real-time updates via Supabase Realtime\n * - Optimistic updates for better UX\n * - Organized in /src/lib/stores/ directory\n *\n * Usage in components:\n * ```typescript\n * const notifications = useNotificationsStore((state) => state.notifications);\n * const unreadCount = useNotificationsStore((state) => state.unreadCount);\n * const markAsRead = useNotificationsStore((state) => state.markAsRead);\n * ```\n */\n\nimport type {\n\tRealtimeChannel,\n\tRealtimePostgresChangesPayload,\n} from \"@supabase/supabase-js\";\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport { createClient } from \"@/lib/supabase/client\";\nimport {\n\tCOMMUNICATION_MARK_AS_READ_EVENT,\n\ttype CommunicationMarkAsReadDetail,\n} from \"./notification-events\";\n\n// =====================================================================================\n// Types\n// =====================================================================================\n\n// Import and re-export shared types to maintain backward compatibility\nimport type {\n\tNotification,\n\tNotificationPriority,\n\tNotificationType,\n} from \"./notifications-types\";\n\nexport type { Notification, NotificationPriority, NotificationType };\n\ntype NotificationsState = {\n\t// State\n\tnotifications: Notification[];\n\tunreadCount: number;\n\tisLoading: boolean;\n\tisSubscribed: boolean;\n\terror: string | null;\n\trealtimeChannel: RealtimeChannel | null;\n\tsubscriptionPromise: Promise<void> | null; // Prevents race conditions\n\n\t// Actions\n\tsetNotifications: (notifications: Notification[]) => void;\n\taddNotification: (notification: Notification) => void;\n\tupdateNotification: (id: string, updates: Partial<Notification>) => void;\n\tremoveNotification: (id: string) => void;\n\tsetUnreadCount: (count: number) => void;\n\tsetLoading: (isLoading: boolean) => void;\n\tsetError: (error: string | null) => void;\n\n\t// Optimistic updates\n\toptimisticMarkAsRead: (id: string) => void;\n\toptimisticMarkAsUnread: (id: string) => void;\n\toptimisticMarkAllAsRead: () => void;\n\toptimisticDelete: (id: string) => void;\n\n\t// Realtime subscription management\n\tsubscribe: (userId: string) => Promise<void>;\n\tunsubscribe: () => void;\n\n\t// Utility\n\treset: () => void;\n};\n\n// Initial state\nconst initialState = {\n\tnotifications: [],\n\tunreadCount: 0,\n\tisLoading: false,\n\tisSubscribed: false,\n\terror: null,\n\trealtimeChannel: null,\n\tsubscriptionPromise: null,\n};\n\n// =====================================================================================\n// Zustand Store\n// =====================================================================================\n\nexport const useNotificationsStore = create<NotificationsState>()(\n\tdevtools(\n\t\t(set, get) => ({\n\t\t\t...initialState,\n\n\t\t\t// ===============================================================================\n\t\t\t// Basic State Setters\n\t\t\t// ===============================================================================\n\n\t\t\tsetNotifications: (notifications) => {\n\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\t\t\t\tset({ notifications, unreadCount });\n\t\t\t},\n\n\t\t\taddNotification: (notification) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst exists = state.notifications.some(\n\t\t\t\t\t\t(n) => n.id === notification.id,\n\t\t\t\t\t);\n\t\t\t\t\tif (exists) {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newNotifications = [notification, ...state.notifications];\n\t\t\t\t\tconst unreadCount = newNotifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnotifications: newNotifications,\n\t\t\t\t\t\tunreadCount,\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\tupdateNotification: (id, updates) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) =>\n\t\t\t\t\t\tn.id === id ? { ...n, ...updates } : n,\n\t\t\t\t\t);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\tremoveNotification: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.filter((n) => n.id !== id);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\tsetUnreadCount: (unreadCount) => set({ unreadCount }),\n\n\t\t\tsetLoading: (isLoading) => set({ isLoading }),\n\n\t\t\tsetError: (error) => set({ error }),\n\n\t\t\t// ===============================================================================\n\t\t\t// Optimistic Updates\n\t\t\t// ===============================================================================\n\n\t\t\toptimisticMarkAsRead: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) =>\n\t\t\t\t\t\tn.id === id\n\t\t\t\t\t\t\t? { ...n, read: true, read_at: new Date().toISOString() }\n\t\t\t\t\t\t\t: n,\n\t\t\t\t\t);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\toptimisticMarkAsUnread: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) =>\n\t\t\t\t\t\tn.id === id ? { ...n, read: false, read_at: null } : n,\n\t\t\t\t\t);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\toptimisticMarkAllAsRead: () =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) => ({\n\t\t\t\t\t\t...n,\n\t\t\t\t\t\tread: true,\n\t\t\t\t\t\tread_at: n.read_at || new Date().toISOString(),\n\t\t\t\t\t}));\n\n\t\t\t\t\treturn { notifications, unreadCount: 0 };\n\t\t\t\t}),\n\n\t\t\toptimisticDelete: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.filter((n) => n.id !== id);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\t// ===============================================================================\n\t\t\t// Realtime Subscription Management\n\t\t\t// ===============================================================================\n\n\t\t\tsubscribe: async (userId: string) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst state = get();\n\n\t\t\t\t\t// CRITICAL: Return existing promise if subscription is in progress\n\t\t\t\t\tif (state.subscriptionPromise) {\n\t\t\t\t\t\treturn state.subscriptionPromise;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't subscribe if already subscribed\n\t\t\t\t\tif (state.isSubscribed || state.realtimeChannel) {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create subscription promise BEFORE any async operations\n\t\t\t\t\tconst subscriptionPromise = (async () => {\n\t\t\t\t\t\t// CRITICAL FIX: Set flag immediately to prevent race condition\n\t\t\t\t\t\tset({ isSubscribed: true });\n\n\t\t\t\t\t\tconst supabase = createClient();\n\n\t\t\t\t\t\tif (!supabase) {\n\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create realtime channel for notifications\n\t\t\t\t\t\tconst channel = supabase\n\t\t\t\t\t\t\t.channel(\"notifications-changes\")\n\t\t\t\t\t\t\t.on(\n\t\t\t\t\t\t\t\t\"postgres_changes\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tevent: \"INSERT\",\n\t\t\t\t\t\t\t\t\tschema: \"public\",\n\t\t\t\t\t\t\t\t\ttable: \"notifications\",\n\t\t\t\t\t\t\t\t\tfilter: `user_id=eq.${userId}`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(payload: RealtimePostgresChangesPayload<Notification>) => {\n\t\t\t\t\t\t\t\t\t// New notification received\n\t\t\t\t\t\t\t\t\tif (payload.new) {\n\t\t\t\t\t\t\t\t\t\tconst notification = payload.new as Notification;\n\t\t\t\t\t\t\t\t\t\tget().addNotification(notification);\n\n\t\t\t\t\t\t\t\t\t\t// Show toast notification for communication events\n\t\t\t\t\t\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\t\t\t\t\t\t// Check if this is a communication-related notification\n\t\t\t\t\t\t\t\t\t\t\tconst isCommunication =\n\t\t\t\t\t\t\t\t\t\t\t\tnotification.metadata?.communication_id;\n\n\t\t\t\t\t\t\t\t\t\t\tif (isCommunication) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Use communication notifications store for toast\n\t\t\t\t\t\t\t\t\t\t\t\timport(\"./communication-notifications-store\").then(\n\t\t\t\t\t\t\t\t\t\t\t\t\t({ useCommunicationNotificationsStore }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuseCommunicationNotificationsStore\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getState()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.showCommunicationToast(notification);\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// Use standard notification handling for non-communication events\n\t\t\t\t\t\t\t\t\t\t\t\t// Play notification sound if enabled\n\t\t\t\t\t\t\t\t\t\t\t\tconst soundEnabled = localStorage.getItem(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"notifications_sound_enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tif (soundEnabled !== \"false\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Play a subtle notification sound\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst audio = new Audio(\"/sounds/notification.mp3\");\n\t\t\t\t\t\t\t\t\t\t\t\t\taudio.volume = 0.3;\n\t\t\t\t\t\t\t\t\t\t\t\t\taudio.play().catch(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Ignore errors (user hasn't interacted with page yet)\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Show desktop notification if enabled and permission granted\n\t\t\t\t\t\t\t\t\t\t\t\tconst desktopEnabled = localStorage.getItem(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"notifications_desktop_enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\tdesktopEnabled !== \"false\" &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Notification\" in window &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tNotification.permission === \"granted\"\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Notification(notification.title, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: notification.message,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ticon: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbadge: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttag: notification.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.on(\n\t\t\t\t\t\t\t\t\"postgres_changes\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tevent: \"UPDATE\",\n\t\t\t\t\t\t\t\t\tschema: \"public\",\n\t\t\t\t\t\t\t\t\ttable: \"notifications\",\n\t\t\t\t\t\t\t\t\tfilter: `user_id=eq.${userId}`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(payload: RealtimePostgresChangesPayload<Notification>) => {\n\t\t\t\t\t\t\t\t\t// Notification updated\n\t\t\t\t\t\t\t\t\tif (payload.new) {\n\t\t\t\t\t\t\t\t\t\tconst notification = payload.new as Notification;\n\t\t\t\t\t\t\t\t\t\tget().updateNotification(notification.id, notification);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.on(\n\t\t\t\t\t\t\t\t\"postgres_changes\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tevent: \"DELETE\",\n\t\t\t\t\t\t\t\t\tschema: \"public\",\n\t\t\t\t\t\t\t\t\ttable: \"notifications\",\n\t\t\t\t\t\t\t\t\tfilter: `user_id=eq.${userId}`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(payload: RealtimePostgresChangesPayload<Notification>) => {\n\t\t\t\t\t\t\t\t\t// Notification deleted\n\t\t\t\t\t\t\t\t\tif (payload.old) {\n\t\t\t\t\t\t\t\t\t\tget().removeNotification((payload.old as Notification).id);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.subscribe((status, _err) => {\n\t\t\t\t\t\t\t\tif (status === \"SUBSCRIBED\") {\n\t\t\t\t\t\t\t\t\tset({ error: null }); // Clear any previous errors\n\t\t\t\t\t\t\t\t} else if (status === \"CHANNEL_ERROR\") {\n\t\t\t\t\t\t\t\t\t// Don't set error state to avoid breaking the UI\n\t\t\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else if (status === \"TIMED_OUT\") {\n\t\t\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else if (status === \"CLOSED\") {\n\t\t\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tset({\n\t\t\t\t\t\t\trealtimeChannel: channel,\n\t\t\t\t\t\t\tsubscriptionPromise: null, // Clear promise when done\n\t\t\t\t\t\t});\n\t\t\t\t\t})(); // End of async IIFE\n\n\t\t\t\t\t// Set the promise immediately to prevent concurrent calls\n\t\t\t\t\tset({ subscriptionPromise });\n\t\t\t\t\treturn subscriptionPromise;\n\t\t\t\t} catch (_error) {\n\t\t\t\t\t// App will still work without realtime, so don't set error state\n\t\t\t\t\tset({\n\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\tsubscriptionPromise: null,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tunsubscribe: () => {\n\t\t\t\tconst state = get();\n\n\t\t\t\tif (state.realtimeChannel) {\n\t\t\t\t\tstate.realtimeChannel.unsubscribe();\n\t\t\t\t\tset({ realtimeChannel: null, isSubscribed: false });\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// ===============================================================================\n\t\t\t// Utility\n\t\t\t// ===============================================================================\n\n\t\t\treset: () => set(initialState),\n\t\t}),\n\t\t{ name: \"NotificationsStore\" },\n\t),\n);\n\nif (typeof window !== \"undefined\") {\n\twindow.addEventListener(COMMUNICATION_MARK_AS_READ_EVENT, (event: Event) => {\n\t\tconst { detail } = event as CustomEvent<CommunicationMarkAsReadDetail>;\n\t\tconst notificationId = detail?.notificationId;\n\n\t\tif (!notificationId) {\n\t\t\treturn;\n\t\t}\n\n\t\tuseNotificationsStore.getState().optimisticMarkAsRead(notificationId);\n\t});\n}\n\n// =====================================================================================\n// Selectors (for optimized re-renders)\n// =====================================================================================\n\n/**\n * Get only unread notifications\n */\nconst selectUnreadNotifications = (state: NotificationsState) =>\n\tstate.notifications.filter((n) => !n.read);\n\n/**\n * Get notifications by type\n */\nconst selectNotificationsByType =\n\t(type: NotificationType) => (state: NotificationsState) =>\n\t\tstate.notifications.filter((n) => n.type === type);\n\n/**\n * Get notifications by priority\n */\nconst selectNotificationsByPriority =\n\t(priority: NotificationPriority) => (state: NotificationsState) =>\n\t\tstate.notifications.filter((n) => n.priority === priority);\n\n/**\n * Get urgent unread notifications\n */\nconst selectUrgentUnreadNotifications = (state: NotificationsState) =>\n\tstate.notifications.filter((n) => !n.read && n.priority === \"urgent\");\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/sync-store.ts"],"sourcesContent":["/**\n * Sync Store - Global state management for sync operations\n *\n * Manages:\n * - Active sync operations (bulk send, data sync, etc.)\n * - Offline queue\n * - Real-time progress tracking\n * - Operation history\n */\n\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\n\nexport type SyncOperationType =\n\t| \"bulk_send_invoices\"\n\t| \"bulk_send_estimates\"\n\t| \"data_sync\"\n\t| \"offline_sync\"\n\t| \"file_upload\"\n\t| \"export\";\n\nexport type SyncOperationStatus =\n\t| \"pending\"\n\t| \"in_progress\"\n\t| \"completed\"\n\t| \"failed\"\n\t| \"queued\";\n\nexport type SyncOperation = {\n\tid: string;\n\ttype: SyncOperationType;\n\tstatus: SyncOperationStatus;\n\ttitle: string;\n\tdescription?: string;\n\tprogress: number; // 0-100\n\ttotal?: number;\n\tcurrent?: number;\n\tstartedAt: Date;\n\tcompletedAt?: Date;\n\terror?: string;\n\tmetadata?: Record<string, any>;\n};\n\nexport type OfflineOperation = {\n\tid: string;\n\ttype: SyncOperationType;\n\taction: string;\n\tpayload: any;\n\tcreatedAt: Date;\n\tretryCount: number;\n};\n\ntype SyncState = {\n\t// Active operations\n\toperations: SyncOperation[];\n\n\t// Offline queue\n\tofflineQueue: OfflineOperation[];\n\tisOnline: boolean;\n\n\t// UI state\n\tisPanelOpen: boolean;\n\n\t// Actions\n\tstartOperation: (\n\t\toperation: Omit<SyncOperation, \"id\" | \"startedAt\" | \"progress\" | \"status\">,\n\t) => string;\n\tupdateOperation: (id: string, updates: Partial<SyncOperation>) => void;\n\tcompleteOperation: (id: string, success: boolean, error?: string) => void;\n\tremoveOperation: (id: string) => void;\n\tclearCompleted: () => void;\n\n\t// Offline queue actions\n\tqueueOperation: (\n\t\toperation: Omit<OfflineOperation, \"id\" | \"createdAt\" | \"retryCount\">,\n\t) => void;\n\tremoveFromQueue: (id: string) => void;\n\tclearQueue: () => void;\n\tsetOnlineStatus: (isOnline: boolean) => void;\n\n\t// UI actions\n\ttogglePanel: () => void;\n\topenPanel: () => void;\n\tclosePanel: () => void;\n};\n\nexport const useSyncStore = create<SyncState>()(\n\tpersist(\n\t\t(set, get) => ({\n\t\t\toperations: [],\n\t\t\tofflineQueue: [],\n\t\t\tisOnline: typeof navigator !== \"undefined\" ? navigator.onLine : true,\n\t\t\tisPanelOpen: false,\n\n\t\t\tstartOperation: (operation) => {\n\t\t\t\tconst id = `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\t\t\t\tconst newOperation: SyncOperation = {\n\t\t\t\t\t...operation,\n\t\t\t\t\tid,\n\t\t\t\t\tstatus: \"in_progress\",\n\t\t\t\t\tprogress: 0,\n\t\t\t\t\tstartedAt: new Date(),\n\t\t\t\t};\n\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: [...state.operations, newOperation],\n\t\t\t\t}));\n\n\t\t\t\treturn id;\n\t\t\t},\n\n\t\t\tupdateOperation: (id, updates) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.map((op) =>\n\t\t\t\t\t\top.id === id ? { ...op, ...updates } : op,\n\t\t\t\t\t),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tcompleteOperation: (id, success, error) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.map((op) =>\n\t\t\t\t\t\top.id === id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...op,\n\t\t\t\t\t\t\t\t\tstatus: success ? \"completed\" : \"failed\",\n\t\t\t\t\t\t\t\t\tprogress: success ? 100 : op.progress,\n\t\t\t\t\t\t\t\t\tcompletedAt: new Date(),\n\t\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: op,\n\t\t\t\t\t),\n\t\t\t\t}));\n\n\t\t\t\t// Auto-remove completed operations after 10 seconds\n\t\t\t\tif (success) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tget().removeOperation(id);\n\t\t\t\t\t}, 10_000);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremoveOperation: (id) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.filter((op) => op.id !== id),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tclearCompleted: () => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.filter(\n\t\t\t\t\t\t(op) => op.status !== \"completed\" && op.status !== \"failed\",\n\t\t\t\t\t),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tqueueOperation: (operation) => {\n\t\t\t\tconst id = `queue_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\t\t\t\tconst queuedOp: OfflineOperation = {\n\t\t\t\t\t...operation,\n\t\t\t\t\tid,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tretryCount: 0,\n\t\t\t\t};\n\n\t\t\t\tset((state) => ({\n\t\t\t\t\tofflineQueue: [...state.offlineQueue, queuedOp],\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tremoveFromQueue: (id) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\tofflineQueue: state.offlineQueue.filter((op) => op.id !== id),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tclearQueue: () => {\n\t\t\t\tset({ offlineQueue: [] });\n\t\t\t},\n\n\t\t\tsetOnlineStatus: (isOnline) => {\n\t\t\t\tset({ isOnline });\n\t\t\t},\n\n\t\t\ttogglePanel: () => {\n\t\t\t\tset((state) => ({ isPanelOpen: !state.isPanelOpen }));\n\t\t\t},\n\n\t\t\topenPanel: () => {\n\t\t\t\tset({ isPanelOpen: true });\n\t\t\t},\n\n\t\t\tclosePanel: () => {\n\t\t\t\tset({ isPanelOpen: false });\n\t\t\t},\n\t\t}),\n\t\t{\n\t\t\tname: \"thorbis-sync-store\",\n\t\t\tskipHydration: true, // CRITICAL: Prevents hydration mismatch with Next.js 16\n\t\t\tpartialize: (state) => ({\n\t\t\t\tofflineQueue: state.offlineQueue,\n\t\t\t\t// Don't persist operations or UI state\n\t\t\t}),\n\t\t},\n\t),\n);\n\n// Hook to get active operations count\nconst useActiveOperationsCount = () =>\n\tuseSyncStore(\n\t\t(state) =>\n\t\t\tstate.operations.filter((op) => op.status === \"in_progress\").length,\n\t);\n\n// Hook to get queued operations count\nconst useQueuedOperationsCount = () =>\n\tuseSyncStore((state) => state.offlineQueue.length);\n\n// Hook to get if syncing\nconst useIsSyncing = () =>\n\tuseSyncStore((state) =>\n\t\tstate.operations.some((op) => op.status === \"in_progress\"),\n\t);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/telnyx/web-credentials-client.ts"],"sourcesContent":["\"use client\";\n\nimport { getWebRTCCredentials } from \"@/actions/telnyx\";\n\ntype WebRTCCredentialsResult = Awaited<ReturnType<typeof getWebRTCCredentials>>;\ntype Credential = NonNullable<WebRTCCredentialsResult[\"credential\"]>;\n\nconst STORAGE_KEY = \"telnyx-webrtc-credential\";\n// Refresh 5 minutes before expiration (Telnyx recommended buffer)\n// This prevents credential expiry during active calls\nconst EXPIRY_BUFFER_MS = 5 * 60 * 1000;\n\nlet credentialsPromise: Promise<WebRTCCredentialsResult> | null = null;\n\nfunction getExpiresAtMs(expiresAt: Credential[\"expires_at\"]): number | null {\n\tif (typeof expiresAt === \"number\") {\n\t\treturn expiresAt;\n\t}\n\tif (typeof expiresAt === \"string\") {\n\t\tconst parsed = Date.parse(expiresAt);\n\t\treturn Number.isNaN(parsed) ? null : parsed;\n\t}\n\treturn null;\n}\n\nfunction loadFromStorage(): Credential | null {\n\tif (typeof window === \"undefined\") {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst raw = window.localStorage.getItem(STORAGE_KEY);\n\t\tif (!raw) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst parsed = JSON.parse(raw) as { credential?: Credential } | null;\n\t\tif (!parsed?.credential) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst expiresAtMs = getExpiresAtMs(parsed.credential.expires_at);\n\t\tif (!expiresAtMs || expiresAtMs - EXPIRY_BUFFER_MS <= Date.now()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn parsed.credential;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nfunction persistCredential(credential: Credential) {\n\tif (typeof window === \"undefined\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\twindow.localStorage.setItem(\n\t\t\tSTORAGE_KEY,\n\t\t\tJSON.stringify({\n\t\t\t\tcredential,\n\t\t\t}),\n\t\t);\n\t} catch {\n\t\t// Ignore storage errors (e.g., Safari private mode)\n\t}\n}\n\nfunction createPromise() {\n\tconst cached = loadFromStorage();\n\tif (cached) {\n\t\tconsole.log(\"ðŸ”‘ Using cached WebRTC credentials:\", {\n\t\t\tusername: cached.username,\n\t\t\texpiresAt: new Date(cached.expires_at).toISOString(),\n\t\t\tisExpired: cached.expires_at <= Date.now(),\n\t\t});\n\t\tconst cachedResult: WebRTCCredentialsResult = {\n\t\t\tsuccess: true,\n\t\t\tcredential: cached,\n\t\t};\n\t\tconst promise = Promise.resolve(cachedResult);\n\t\tcredentialsPromise = promise;\n\t\treturn promise;\n\t}\n\n\tconsole.log(\"ðŸ”‘ Fetching WebRTC credentials from server...\");\n\tconst promise = getWebRTCCredentials()\n\t\t.then((result) => {\n\t\t\tconsole.log(\"ðŸ”‘ WebRTC credentials response:\", result);\n\t\t\tif (result?.success && result.credential) {\n\t\t\t\tconsole.log(\"ðŸ”‘ Persisting new credentials to localStorage\");\n\t\t\t\tpersistCredential(result.credential);\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"ðŸ”‘ Failed to get credentials, clearing cache\");\n\t\t\t\tcredentialsPromise = null;\n\t\t\t}\n\t\t\treturn result;\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error(\"ðŸ”‘ WebRTC credentials fetch error:\", error);\n\t\t\tcredentialsPromise = null;\n\t\t\tthrow error;\n\t\t});\n\n\tcredentialsPromise = promise;\n\treturn promise;\n}\n\nexport function fetchWebRTCCredentialsOnce() {\n\treturn credentialsPromise ?? createPromise();\n}\n\nexport function resetWebRTCCredentialsCache() {\n\tcredentialsPromise = null;\n\tif (typeof window !== \"undefined\") {\n\t\ttry {\n\t\t\twindow.localStorage.removeItem(STORAGE_KEY);\n\t\t} catch {\n\t\t\t// Ignore storage removal errors\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;;AAEA;AAFA;;AAOA,MAAM,cAAc;AACpB,kEAAkE;AAClE,sDAAsD;AACtD,MAAM,mBAAmB,IAAI,KAAK;AAElC,IAAI,qBAA8D;AAElE,SAAS,eAAe,SAAmC;IAC1D,IAAI,OAAO,cAAc,UAAU;QAClC,OAAO;IACR;IACA,IAAI,OAAO,cAAc,UAAU;QAClC,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,OAAO,OAAO,KAAK,CAAC,UAAU,OAAO;IACtC;IACA,OAAO;AACR;AAEA,SAAS;IACR,wCAAmC;QAClC,OAAO;IACR;;;AAsBD;AAEA,SAAS,kBAAkB,UAAsB;IAChD,wCAAmC;QAClC;IACD;;;AAYD;AAEA,SAAS;IACR,MAAM,SAAS;IACf,IAAI,QAAQ;QACX,QAAQ,GAAG,CAAC,uCAAuC;YAClD,UAAU,OAAO,QAAQ;YACzB,WAAW,IAAI,KAAK,OAAO,UAAU,EAAE,WAAW;YAClD,WAAW,OAAO,UAAU,IAAI,KAAK,GAAG;QACzC;QACA,MAAM,eAAwC;YAC7C,SAAS;YACT,YAAY;QACb;QACA,MAAM,UAAU,QAAQ,OAAO,CAAC;QAChC,qBAAqB;QACrB,OAAO;IACR;IAEA,QAAQ,GAAG,CAAC;IACZ,MAAM,UAAU,IAAA,6LAAoB,IAClC,IAAI,CAAC,CAAC;QACN,QAAQ,GAAG,CAAC,mCAAmC;QAC/C,IAAI,QAAQ,WAAW,OAAO,UAAU,EAAE;YACzC,QAAQ,GAAG,CAAC;YACZ,kBAAkB,OAAO,UAAU;QACpC,OAAO;YACN,QAAQ,IAAI,CAAC;YACb,qBAAqB;QACtB;QACA,OAAO;IACR,GACC,KAAK,CAAC,CAAC;QACP,QAAQ,KAAK,CAAC,sCAAsC;QACpD,qBAAqB;QACrB,MAAM;IACP;IAED,qBAAqB;IACrB,OAAO;AACR;AAEO,SAAS;IACf,OAAO,sBAAsB;AAC9B;AAEO,SAAS;IACf,qBAAqB;IACrB;;AAOD"}},
    {"offset": {"line": 547, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACzC,OAAO,IAAA,oOAAO,EAAC,IAAA,8LAAI,EAAC;AACrB"}},
    {"offset": {"line": 562, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/communication-notifications-store.ts"],"sourcesContent":["/**\n * Communication Notifications Store - Zustand State Management\n *\n * Handles real-time toast notifications for:\n * - Phone calls (incoming, missed, completed)\n * - Voicemails (new messages)\n * - Text messages/SMS (incoming)\n * - Emails (incoming)\n *\n * Performance optimizations:\n * - Lightweight state management with Zustand\n * - Automatic toast display on new communications\n * - Integrated with existing notifications system\n * - Sound and desktop notification support\n */\n\nimport { toast } from \"sonner\";\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport {\n\tCOMMUNICATION_MARK_AS_READ_EVENT,\n\ttype CommunicationMarkAsReadDetail,\n} from \"./notification-events\";\nimport type { Notification } from \"./notifications-types\";\n\n// =====================================================================================\n// Types\n// =====================================================================================\n\nexport type CommunicationType = \"call\" | \"sms\" | \"email\" | \"voicemail\";\n\nexport type CommunicationToastOptions = {\n\tid?: string;\n\tduration?: number;\n\tcloseButton?: boolean;\n\tdismissible?: boolean;\n\taction?: {\n\t\tlabel: string;\n\t\tonClick: () => void;\n\t};\n};\n\ntype CommunicationNotificationsState = {\n\t// State\n\ttoastQueue: string[]; // Track active toast IDs\n\tsoundEnabled: boolean;\n\tdesktopNotificationsEnabled: boolean;\n\ttoastDuration: number;\n\n\t// Actions\n\tshowCommunicationToast: (\n\t\tnotification: Notification,\n\t\toptions?: CommunicationToastOptions,\n\t) => string | number;\n\tshowCallToast: (\n\t\tcustomerName: string,\n\t\tphoneNumber: string,\n\t\tstatus: \"incoming\" | \"missed\" | \"completed\",\n\t\tmetadata?: Record<string, any>,\n\t) => void;\n\tshowVoicemailToast: (\n\t\tcustomerName: string,\n\t\tphoneNumber: string,\n\t\tduration?: number,\n\t) => void;\n\tshowSMSToast: (\n\t\tcustomerName: string,\n\t\tphoneNumber: string,\n\t\tmessage: string,\n\t) => void;\n\tshowEmailToast: (\n\t\tcustomerName: string,\n\t\tfromAddress: string,\n\t\tsubject: string,\n\t) => void;\n\tdismissToast: (id: string | number) => void;\n\tdismissAllToasts: () => void;\n\n\t// Settings\n\tsetSoundEnabled: (enabled: boolean) => void;\n\tsetDesktopNotificationsEnabled: (enabled: boolean) => void;\n\tsetToastDuration: (duration: number) => void;\n\n\t// Utility\n\tplayNotificationSound: () => void;\n\trequestDesktopNotificationPermission: () => Promise<boolean>;\n\tshowDesktopNotification: (\n\t\ttitle: string,\n\t\tbody: string,\n\t\tdata?: Record<string, any>,\n\t) => void;\n};\n\n// Initial state (load from localStorage if available)\nconst loadSettings = () => {\n\tif (typeof window === \"undefined\") {\n\t\treturn {\n\t\t\tsoundEnabled: true,\n\t\t\tdesktopNotificationsEnabled: true,\n\t\t\ttoastDuration: 5000,\n\t\t};\n\t}\n\n\treturn {\n\t\tsoundEnabled:\n\t\t\tlocalStorage.getItem(\"communication_sound_enabled\") !== \"false\",\n\t\tdesktopNotificationsEnabled:\n\t\t\tlocalStorage.getItem(\"communication_desktop_enabled\") !== \"false\",\n\t\ttoastDuration: Number.parseInt(\n\t\t\tlocalStorage.getItem(\"communication_toast_duration\") || \"5000\",\n\t\t\t10,\n\t\t),\n\t};\n};\n\n// =====================================================================================\n// Zustand Store\n// =====================================================================================\n\nexport const useCommunicationNotificationsStore =\n\tcreate<CommunicationNotificationsState>()(\n\t\tdevtools(\n\t\t\t(set, get) => ({\n\t\t\t\t...loadSettings(),\n\t\t\t\ttoastQueue: [],\n\n\t\t\t\t// ===============================================================================\n\t\t\t\t// Toast Display\n\t\t\t\t// ===============================================================================\n\n\t\t\t\tshowCommunicationToast: (notification, options = {}) => {\n\t\t\t\t\tconst { metadata } = notification;\n\t\t\t\t\tconst communicationType = metadata?.communication_type as\n\t\t\t\t\t\t| CommunicationType\n\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\t// Determine toast appearance based on communication type\n\t\t\t\t\tlet icon = \"ðŸ“©\"; // Default\n\t\t\t\t\tlet _toastType: \"info\" | \"success\" | \"error\" = \"info\";\n\n\t\t\t\t\tswitch (communicationType) {\n\t\t\t\t\t\tcase \"call\":\n\t\t\t\t\t\t\ticon = \"ðŸ“ž\";\n\t\t\t\t\t\t\tif (notification.priority === \"high\") {\n\t\t\t\t\t\t\t\ticon = \"ðŸ“µ\"; // Missed call\n\t\t\t\t\t\t\t\t_toastType = \"error\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"sms\":\n\t\t\t\t\t\t\ticon = \"ðŸ’¬\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"email\":\n\t\t\t\t\t\t\ticon = \"ðŸ“§\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"voicemail\":\n\t\t\t\t\t\t\ticon = \"ðŸŽ™ï¸\";\n\t\t\t\t\t\t\tif (notification.priority === \"urgent\") {\n\t\t\t\t\t\t\t\t_toastType = \"error\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Play sound if enabled\n\t\t\t\t\tconst { soundEnabled } = get();\n\t\t\t\t\tif (soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Show desktop notification if enabled\n\t\t\t\t\tconst { desktopNotificationsEnabled } = get();\n\t\t\t\t\tif (desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(\n\t\t\t\t\t\t\tnotification.title,\n\t\t\t\t\t\t\tnotification.message,\n\t\t\t\t\t\t\tmetadata ?? undefined,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create toast with custom styling\n\t\t\t\t\tconst toastId = toast(notification.title, {\n\t\t\t\t\t\tdescription: notification.message,\n\t\t\t\t\t\tduration: options.duration || get().toastDuration,\n\t\t\t\t\t\ticon,\n\t\t\t\t\t\tcloseButton: options.closeButton ?? true,\n\t\t\t\t\t\tdismissible: options.dismissible ?? true,\n\t\t\t\t\t\taction: notification.action_url\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tlabel: notification.action_label || \"View\",\n\t\t\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\t\t\t\t\t\tconst detail: CommunicationMarkAsReadDetail = {\n\t\t\t\t\t\t\t\t\t\t\t\tnotificationId: notification.id,\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\t\t\t\t\t\t\t\tnew CustomEvent(COMMUNICATION_MARK_AS_READ_EVENT, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdetail,\n\t\t\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (notification.action_url) {\n\t\t\t\t\t\t\t\t\t\t\twindow.location.href = notification.action_url;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: options.action,\n\t\t\t\t\t\tclassName:\n\t\t\t\t\t\t\tnotification.priority === \"urgent\"\n\t\t\t\t\t\t\t\t? \"border-destructive bg-destructive/10\"\n\t\t\t\t\t\t\t\t: \"\",\n\t\t\t\t\t});\n\n\t\t\t\t\t// Track toast ID\n\t\t\t\t\tset((state) => ({\n\t\t\t\t\t\ttoastQueue: [...state.toastQueue, String(toastId)],\n\t\t\t\t\t}));\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowCallToast: (customerName, phoneNumber, status, metadata = {}) => {\n\t\t\t\t\tlet title = \"\";\n\t\t\t\t\tlet message = \"\";\n\t\t\t\t\tlet _priority: \"low\" | \"medium\" | \"high\" = \"medium\";\n\t\t\t\t\tlet icon = \"ðŸ“ž\";\n\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase \"incoming\":\n\t\t\t\t\t\t\ttitle = `Incoming call from ${customerName}`;\n\t\t\t\t\t\t\tmessage = phoneNumber;\n\t\t\t\t\t\t\t_priority = \"high\";\n\t\t\t\t\t\t\ticon = \"ðŸ“ž\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"missed\":\n\t\t\t\t\t\t\ttitle = `Missed call from ${customerName}`;\n\t\t\t\t\t\t\tmessage = phoneNumber;\n\t\t\t\t\t\t\t_priority = \"high\";\n\t\t\t\t\t\t\ticon = \"ðŸ“µ\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"completed\":\n\t\t\t\t\t\t\ttitle = `Call with ${customerName}`;\n\t\t\t\t\t\t\tmessage = `Duration: ${metadata.duration || \"Unknown\"}`;\n\t\t\t\t\t\t\t_priority = \"low\";\n\t\t\t\t\t\t\ticon = \"âœ…\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: message,\n\t\t\t\t\t\ticon,\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"View\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=calls\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclassName: status === \"missed\" ? \"border-destructive\" : \"\",\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, message, {\n\t\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t\t...metadata,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowVoicemailToast: (customerName, phoneNumber, duration) => {\n\t\t\t\t\tconst title = `New voicemail from ${customerName}`;\n\t\t\t\t\tconst message = duration\n\t\t\t\t\t\t? `${phoneNumber} â€¢ ${duration}s`\n\t\t\t\t\t\t: phoneNumber;\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: message,\n\t\t\t\t\t\ticon: \"ðŸŽ™ï¸\",\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"Listen\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=voicemails\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, message, {\n\t\t\t\t\t\t\ttype: \"voicemail\",\n\t\t\t\t\t\t\tduration,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowSMSToast: (customerName, phoneNumber, message) => {\n\t\t\t\t\tconst title = `Text from ${customerName}`;\n\t\t\t\t\tconst preview =\n\t\t\t\t\t\tmessage.length > 100 ? `${message.substring(0, 100)}...` : message;\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: preview,\n\t\t\t\t\t\ticon: \"ðŸ’¬\",\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"Reply\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=sms\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, preview, {\n\t\t\t\t\t\t\ttype: \"sms\",\n\t\t\t\t\t\t\tfrom: phoneNumber,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowEmailToast: (customerName, fromAddress, subject) => {\n\t\t\t\t\tconst title = `Email from ${customerName}`;\n\t\t\t\t\tconst message = subject || \"No subject\";\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: message,\n\t\t\t\t\t\ticon: \"ðŸ“§\",\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"View\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=emails\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, message, {\n\t\t\t\t\t\t\ttype: \"email\",\n\t\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tdismissToast: (id) => {\n\t\t\t\t\ttoast.dismiss(id);\n\t\t\t\t\tset((state) => ({\n\t\t\t\t\t\ttoastQueue: state.toastQueue.filter(\n\t\t\t\t\t\t\t(toastId) => toastId !== String(id),\n\t\t\t\t\t\t),\n\t\t\t\t\t}));\n\t\t\t\t},\n\n\t\t\t\tdismissAllToasts: () => {\n\t\t\t\t\ttoast.dismiss();\n\t\t\t\t\tset({ toastQueue: [] });\n\t\t\t\t},\n\n\t\t\t\t// ===============================================================================\n\t\t\t\t// Settings\n\t\t\t\t// ===============================================================================\n\n\t\t\t\tsetSoundEnabled: (enabled) => {\n\t\t\t\t\tset({ soundEnabled: enabled });\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t\t\"communication_sound_enabled\",\n\t\t\t\t\t\t\tenabled.toString(),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetDesktopNotificationsEnabled: (enabled) => {\n\t\t\t\t\tset({ desktopNotificationsEnabled: enabled });\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t\t\"communication_desktop_enabled\",\n\t\t\t\t\t\t\tenabled.toString(),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Request permission if enabling\n\t\t\t\t\tif (enabled) {\n\t\t\t\t\t\tget().requestDesktopNotificationPermission();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetToastDuration: (duration) => {\n\t\t\t\t\tset({ toastDuration: duration });\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t\t\"communication_toast_duration\",\n\t\t\t\t\t\t\tduration.toString(),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// ===============================================================================\n\t\t\t\t// Utility\n\t\t\t\t// ===============================================================================\n\n\t\t\t\tplayNotificationSound: () => {\n\t\t\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Create audio element for notification sound\n\t\t\t\t\t\tconst audio = new Audio(\"/sounds/notification.mp3\");\n\t\t\t\t\t\taudio.volume = 0.4;\n\t\t\t\t\t\taudio.play().catch((_error) => {});\n\t\t\t\t\t} catch (_error) {}\n\t\t\t\t},\n\n\t\t\t\trequestDesktopNotificationPermission: async () => {\n\t\t\t\t\tif (typeof window === \"undefined\" || !(\"Notification\" in window)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission === \"granted\") {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission !== \"denied\") {\n\t\t\t\t\t\tconst permission = await Notification.requestPermission();\n\t\t\t\t\t\treturn permission === \"granted\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\tshowDesktopNotification: (title, body, data = {}) => {\n\t\t\t\t\tif (typeof window === \"undefined\" || !(\"Notification\" in window)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission !== \"granted\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst notification = new Notification(title, {\n\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t\ticon: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\tbadge: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\ttag: `communication-${data.type || \"general\"}`,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\trequireInteraction:\n\t\t\t\t\t\t\t\tdata.type === \"call\" && data.status === \"incoming\",\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Handle notification click\n\t\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\t\twindow.focus();\n\t\t\t\t\t\t\tif (data.action_url) {\n\t\t\t\t\t\t\t\twindow.location.href = data.action_url;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (_error) {}\n\t\t\t\t},\n\t\t\t}),\n\t\t\t{ name: \"CommunicationNotificationsStore\" },\n\t\t),\n\t);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-dialer-shortcut.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useDialerStore } from \"@/lib/stores/dialer-store\";\n\n/**\n * Global keyboard shortcut hook for the phone dialer\n *\n * Listens for Ctrl+Shift+D (or Cmd+Shift+D on Mac) to toggle the dialer\n *\n * Usage: Call this hook once in a layout component\n */\nexport function useDialerShortcut() {\n\tconst openDialer = useDialerStore((state) => state.openDialer);\n\tconst closeDialer = useDialerStore((state) => state.closeDialer);\n\tconst isOpen = useDialerStore((state) => state.isOpen);\n\n\tuseEffect(() => {\n\t\tconst handleKeyDown = (event: KeyboardEvent) => {\n\t\t\t// Check for Ctrl+Shift+D (Windows/Linux) or Cmd+Shift+D (Mac)\n\t\t\tif (\n\t\t\t\t(event.ctrlKey || event.metaKey) &&\n\t\t\t\tevent.shiftKey &&\n\t\t\t\tevent.key === \"D\"\n\t\t\t) {\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\t// Toggle dialer\n\t\t\t\tif (isOpen) {\n\t\t\t\t\tcloseDialer();\n\t\t\t\t} else {\n\t\t\t\t\topenDialer();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"keydown\", handleKeyDown);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"keydown\", handleKeyDown);\n\t\t};\n\t}, [openDialer, closeDialer, isOpen]);\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAYO,SAAS;IACf,MAAM,aAAa,IAAA,wKAAc,EAAC,CAAC,QAAU,MAAM,UAAU;IAC7D,MAAM,cAAc,IAAA,wKAAc,EAAC,CAAC,QAAU,MAAM,WAAW;IAC/D,MAAM,SAAS,IAAA,wKAAc,EAAC,CAAC,QAAU,MAAM,MAAM;IAErD,IAAA,yXAAS,EAAC;QACT,MAAM,gBAAgB,CAAC;YACtB,8DAA8D;YAC9D,IACC,CAAC,MAAM,OAAO,IAAI,MAAM,OAAO,KAC/B,MAAM,QAAQ,IACd,MAAM,GAAG,KAAK,KACb;gBACD,MAAM,cAAc;gBAEpB,gBAAgB;gBAChB,IAAI,QAAQ;oBACX;gBACD,OAAO;oBACN;gBACD;YACD;QACD;QAEA,OAAO,gBAAgB,CAAC,WAAW;QAEnC,OAAO;YACN,OAAO,mBAAmB,CAAC,WAAW;QACvC;IACD,GAAG;QAAC;QAAY;QAAa;KAAO;AACrC"}},
    {"offset": {"line": 909, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-dialer-customers.ts"],"sourcesContent":["/**\n * Dialer Customers Hook - Client-Side Lazy Loading\n *\n * PERFORMANCE CRITICAL:\n * Previously, AppHeader fetched ALL customers on EVERY page load (~400-800ms).\n * Now customers are only fetched when the dialer is opened.\n *\n * Features:\n * - Lazy load on first dialer open\n * - 5-minute cache in memory\n * - No server-side overhead on page loads\n *\n * Expected savings: 400-800ms per page load\n */\n\nimport { useEffect, useState } from \"react\";\n\ntype DialerCustomer = {\n\tid: string;\n\tfirst_name: string | null;\n\tlast_name: string | null;\n\tdisplay_name: string | null;\n\temail: string | null;\n\tphone: string | null;\n\tcompany_name: string | null;\n\tsecondary_phone?: string | null;\n\taddress: string | null;\n\taddress2: string | null;\n\tcity: string | null;\n\tstate: string | null;\n\tzip_code: string | null;\n};\n\n// In-memory cache with 5-minute TTL\nlet cachedCustomers: DialerCustomer[] | null = null;\nlet cacheTimestamp = 0;\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport function useDialerCustomers(shouldFetch = false) {\n\tconst [customers, setCustomers] = useState<DialerCustomer[]>([]);\n\tconst [isLoading, setIsLoading] = useState(false);\n\tconst [error, setError] = useState<string | null>(null);\n\n\tuseEffect(() => {\n\t\t// Only fetch if explicitly requested (e.g., dialer opened)\n\t\tif (!shouldFetch) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Serve from cache when available\n\t\tconst now = Date.now();\n\t\tif (cachedCustomers && now - cacheTimestamp < CACHE_TTL) {\n\t\t\tsetCustomers(cachedCustomers);\n\t\t\treturn;\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\tconst fetchCustomers = async () => {\n\t\t\tsetIsLoading(true);\n\t\t\tsetError(null);\n\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(\"/api/dialer/customers\", {\n\t\t\t\t\tsignal: controller.signal,\n\t\t\t\t\tcache: \"no-store\",\n\t\t\t\t});\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tconst payload = await response.json().catch(() => ({}));\n\t\t\t\t\tthrow new Error(payload.error || \"Failed to load customers\");\n\t\t\t\t}\n\n\t\t\t\tconst payload = (await response.json()) as {\n\t\t\t\t\tcustomers: DialerCustomer[];\n\t\t\t\t};\n\t\t\t\tcachedCustomers = payload.customers;\n\t\t\t\tcacheTimestamp = Date.now();\n\t\t\t\tsetCustomers(payload.customers);\n\t\t\t} catch (err) {\n\t\t\t\tif (controller.signal.aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetError(\n\t\t\t\t\terr instanceof Error ? err.message : \"Failed to load customers\",\n\t\t\t\t);\n\t\t\t} finally {\n\t\t\t\tif (!controller.signal.aborted) {\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfetchCustomers();\n\n\t\treturn () => {\n\t\t\tcontroller.abort();\n\t\t};\n\t}, [shouldFetch]);\n\n\treturn { customers, isLoading, error };\n}\n\n// Helper to invalidate cache (call after creating/updating customers)\nfunction invalidateDialerCustomersCache() {\n\tcachedCustomers = null;\n\tcacheTimestamp = 0;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;CAaC;;;;AAED;;AAkBA,oCAAoC;AACpC,IAAI,kBAA2C;AAC/C,IAAI,iBAAiB;AACrB,MAAM,YAAY,IAAI,KAAK,MAAM,YAAY;AAEtC,SAAS,mBAAmB,cAAc,KAAK;IACrD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,wXAAQ,EAAmB,EAAE;IAC/D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,wXAAQ,EAAC;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,wXAAQ,EAAgB;IAElD,IAAA,yXAAS,EAAC;QACT,2DAA2D;QAC3D,IAAI,CAAC,aAAa;YACjB;QACD;QAEA,kCAAkC;QAClC,MAAM,MAAM,KAAK,GAAG;QACpB,IAAI,mBAAmB,MAAM,iBAAiB,WAAW;YACxD,aAAa;YACb;QACD;QAEA,MAAM,aAAa,IAAI;QACvB,MAAM,iBAAiB;YACtB,aAAa;YACb,SAAS;YAET,IAAI;gBACH,MAAM,WAAW,MAAM,MAAM,yBAAyB;oBACrD,QAAQ,WAAW,MAAM;oBACzB,OAAO;gBACR;gBAEA,IAAI,CAAC,SAAS,EAAE,EAAE;oBACjB,MAAM,UAAU,MAAM,SAAS,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;oBACrD,MAAM,IAAI,MAAM,QAAQ,KAAK,IAAI;gBAClC;gBAEA,MAAM,UAAW,MAAM,SAAS,IAAI;gBAGpC,kBAAkB,QAAQ,SAAS;gBACnC,iBAAiB,KAAK,GAAG;gBACzB,aAAa,QAAQ,SAAS;YAC/B,EAAE,OAAO,KAAK;gBACb,IAAI,WAAW,MAAM,CAAC,OAAO,EAAE;oBAC9B;gBACD;gBACA,SACC,eAAe,QAAQ,IAAI,OAAO,GAAG;YAEvC,SAAU;gBACT,IAAI,CAAC,WAAW,MAAM,CAAC,OAAO,EAAE;oBAC/B,aAAa;gBACd;YACD;QACD;QAEA;QAEA,OAAO;YACN,WAAW,KAAK;QACjB;IACD,GAAG;QAAC;KAAY;IAEhB,OAAO;QAAE;QAAW;QAAW;IAAM;AACtC;AAEA,sEAAsE;AACtE,SAAS;IACR,kBAAkB;IAClB,iBAAiB;AAClB"}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-telnyx-webrtc.ts"],"sourcesContent":["/**\n * Telnyx WebRTC Hook\n *\n * Provides WebRTC calling functionality using the Telnyx WebRTC SDK.\n * Compatible with both web browsers and React Native.\n *\n * Features:\n * - Make and receive calls\n * - Call controls (mute, hold, end)\n * - Real-time call state management\n * - Audio device selection\n * - Connection status monitoring\n * - Auto-reconnection with exponential backoff\n */\n\n\"use client\";\n\nimport type { Call, INotification } from \"@telnyx/webrtc\";\nimport { TelnyxRTC } from \"@telnyx/webrtc\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n// =============================================================================\n// AUTO-RECONNECTION CONFIGURATION\n// =============================================================================\n\nconst RECONNECT_CONFIG = {\n\t// Maximum number of reconnection attempts\n\tmaxAttempts: 5,\n\t// Base delay in milliseconds (doubles with each attempt)\n\tbaseDelayMs: 1000,\n\t// Maximum delay between attempts\n\tmaxDelayMs: 30000,\n\t// Jitter factor (0-1) to add randomness\n\tjitterFactor: 0.3,\n};\n\n/**\n * Call state types\n */\nexport type CallState =\n\t| \"idle\"\n\t| \"connecting\"\n\t| \"ringing\"\n\t| \"active\"\n\t| \"held\"\n\t| \"ended\";\n\n/**\n * Call direction\n */\nexport type CallDirection = \"inbound\" | \"outbound\";\n\n/**\n * WebRTC call information\n */\nexport type WebRTCCall = {\n\tid: string;\n\tstate: CallState;\n\tdirection: CallDirection;\n\tremoteNumber: string;\n\tremoteName?: string;\n\tlocalNumber: string;\n\tstartTime?: Date;\n\tduration: number;\n\tisMuted: boolean;\n\tisHeld: boolean;\n\tisRecording: boolean;\n};\n\n/**\n * Hook options\n */\nexport type UseTelnyxWebRTCOptions = {\n\tusername: string;\n\tpassword: string;\n\tautoConnect?: boolean;\n\tdebug?: boolean;\n\tonIncomingCall?: (call: WebRTCCall) => void;\n\tonCallEnded?: (call: WebRTCCall) => void;\n};\n\n/**\n * Hook return type\n */\nexport type UseTelnyxWebRTCReturn = {\n\t// Connection state\n\tisConnected: boolean;\n\tisConnecting: boolean;\n\tisReconnecting: boolean;\n\tconnectionError: string | null;\n\treconnectAttempts: number;\n\n\t// Current call\n\tcurrentCall: WebRTCCall | null;\n\n\t// Call actions\n\tmakeCall: (destination: string, callerIdNumber?: string) => Promise<Call>;\n\tanswerCall: () => Promise<void>;\n\tendCall: () => Promise<void>;\n\tmuteCall: () => Promise<void>;\n\tunmuteCall: () => Promise<void>;\n\tholdCall: () => Promise<void>;\n\tunholdCall: () => Promise<void>;\n\tsendDTMF: (digit: string) => Promise<void>;\n\n\t// Connection actions\n\tconnect: () => Promise<void>;\n\tdisconnect: () => void;\n\treconnect: () => Promise<void>;\n\n\t// Audio devices\n\taudioDevices: MediaDeviceInfo[];\n\tsetAudioDevice: (deviceId: string) => Promise<void>;\n};\n\n/**\n * Telnyx WebRTC Hook\n *\n * Manages WebRTC connection and call state\n */\nexport function useTelnyxWebRTC(\n\toptions: UseTelnyxWebRTCOptions,\n): UseTelnyxWebRTCReturn {\n\t// Connection state\n\tconst [isConnected, setIsConnected] = useState(false);\n\tconst [isConnecting, setIsConnecting] = useState(false);\n\tconst [isReconnecting, setIsReconnecting] = useState(false);\n\tconst [connectionError, setConnectionError] = useState<string | null>(null);\n\tconst [reconnectAttempts, setReconnectAttempts] = useState(0);\n\n\t// Call state\n\tconst [currentCall, setCurrentCall] = useState<WebRTCCall | null>(null);\n\n\t// Audio devices\n\tconst [audioDevices, setAudioDevices] = useState<MediaDeviceInfo[]>([]);\n\n\t// Refs\n\tconst clientRef = useRef<TelnyxRTC | null>(null);\n\tconst activeCallRef = useRef<Call | null>(null);\n\tconst optionsRef = useRef(options);\n\tconst reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\tconst shouldReconnectRef = useRef(true);\n\n\t// Keep options ref up to date\n\tuseEffect(() => {\n\t\toptionsRef.current = options;\n\t}, [options]);\n\n\t/**\n\t * Calculate reconnection delay with exponential backoff and jitter\n\t */\n\tconst calculateReconnectDelay = useCallback((attempt: number): number => {\n\t\t// Exponential backoff: baseDelay * 2^attempt\n\t\tconst exponentialDelay =\n\t\t\tRECONNECT_CONFIG.baseDelayMs * Math.pow(2, attempt);\n\n\t\t// Cap at maxDelay\n\t\tconst cappedDelay = Math.min(exponentialDelay, RECONNECT_CONFIG.maxDelayMs);\n\n\t\t// Add jitter to prevent thundering herd\n\t\tconst jitter =\n\t\t\tcappedDelay * RECONNECT_CONFIG.jitterFactor * Math.random();\n\n\t\treturn Math.round(cappedDelay + jitter);\n\t}, []);\n\n\t/**\n\t * Schedule a reconnection attempt\n\t */\n\tconst scheduleReconnect = useCallback(() => {\n\t\t// Clear any existing timeout\n\t\tif (reconnectTimeoutRef.current) {\n\t\t\tclearTimeout(reconnectTimeoutRef.current);\n\t\t}\n\n\t\tsetReconnectAttempts((prev) => {\n\t\t\tconst nextAttempt = prev + 1;\n\n\t\t\tif (nextAttempt > RECONNECT_CONFIG.maxAttempts) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`âŒ WebRTC: Max reconnection attempts (${RECONNECT_CONFIG.maxAttempts}) reached`\n\t\t\t\t);\n\t\t\t\tsetIsReconnecting(false);\n\t\t\t\tsetConnectionError(\n\t\t\t\t\t`Connection lost. Max reconnection attempts (${RECONNECT_CONFIG.maxAttempts}) exceeded.`\n\t\t\t\t);\n\t\t\t\treturn prev;\n\t\t\t}\n\n\t\t\tconst delay = calculateReconnectDelay(nextAttempt - 1);\n\t\t\tconsole.log(\n\t\t\t\t`ðŸ”„ WebRTC: Scheduling reconnection attempt ${nextAttempt}/${RECONNECT_CONFIG.maxAttempts} in ${delay}ms`\n\t\t\t);\n\n\t\t\tsetIsReconnecting(true);\n\n\t\t\treconnectTimeoutRef.current = setTimeout(async () => {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`ðŸ”„ WebRTC: Attempting reconnection ${nextAttempt}/${RECONNECT_CONFIG.maxAttempts}`\n\t\t\t\t);\n\n\t\t\t\t// Clear the old client before reconnecting\n\t\t\t\tif (clientRef.current) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclientRef.current.disconnect();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignore disconnect errors\n\t\t\t\t\t}\n\t\t\t\t\tclientRef.current = null;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to reconnect\n\t\t\t\ttry {\n\t\t\t\t\tconst currentOptions = optionsRef.current;\n\t\t\t\t\tif (currentOptions.username && currentOptions.password) {\n\t\t\t\t\t\t// Create new client and connect\n\t\t\t\t\t\tconst client = new TelnyxRTC({\n\t\t\t\t\t\t\tlogin: currentOptions.username,\n\t\t\t\t\t\t\tpassword: currentOptions.password,\n\t\t\t\t\t\t\tdebug: currentOptions.debug,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Re-setup event handlers\n\t\t\t\t\t\tclient.on(\"telnyx.ready\", () => {\n\t\t\t\t\t\t\tconsole.log(\"ðŸŽ‰ WebRTC: Reconnection successful!\");\n\t\t\t\t\t\t\tsetIsConnected(true);\n\t\t\t\t\t\t\tsetIsConnecting(false);\n\t\t\t\t\t\t\tsetIsReconnecting(false);\n\t\t\t\t\t\t\tsetConnectionError(null);\n\t\t\t\t\t\t\tsetReconnectAttempts(0);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclient.on(\"telnyx.error\", (error: any) => {\n\t\t\t\t\t\t\tconsole.error(\"âŒ WebRTC: Reconnection error:\", error);\n\t\t\t\t\t\t\tscheduleReconnect();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclient.on(\"telnyx.socket.error\", () => {\n\t\t\t\t\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\t\t\t\t\tscheduleReconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclient.on(\"telnyx.socket.close\", () => {\n\t\t\t\t\t\t\tsetIsConnected(false);\n\t\t\t\t\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\t\t\t\t\tscheduleReconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclientRef.current = client;\n\t\t\t\t\t\tawait client.connect();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(\"âŒ WebRTC: Reconnection attempt failed:\", error);\n\t\t\t\t\t// Will be retried by the socket close handler\n\t\t\t\t}\n\t\t\t}, delay);\n\n\t\t\treturn nextAttempt;\n\t\t});\n\t}, [calculateReconnectDelay]);\n\n\t/**\n\t * Manual reconnect function\n\t */\n\tconst reconnect = useCallback(async () => {\n\t\tconsole.log(\"ðŸ”„ WebRTC: Manual reconnection requested\");\n\t\tsetReconnectAttempts(0);\n\t\tshouldReconnectRef.current = true;\n\n\t\t// Clear existing client\n\t\tif (clientRef.current) {\n\t\t\ttry {\n\t\t\t\tclientRef.current.disconnect();\n\t\t\t} catch {\n\t\t\t\t// Ignore disconnect errors\n\t\t\t}\n\t\t\tclientRef.current = null;\n\t\t}\n\n\t\t// Clear any pending reconnect timeout\n\t\tif (reconnectTimeoutRef.current) {\n\t\t\tclearTimeout(reconnectTimeoutRef.current);\n\t\t\treconnectTimeoutRef.current = null;\n\t\t}\n\n\t\tsetIsReconnecting(false);\n\n\t\t// Use the normal connect flow\n\t\tconst currentOptions = optionsRef.current;\n\t\tif (currentOptions.username && currentOptions.password) {\n\t\t\tsetIsConnecting(true);\n\t\t\tsetConnectionError(null);\n\n\t\t\ttry {\n\t\t\t\tconst client = initializeClient();\n\t\t\t\tif (client) {\n\t\t\t\t\tawait client.connect();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"âŒ WebRTC: Manual reconnection failed:\", error);\n\t\t\t\tsetConnectionError(\n\t\t\t\t\terror instanceof Error ? error.message : \"Reconnection failed\"\n\t\t\t\t);\n\t\t\t\tsetIsConnecting(false);\n\t\t\t}\n\t\t}\n\t}, []);\n\n\t/**\n\t * Initialize WebRTC client\n\t * Uses ref to avoid circular dependencies\n\t */\n\tconst initializeClient = useCallback(() => {\n\t\tif (clientRef.current) {\n\t\t\tconsole.log(\"ðŸ”§ WebRTC: Reusing existing client instance\");\n\t\t\treturn clientRef.current;\n\t\t}\n\n\t\tconst currentOptions = optionsRef.current;\n\t\tconst hasCredentials =\n\t\t\tBoolean(currentOptions.username) && Boolean(currentOptions.password);\n\n\t\tconsole.log(\"ðŸ”§ WebRTC: Initializing client with credentials:\", {\n\t\t\thasUsername: Boolean(currentOptions.username),\n\t\t\thasPassword: Boolean(currentOptions.password),\n\t\t\tusername: currentOptions.username,\n\t\t\tdebug: currentOptions.debug,\n\t\t});\n\n\t\tif (!hasCredentials) {\n\t\t\tconsole.error(\"âŒ WebRTC: Missing credentials, cannot initialize\");\n\t\t\t// Don't initialize if credentials are missing\n\t\t\treturn null;\n\t\t}\n\n\t\tconsole.log(\"ðŸ”§ WebRTC: Creating new TelnyxRTC instance...\");\n\t\tconst client = new TelnyxRTC({\n\t\t\tlogin: currentOptions.username,\n\t\t\tpassword: currentOptions.password,\n\t\t\tringtoneFile: undefined, // Use browser default\n\t\t\tringbackFile: undefined,\n\t\t\tdebug: currentOptions.debug,\n\t\t});\n\t\tconsole.log(\n\t\t\t\"ðŸ”§ WebRTC: TelnyxRTC instance created, SDK version:\",\n\t\t\t(client as any).version || \"unknown\",\n\t\t);\n\n\t\t// Handle ready event\n\t\tclient.on(\"telnyx.ready\", () => {\n\t\t\tconsole.log(\"ðŸŽ‰ WebRTC: telnyx.ready event - Connection successful!\");\n\t\t\tsetIsConnected(true);\n\t\t\tsetIsConnecting(false);\n\t\t\tsetIsReconnecting(false);\n\t\t\tsetConnectionError(null);\n\t\t\tsetReconnectAttempts(0); // Reset on successful connection\n\t\t});\n\n\t\t// Handle error event\n\t\tclient.on(\"telnyx.error\", (error: any) => {\n\t\t\tconsole.error(\"âŒ WebRTC: telnyx.error event:\", error);\n\t\t\tconst errorMessage =\n\t\t\t\terror?.error?.message ||\n\t\t\t\terror?.message ||\n\t\t\t\terror?.description ||\n\t\t\t\t\"Connection error\";\n\t\t\tconsole.error(\"âŒ WebRTC: Error message:\", errorMessage);\n\t\t\tsetConnectionError(errorMessage);\n\t\t\tsetIsConnecting(false);\n\t\t});\n\n\t\t// Handle socket error - trigger reconnection\n\t\tclient.on(\"telnyx.socket.error\", (socketError: any) => {\n\t\t\tconsole.error(\"âŒ WebRTC: telnyx.socket.error event:\", socketError);\n\t\t\tsetConnectionError(\"Socket connection failed\");\n\t\t\tsetIsConnecting(false);\n\t\t\tsetIsConnected(false);\n\n\t\t\t// Trigger auto-reconnection\n\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\tscheduleReconnect();\n\t\t\t}\n\t\t});\n\n\t\t// Handle socket close - trigger reconnection\n\t\tclient.on(\"telnyx.socket.close\", (closeEvent: any) => {\n\t\t\tconsole.warn(\"âš ï¸ WebRTC: telnyx.socket.close event:\", closeEvent);\n\t\t\tsetIsConnected(false);\n\n\t\t\t// Trigger auto-reconnection (unless manually disconnected)\n\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\tscheduleReconnect();\n\t\t\t}\n\t\t});\n\n\t\t// Handle incoming call\n\t\tclient.on(\"telnyx.notification\", (notification: INotification) => {\n\t\t\tconsole.log(\"ðŸ“¨ WebRTC notification:\", notification.type);\n\n\t\t\tif (notification.type !== \"callUpdate\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst call = notification.call as Call | undefined;\n\n\t\t\tif (!call) {\n\t\t\t\t// Guard against undefined call object\n\t\t\t\tconsole.warn(\"âš ï¸ WebRTC: callUpdate notification with undefined call\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.log(\"ðŸ“¨ WebRTC callUpdate:\", {\n\t\t\t\tcallId: call.id,\n\t\t\t\tstate: call.state,\n\t\t\t\tdirection: call.direction,\n\t\t\t\tcause: (call as any).cause,\n\t\t\t\tsipCode: (call as any).sipCode,\n\t\t\t});\n\n\t\t\t// Update call state\n\t\t\tconst callState = mapTelnyxCallState(call.state);\n\t\t\tconst callInfo: WebRTCCall = {\n\t\t\t\tid: call.id || \"unknown\",\n\t\t\t\tstate: callState,\n\t\t\t\tdirection: call.direction === \"inbound\" ? \"inbound\" : \"outbound\",\n\t\t\t\tremoteNumber:\n\t\t\t\t\t(call as any).remoteNumber || (call as any).to || \"Unknown\",\n\t\t\t\tremoteName: (call as any).remoteName,\n\t\t\t\tlocalNumber: ((call as any).localNumber as string) || \"\",\n\t\t\t\tstartTime: callState === \"active\" ? new Date() : undefined,\n\t\t\t\tduration: 0,\n\t\t\t\tisMuted: false,\n\t\t\t\tisHeld: call.state === \"held\",\n\t\t\t\tisRecording: false,\n\t\t\t};\n\n\t\t\tsetCurrentCall(callInfo);\n\t\t\tactiveCallRef.current = call;\n\n\t\t\t// Notify parent component\n\t\t\tif (call.direction === \"inbound\" && call.state === \"ringing\") {\n\t\t\t\toptionsRef.current.onIncomingCall?.(callInfo);\n\t\t\t}\n\n\t\t\t// Handle call ended\n\t\t\tif (call.state === \"destroy\" || call.state === \"hangup\") {\n\t\t\t\toptionsRef.current.onCallEnded?.(callInfo);\n\t\t\t\tsetCurrentCall(null);\n\t\t\t\tactiveCallRef.current = null;\n\t\t\t}\n\t\t});\n\n\t\tclientRef.current = client;\n\t\treturn client;\n\t}, []); // âœ… No dependencies - uses ref\n\n\t/**\n\t * Connect to Telnyx\n\t */\n\tconst connect = useCallback(async () => {\n\t\ttry {\n\t\t\tconsole.log(\"ðŸ”Œ WebRTC: Starting connection...\");\n\t\t\tsetIsConnecting(true);\n\t\t\tsetConnectionError(null);\n\n\t\t\tconst client = initializeClient();\n\n\t\t\t// If client is null (no credentials), silently fail\n\t\t\tif (!client) {\n\t\t\t\tconsole.warn(\"âš ï¸ WebRTC: No credentials available, aborting connection\");\n\t\t\t\tsetIsConnecting(false);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.log(\"ðŸ”Œ WebRTC: Client initialized, calling connect()...\");\n\t\t\tawait client.connect();\n\t\t\tconsole.log(\"ðŸ”Œ WebRTC: client.connect() completed\");\n\t\t} catch (error) {\n\t\t\tconsole.error(\"âŒ WebRTC: Connection error in connect():\", error);\n\t\t\tsetConnectionError(\n\t\t\t\terror instanceof Error ? error.message : \"Connection failed\",\n\t\t\t);\n\t\t\tsetIsConnecting(false);\n\t\t}\n\t}, [initializeClient]);\n\n\t/**\n\t * Disconnect from Telnyx\n\t */\n\tconst disconnect = useCallback(() => {\n\t\t// Disable auto-reconnection\n\t\tshouldReconnectRef.current = false;\n\n\t\t// Clear any pending reconnect timeout\n\t\tif (reconnectTimeoutRef.current) {\n\t\t\tclearTimeout(reconnectTimeoutRef.current);\n\t\t\treconnectTimeoutRef.current = null;\n\t\t}\n\n\t\tif (clientRef.current) {\n\t\t\tclientRef.current.disconnect();\n\t\t\tclientRef.current = null;\n\t\t}\n\t\tsetIsConnected(false);\n\t\tsetIsConnecting(false);\n\t\tsetIsReconnecting(false);\n\t\tsetReconnectAttempts(0);\n\t\tsetCurrentCall(null);\n\t\tactiveCallRef.current = null;\n\t}, []);\n\n\t/**\n\t * Make an outbound call\n\t */\n\tconst makeCall = useCallback(\n\t\tasync (destination: string, callerIdNumber?: string) => {\n\t\t\t// Normalize phone numbers to E.164 format\n\t\t\tconst normalizeToE164 = (phone: string): string => {\n\t\t\t\tconst digits = phone.replace(/\\D/g, \"\");\n\t\t\t\tif (digits.length === 10) {\n\t\t\t\t\treturn `+1${digits}`;\n\t\t\t\t}\n\t\t\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\t\t\treturn `+${digits}`;\n\t\t\t\t}\n\t\t\t\tif (digits.length > 10 && !phone.startsWith(\"+\")) {\n\t\t\t\t\treturn `+${digits}`;\n\t\t\t\t}\n\t\t\t\treturn phone.startsWith(\"+\") ? phone : `+${digits}`;\n\t\t\t};\n\n\t\t\tconst normalizedDestination = normalizeToE164(destination);\n\t\t\tconst normalizedCallerId = callerIdNumber ? normalizeToE164(callerIdNumber) : undefined;\n\n\t\t\tconsole.log(\"ðŸ“ž WebRTC makeCall:\", {\n\t\t\t\tdestination,\n\t\t\t\tnormalizedDestination,\n\t\t\t\tcallerIdNumber,\n\t\t\t\tnormalizedCallerId,\n\t\t\t\tisConnected,\n\t\t\t\thasClient: !!clientRef.current,\n\t\t\t});\n\n\t\t\tif (!(clientRef.current && isConnected)) {\n\t\t\t\tconsole.error(\"âŒ WebRTC makeCall: Not connected to Telnyx\");\n\t\t\t\tthrow new Error(\"Not connected to Telnyx\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconsole.log(\"ðŸ“ž WebRTC: Calling newCall()...\");\n\t\t\t\tconst call = await clientRef.current.newCall({\n\t\t\t\t\tdestinationNumber: normalizedDestination,\n\t\t\t\t\tcallerNumber: normalizedCallerId,\n\t\t\t\t});\n\n\t\t\t\tconsole.log(\"ðŸ“ž WebRTC: newCall() returned:\", {\n\t\t\t\t\tcallId: call?.id,\n\t\t\t\t\tcallState: (call as any)?.state,\n\t\t\t\t});\n\n\t\t\t\tactiveCallRef.current = call;\n\n\t\t\t\t// Set initial call state immediately\n\t\t\t\tconst callInfo: WebRTCCall = {\n\t\t\t\t\tid: call.id,\n\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\tdirection: \"outbound\",\n\t\t\t\t\tremoteNumber: destination,\n\t\t\t\t\tlocalNumber: callerIdNumber || \"\",\n\t\t\t\t\tduration: 0,\n\t\t\t\t\tisMuted: false,\n\t\t\t\t\tisHeld: false,\n\t\t\t\t\tisRecording: false,\n\t\t\t\t};\n\t\t\t\tsetCurrentCall(callInfo);\n\n\t\t\t\treturn call;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"âŒ WebRTC makeCall error:\", error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\t\t[isConnected],\n\t);\n\n\t/**\n\t * Answer incoming call\n\t */\n\tconst answerCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to answer\");\n\t\t}\n\t\tawait activeCallRef.current.answer();\n\t}, []);\n\n\t/**\n\t * End active call\n\t */\n\tconst endCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to end\");\n\t\t}\n\t\tawait activeCallRef.current.hangup();\n\t\tsetCurrentCall(null);\n\t\tactiveCallRef.current = null;\n\t}, []);\n\n\t/**\n\t * Mute call\n\t */\n\tconst muteCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to mute\");\n\t\t}\n\t\tawait activeCallRef.current.muteAudio();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isMuted: true } : null));\n\t}, []);\n\n\t/**\n\t * Unmute call\n\t */\n\tconst unmuteCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to unmute\");\n\t\t}\n\t\tawait activeCallRef.current.unmuteAudio();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isMuted: false } : null));\n\t}, []);\n\n\t/**\n\t * Hold call\n\t */\n\tconst holdCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to hold\");\n\t\t}\n\t\tawait activeCallRef.current.hold();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isHeld: true } : null));\n\t}, []);\n\n\t/**\n\t * Unhold call\n\t */\n\tconst unholdCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to unhold\");\n\t\t}\n\t\tawait activeCallRef.current.unhold();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isHeld: false } : null));\n\t}, []);\n\n\t/**\n\t * Send DTMF tone\n\t */\n\tconst sendDTMF = useCallback(async (digit: string) => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call\");\n\t\t}\n\t\tawait activeCallRef.current.dtmf(digit);\n\t}, []);\n\n\t/**\n\t * Set audio output device\n\t */\n\tconst setAudioDevice = useCallback(async (deviceId: string) => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call\");\n\t\t}\n\t\tawait activeCallRef.current.setAudioOutDevice(deviceId);\n\t}, []);\n\n\t/**\n\t * Load audio devices\n\t */\n\tconst loadAudioDevices = useCallback(async () => {\n\t\t// Check if MediaDevices API is available\n\t\tif (\n\t\t\ttypeof navigator === \"undefined\" ||\n\t\t\t!navigator.mediaDevices ||\n\t\t\t!navigator.mediaDevices.enumerateDevices\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst devices = await navigator.mediaDevices.enumerateDevices();\n\t\t\tconst audioOutputDevices = devices.filter(\n\t\t\t\t(d) => d.kind === \"audiooutput\",\n\t\t\t);\n\t\t\tsetAudioDevices(audioOutputDevices);\n\t\t} catch {\n\t\t\t// Ignore audio device loading errors\n\t\t}\n\t}, []);\n\n\t/**\n\t * Auto-connect on mount if enabled\n\t * Uses ref pattern to prevent infinite loop from dependency chain\n\t */\n\tuseEffect(() => {\n\t\t// Check if MediaDevices API is available\n\t\tif (\n\t\t\ttypeof navigator === \"undefined\" ||\n\t\t\t!navigator.mediaDevices ||\n\t\t\t!navigator.mediaDevices.enumerateDevices\n\t\t) {\n\t\t\treturn () => {\n\t\t\t\t// No-op cleanup when MediaDevices API is not available\n\t\t\t};\n\t\t}\n\n\t\t// Load audio devices on mount\n\t\tloadAudioDevices();\n\n\t\t// Listen for device changes\n\t\tconst deviceChangeHandler = () => {\n\t\t\tloadAudioDevices();\n\t\t};\n\t\tnavigator.mediaDevices.addEventListener(\n\t\t\t\"devicechange\",\n\t\t\tdeviceChangeHandler,\n\t\t);\n\n\t\treturn () => {\n\t\t\tif (navigator.mediaDevices) {\n\t\t\t\tnavigator.mediaDevices.removeEventListener(\n\t\t\t\t\t\"devicechange\",\n\t\t\t\t\tdeviceChangeHandler,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [\n\t\t// Load audio devices on mount\n\t\tloadAudioDevices,\n\t]); // âœ… Runs once on mount only - loadAudioDevices is stable (useCallback with no deps)\n\n\t/**\n\t * Separate effect for auto-connect to prevent dependency loop\n\t */\n\tuseEffect(() => {\n\t\tif (optionsRef.current.autoConnect) {\n\t\t\tconnect();\n\t\t}\n\n\t\treturn () => {\n\t\t\t// Cleanup on unmount\n\t\t\tdisconnect();\n\t\t};\n\t}, [\n\t\tconnect, // Cleanup on unmount\n\t\tdisconnect,\n\t]); // âœ… Runs once - uses ref for options\n\n\treturn {\n\t\t// Connection state\n\t\tisConnected,\n\t\tisConnecting,\n\t\tisReconnecting,\n\t\tconnectionError,\n\t\treconnectAttempts,\n\n\t\t// Current call\n\t\tcurrentCall,\n\n\t\t// Call actions\n\t\tmakeCall,\n\t\tanswerCall,\n\t\tendCall,\n\t\tmuteCall,\n\t\tunmuteCall,\n\t\tholdCall,\n\t\tunholdCall,\n\t\tsendDTMF,\n\n\t\t// Connection actions\n\t\tconnect,\n\t\tdisconnect,\n\t\treconnect,\n\n\t\t// Audio devices\n\t\taudioDevices,\n\t\tsetAudioDevice,\n\t};\n}\n\n/**\n * Map Telnyx call state to our call state\n */\nfunction mapTelnyxCallState(telnyxState: string): CallState {\n\tswitch (telnyxState) {\n\t\tcase \"new\":\n\t\tcase \"requesting\":\n\t\t\treturn \"connecting\";\n\t\tcase \"trying\":\n\t\tcase \"recovering\":\n\t\tcase \"ringing\":\n\t\t\treturn \"ringing\";\n\t\tcase \"active\":\n\t\t\treturn \"active\";\n\t\tcase \"held\":\n\t\t\treturn \"held\";\n\t\tcase \"hangup\":\n\t\tcase \"destroy\":\n\t\t\treturn \"ended\";\n\t\tdefault:\n\t\t\treturn \"idle\";\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1597, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-toast.ts"],"sourcesContent":["/**\n * Toast Hook - Wrapper around Sonner\n *\n * Provides a consistent interface for displaying toast notifications\n * across the application with success, error, loading, and promise states.\n *\n * @example\n * const { toast } = useToast();\n *\n * // Success\n * toast.success(\"Customer created successfully!\");\n *\n * // Error\n * toast.error(\"Failed to save changes\");\n *\n * // Loading\n * const id = toast.loading(\"Saving...\");\n * toast.success(\"Saved!\", { id });\n *\n * // Promise\n * toast.promise(createCustomer(data), {\n *   loading: \"Creating customer...\",\n *   success: \"Customer created!\",\n *   error: \"Failed to create customer\"\n * });\n */\n\nimport { toast as sonnerToast } from \"sonner\";\n\nexport function useToast() {\n\treturn {\n\t\ttoast: {\n\t\t\tsuccess: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.success(message, {\n\t\t\t\t\tduration: 3000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\terror: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.error(message, {\n\t\t\t\t\tduration: 5000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\tloading: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.loading(message, options),\n\n\t\t\tinfo: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.info(message, {\n\t\t\t\t\tduration: 3000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\twarning: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.warning(message, {\n\t\t\t\t\tduration: 4000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\tpromise: <T>(\n\t\t\t\tpromise: Promise<T>,\n\t\t\t\tmessages: {\n\t\t\t\t\tloading: string;\n\t\t\t\t\tsuccess: string | ((data: T) => string);\n\t\t\t\t\terror: string | ((error: any) => string);\n\t\t\t\t},\n\t\t\t) => sonnerToast.promise(promise, messages),\n\n\t\t\tdismiss: (id?: string | number) => {\n\t\t\t\tsonnerToast.dismiss(id);\n\t\t\t},\n\n\t\t\t// Shorthand for Server Action responses\n\t\t\tfromActionResult: (result: {\n\t\t\t\tsuccess: boolean;\n\t\t\t\terror?: string;\n\t\t\t\tmessage?: string;\n\t\t\t}) => {\n\t\t\t\tif (result.success) {\n\t\t\t\t\tsonnerToast.success(\n\t\t\t\t\t\tresult.message || \"Operation completed successfully\",\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tsonnerToast.error(result.error || \"Operation failed\");\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t};\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;CAyBC;;;;AAED;;AAEO,SAAS;IACf,OAAO;QACN,OAAO;YACN,SAAS,CAAC,SAAiB,UAC1B,iRAAW,CAAC,OAAO,CAAC,SAAS;oBAC5B,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,OAAO,CAAC,SAAiB,UACxB,iRAAW,CAAC,KAAK,CAAC,SAAS;oBAC1B,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,SAAS,CAAC,SAAiB,UAC1B,iRAAW,CAAC,OAAO,CAAC,SAAS;YAE9B,MAAM,CAAC,SAAiB,UACvB,iRAAW,CAAC,IAAI,CAAC,SAAS;oBACzB,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,SAAS,CAAC,SAAiB,UAC1B,iRAAW,CAAC,OAAO,CAAC,SAAS;oBAC5B,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,SAAS,CACR,SACA,WAKI,iRAAW,CAAC,OAAO,CAAC,SAAS;YAElC,SAAS,CAAC;gBACT,iRAAW,CAAC,OAAO,CAAC;YACrB;YAEA,wCAAwC;YACxC,kBAAkB,CAAC;gBAKlB,IAAI,OAAO,OAAO,EAAE;oBACnB,iRAAW,CAAC,OAAO,CAClB,OAAO,OAAO,IAAI;gBAEpB,OAAO;oBACN,iRAAW,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;gBACnC;YACD;QACD;IACD;AACD"}}]
}