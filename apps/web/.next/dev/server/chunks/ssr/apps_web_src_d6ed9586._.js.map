{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/dialer-store.ts"],"sourcesContent":["import { create } from \"zustand\";\n\n/**\n * Dialer Store - Manages phone dialer state\n *\n * Allows programmatic control of the phone dropdown:\n * - Open dialer with pre-filled phone number\n * - Pre-select customer\n * - Keyboard shortcuts support\n */\n\ninterface DialerState {\n\tisOpen: boolean;\n\tphoneNumber: string;\n\tcustomerId: string | null;\n\tcustomerName: string | null;\n}\n\ninterface DialerActions {\n\topenDialer: (\n\t\tphoneNumber?: string,\n\t\tcustomerId?: string,\n\t\tcustomerName?: string,\n\t) => void;\n\tcloseDialer: () => void;\n\tsetPhoneNumber: (phoneNumber: string) => void;\n\treset: () => void;\n}\n\nexport type DialerStore = DialerState & DialerActions;\n\nconst initialState: DialerState = {\n\tisOpen: false,\n\tphoneNumber: \"\",\n\tcustomerId: null,\n\tcustomerName: null,\n};\n\nexport const useDialerStore = create<DialerStore>((set) => ({\n\t...initialState,\n\n\topenDialer: (phoneNumber = \"\", customerId = null, customerName = null) =>\n\t\tset({\n\t\t\tisOpen: true,\n\t\t\tphoneNumber,\n\t\t\tcustomerId,\n\t\t\tcustomerName,\n\t\t}),\n\n\tcloseDialer: () =>\n\t\tset({\n\t\t\tisOpen: false,\n\t\t}),\n\n\tsetPhoneNumber: (phoneNumber) =>\n\t\tset({\n\t\t\tphoneNumber,\n\t\t}),\n\n\treset: () => set(initialState),\n}));\n"],"names":[],"mappings":";;;;AAAA;;AA+BA,MAAM,eAA4B;IACjC,QAAQ;IACR,aAAa;IACb,YAAY;IACZ,cAAc;AACf;AAEO,MAAM,iBAAiB,IAAA,4VAAM,EAAc,CAAC,MAAQ,CAAC;QAC3D,GAAG,YAAY;QAEf,YAAY,CAAC,cAAc,EAAE,EAAE,aAAa,IAAI,EAAE,eAAe,IAAI,GACpE,IAAI;gBACH,QAAQ;gBACR;gBACA;gBACA;YACD;QAED,aAAa,IACZ,IAAI;gBACH,QAAQ;YACT;QAED,gBAAgB,CAAC,cAChB,IAAI;gBACH;YACD;QAED,OAAO,IAAM,IAAI;IAClB,CAAC"}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-dialer-shortcut.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useDialerStore } from \"@/lib/stores/dialer-store\";\n\n/**\n * Global keyboard shortcut hook for the phone dialer\n *\n * Listens for Ctrl+Shift+D (or Cmd+Shift+D on Mac) to toggle the dialer\n *\n * Usage: Call this hook once in a layout component\n */\nexport function useDialerShortcut() {\n\tconst openDialer = useDialerStore((state) => state.openDialer);\n\tconst closeDialer = useDialerStore((state) => state.closeDialer);\n\tconst isOpen = useDialerStore((state) => state.isOpen);\n\n\tuseEffect(() => {\n\t\tconst handleKeyDown = (event: KeyboardEvent) => {\n\t\t\t// Check for Ctrl+Shift+D (Windows/Linux) or Cmd+Shift+D (Mac)\n\t\t\tif (\n\t\t\t\t(event.ctrlKey || event.metaKey) &&\n\t\t\t\tevent.shiftKey &&\n\t\t\t\tevent.key === \"D\"\n\t\t\t) {\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\t// Toggle dialer\n\t\t\t\tif (isOpen) {\n\t\t\t\t\tcloseDialer();\n\t\t\t\t} else {\n\t\t\t\t\topenDialer();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"keydown\", handleKeyDown);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"keydown\", handleKeyDown);\n\t\t};\n\t}, [openDialer, closeDialer, isOpen]);\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAYO,SAAS;IACf,MAAM,aAAa,IAAA,wKAAc,EAAC,CAAC,QAAU,MAAM,UAAU;IAC7D,MAAM,cAAc,IAAA,wKAAc,EAAC,CAAC,QAAU,MAAM,WAAW;IAC/D,MAAM,SAAS,IAAA,wKAAc,EAAC,CAAC,QAAU,MAAM,MAAM;IAErD,IAAA,yXAAS,EAAC;QACT,MAAM,gBAAgB,CAAC;YACtB,8DAA8D;YAC9D,IACC,CAAC,MAAM,OAAO,IAAI,MAAM,OAAO,KAC/B,MAAM,QAAQ,IACd,MAAM,GAAG,KAAK,KACb;gBACD,MAAM,cAAc;gBAEpB,gBAAgB;gBAChB,IAAI,QAAQ;oBACX;gBACD,OAAO;oBACN;gBACD;YACD;QACD;QAEA,OAAO,gBAAgB,CAAC,WAAW;QAEnC,OAAO;YACN,OAAO,mBAAmB,CAAC,WAAW;QACvC;IACD,GAAG;QAAC;QAAY;QAAa;KAAO;AACrC"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/help-dropdown.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n\tBookOpen,\n\tExternalLink,\n\tHelpCircle,\n\tLifeBuoy,\n\tMessageCircle,\n\tVideo,\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { useEffect, useRef, useState } from \"react\";\n\ntype HelpItem = {\n\tlabel: string;\n\tdescription: string;\n\thref: string;\n\ticon: typeof BookOpen;\n\texternal?: boolean;\n};\n\nconst helpItems: HelpItem[] = [\n\t{\n\t\tlabel: \"Documentation\",\n\t\tdescription: \"Guides and tutorials for all features\",\n\t\thref: \"/docs\",\n\t\ticon: BookOpen,\n\t},\n\t{\n\t\tlabel: \"Video Tutorials\",\n\t\tdescription: \"Step-by-step video guides\",\n\t\thref: \"/docs/videos\",\n\t\ticon: Video,\n\t},\n\t{\n\t\tlabel: \"Support Center\",\n\t\tdescription: \"Get help from our support team\",\n\t\thref: \"/support\",\n\t\ticon: LifeBuoy,\n\t},\n\t{\n\t\tlabel: \"Contact Support\",\n\t\tdescription: \"Chat with our support team\",\n\t\thref: \"/support/contact\",\n\t\ticon: MessageCircle,\n\t},\n\t{\n\t\tlabel: \"What's New\",\n\t\tdescription: \"Latest features and updates\",\n\t\thref: \"/changelog\",\n\t\ticon: HelpCircle,\n\t},\n];\n\nexport function HelpDropdown() {\n\tconst [isOpen, setIsOpen] = useState(false);\n\tconst dropdownRef = useRef<HTMLDivElement>(null);\n\n\tuseEffect(() => {\n\t\tconst handleClickOutside = (event: MouseEvent) => {\n\t\t\tif (\n\t\t\t\tdropdownRef.current &&\n\t\t\t\t!dropdownRef.current.contains(event.target as Node)\n\t\t\t) {\n\t\t\t\tsetIsOpen(false);\n\t\t\t}\n\t\t};\n\n\t\tif (isOpen) {\n\t\t\tdocument.addEventListener(\"mousedown\", handleClickOutside);\n\t\t}\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"mousedown\", handleClickOutside);\n\t\t};\n\t}, [isOpen]);\n\n\treturn (\n\t\t<div className=\"relative\" ref={dropdownRef}>\n\t\t\t<button\n\t\t\t\tclassName=\"hover-gradient hover:border-primary/20 hover:bg-primary/10 hover:text-primary focus-visible:ring-ring/50 flex h-8 w-8 items-center justify-center rounded-md border border-transparent transition-all outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50\"\n\t\t\t\tonClick={() => setIsOpen(!isOpen)}\n\t\t\t\ttitle=\"Help\"\n\t\t\t\ttype=\"button\"\n\t\t\t>\n\t\t\t\t<HelpCircle className=\"size-4\" />\n\t\t\t\t<span className=\"sr-only\">Help</span>\n\t\t\t</button>\n\n\t\t\t{isOpen && (\n\t\t\t\t<div className=\"bg-popover text-popover-foreground absolute top-full right-0 z-50 mt-2 w-80 rounded-lg border p-2 shadow-lg\">\n\t\t\t\t\t<div className=\"mb-2 border-b px-3 py-2\">\n\t\t\t\t\t\t<h3 className=\"text-sm font-semibold\">Help &amp; Support</h3>\n\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\tFind answers and get assistance\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"space-y-1\">\n\t\t\t\t\t\t{helpItems.map((item) => {\n\t\t\t\t\t\t\tconst Icon = item.icon;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\tclassName=\"hover:bg-accent flex items-start gap-3 rounded-md px-3 py-2.5 transition-colors\"\n\t\t\t\t\t\t\t\t\thref={item.href}\n\t\t\t\t\t\t\t\t\tkey={item.label}\n\t\t\t\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t\t\t\t\trel={item.external ? \"noopener noreferrer\" : undefined}\n\t\t\t\t\t\t\t\t\ttarget={item.external ? \"_blank\" : undefined}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<Icon className=\"text-muted-foreground mt-0.5 size-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t<div className=\"flex-1\">\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm font-medium\">{item.label}</p>\n\t\t\t\t\t\t\t\t\t\t\t{item.external && (\n\t\t\t\t\t\t\t\t\t\t\t\t<ExternalLink className=\"text-muted-foreground size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t{item.description}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"mt-2 border-t pt-2\">\n\t\t\t\t\t\t<div className=\"bg-accent/50 rounded-md px-3 py-2\">\n\t\t\t\t\t\t\t<p className=\"text-xs font-medium\">Need more help?</p>\n\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\tEmail us at{\" \"}\n\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\tclassName=\"text-primary hover:underline\"\n\t\t\t\t\t\t\t\t\thref=\"mailto:support@thorbis.com\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tsupport@thorbis.com\n\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAXA;;;;;AAqBA,MAAM,YAAwB;IAC7B;QACC,OAAO;QACP,aAAa;QACb,MAAM;QACN,MAAM,8SAAQ;IACf;IACA;QACC,OAAO;QACP,aAAa;QACb,MAAM;QACN,MAAM,iSAAK;IACZ;IACA;QACC,OAAO;QACP,aAAa;QACb,MAAM;QACN,MAAM,8SAAQ;IACf;IACA;QACC,OAAO;QACP,aAAa;QACb,MAAM;QACN,MAAM,6TAAa;IACpB;IACA;QACC,OAAO;QACP,aAAa;QACb,MAAM;QACN,MAAM,gUAAU;IACjB;CACA;AAEM,SAAS;IACf,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,wXAAQ,EAAC;IACrC,MAAM,cAAc,IAAA,sXAAM,EAAiB;IAE3C,IAAA,yXAAS,EAAC;QACT,MAAM,qBAAqB,CAAC;YAC3B,IACC,YAAY,OAAO,IACnB,CAAC,YAAY,OAAO,CAAC,QAAQ,CAAC,MAAM,MAAM,GACzC;gBACD,UAAU;YACX;QACD;QAEA,IAAI,QAAQ;YACX,SAAS,gBAAgB,CAAC,aAAa;QACxC;QAEA,OAAO;YACN,SAAS,mBAAmB,CAAC,aAAa;QAC3C;IACD,GAAG;QAAC;KAAO;IAEX,qBACC,qZAAC;QAAI,WAAU;QAAW,KAAK;;0BAC9B,qZAAC;gBACA,WAAU;gBACV,SAAS,IAAM,UAAU,CAAC;gBAC1B,OAAM;gBACN,MAAK;;kCAEL,qZAAC,gUAAU;wBAAC,WAAU;;;;;;kCACtB,qZAAC;wBAAK,WAAU;kCAAU;;;;;;;;;;;;YAG1B,wBACA,qZAAC;gBAAI,WAAU;;kCACd,qZAAC;wBAAI,WAAU;;0CACd,qZAAC;gCAAG,WAAU;0CAAwB;;;;;;0CACtC,qZAAC;gCAAE,WAAU;0CAAgC;;;;;;;;;;;;kCAI9C,qZAAC;wBAAI,WAAU;kCACb,UAAU,GAAG,CAAC,CAAC;4BACf,MAAM,OAAO,KAAK,IAAI;4BACtB,qBACC,qZAAC,8UAAI;gCACJ,WAAU;gCACV,MAAM,KAAK,IAAI;gCAEf,SAAS,IAAM,UAAU;gCACzB,KAAK,KAAK,QAAQ,GAAG,wBAAwB;gCAC7C,QAAQ,KAAK,QAAQ,GAAG,WAAW;;kDAEnC,qZAAC;wCAAK,WAAU;;;;;;kDAChB,qZAAC;wCAAI,WAAU;;0DACd,qZAAC;gDAAI,WAAU;;kEACd,qZAAC;wDAAE,WAAU;kEAAuB,KAAK,KAAK;;;;;;oDAC7C,KAAK,QAAQ,kBACb,qZAAC,0TAAY;wDAAC,WAAU;;;;;;;;;;;;0DAG1B,qZAAC;gDAAE,WAAU;0DACX,KAAK,WAAW;;;;;;;;;;;;;+BAdd,KAAK,KAAK;;;;;wBAmBlB;;;;;;kCAED,qZAAC;wBAAI,WAAU;kCACd,cAAA,qZAAC;4BAAI,WAAU;;8CACd,qZAAC;oCAAE,WAAU;8CAAsB;;;;;;8CACnC,qZAAC;oCAAE,WAAU;;wCAAgC;wCAChC;sDACZ,qZAAC;4CACA,WAAU;4CACV,MAAK;sDACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUT"}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/notifications.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA4YsB,qBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/notifications.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA8TsB,gBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/notifications.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAqRsB,aAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/notification-events.ts"],"sourcesContent":["export const COMMUNICATION_MARK_AS_READ_EVENT = \"communication:mark-as-read\";\n\nexport type CommunicationMarkAsReadDetail = {\n\tnotificationId: string;\n};\n"],"names":[],"mappings":";;;;AAAO,MAAM,mCAAmC"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/notifications-store.ts"],"sourcesContent":["/**\n * Notifications Store - Zustand State Management\n *\n * Performance optimizations:\n * - Lightweight state management with Zustand (no provider wrapper)\n * - Selective subscriptions prevent unnecessary re-renders\n * - Real-time updates via Supabase Realtime\n * - Optimistic updates for better UX\n * - Organized in /src/lib/stores/ directory\n *\n * Usage in components:\n * ```typescript\n * const notifications = useNotificationsStore((state) => state.notifications);\n * const unreadCount = useNotificationsStore((state) => state.unreadCount);\n * const markAsRead = useNotificationsStore((state) => state.markAsRead);\n * ```\n */\n\nimport type {\n\tRealtimeChannel,\n\tRealtimePostgresChangesPayload,\n} from \"@supabase/supabase-js\";\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport { createClient } from \"@/lib/supabase/client\";\nimport {\n\tCOMMUNICATION_MARK_AS_READ_EVENT,\n\ttype CommunicationMarkAsReadDetail,\n} from \"./notification-events\";\n\n// =====================================================================================\n// Types\n// =====================================================================================\n\n// Import and re-export shared types to maintain backward compatibility\nimport type {\n\tNotification,\n\tNotificationPriority,\n\tNotificationType,\n} from \"./notifications-types\";\n\nexport type { Notification, NotificationPriority, NotificationType };\n\ntype NotificationsState = {\n\t// State\n\tnotifications: Notification[];\n\tunreadCount: number;\n\tisLoading: boolean;\n\tisSubscribed: boolean;\n\terror: string | null;\n\trealtimeChannel: RealtimeChannel | null;\n\tsubscriptionPromise: Promise<void> | null; // Prevents race conditions\n\n\t// Actions\n\tsetNotifications: (notifications: Notification[]) => void;\n\taddNotification: (notification: Notification) => void;\n\tupdateNotification: (id: string, updates: Partial<Notification>) => void;\n\tremoveNotification: (id: string) => void;\n\tsetUnreadCount: (count: number) => void;\n\tsetLoading: (isLoading: boolean) => void;\n\tsetError: (error: string | null) => void;\n\n\t// Optimistic updates\n\toptimisticMarkAsRead: (id: string) => void;\n\toptimisticMarkAsUnread: (id: string) => void;\n\toptimisticMarkAllAsRead: () => void;\n\toptimisticDelete: (id: string) => void;\n\n\t// Realtime subscription management\n\tsubscribe: (userId: string) => Promise<void>;\n\tunsubscribe: () => void;\n\n\t// Utility\n\treset: () => void;\n};\n\n// Initial state\nconst initialState = {\n\tnotifications: [],\n\tunreadCount: 0,\n\tisLoading: false,\n\tisSubscribed: false,\n\terror: null,\n\trealtimeChannel: null,\n\tsubscriptionPromise: null,\n};\n\n// =====================================================================================\n// Zustand Store\n// =====================================================================================\n\nexport const useNotificationsStore = create<NotificationsState>()(\n\tdevtools(\n\t\t(set, get) => ({\n\t\t\t...initialState,\n\n\t\t\t// ===============================================================================\n\t\t\t// Basic State Setters\n\t\t\t// ===============================================================================\n\n\t\t\tsetNotifications: (notifications) => {\n\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\t\t\t\tset({ notifications, unreadCount });\n\t\t\t},\n\n\t\t\taddNotification: (notification) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst exists = state.notifications.some(\n\t\t\t\t\t\t(n) => n.id === notification.id,\n\t\t\t\t\t);\n\t\t\t\t\tif (exists) {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newNotifications = [notification, ...state.notifications];\n\t\t\t\t\tconst unreadCount = newNotifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnotifications: newNotifications,\n\t\t\t\t\t\tunreadCount,\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\tupdateNotification: (id, updates) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) =>\n\t\t\t\t\t\tn.id === id ? { ...n, ...updates } : n,\n\t\t\t\t\t);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\tremoveNotification: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.filter((n) => n.id !== id);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\tsetUnreadCount: (unreadCount) => set({ unreadCount }),\n\n\t\t\tsetLoading: (isLoading) => set({ isLoading }),\n\n\t\t\tsetError: (error) => set({ error }),\n\n\t\t\t// ===============================================================================\n\t\t\t// Optimistic Updates\n\t\t\t// ===============================================================================\n\n\t\t\toptimisticMarkAsRead: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) =>\n\t\t\t\t\t\tn.id === id\n\t\t\t\t\t\t\t? { ...n, read: true, read_at: new Date().toISOString() }\n\t\t\t\t\t\t\t: n,\n\t\t\t\t\t);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\toptimisticMarkAsUnread: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) =>\n\t\t\t\t\t\tn.id === id ? { ...n, read: false, read_at: null } : n,\n\t\t\t\t\t);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\toptimisticMarkAllAsRead: () =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.map((n) => ({\n\t\t\t\t\t\t...n,\n\t\t\t\t\t\tread: true,\n\t\t\t\t\t\tread_at: n.read_at || new Date().toISOString(),\n\t\t\t\t\t}));\n\n\t\t\t\t\treturn { notifications, unreadCount: 0 };\n\t\t\t\t}),\n\n\t\t\toptimisticDelete: (id) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst notifications = state.notifications.filter((n) => n.id !== id);\n\t\t\t\t\tconst unreadCount = notifications.filter((n) => !n.read).length;\n\n\t\t\t\t\treturn { notifications, unreadCount };\n\t\t\t\t}),\n\n\t\t\t// ===============================================================================\n\t\t\t// Realtime Subscription Management\n\t\t\t// ===============================================================================\n\n\t\t\tsubscribe: async (userId: string) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst state = get();\n\n\t\t\t\t\t// CRITICAL: Return existing promise if subscription is in progress\n\t\t\t\t\tif (state.subscriptionPromise) {\n\t\t\t\t\t\treturn state.subscriptionPromise;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't subscribe if already subscribed\n\t\t\t\t\tif (state.isSubscribed || state.realtimeChannel) {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create subscription promise BEFORE any async operations\n\t\t\t\t\tconst subscriptionPromise = (async () => {\n\t\t\t\t\t\t// CRITICAL FIX: Set flag immediately to prevent race condition\n\t\t\t\t\t\tset({ isSubscribed: true });\n\n\t\t\t\t\t\tconst supabase = createClient();\n\n\t\t\t\t\t\tif (!supabase) {\n\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create realtime channel for notifications\n\t\t\t\t\t\tconst channel = supabase\n\t\t\t\t\t\t\t.channel(\"notifications-changes\")\n\t\t\t\t\t\t\t.on(\n\t\t\t\t\t\t\t\t\"postgres_changes\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tevent: \"INSERT\",\n\t\t\t\t\t\t\t\t\tschema: \"public\",\n\t\t\t\t\t\t\t\t\ttable: \"notifications\",\n\t\t\t\t\t\t\t\t\tfilter: `user_id=eq.${userId}`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(payload: RealtimePostgresChangesPayload<Notification>) => {\n\t\t\t\t\t\t\t\t\t// New notification received\n\t\t\t\t\t\t\t\t\tif (payload.new) {\n\t\t\t\t\t\t\t\t\t\tconst notification = payload.new as Notification;\n\t\t\t\t\t\t\t\t\t\tget().addNotification(notification);\n\n\t\t\t\t\t\t\t\t\t\t// Show toast notification for communication events\n\t\t\t\t\t\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\t\t\t\t\t\t// Check if this is a communication-related notification\n\t\t\t\t\t\t\t\t\t\t\tconst isCommunication =\n\t\t\t\t\t\t\t\t\t\t\t\tnotification.metadata?.communication_id;\n\n\t\t\t\t\t\t\t\t\t\t\tif (isCommunication) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Use communication notifications store for toast\n\t\t\t\t\t\t\t\t\t\t\t\timport(\"./communication-notifications-store\").then(\n\t\t\t\t\t\t\t\t\t\t\t\t\t({ useCommunicationNotificationsStore }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuseCommunicationNotificationsStore\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getState()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.showCommunicationToast(notification);\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// Use standard notification handling for non-communication events\n\t\t\t\t\t\t\t\t\t\t\t\t// Play notification sound if enabled\n\t\t\t\t\t\t\t\t\t\t\t\tconst soundEnabled = localStorage.getItem(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"notifications_sound_enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tif (soundEnabled !== \"false\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Play a subtle notification sound\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst audio = new Audio(\"/sounds/notification.mp3\");\n\t\t\t\t\t\t\t\t\t\t\t\t\taudio.volume = 0.3;\n\t\t\t\t\t\t\t\t\t\t\t\t\taudio.play().catch(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Ignore errors (user hasn't interacted with page yet)\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Show desktop notification if enabled and permission granted\n\t\t\t\t\t\t\t\t\t\t\t\tconst desktopEnabled = localStorage.getItem(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"notifications_desktop_enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\tdesktopEnabled !== \"false\" &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Notification\" in window &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tNotification.permission === \"granted\"\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Notification(notification.title, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: notification.message,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ticon: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbadge: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttag: notification.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.on(\n\t\t\t\t\t\t\t\t\"postgres_changes\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tevent: \"UPDATE\",\n\t\t\t\t\t\t\t\t\tschema: \"public\",\n\t\t\t\t\t\t\t\t\ttable: \"notifications\",\n\t\t\t\t\t\t\t\t\tfilter: `user_id=eq.${userId}`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(payload: RealtimePostgresChangesPayload<Notification>) => {\n\t\t\t\t\t\t\t\t\t// Notification updated\n\t\t\t\t\t\t\t\t\tif (payload.new) {\n\t\t\t\t\t\t\t\t\t\tconst notification = payload.new as Notification;\n\t\t\t\t\t\t\t\t\t\tget().updateNotification(notification.id, notification);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.on(\n\t\t\t\t\t\t\t\t\"postgres_changes\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tevent: \"DELETE\",\n\t\t\t\t\t\t\t\t\tschema: \"public\",\n\t\t\t\t\t\t\t\t\ttable: \"notifications\",\n\t\t\t\t\t\t\t\t\tfilter: `user_id=eq.${userId}`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(payload: RealtimePostgresChangesPayload<Notification>) => {\n\t\t\t\t\t\t\t\t\t// Notification deleted\n\t\t\t\t\t\t\t\t\tif (payload.old) {\n\t\t\t\t\t\t\t\t\t\tget().removeNotification((payload.old as Notification).id);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.subscribe((status, _err) => {\n\t\t\t\t\t\t\t\tif (status === \"SUBSCRIBED\") {\n\t\t\t\t\t\t\t\t\tset({ error: null }); // Clear any previous errors\n\t\t\t\t\t\t\t\t} else if (status === \"CHANNEL_ERROR\") {\n\t\t\t\t\t\t\t\t\t// Don't set error state to avoid breaking the UI\n\t\t\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else if (status === \"TIMED_OUT\") {\n\t\t\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else if (status === \"CLOSED\") {\n\t\t\t\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tset({\n\t\t\t\t\t\t\trealtimeChannel: channel,\n\t\t\t\t\t\t\tsubscriptionPromise: null, // Clear promise when done\n\t\t\t\t\t\t});\n\t\t\t\t\t})(); // End of async IIFE\n\n\t\t\t\t\t// Set the promise immediately to prevent concurrent calls\n\t\t\t\t\tset({ subscriptionPromise });\n\t\t\t\t\treturn subscriptionPromise;\n\t\t\t\t} catch (_error) {\n\t\t\t\t\t// App will still work without realtime, so don't set error state\n\t\t\t\t\tset({\n\t\t\t\t\t\tisSubscribed: false,\n\t\t\t\t\t\trealtimeChannel: null,\n\t\t\t\t\t\tsubscriptionPromise: null,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tunsubscribe: () => {\n\t\t\t\tconst state = get();\n\n\t\t\t\tif (state.realtimeChannel) {\n\t\t\t\t\tstate.realtimeChannel.unsubscribe();\n\t\t\t\t\tset({ realtimeChannel: null, isSubscribed: false });\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// ===============================================================================\n\t\t\t// Utility\n\t\t\t// ===============================================================================\n\n\t\t\treset: () => set(initialState),\n\t\t}),\n\t\t{ name: \"NotificationsStore\" },\n\t),\n);\n\nif (typeof window !== \"undefined\") {\n\twindow.addEventListener(COMMUNICATION_MARK_AS_READ_EVENT, (event: Event) => {\n\t\tconst { detail } = event as CustomEvent<CommunicationMarkAsReadDetail>;\n\t\tconst notificationId = detail?.notificationId;\n\n\t\tif (!notificationId) {\n\t\t\treturn;\n\t\t}\n\n\t\tuseNotificationsStore.getState().optimisticMarkAsRead(notificationId);\n\t});\n}\n\n// =====================================================================================\n// Selectors (for optimized re-renders)\n// =====================================================================================\n\n/**\n * Get only unread notifications\n */\nconst selectUnreadNotifications = (state: NotificationsState) =>\n\tstate.notifications.filter((n) => !n.read);\n\n/**\n * Get notifications by type\n */\nconst selectNotificationsByType =\n\t(type: NotificationType) => (state: NotificationsState) =>\n\t\tstate.notifications.filter((n) => n.type === type);\n\n/**\n * Get notifications by priority\n */\nconst selectNotificationsByPriority =\n\t(priority: NotificationPriority) => (state: NotificationsState) =>\n\t\tstate.notifications.filter((n) => n.priority === priority);\n\n/**\n * Get urgent unread notifications\n */\nconst selectUrgentUnreadNotifications = (state: NotificationsState) =>\n\tstate.notifications.filter((n) => !n.read && n.priority === \"urgent\");\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;CAgBC;;;;AAMD;AACA;AACA;AACA;;;;;AAmDA,gBAAgB;AAChB,MAAM,eAAe;IACpB,eAAe,EAAE;IACjB,aAAa;IACb,WAAW;IACX,cAAc;IACd,OAAO;IACP,iBAAiB;IACjB,qBAAqB;AACtB;AAMO,MAAM,wBAAwB,IAAA,4VAAM,IAC1C,IAAA,mWAAQ,EACP,CAAC,KAAK,MAAQ,CAAC;QACd,GAAG,YAAY;QAEf,kFAAkF;QAClF,sBAAsB;QACtB,kFAAkF;QAElF,kBAAkB,CAAC;YAClB,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;YAC/D,IAAI;gBAAE;gBAAe;YAAY;QAClC;QAEA,iBAAiB,CAAC,eACjB,IAAI,CAAC;gBACJ,MAAM,SAAS,MAAM,aAAa,CAAC,IAAI,CACtC,CAAC,IAAM,EAAE,EAAE,KAAK,aAAa,EAAE;gBAEhC,IAAI,QAAQ;oBACX,OAAO;gBACR;gBAEA,MAAM,mBAAmB;oBAAC;uBAAiB,MAAM,aAAa;iBAAC;gBAC/D,MAAM,cAAc,iBAAiB,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;gBAElE,OAAO;oBACN,eAAe;oBACf;gBACD;YACD;QAED,oBAAoB,CAAC,IAAI,UACxB,IAAI,CAAC;gBACJ,MAAM,gBAAgB,MAAM,aAAa,CAAC,GAAG,CAAC,CAAC,IAC9C,EAAE,EAAE,KAAK,KAAK;wBAAE,GAAG,CAAC;wBAAE,GAAG,OAAO;oBAAC,IAAI;gBAEtC,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;gBAE/D,OAAO;oBAAE;oBAAe;gBAAY;YACrC;QAED,oBAAoB,CAAC,KACpB,IAAI,CAAC;gBACJ,MAAM,gBAAgB,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;gBACjE,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;gBAE/D,OAAO;oBAAE;oBAAe;gBAAY;YACrC;QAED,gBAAgB,CAAC,cAAgB,IAAI;gBAAE;YAAY;QAEnD,YAAY,CAAC,YAAc,IAAI;gBAAE;YAAU;QAE3C,UAAU,CAAC,QAAU,IAAI;gBAAE;YAAM;QAEjC,kFAAkF;QAClF,qBAAqB;QACrB,kFAAkF;QAElF,sBAAsB,CAAC,KACtB,IAAI,CAAC;gBACJ,MAAM,gBAAgB,MAAM,aAAa,CAAC,GAAG,CAAC,CAAC,IAC9C,EAAE,EAAE,KAAK,KACN;wBAAE,GAAG,CAAC;wBAAE,MAAM;wBAAM,SAAS,IAAI,OAAO,WAAW;oBAAG,IACtD;gBAEJ,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;gBAE/D,OAAO;oBAAE;oBAAe;gBAAY;YACrC;QAED,wBAAwB,CAAC,KACxB,IAAI,CAAC;gBACJ,MAAM,gBAAgB,MAAM,aAAa,CAAC,GAAG,CAAC,CAAC,IAC9C,EAAE,EAAE,KAAK,KAAK;wBAAE,GAAG,CAAC;wBAAE,MAAM;wBAAO,SAAS;oBAAK,IAAI;gBAEtD,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;gBAE/D,OAAO;oBAAE;oBAAe;gBAAY;YACrC;QAED,yBAAyB,IACxB,IAAI,CAAC;gBACJ,MAAM,gBAAgB,MAAM,aAAa,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;wBACrD,GAAG,CAAC;wBACJ,MAAM;wBACN,SAAS,EAAE,OAAO,IAAI,IAAI,OAAO,WAAW;oBAC7C,CAAC;gBAED,OAAO;oBAAE;oBAAe,aAAa;gBAAE;YACxC;QAED,kBAAkB,CAAC,KAClB,IAAI,CAAC;gBACJ,MAAM,gBAAgB,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;gBACjE,MAAM,cAAc,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,EAAE,MAAM;gBAE/D,OAAO;oBAAE;oBAAe;gBAAY;YACrC;QAED,kFAAkF;QAClF,mCAAmC;QACnC,kFAAkF;QAElF,WAAW,OAAO;YACjB,IAAI;gBACH,MAAM,QAAQ;gBAEd,mEAAmE;gBACnE,IAAI,MAAM,mBAAmB,EAAE;oBAC9B,OAAO,MAAM,mBAAmB;gBACjC;gBAEA,wCAAwC;gBACxC,IAAI,MAAM,YAAY,IAAI,MAAM,eAAe,EAAE;oBAChD,OAAO,QAAQ,OAAO;gBACvB;gBAEA,0DAA0D;gBAC1D,MAAM,sBAAsB,CAAC;oBAC5B,+DAA+D;oBAC/D,IAAI;wBAAE,cAAc;oBAAK;oBAEzB,MAAM,WAAW,IAAA,qJAAY;oBAE7B,IAAI,CAAC,UAAU;wBACd,IAAI;4BACH,cAAc;wBACf;wBACA;oBACD;oBAEA,4CAA4C;oBAC5C,MAAM,UAAU,SACd,OAAO,CAAC,yBACR,EAAE,CACF,oBACA;wBACC,OAAO;wBACP,QAAQ;wBACR,OAAO;wBACP,QAAQ,CAAC,WAAW,EAAE,QAAQ;oBAC/B,GACA,CAAC;wBACA,4BAA4B;wBAC5B,IAAI,QAAQ,GAAG,EAAE;4BAChB,MAAM,eAAe,QAAQ,GAAG;4BAChC,MAAM,eAAe,CAAC;4BAEtB,mDAAmD;4BACnD;;wBA+CD;oBACD,GAEA,EAAE,CACF,oBACA;wBACC,OAAO;wBACP,QAAQ;wBACR,OAAO;wBACP,QAAQ,CAAC,WAAW,EAAE,QAAQ;oBAC/B,GACA,CAAC;wBACA,uBAAuB;wBACvB,IAAI,QAAQ,GAAG,EAAE;4BAChB,MAAM,eAAe,QAAQ,GAAG;4BAChC,MAAM,kBAAkB,CAAC,aAAa,EAAE,EAAE;wBAC3C;oBACD,GAEA,EAAE,CACF,oBACA;wBACC,OAAO;wBACP,QAAQ;wBACR,OAAO;wBACP,QAAQ,CAAC,WAAW,EAAE,QAAQ;oBAC/B,GACA,CAAC;wBACA,uBAAuB;wBACvB,IAAI,QAAQ,GAAG,EAAE;4BAChB,MAAM,kBAAkB,CAAC,AAAC,QAAQ,GAAG,CAAkB,EAAE;wBAC1D;oBACD,GAEA,SAAS,CAAC,CAAC,QAAQ;wBACnB,IAAI,WAAW,cAAc;4BAC5B,IAAI;gCAAE,OAAO;4BAAK,IAAI,4BAA4B;wBACnD,OAAO,IAAI,WAAW,iBAAiB;4BACtC,iDAAiD;4BACjD,IAAI;gCACH,cAAc;gCACd,iBAAiB;4BAClB;wBACD,OAAO,IAAI,WAAW,aAAa;4BAClC,IAAI;gCACH,cAAc;gCACd,iBAAiB;4BAClB;wBACD,OAAO,IAAI,WAAW,UAAU;4BAC/B,IAAI;gCACH,cAAc;gCACd,iBAAiB;4BAClB;wBACD;oBACD;oBAED,IAAI;wBACH,iBAAiB;wBACjB,qBAAqB;oBACtB;gBACD,CAAC,KAAK,oBAAoB;gBAE1B,0DAA0D;gBAC1D,IAAI;oBAAE;gBAAoB;gBAC1B,OAAO;YACR,EAAE,OAAO,QAAQ;gBAChB,iEAAiE;gBACjE,IAAI;oBACH,cAAc;oBACd,iBAAiB;oBACjB,qBAAqB;gBACtB;YACD;QACD;QAEA,aAAa;YACZ,MAAM,QAAQ;YAEd,IAAI,MAAM,eAAe,EAAE;gBAC1B,MAAM,eAAe,CAAC,WAAW;gBACjC,IAAI;oBAAE,iBAAiB;oBAAM,cAAc;gBAAM;YAClD;QACD;QAEA,kFAAkF;QAClF,UAAU;QACV,kFAAkF;QAElF,OAAO,IAAM,IAAI;IAClB,CAAC,GACD;IAAE,MAAM;AAAqB;AAI/B;;AAaA,wFAAwF;AACxF,uCAAuC;AACvC,wFAAwF;AAExF;;CAEC,GACD,MAAM,4BAA4B,CAAC,QAClC,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI;AAE1C;;CAEC,GACD,MAAM,4BACL,CAAC,OAA2B,CAAC,QAC5B,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,IAAI,KAAK;AAE/C;;CAEC,GACD,MAAM,gCACL,CAAC,WAAmC,CAAC,QACpC,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK;AAEnD;;CAEC,GACD,MAAM,kCAAkC,CAAC,QACxC,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,IAAI,IAAI,EAAE,QAAQ,KAAK"}},
    {"offset": {"line": 662, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/sync-store.ts"],"sourcesContent":["/**\n * Sync Store - Global state management for sync operations\n *\n * Manages:\n * - Active sync operations (bulk send, data sync, etc.)\n * - Offline queue\n * - Real-time progress tracking\n * - Operation history\n */\n\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\n\nexport type SyncOperationType =\n\t| \"bulk_send_invoices\"\n\t| \"bulk_send_estimates\"\n\t| \"data_sync\"\n\t| \"offline_sync\"\n\t| \"file_upload\"\n\t| \"export\";\n\nexport type SyncOperationStatus =\n\t| \"pending\"\n\t| \"in_progress\"\n\t| \"completed\"\n\t| \"failed\"\n\t| \"queued\";\n\nexport type SyncOperation = {\n\tid: string;\n\ttype: SyncOperationType;\n\tstatus: SyncOperationStatus;\n\ttitle: string;\n\tdescription?: string;\n\tprogress: number; // 0-100\n\ttotal?: number;\n\tcurrent?: number;\n\tstartedAt: Date;\n\tcompletedAt?: Date;\n\terror?: string;\n\tmetadata?: Record<string, any>;\n};\n\nexport type OfflineOperation = {\n\tid: string;\n\ttype: SyncOperationType;\n\taction: string;\n\tpayload: any;\n\tcreatedAt: Date;\n\tretryCount: number;\n};\n\ntype SyncState = {\n\t// Active operations\n\toperations: SyncOperation[];\n\n\t// Offline queue\n\tofflineQueue: OfflineOperation[];\n\tisOnline: boolean;\n\n\t// UI state\n\tisPanelOpen: boolean;\n\n\t// Actions\n\tstartOperation: (\n\t\toperation: Omit<SyncOperation, \"id\" | \"startedAt\" | \"progress\" | \"status\">,\n\t) => string;\n\tupdateOperation: (id: string, updates: Partial<SyncOperation>) => void;\n\tcompleteOperation: (id: string, success: boolean, error?: string) => void;\n\tremoveOperation: (id: string) => void;\n\tclearCompleted: () => void;\n\n\t// Offline queue actions\n\tqueueOperation: (\n\t\toperation: Omit<OfflineOperation, \"id\" | \"createdAt\" | \"retryCount\">,\n\t) => void;\n\tremoveFromQueue: (id: string) => void;\n\tclearQueue: () => void;\n\tsetOnlineStatus: (isOnline: boolean) => void;\n\n\t// UI actions\n\ttogglePanel: () => void;\n\topenPanel: () => void;\n\tclosePanel: () => void;\n};\n\nexport const useSyncStore = create<SyncState>()(\n\tpersist(\n\t\t(set, get) => ({\n\t\t\toperations: [],\n\t\t\tofflineQueue: [],\n\t\t\tisOnline: typeof navigator !== \"undefined\" ? navigator.onLine : true,\n\t\t\tisPanelOpen: false,\n\n\t\t\tstartOperation: (operation) => {\n\t\t\t\tconst id = `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\t\t\t\tconst newOperation: SyncOperation = {\n\t\t\t\t\t...operation,\n\t\t\t\t\tid,\n\t\t\t\t\tstatus: \"in_progress\",\n\t\t\t\t\tprogress: 0,\n\t\t\t\t\tstartedAt: new Date(),\n\t\t\t\t};\n\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: [...state.operations, newOperation],\n\t\t\t\t}));\n\n\t\t\t\treturn id;\n\t\t\t},\n\n\t\t\tupdateOperation: (id, updates) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.map((op) =>\n\t\t\t\t\t\top.id === id ? { ...op, ...updates } : op,\n\t\t\t\t\t),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tcompleteOperation: (id, success, error) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.map((op) =>\n\t\t\t\t\t\top.id === id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...op,\n\t\t\t\t\t\t\t\t\tstatus: success ? \"completed\" : \"failed\",\n\t\t\t\t\t\t\t\t\tprogress: success ? 100 : op.progress,\n\t\t\t\t\t\t\t\t\tcompletedAt: new Date(),\n\t\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: op,\n\t\t\t\t\t),\n\t\t\t\t}));\n\n\t\t\t\t// Auto-remove completed operations after 10 seconds\n\t\t\t\tif (success) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tget().removeOperation(id);\n\t\t\t\t\t}, 10_000);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremoveOperation: (id) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.filter((op) => op.id !== id),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tclearCompleted: () => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\toperations: state.operations.filter(\n\t\t\t\t\t\t(op) => op.status !== \"completed\" && op.status !== \"failed\",\n\t\t\t\t\t),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tqueueOperation: (operation) => {\n\t\t\t\tconst id = `queue_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\t\t\t\tconst queuedOp: OfflineOperation = {\n\t\t\t\t\t...operation,\n\t\t\t\t\tid,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tretryCount: 0,\n\t\t\t\t};\n\n\t\t\t\tset((state) => ({\n\t\t\t\t\tofflineQueue: [...state.offlineQueue, queuedOp],\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tremoveFromQueue: (id) => {\n\t\t\t\tset((state) => ({\n\t\t\t\t\tofflineQueue: state.offlineQueue.filter((op) => op.id !== id),\n\t\t\t\t}));\n\t\t\t},\n\n\t\t\tclearQueue: () => {\n\t\t\t\tset({ offlineQueue: [] });\n\t\t\t},\n\n\t\t\tsetOnlineStatus: (isOnline) => {\n\t\t\t\tset({ isOnline });\n\t\t\t},\n\n\t\t\ttogglePanel: () => {\n\t\t\t\tset((state) => ({ isPanelOpen: !state.isPanelOpen }));\n\t\t\t},\n\n\t\t\topenPanel: () => {\n\t\t\t\tset({ isPanelOpen: true });\n\t\t\t},\n\n\t\t\tclosePanel: () => {\n\t\t\t\tset({ isPanelOpen: false });\n\t\t\t},\n\t\t}),\n\t\t{\n\t\t\tname: \"thorbis-sync-store\",\n\t\t\tskipHydration: true, // CRITICAL: Prevents hydration mismatch with Next.js 16\n\t\t\tpartialize: (state) => ({\n\t\t\t\tofflineQueue: state.offlineQueue,\n\t\t\t\t// Don't persist operations or UI state\n\t\t\t}),\n\t\t},\n\t),\n);\n\n// Hook to get active operations count\nconst useActiveOperationsCount = () =>\n\tuseSyncStore(\n\t\t(state) =>\n\t\t\tstate.operations.filter((op) => op.status === \"in_progress\").length,\n\t);\n\n// Hook to get queued operations count\nconst useQueuedOperationsCount = () =>\n\tuseSyncStore((state) => state.offlineQueue.length);\n\n// Hook to get if syncing\nconst useIsSyncing = () =>\n\tuseSyncStore((state) =>\n\t\tstate.operations.some((op) => op.status === \"in_progress\"),\n\t);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 797, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/notifications-dropdown.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * NotificationsDropdown - Client Component\n *\n * Client-side features:\n * - Interactive dropdown with notifications\n * - Real-time updates via Zustand store and Supabase Realtime\n * - Optimistic updates for better UX\n * - Mark as read/delete functionality\n */\n\nimport {\n\tAlertCircle,\n\tBell,\n\tCheck,\n\tCheckCheck,\n\tCheckCircle2,\n\tClock,\n\tCreditCard,\n\tDollarSign,\n\tLoader2,\n\tMessageSquare,\n\tPhone,\n\tSettings,\n\tTrash2,\n\tUserPlus,\n\tWrench,\n\tX,\n\tXCircle,\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { useEffect, useRef, useState } from \"react\";\nimport {\n\tdeleteNotification as deleteNotificationAction,\n\tmarkAllAsRead as markAllAsReadAction,\n\tmarkAsRead as markAsReadAction,\n} from \"@/actions/notifications\";\nimport type { NotificationType } from \"@/lib/stores/notifications-store\";\nimport { useNotificationsStore } from \"@/lib/stores/notifications-store\";\nimport { useSyncStore } from \"@/lib/stores/sync-store\";\nimport { createClient } from \"@/lib/supabase/client\";\n\n// Time constants in milliseconds\nconst MS_PER_SECOND = 1000;\nconst MS_PER_MINUTE = 60 * MS_PER_SECOND;\nconst MS_PER_HOUR = 60 * MS_PER_MINUTE;\n\nconst notificationIcons: Record<NotificationType, typeof Bell> = {\n\tmessage: MessageSquare,\n\talert: AlertCircle,\n\tpayment: DollarSign,\n\tjob: Wrench,\n\tteam: UserPlus,\n\tsystem: Settings,\n};\n\nconst notificationColors: Record<NotificationType, string> = {\n\tmessage: \"text-primary\",\n\talert: \"text-warning\",\n\tpayment: \"text-success\",\n\tjob: \"text-accent-foreground\",\n\tteam: \"text-cyan-500\",\n\tsystem: \"text-muted-foreground\",\n};\n\n// Display constants\nconst ONE_MINUTE = 60;\nconst ONE_HOUR = 24;\nconst ONE_WEEK = 7;\n\nfunction formatBadgeCount(count: number): string {\n\tif (count <= 9) {\n\t\treturn count.toString();\n\t}\n\tif (count <= 99) {\n\t\treturn \"99+\";\n\t}\n\tif (count <= 999) {\n\t\treturn \"999+\";\n\t}\n\treturn \"1K+\";\n}\n\nfunction formatTimestamp(date: Date): string {\n\tconst now = new Date();\n\tconst diffMs = now.getTime() - date.getTime();\n\tconst diffMins = Math.floor(diffMs / MS_PER_MINUTE);\n\tconst diffHours = Math.floor(diffMs / MS_PER_HOUR);\n\tconst diffDays = Math.floor(diffMs / (MS_PER_HOUR * 24));\n\n\tif (diffMins < 1) {\n\t\treturn \"Just now\";\n\t}\n\tif (diffMins < ONE_MINUTE) {\n\t\treturn `${diffMins}m ago`;\n\t}\n\tif (diffHours < ONE_HOUR) {\n\t\treturn `${diffHours}h ago`;\n\t}\n\tif (diffDays < ONE_WEEK) {\n\t\treturn `${diffDays}d ago`;\n\t}\n\n\treturn date.toLocaleDateString();\n}\n\nfunction NotificationBadge({ count }: { count: number }) {\n\tif (count === 0) {\n\t\treturn null;\n\t}\n\treturn (\n\t\t<span className=\"bg-destructive absolute -top-1 -right-1 flex h-[18px] min-w-[18px] items-center justify-center rounded-full px-1.5 text-[0.625rem] leading-none font-bold text-white\">\n\t\t\t{formatBadgeCount(count)}\n\t\t</span>\n\t);\n}\n\nfunction EmptyState() {\n\treturn (\n\t\t<div className=\"flex flex-col items-center justify-center py-12 text-center\">\n\t\t\t<Bell className=\"text-muted-foreground/30 mb-3 size-12\" />\n\t\t\t<p className=\"text-muted-foreground text-sm font-medium\">\n\t\t\t\tAll caught up!\n\t\t\t</p>\n\t\t\t<p className=\"text-muted-foreground text-xs\">No new notifications</p>\n\t\t</div>\n\t);\n}\n\ntype NotificationsDropdownProps = {\n\thasPhoneNumbers?: boolean;\n\thasPayrixAccount?: boolean;\n\tpayrixStatus?: string | null;\n};\n\nexport function NotificationsDropdown({\n\thasPhoneNumbers = false,\n\thasPayrixAccount = false,\n\tpayrixStatus = null,\n}: NotificationsDropdownProps = {}) {\n\tconst [isOpen, setIsOpen] = useState(false);\n\tconst dropdownRef = useRef<HTMLDivElement>(null);\n\n\t// Get notifications from Zustand store\n\tconst notifications = useNotificationsStore((state) => state.notifications);\n\tconst unreadCount = useNotificationsStore((state) => state.unreadCount);\n\tconst setNotifications = useNotificationsStore(\n\t\t(state) => state.setNotifications,\n\t);\n\tconst optimisticMarkAsRead = useNotificationsStore(\n\t\t(state) => state.optimisticMarkAsRead,\n\t);\n\tconst optimisticMarkAllAsRead = useNotificationsStore(\n\t\t(state) => state.optimisticMarkAllAsRead,\n\t);\n\tconst optimisticDelete = useNotificationsStore(\n\t\t(state) => state.optimisticDelete,\n\t);\n\tconst subscribe = useNotificationsStore((state) => state.subscribe);\n\tconst unsubscribe = useNotificationsStore((state) => state.unsubscribe);\n\n\t// Get sync operations from sync store\n\tconst operations = useSyncStore((state) => state.operations ?? []);\n\tconst offlineQueue = useSyncStore((state) => state.offlineQueue ?? []);\n\tconst clearCompleted = useSyncStore((state) => state.clearCompleted);\n\n\t// Filter for active operations\n\tconst activeOperations = operations.filter(\n\t\t(op) => op.status === \"in_progress\",\n\t);\n\tconst recentOperations = operations.filter(\n\t\t(op) => op.status === \"completed\" || op.status === \"failed\",\n\t);\n\n\tconst hasSyncActivity =\n\t\tactiveOperations.length > 0 || offlineQueue.length > 0;\n\tconst syncBadgeCount = activeOperations.length + offlineQueue.length;\n\tconst totalBadgeCount = unreadCount + syncBadgeCount;\n\n\t// Load notifications and set up realtime subscription on mount\n\tconst hasInitializedRef = useRef(false);\n\n\tuseEffect(() => {\n\t\tif (!isOpen || hasInitializedRef.current) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet cancelled = false;\n\n\t\tasync function initialize() {\n\t\t\ttry {\n\t\t\t\tconst supabase = createClient();\n\n\t\t\t\tif (!supabase) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tdata: { user },\n\t\t\t\t} = await supabase.auth.getUser();\n\n\t\t\t\tif (!user) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { data, error } = await supabase\n\t\t\t\t\t.from(\"notifications\")\n\t\t\t\t\t.select(\"*\")\n\t\t\t\t\t.eq(\"user_id\", user.id)\n\t\t\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t\t\t.range(0, 49);\n\n\t\t\t\tif (!cancelled && !error && data) {\n\t\t\t\t\tsetNotifications(data);\n\t\t\t\t}\n\n\t\t\t\tif (!cancelled) {\n\t\t\t\t\tawait subscribe(user.id);\n\t\t\t\t\thasInitializedRef.current = true;\n\t\t\t\t}\n\t\t\t} catch (_error) {\n\t\t\t\t// Ignore initialization errors - component can retry later\n\t\t\t}\n\t\t}\n\n\t\tinitialize();\n\n\t\treturn () => {\n\t\t\tcancelled = true;\n\t\t};\n\t}, [isOpen, setNotifications, subscribe]);\n\n\tuseEffect(() => {\n\t\treturn () => {\n\t\t\tunsubscribe();\n\t\t};\n\t}, [unsubscribe]);\n\n\t// Handle click outside to close dropdown\n\tuseEffect(() => {\n\t\tconst handleClickOutside = (event: MouseEvent) => {\n\t\t\tif (\n\t\t\t\tdropdownRef.current &&\n\t\t\t\t!dropdownRef.current.contains(event.target as Node)\n\t\t\t) {\n\t\t\t\tsetIsOpen(false);\n\t\t\t}\n\t\t};\n\n\t\tif (isOpen) {\n\t\t\tdocument.addEventListener(\"mousedown\", handleClickOutside);\n\t\t}\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"mousedown\", handleClickOutside);\n\t\t};\n\t}, [isOpen]);\n\n\t// Mark notification as read with optimistic update\n\tconst markAsRead = async (id: string) => {\n\t\t// Optimistic update\n\t\toptimisticMarkAsRead(id);\n\n\t\t// Server action\n\t\tconst result = await markAsReadAction(id);\n\t\tif (!result.success) {\n\t\t\t// Optimistic update already applied - log error but don't block UI\n\t\t\tconsole.error(\"Failed to mark notification as read:\", result.error);\n\t\t}\n\t};\n\n\t// Mark all notifications as read with optimistic update\n\tconst markAllAsRead = async () => {\n\t\t// Optimistic update\n\t\toptimisticMarkAllAsRead();\n\n\t\t// Server action\n\t\tconst result = await markAllAsReadAction();\n\t\tif (!result.success) {\n\t\t\t// Optimistic update already applied - log error but don't block UI\n\t\t\tconsole.error(\"Failed to mark all notifications as read:\", result.error);\n\t\t}\n\t};\n\n\t// Delete notification with optimistic update\n\tconst deleteNotification = async (id: string) => {\n\t\t// Optimistic update\n\t\toptimisticDelete(id);\n\n\t\t// Server action\n\t\tconst result = await deleteNotificationAction(id);\n\t\tif (!result.success) {\n\t\t\t// Optimistic update already applied - log error but don't block UI\n\t\t\tconsole.error(\"Failed to delete notification:\", result.error);\n\t\t}\n\t};\n\n\treturn (\n\t\t<div className=\"relative overflow-visible\" ref={dropdownRef}>\n\t\t\t<button\n\t\t\t\tclassName=\"hover-gradient hover:border-primary/20 hover:bg-primary/10 hover:text-primary focus-visible:ring-ring/50 relative flex h-8 w-8 items-center justify-center rounded-md border border-transparent transition-all outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50\"\n\t\t\t\tonClick={() => setIsOpen(!isOpen)}\n\t\t\t\ttitle={\n\t\t\t\t\thasSyncActivity ? \"Notifications & Sync Status\" : \"Notifications\"\n\t\t\t\t}\n\t\t\t\ttype=\"button\"\n\t\t\t>\n\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t<Bell className=\"size-4\" />\n\t\t\t\t\t{hasSyncActivity && (\n\t\t\t\t\t\t<Loader2 className=\"text-primary absolute -top-1 -right-1 size-2.5 animate-spin\" />\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t<NotificationBadge count={totalBadgeCount} />\n\t\t\t\t<span className=\"sr-only\">\n\t\t\t\t\tNotifications {unreadCount > 0 && `(${unreadCount} unread)`}\n\t\t\t\t\t{hasSyncActivity && `  ${syncBadgeCount} syncing`}\n\t\t\t\t</span>\n\t\t\t</button>\n\n\t\t\t{isOpen && (\n\t\t\t\t<div className=\"bg-popover text-popover-foreground absolute top-full right-0 z-50 mt-2 flex w-[380px] max-w-[calc(100vw-2rem)] flex-col rounded-lg border shadow-lg\">\n\t\t\t\t\t{/* Header */}\n\t\t\t\t\t<div className=\"flex items-center justify-between border-b px-4 py-2.5\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<h3 className=\"text-sm font-semibold\">\n\t\t\t\t\t\t\t\t{hasSyncActivity ? \"Sync & Notifications\" : \"Notifications\"}\n\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t{(unreadCount > 0 || hasSyncActivity) && (\n\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t{hasSyncActivity && `${syncBadgeCount} syncing`}\n\t\t\t\t\t\t\t\t\t{hasSyncActivity && unreadCount > 0 && \"  \"}\n\t\t\t\t\t\t\t\t\t{unreadCount > 0 && `${unreadCount} unread`}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t{unreadCount > 0 && (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tclassName=\"hover:bg-accent flex h-7 w-7 items-center justify-center rounded-md transition-colors\"\n\t\t\t\t\t\t\t\t\tonClick={markAllAsRead}\n\t\t\t\t\t\t\t\t\ttitle=\"Mark all as read\"\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<CheckCheck className=\"size-3.5\" />\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tclassName=\"hover:bg-accent flex h-7 w-7 items-center justify-center rounded-md transition-colors\"\n\t\t\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<X className=\"size-3.5\" />\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Sync Operations */}\n\t\t\t\t\t{(activeOperations.length > 0 ||\n\t\t\t\t\t\tofflineQueue.length > 0 ||\n\t\t\t\t\t\trecentOperations.length > 0) && (\n\t\t\t\t\t\t<div className=\"border-b\">\n\t\t\t\t\t\t\t{/* Active Operations */}\n\t\t\t\t\t\t\t{activeOperations.length > 0 && (\n\t\t\t\t\t\t\t\t<div className=\"space-y-1 px-4 py-3\">\n\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground mb-2 text-xs font-medium tracking-wider uppercase\">\n\t\t\t\t\t\t\t\t\t\tActive\n\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t{activeOperations.map((op) => (\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"bg-primary/5 flex items-start gap-2 rounded-md p-2\"\n\t\t\t\t\t\t\t\t\t\t\tkey={op.id}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<Loader2 className=\"text-primary mt-0.5 size-3.5 shrink-0 animate-spin\" />\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm leading-tight font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{op.title}\n\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t{op.description && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{op.description}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t{op.total && op.total > 0 && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"mt-1 space-y-0.5\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"bg-muted h-1 overflow-hidden rounded-full\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"bg-primary h-full transition-all\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth: `${((op.current ?? 0) / op.total) * 100}%`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-[0.625rem]\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{op.current ?? 0} / {op.total}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t{/* Offline Queue */}\n\t\t\t\t\t\t\t{offlineQueue.length > 0 && (\n\t\t\t\t\t\t\t\t<div className=\"space-y-1 px-4 py-3\">\n\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground mb-2 flex items-center gap-1.5 text-xs font-medium tracking-wider uppercase\">\n\t\t\t\t\t\t\t\t\t\t<span className=\"size-1.5 animate-pulse rounded-full bg-orange-500\" />\n\t\t\t\t\t\t\t\t\t\tQueued (Offline)\n\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t{offlineQueue.map((op) => (\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"flex items-start gap-2 rounded-md bg-orange-50 p-2 dark:bg-orange-950/20\"\n\t\t\t\t\t\t\t\t\t\t\tkey={op.id}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<Clock className=\"mt-0.5 size-3.5 shrink-0 text-orange-500\" />\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm leading-tight font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{op.action}\n\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"mt-0.5 text-[0.625rem] text-orange-600 dark:text-orange-400\">\n\t\t\t\t\t\t\t\t\t\t\t\t\tWill sync when online\n\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t{/* Recent Operations */}\n\t\t\t\t\t\t\t{recentOperations.length > 0 && (\n\t\t\t\t\t\t\t\t<div className=\"space-y-1 px-4 py-3\">\n\t\t\t\t\t\t\t\t\t<div className=\"mb-2 flex items-center justify-between\">\n\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs font-medium tracking-wider uppercase\">\n\t\t\t\t\t\t\t\t\t\t\tRecent\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"text-muted-foreground hover:text-foreground text-xs\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={clearCompleted}\n\t\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\tClear\n\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t{recentOperations.map((op) => (\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclassName={`flex items-start gap-2 rounded-md p-2 ${\n\t\t\t\t\t\t\t\t\t\t\t\top.status === \"completed\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-green-50 dark:bg-green-950/20\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"bg-red-50 dark:bg-red-950/20\"\n\t\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\t\tkey={op.id}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{op.status === \"completed\" ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<CheckCircle2 className=\"mt-0.5 size-3.5 shrink-0 text-green-600 dark:text-green-400\" />\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\t<XCircle className=\"mt-0.5 size-3.5 shrink-0 text-red-600 dark:text-red-400\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm leading-tight font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{op.title}\n\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t{op.error && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-xs text-red-600 dark:text-red-400\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{op.error}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Notifications List */}\n\t\t\t\t\t<div className=\"max-h-[450px] overflow-y-auto\">\n\t\t\t\t\t\t{/* System Notification - Phone Numbers Setup Missing */}\n\t\t\t\t\t\t{!hasPhoneNumbers && (\n\t\t\t\t\t\t\t<div className=\"border-b\">\n\t\t\t\t\t\t\t\t<div className=\"group bg-warning/10 hover:bg-warning/15 relative px-4 py-3 transition-colors\">\n\t\t\t\t\t\t\t\t\t{/* Warning indicator */}\n\t\t\t\t\t\t\t\t\t<div className=\"bg-warning absolute top-0 left-0 h-full w-0.5\" />\n\n\t\t\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t\t\t{/* Icon */}\n\t\t\t\t\t\t\t\t\t\t<div className=\"text-warning mt-0.5 shrink-0\">\n\t\t\t\t\t\t\t\t\t\t\t<Phone className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t{/* Content */}\n\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1 space-y-1\">\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm leading-snug font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\tPhone System Not Configured\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs leading-relaxed\">\n\t\t\t\t\t\t\t\t\t\t\t\tYou cannot use calling, texting, or communication\n\t\t\t\t\t\t\t\t\t\t\t\tfeatures without setting up phone numbers. Complete the\n\t\t\t\t\t\t\t\t\t\t\t\tsetup to enable phone system capabilities.\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\n\t\t\t\t\t\t\t\t\t\t\t{/* Footer */}\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center justify-between gap-2 pt-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<AlertCircle className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\tSystem Alert\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t\t{/* Actions */}\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"bg-warning/20 text-warning hover:bg-warning/30 rounded px-2 py-1 text-xs font-medium transition-colors\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thref=\"/welcome?step=3\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComplete Setup\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* System Notification - Payrix Setup Missing */}\n\t\t\t\t\t\t{!hasPayrixAccount && (\n\t\t\t\t\t\t\t<div className=\"border-b\">\n\t\t\t\t\t\t\t\t<div className=\"group bg-warning/10 hover:bg-warning/15 relative px-4 py-3 transition-colors\">\n\t\t\t\t\t\t\t\t\t{/* Warning indicator */}\n\t\t\t\t\t\t\t\t\t<div className=\"bg-warning absolute top-0 left-0 h-full w-0.5\" />\n\n\t\t\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t\t\t{/* Icon */}\n\t\t\t\t\t\t\t\t\t\t<div className=\"text-warning mt-0.5 shrink-0\">\n\t\t\t\t\t\t\t\t\t\t\t<CreditCard className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t{/* Content */}\n\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1 space-y-1\">\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm leading-snug font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\tPayment Processing Not Configured\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs leading-relaxed\">\n\t\t\t\t\t\t\t\t\t\t\t\tYou cannot collect payments from customers without\n\t\t\t\t\t\t\t\t\t\t\t\tsetting up your merchant account. Complete the setup to\n\t\t\t\t\t\t\t\t\t\t\t\tstart accepting payments on invoices and estimates.\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\n\t\t\t\t\t\t\t\t\t\t\t{/* Footer */}\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center justify-between gap-2 pt-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<AlertCircle className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\tSystem Alert\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t\t{/* Actions */}\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"bg-warning/20 text-warning hover:bg-warning/30 rounded px-2 py-1 text-xs font-medium transition-colors\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thref=\"/welcome?step=5\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComplete Setup\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{notifications.length === 0 &&\n\t\t\t\t\t\thasPhoneNumbers &&\n\t\t\t\t\t\thasPayrixAccount ? (\n\t\t\t\t\t\t\t<EmptyState />\n\t\t\t\t\t\t) : notifications.length > 0 ? (\n\t\t\t\t\t\t\t<div className=\"divide-y\">\n\t\t\t\t\t\t\t\t{notifications.map((notification) => {\n\t\t\t\t\t\t\t\t\tconst Icon = notificationIcons[notification.type];\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclassName={`group hover:bg-accent/50 relative px-4 py-3 transition-colors ${\n\t\t\t\t\t\t\t\t\t\t\t\tnotification.read ? \"\" : \"bg-primary/5\"\n\t\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\t\tkey={notification.id}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{/* Unread indicator */}\n\t\t\t\t\t\t\t\t\t\t\t{!notification.read && (\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"bg-primary absolute top-0 left-0 h-full w-0.5\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex gap-3\">\n\t\t\t\t\t\t\t\t\t\t\t\t{/* Icon */}\n\t\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\t\tclassName={`mt-0.5 shrink-0 ${notificationColors[notification.type]}`}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Icon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t\t{/* Content */}\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1 space-y-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm leading-snug font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{notification.title}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs leading-relaxed\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{notification.message}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t{/* Footer */}\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center justify-between gap-2 pt-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Clock className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{formatTimestamp(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Date(notification.created_at),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/* Actions */}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{notification.action_url && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"text-primary hover:bg-primary/10 rounded px-2 py-1 text-xs font-medium transition-colors\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thref={notification.action_url}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmarkAsRead(notification.id);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetIsOpen(false);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{notification.action_label || \"View\"}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{!notification.read && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"hover:bg-accent flex h-6 w-6 items-center justify-center rounded transition-colors\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => markAsRead(notification.id)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle=\"Mark as read\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Check className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"hover:bg-destructive/10 hover:text-destructive flex h-6 w-6 items-center justify-center rounded transition-colors\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeleteNotification(notification.id)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle=\"Delete\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Trash2 className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t) : null}\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Footer */}\n\t\t\t\t\t{notifications.length > 0 && (\n\t\t\t\t\t\t<div className=\"border-t px-4 py-2\">\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\tclassName=\"text-primary hover:bg-accent flex items-center justify-center rounded-md py-1.5 text-xs font-medium transition-colors\"\n\t\t\t\t\t\t\t\thref=\"/dashboard/notifications\"\n\t\t\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tView all notifications\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1891, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/telnyx.ts"],"sourcesContent":["/**\n * Telnyx Server Actions\n *\n * Server-side actions for Telnyx VoIP operations:\n * - Phone number management\n * - Call operations\n * - SMS operations\n * - Voicemail operations\n *\n * All actions include proper authentication and authorization checks.\n */\n\n\"use server\";\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { revalidatePath } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tanswerCall,\n\thangupCall,\n\tinitiateCall,\n\trejectCall,\n\tstartRecording,\n\tstopRecording,\n} from \"@/lib/telnyx/calls\";\nimport { TELNYX_CONFIG } from \"@/lib/telnyx/client\";\nimport {\n\tvalidateCallConfig,\n\tvalidateSmsConfig,\n} from \"@/lib/telnyx/config-validator\";\nimport { verifyConnection } from \"@/lib/telnyx/connection-setup\";\nimport { formatPhoneNumber, sendMMS, sendSMS } from \"@/lib/telnyx/messaging\";\nimport { verifyMessagingProfile } from \"@/lib/telnyx/messaging-profile-setup\";\nimport {\n\ttype NumberFeature,\n\ttype NumberType,\n\tpurchaseNumber,\n\treleaseNumber,\n\tsearchAvailableNumbers,\n} from \"@/lib/telnyx/numbers\";\nimport {\n\tverifySmsCapability,\n\tverifyVoiceCapability,\n} from \"@/lib/telnyx/phone-number-setup\";\nimport {\n\ttype CompanyTelnyxSettingsRow,\n\tensureCompanyTelnyxSetup,\n\tfetchCompanyTelnyxSettings,\n} from \"@/lib/telnyx/provision-company\";\nimport type { Database, Json } from \"@/types/supabase\";\nimport { ensureMessagingCampaign } from \"./messaging-branding\";\n\ntype TypedSupabaseClient = SupabaseClient<Database>;\n\nfunction normalizePhoneNumber(phoneNumber: string): string {\n\treturn formatPhoneNumber(phoneNumber);\n}\n\nfunction extractAreaCode(phoneNumber: string): string | null {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn digits.slice(1, 4);\n\t}\n\tif (digits.length === 10) {\n\t\treturn digits.slice(0, 3);\n\t}\n\treturn null;\n}\n\nconst DEFAULT_MESSAGING_PROFILE_ID =\n\tprocess.env.TELNYX_DEFAULT_MESSAGING_PROFILE_ID ||\n\tprocess.env.NEXT_PUBLIC_TELNYX_MESSAGING_PROFILE_ID ||\n\t\"\";\n\nconst DEFAULT_PHONE_NUMBER_FEATURES: Json = [\"voice\", \"sms\", \"mms\"];\n\nfunction formatDisplayPhoneNumber(phoneNumber: string): string {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\n\t}\n\tif (digits.length === 10) {\n\t\treturn `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n\t}\n\treturn phoneNumber;\n}\n\nasync function getCompanyTelnyxSettings(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string | null,\n): Promise<CompanyTelnyxSettingsRow | null> {\n\tif (!companyId) {\n\t\treturn null;\n\t}\n\n\tconst existing = await fetchCompanyTelnyxSettings(supabase, companyId);\n\tif (existing && existing.status === \"ready\") {\n\t\treturn existing;\n\t}\n\n\tconst provisionResult = await ensureCompanyTelnyxSetup({\n\t\tcompanyId,\n\t\tsupabase,\n\t});\n\n\tif (!provisionResult.success) {\n\t\treturn null;\n\t}\n\n\treturn provisionResult.settings ?? null;\n}\n\nfunction normalizeBaseUrl(url: string): string {\n\tconst trimmed = url.trim().replace(/\\/+$/, \"\");\n\tif (/^https?:\\/\\//i.test(trimmed)) {\n\t\tif (/^http:\\/\\//i.test(trimmed) && !isLocalUrl(trimmed)) {\n\t\t\treturn trimmed.replace(/^http:\\/\\//i, \"https://\");\n\t\t}\n\t\treturn trimmed;\n\t}\n\treturn `https://${trimmed}`;\n}\n\nfunction isLocalUrl(url: string): boolean {\n\tconst lowered = url.toLowerCase();\n\treturn (\n\t\tlowered.includes(\"localhost\") ||\n\t\tlowered.includes(\"127.0.0.1\") ||\n\t\tlowered.includes(\"0.0.0.0\") ||\n\t\tlowered.endsWith(\".local\") ||\n\t\tlowered.includes(\"://local\")\n\t);\n}\n\nfunction shouldUseUrl(url: string): boolean {\n\tif (!url) {\n\t\treturn false;\n\t}\n\tconst trimmed = url.trim();\n\tif (!trimmed) {\n\t\treturn false;\n\t}\n\tconst isHostedProduction =\n\t\t(process.env.VERCEL === \"1\" && process.env.VERCEL_ENV === \"production\") ||\n\t\tprocess.env.DEPLOYMENT_ENV === \"production\";\n\n\tif (isHostedProduction && isLocalUrl(trimmed)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nasync function getBaseAppUrl(): Promise<string | undefined> {\n\tconst candidates = [\n\t\tprocess.env.NEXT_PUBLIC_SITE_URL,\n\t\tprocess.env.SITE_URL,\n\t\tprocess.env.NEXT_PUBLIC_APP_URL,\n\t\tprocess.env.APP_URL,\n\t];\n\tfor (const candidate of candidates) {\n\t\tif (candidate && shouldUseUrl(candidate)) {\n\t\t\treturn normalizeBaseUrl(candidate);\n\t\t}\n\t}\n\n\tconst vercelUrl = process.env.VERCEL_URL;\n\tif (vercelUrl && shouldUseUrl(vercelUrl)) {\n\t\treturn normalizeBaseUrl(\n\t\t\tvercelUrl.startsWith(\"http\") ? vercelUrl : `https://${vercelUrl}`,\n\t\t);\n\t}\n\n\ttry {\n\t\tconst hdrs = await headers();\n\t\tconst origin = hdrs.get(\"origin\");\n\t\tif (origin && shouldUseUrl(origin)) {\n\t\t\treturn normalizeBaseUrl(origin);\n\t\t}\n\t\tconst host = hdrs.get(\"host\");\n\t\tif (host && shouldUseUrl(host)) {\n\t\t\tconst protocol = host.includes(\"localhost\") ? \"http\" : \"https\";\n\t\t\treturn normalizeBaseUrl(`${protocol}://${host}`);\n\t\t}\n\t} catch {\n\t\t// headers() not available outside of a request context\n\t}\n\n\treturn undefined;\n}\n\nasync function buildAbsoluteUrl(path: string): Promise<string | undefined> {\n\tconst base = await getBaseAppUrl();\n\tif (!base) {\n\t\treturn undefined;\n\t}\n\tconst normalizedPath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${base}${normalizedPath}`;\n}\n\nasync function getTelnyxWebhookUrl(\n\tcompanyId?: string,\n): Promise<string | undefined> {\n\tif (companyId) {\n\t\treturn buildAbsoluteUrl(`/api/webhooks/telnyx?company=${companyId}`);\n\t}\n\treturn buildAbsoluteUrl(\"/api/webhooks/telnyx\");\n}\n\nasync function getPhoneNumberId(\n\tsupabase: TypedSupabaseClient,\n\tphoneNumber: string,\n): Promise<string | null> {\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"phone_number\", normalized)\n\t\t.is(\"deleted_at\", null)\n\t\t.maybeSingle();\n\n\treturn data?.id ?? null;\n}\n\nasync function ensurePhoneNumberRecordExists(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\tphoneNumber: string | null,\n): Promise<void> {\n\tif (!phoneNumber) {\n\t\treturn;\n\t}\n\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"phone_number\", normalized)\n\t\t.limit(1);\n\n\tif (data && data.length > 0) {\n\t\treturn;\n\t}\n\n\tawait supabase.from(\"phone_numbers\").insert({\n\t\tcompany_id: companyId,\n\t\tphone_number: normalized,\n\t\tformatted_number: formatDisplayPhoneNumber(normalized),\n\t\tcountry_code: \"US\",\n\t\tarea_code: extractAreaCode(normalized),\n\t\tnumber_type: \"local\",\n\t\tstatus: \"active\",\n\t\tfeatures: DEFAULT_PHONE_NUMBER_FEATURES,\n\t});\n}\n\nasync function resolveOutboundPhoneNumber(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\texplicitFrom?: string | null,\n\tdefaultNumber?: string | null,\n): Promise<string | null> {\n\tif (explicitFrom) {\n\t\treturn normalizePhoneNumber(explicitFrom);\n\t}\n\n\tconst normalizedDefault = defaultNumber\n\t\t? normalizePhoneNumber(defaultNumber)\n\t\t: null;\n\n\ttry {\n\t\tconst { data } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number, number_type\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (data && data.length > 0) {\n\t\t\tconst tollFree = data.find((n) => n.number_type === \"toll-free\");\n\t\t\tif (tollFree) {\n\t\t\t\treturn normalizePhoneNumber(tollFree.phone_number);\n\t\t\t}\n\n\t\t\tif (normalizedDefault) {\n\t\t\t\tconst defaultExists = data.some(\n\t\t\t\t\t(n) => normalizePhoneNumber(n.phone_number) === normalizedDefault,\n\t\t\t\t);\n\t\t\t\tif (defaultExists) {\n\t\t\t\t\treturn normalizedDefault;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn normalizePhoneNumber(data[0].phone_number);\n\t\t}\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"Failed to load company phone numbers for outbound selection:\",\n\t\t\terror,\n\t\t);\n\t}\n\n\treturn normalizedDefault;\n}\n\nasync function mergeProviderMetadata(\n\tsupabase: TypedSupabaseClient,\n\tcommunicationId: string,\n\tpatch: Record<string, Json>,\n): Promise<void> {\n\tconst { data } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"provider_metadata\")\n\t\t.eq(\"id\", communicationId)\n\t\t.maybeSingle();\n\n\tconst currentMetadata =\n\t\t(data?.provider_metadata as Record<string, Json> | null) ?? {};\n\tconst mergedMetadata: Record<string, Json> = {\n\t\t...currentMetadata,\n\t\t...patch,\n\t};\n\n\tawait supabase\n\t\t.from(\"communications\")\n\t\t.update({\n\t\t\tprovider_metadata: mergedMetadata,\n\t\t})\n\t\t.eq(\"id\", communicationId);\n}\n\n// =====================================================================================\n// PHONE NUMBER MANAGEMENT ACTIONS\n// =====================================================================================\n\n/**\n * Search for available phone numbers to purchase\n */\nexport async function searchPhoneNumbers(params: {\n\tareaCode?: string;\n\tnumberType?: NumberType;\n\tfeatures?: NumberFeature[];\n\tlimit?: number;\n}) {\n\ttry {\n\t\tconst result = await searchAvailableNumbers({\n\t\t\tcountryCode: \"US\",\n\t\t\tareaCode: params.areaCode,\n\t\t\tnumberType: params.numberType,\n\t\t\tfeatures: params.features,\n\t\t\tlimit: params.limit || 10,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to search phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Purchase a phone number and associate it with the current company\n */\nexport async function purchasePhoneNumber(params: {\n\tphoneNumber: string;\n\tcompanyId: string;\n\tbillingGroupId?: string;\n}) {\n\ttry {\n\t\t// Validate configuration\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tconst callConfig = validateCallConfig();\n\t\tif (!smsConfig.valid || !callConfig.valid) {\n\t\t\tlet errorMessage =\n\t\t\t\t\"Telnyx configuration is incomplete. Please configure all required environment variables.\";\n\n\t\t\t// If we have a suggested profile ID, include it in the error\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} to use it.`;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst normalizedPhoneNumber = normalizePhoneNumber(params.phoneNumber);\n\t\tconst formattedNumber = formatDisplayPhoneNumber(normalizedPhoneNumber);\n\t\tconst areaCode = extractAreaCode(normalizedPhoneNumber);\n\n\t\t// Purchase number from Telnyx\n\t\tconst messagingProfileId = DEFAULT_MESSAGING_PROFILE_ID || undefined;\n\n\t\tconst result = await purchaseNumber({\n\t\t\tphoneNumber: normalizedPhoneNumber,\n\t\t\tconnectionId: TELNYX_CONFIG.connectionId,\n\t\t\tmessagingProfileId,\n\t\t\tbillingGroupId: params.billingGroupId,\n\t\t\tcustomerReference: `company_${params.companyId}`,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Store in database\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\ttelnyx_phone_number_id: result.orderId,\n\t\t\t\ttelnyx_connection_id: TELNYX_CONFIG.connectionId,\n\t\t\t\tphone_number: normalizedPhoneNumber,\n\t\t\t\tformatted_number: formattedNumber,\n\t\t\t\tcountry_code: \"US\",\n\t\t\t\tarea_code: areaCode,\n\t\t\t\tnumber_type: \"local\",\n\t\t\t\tfeatures: [\"voice\", \"sms\"],\n\t\t\t\tstatus: \"pending\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\ttry {\n\t\t\tawait ensureMessagingCampaign(\n\t\t\t\tparams.companyId,\n\t\t\t\t{ id: data.id, e164: normalizedPhoneNumber },\n\t\t\t\t{ supabase },\n\t\t\t);\n\t\t} catch (_campaignError) {}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to purchase phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Get all phone numbers for a company\n */\nexport async function getCompanyPhoneNumbers(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Update phone number configuration\n */\nasync function updatePhoneNumber(params: {\n\tphoneNumberId: string;\n\troutingRuleId?: string;\n\tforwardToNumber?: string;\n\tvoicemailEnabled?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tcall_routing_rule_id: params.routingRuleId,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tvoicemail_enabled: params.voicemailEnabled,\n\t\t\t})\n\t\t\t.eq(\"id\", params.phoneNumberId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Release (delete) a phone number\n */\nasync function deletePhoneNumber(phoneNumberId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get phone number details\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", phoneNumberId)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) {\n\t\t\treturn { success: false, error: \"Phone number not found\" };\n\t\t}\n\n\t\t// Release from Telnyx if we have the ID\n\t\tif (phoneNumber.telnyx_phone_number_id) {\n\t\t\tawait releaseNumber(phoneNumber.telnyx_phone_number_id);\n\t\t}\n\n\t\t// Soft delete in database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tstatus: \"deleted\",\n\t\t\t})\n\t\t\t.eq(\"id\", phoneNumberId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete phone number\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Initiate an outbound call\n */\nexport async function makeCall(params: {\n\tto: string;\n\tfrom: string;\n\tcompanyId: string;\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconsole.log(\" makeCall called with params:\", params);\n\n\t\tconst callConfig = validateCallConfig();\n\t\tconsole.log(\" Call config validation:\", callConfig);\n\t\tif (!callConfig.valid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: callConfig.error || \"Call configuration is invalid\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t);\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tconst connectionOverride =\n\t\t\tcompanySettings?.call_control_application_id ||\n\t\t\tTELNYX_CONFIG.connectionId;\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tif (!connectionOverride) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"No Telnyx connection configured for this company.\",\n\t\t\t};\n\t\t}\n\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\n\t\t// TEMP: Skip connection verification - Level 2 required for API access\n\t\t// const connectionStatus = await verifyConnection(connectionOverride);\n\t\t// if (connectionStatus.needsFix) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror: `Connection configuration issue: ${connectionStatus.issues.join(\", \")}. Run fixConnection() to auto-fix.`,\n\t\t// \t};\n\t\t// }\n\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\t// TEMP: Skip voice capability check - Level 2 required for API access\n\t\t// const voiceCapability = await verifyVoiceCapability(fromAddress);\n\t\t// if (!voiceCapability.hasVoice) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror:\n\t\t// \t\t\tvoiceCapability.error || \"Phone number does not support voice calls\",\n\t\t// \t};\n\t\t// }\n\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl(params.companyId);\n\t\tconsole.log(\" Webhook URL:\", telnyxWebhookUrl);\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\" Initiating call:\", {\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\tconst result = await initiateCall({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t\tansweringMachineDetection: \"premium\",\n\t\t});\n\n\t\tconsole.log(\" Telnyx API response:\", result);\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"phone\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: \"\",\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_call_control_id: result.callControlId,\n\t\t\t\ttelnyx_call_session_id: result.callSessionId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconsole.log(\" Call created successfully:\", {\n\t\t\tcallControlId: result.callControlId,\n\t\t\tcommunicationId: data.id,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcallControlId: result.callControlId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\" makeCall error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to make call\",\n\t\t};\n\t}\n}\n\n/**\n * Answer an incoming call\n/**\n * Answer an incoming call\n */\nasync function acceptCall(callControlId: string) {\n\ttry {\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl();\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconst result = await answerCall({\n\t\t\tcallControlId,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to answer call\",\n\t\t};\n\t}\n}\n\n/**\n * Reject an incoming call\n */\nasync function declineCall(callControlId: string) {\n\ttry {\n\t\tconst result = await rejectCall({\n\t\t\tcallControlId,\n\t\t\tcause: \"CALL_REJECTED\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to reject call\",\n\t\t};\n\t}\n}\n\n/**\n * End an active call\n */\nasync function endCall(callControlId: string) {\n\ttry {\n\t\tconst result = await hangupCall({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to end call\",\n\t\t};\n\t}\n}\n\n/**\n * Start recording a call\n */\nexport async function startCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await startRecording({\n\t\t\tcallControlId,\n\t\t\tformat: \"mp3\",\n\t\t\tchannels: \"single\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to start recording\",\n\t\t};\n\t}\n}\n\n/**\n * Stop recording a call\n */\nexport async function stopCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await stopRecording({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to stop recording\",\n\t\t};\n\t}\n}\n\n/**\n * Transfer an active call to another number\n */\nexport async function transferActiveCall(params: {\n\tcallControlId: string;\n\tto: string;\n\tfrom: string;\n}) {\n\ttry {\n\t\tconst { transferCall } = await import(\"@/lib/telnyx/calls\");\n\t\tconst result = await transferCall({\n\t\t\tcallControlId: params.callControlId,\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to transfer call\",\n\t\t};\n\t}\n}\n\n/**\n * Transcribe a call recording using AssemblyAI\n *\n * Submits the recording URL to AssemblyAI for post-call transcription.\n * AssemblyAI will process the audio and send the transcript via webhook.\n *\n * @param recordingUrl - URL of the call recording (from Telnyx)\n * @param communicationId - Database ID of the communication record\n * @returns Success/error response with transcription job ID\n */\nexport async function transcribeCallRecording(params: {\n\trecordingUrl: string;\n\tcommunicationId: string;\n}) {\n\ttry {\n\t\tconst { submitTranscription } = await import(\"@/lib/assemblyai/client\");\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst webhookUrl = await buildAbsoluteUrl(\"/api/webhooks/assemblyai\");\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL.\",\n\t\t\t};\n\t\t}\n\n\t\t// Submit to AssemblyAI\n\t\tconst result = await submitTranscription({\n\t\t\taudio_url: params.recordingUrl,\n\t\t\tspeaker_labels: true, // Enable speaker diarization\n\t\t\twebhook_url: webhookUrl,\n\t\t});\n\n\t\tif (!(result.success && result.data)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error || \"Failed to submit transcription\",\n\t\t\t};\n\t\t}\n\n\t\t// Store transcription job ID in database\n\t\tawait mergeProviderMetadata(supabase, params.communicationId, {\n\t\t\tassemblyai_transcription_id: result.data.id,\n\t\t\tassemblyai_status: result.data.status,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttranscriptionId: result.data.id,\n\t\t\tstatus: result.data.status,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to transcribe recording\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// SMS OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Send an SMS message\n */\nexport async function sendTextMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext: string;\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tconsole.error(\" Supabase client unavailable\");\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\" SMS Send Request:\", {\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t\tcompanyId,\n\t\t});\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\tconsole.error(\" Company settings not found\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify the company's onboarding is complete and try again.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Company settings loaded:\", {\n\t\t\tmessagingProfileId: companySettings.messaging_profile_id,\n\t\t\tdefaultNumber: companySettings.default_outbound_number,\n\t\t});\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings?.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or provision company-specific settings.`;\n\t\t\t}\n\t\t\tconsole.error(\" SMS config invalid:\", errorMessage);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS config valid\");\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings?.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\tconsole.error(\" No messaging profile ID\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending SMS.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Using messaging profile:\", messagingProfileId);\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t\" Messaging profile needs fix:\",\n\t\t\t\t\tmessagingProfileStatus.issues,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconsole.log(\" Messaging profile verified\");\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\tconsole.error(\" No from number available\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\t\tconsole.log(\" Phone numbers normalized:\", {\n\t\t\tfrom: fromAddress,\n\t\t\tto: toAddress,\n\t\t});\n\n\t\t// Verify phone number has SMS capability\n\t\tconsole.log(\" Verifying SMS capability for:\", fromAddress);\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\tconsole.error(\" SMS capability check failed:\", smsCapability.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS capability verified\");\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\tconsole.error(\" No webhook URL\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Webhook URL:\", webhookUrl);\n\n\t\t// Send SMS via Telnyx\n\t\tconsole.log(\" Sending SMS via Telnyx API...\");\n\t\tconst result = await sendSMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\tconsole.error(\" Telnyx API failed:\", result.error);\n\n\t\t\t// Check if error is 10DLC registration required\n\t\t\tif (\n\t\t\t\tresult.error &&\n\t\t\t\t(result.error.includes(\"10DLC\") ||\n\t\t\t\t\tresult.error.includes(\"Not 10DLC registered\") ||\n\t\t\t\t\tresult.error.includes(\"A2P\"))\n\t\t\t) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\" Detected 10DLC registration required, attempting auto-registration...\",\n\t\t\t\t);\n\n\t\t\t\t// Import 10DLC registration function\n\t\t\t\tconst { registerCompanyFor10DLC } = await import(\n\t\t\t\t\t\"@/actions/ten-dlc-registration\"\n\t\t\t\t);\n\n\t\t\t\tconst registrationResult = await registerCompanyFor10DLC(\n\t\t\t\t\tcompanyId,\n\t\t\t\t);\n\n\t\t\t\tif (registrationResult.success) {\n\t\t\t\t\tconsole.log(\" 10DLC registration successful, retrying SMS send...\");\n\n\t\t\t\t\t// Retry the SMS send now that 10DLC is registered\n\t\t\t\t\tconst retryResult = await sendSMS({\n\t\t\t\t\t\tto: toAddress,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\ttext: params.text,\n\t\t\t\t\t\twebhookUrl,\n\t\t\t\t\t\tmessagingProfileId,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!retryResult.success) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\terror: `10DLC registration completed but SMS still failed: ${retryResult.error}. The campaign may need additional approval time.`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update result with retry success\n\t\t\t\t\tresult.success = true;\n\t\t\t\t\tresult.messageId = retryResult.messageId;\n\t\t\t\t\tconsole.log(\" SMS retry successful after 10DLC registration\");\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: `10DLC registration failed: ${registrationResult.error}. Original error: ${result.error}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tconsole.log(\" Telnyx API success:\", result.messageId);\n\n\t\t// Create communication record\n\t\tconsole.log(\" Creating communication record in database...\");\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"SMS send error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\ttype: typeof error,\n\t\t\tstringified: JSON.stringify(error, null, 2),\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to send SMS: ${String(error)}`,\n\t\t};\n\t}\n}\n\n/**\n * Send an MMS message with media\n */\nexport async function sendMMSMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext?: string;\n\tmediaUrls: string[];\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify onboarding is complete.\",\n\t\t\t};\n\t\t}\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or reprovision the company.`;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending MMS.\",\n\t\t\t};\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS/MMS\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await sendMMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\tmediaUrls: params.mediaUrls,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text || \"\",\n\t\t\t\tattachments: params.mediaUrls.map((url) => ({ url, type: \"image\" })),\n\t\t\t\tattachment_count: params.mediaUrls.length,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to send MMS\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// WEBRTC OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Generate WebRTC credentials for browser calling\n */\nexport async function getWebRTCCredentials() {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: userError,\n\t\t} = await supabase.auth.getUser();\n\t\tif (userError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User not authenticated\",\n\t\t\t};\n\t\t}\n\n\t\t// OPTION 1: Use static credentials from environment (recommended for production)\n\t\tconst staticUsername = process.env.TELNYX_WEBRTC_USERNAME;\n\t\tconst staticPassword = process.env.TELNYX_WEBRTC_PASSWORD;\n\n\t\tif (staticUsername && staticPassword) {\n\t\t\tconst credential = {\n\t\t\t\tusername: staticUsername,\n\t\t\t\tpassword: staticPassword,\n\t\t\t\texpires_at: Date.now() + 86_400 * 1000, // 24 hours from now\n\t\t\t\trealm: \"sip.telnyx.com\",\n\t\t\t\tsip_uri: `sip:${staticUsername}@sip.telnyx.com`,\n\t\t\t\tstun_servers: [\n\t\t\t\t\t\"stun:stun.telnyx.com:3478\",\n\t\t\t\t\t\"stun:stun.telnyx.com:3479\",\n\t\t\t\t],\n\t\t\t\tturn_servers: [\n\t\t\t\t\t{\n\t\t\t\t\t\turls: [\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=udp\",\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=tcp\",\n\t\t\t\t\t\t],\n\t\t\t\t\t\tusername: staticUsername,\n\t\t\t\t\t\tcredential: staticPassword,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tcredential,\n\t\t\t};\n\t\t}\n\n\t\tconst { generateWebRTCToken } = await import(\"@/lib/telnyx/webrtc\");\n\t\tconst result = await generateWebRTCToken({\n\t\t\tusername: user.email || user.id,\n\t\t\tttl: 86_400, // 24 hours\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcredential: result.credential,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get WebRTC credentials\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// VOICEMAIL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Get all voicemails for a company\n */\nasync function getVoicemails(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        customer:customers(id, first_name, last_name, email, phone),\n        phone_number:phone_numbers(phone_number, formatted_number)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"received_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get voicemails\",\n\t\t};\n\t}\n}\n\n/**\n * Mark voicemail as read\n */\nasync function markVoicemailAsRead(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tis_read: true,\n\t\t\t\tread_at: new Date().toISOString(),\n\t\t\t\tread_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to mark voicemail as read\",\n\t\t};\n\t}\n}\n\n/**\n * Delete voicemail\n */\nasync function deleteVoicemail(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to delete voicemail\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL ROUTING RULES ACTIONS\n// =====================================================================================\n\n/**\n * Get all call routing rules for a company\n */\nexport async function getCallRoutingRules(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        created_by_user:users!call_routing_rules_created_by_fkey(id, name, email),\n        forward_to_user:users!call_routing_rules_forward_to_user_id_fkey(id, name, email)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"priority\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get call routing rules\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new call routing rule\n */\nasync function createCallRoutingRule(params: {\n\tcompanyId: string;\n\tuserId: string;\n\tname: string;\n\tdescription?: string;\n\troutingType:\n\t\t| \"direct\"\n\t\t| \"round_robin\"\n\t\t| \"ivr\"\n\t\t| \"business_hours\"\n\t\t| \"conditional\";\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\tcreated_by: params.userId,\n\t\t\t\tname: params.name,\n\t\t\t\tdescription: params.description,\n\t\t\t\trouting_type: params.routingType,\n\t\t\t\tpriority: params.priority || 0,\n\t\t\t\tbusiness_hours: params.businessHours,\n\t\t\t\ttimezone: params.timezone || \"America/Los_Angeles\",\n\t\t\t\tafter_hours_action: params.afterHoursAction,\n\t\t\t\tafter_hours_forward_to: params.afterHoursForwardTo,\n\t\t\t\tteam_members: params.teamMembers,\n\t\t\t\tring_timeout: params.ringTimeout || 20,\n\t\t\t\tivr_menu: params.ivrMenu,\n\t\t\t\tivr_greeting_url: params.ivrGreetingUrl,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tforward_to_user_id: params.forwardToUserId,\n\t\t\t\tenable_voicemail: params.enableVoicemail !== false,\n\t\t\t\tvoicemail_greeting_url: params.voicemailGreetingUrl,\n\t\t\t\tvoicemail_transcription_enabled:\n\t\t\t\t\tparams.voicemailTranscriptionEnabled !== false,\n\t\t\t\tvoicemail_email_notifications:\n\t\t\t\t\tparams.voicemailEmailNotifications !== false,\n\t\t\t\trecord_calls: params.recordCalls,\n\t\t\t\tis_active: true,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to create call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Update an existing call routing rule\n */\nexport async function updateCallRoutingRule(params: {\n\truleId: string;\n\tname?: string;\n\tdescription?: string;\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n\tisActive?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst updateData: Record<string, unknown> = {};\n\n\t\tif (params.name !== undefined) {\n\t\t\tupdateData.name = params.name;\n\t\t}\n\t\tif (params.description !== undefined) {\n\t\t\tupdateData.description = params.description;\n\t\t}\n\t\tif (params.priority !== undefined) {\n\t\t\tupdateData.priority = params.priority;\n\t\t}\n\t\tif (params.businessHours !== undefined) {\n\t\t\tupdateData.business_hours = params.businessHours;\n\t\t}\n\t\tif (params.timezone !== undefined) {\n\t\t\tupdateData.timezone = params.timezone;\n\t\t}\n\t\tif (params.afterHoursAction !== undefined) {\n\t\t\tupdateData.after_hours_action = params.afterHoursAction;\n\t\t}\n\t\tif (params.afterHoursForwardTo !== undefined) {\n\t\t\tupdateData.after_hours_forward_to = params.afterHoursForwardTo;\n\t\t}\n\t\tif (params.teamMembers !== undefined) {\n\t\t\tupdateData.team_members = params.teamMembers;\n\t\t}\n\t\tif (params.ringTimeout !== undefined) {\n\t\t\tupdateData.ring_timeout = params.ringTimeout;\n\t\t}\n\t\tif (params.ivrMenu !== undefined) {\n\t\t\tupdateData.ivr_menu = params.ivrMenu;\n\t\t}\n\t\tif (params.ivrGreetingUrl !== undefined) {\n\t\t\tupdateData.ivr_greeting_url = params.ivrGreetingUrl;\n\t\t}\n\t\tif (params.forwardToNumber !== undefined) {\n\t\t\tupdateData.forward_to_number = params.forwardToNumber;\n\t\t}\n\t\tif (params.forwardToUserId !== undefined) {\n\t\t\tupdateData.forward_to_user_id = params.forwardToUserId;\n\t\t}\n\t\tif (params.enableVoicemail !== undefined) {\n\t\t\tupdateData.enable_voicemail = params.enableVoicemail;\n\t\t}\n\t\tif (params.voicemailGreetingUrl !== undefined) {\n\t\t\tupdateData.voicemail_greeting_url = params.voicemailGreetingUrl;\n\t\t}\n\t\tif (params.voicemailTranscriptionEnabled !== undefined) {\n\t\t\tupdateData.voicemail_transcription_enabled =\n\t\t\t\tparams.voicemailTranscriptionEnabled;\n\t\t}\n\t\tif (params.voicemailEmailNotifications !== undefined) {\n\t\t\tupdateData.voicemail_email_notifications =\n\t\t\t\tparams.voicemailEmailNotifications;\n\t\t}\n\t\tif (params.recordCalls !== undefined) {\n\t\t\tupdateData.record_calls = params.recordCalls;\n\t\t}\n\t\tif (params.isActive !== undefined) {\n\t\t\tupdateData.is_active = params.isActive;\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", params.ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a call routing rule\n */\nexport async function deleteCallRoutingRule(ruleId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", ruleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Toggle call routing rule active status\n */\nexport async function toggleCallRoutingRule(ruleId: string, isActive: boolean) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({ is_active: isActive })\n\t\t\t.eq(\"id\", ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to toggle call routing rule\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// PHONE NUMBER USAGE STATISTICS ACTIONS\n// =====================================================================================\n\n/**\n * Get usage statistics for a phone number\n */\nasync function getPhoneNumberUsageStats(\n\tphoneNumberId: string,\n\tdays = 30,\n) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get call statistics\n\t\tconst { data: callStats, error: callError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"type\", \"phone\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (callError) {\n\t\t\tthrow callError;\n\t\t}\n\n\t\t// Get SMS statistics\n\t\tconst { data: smsStats, error: smsError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, created_at\")\n\t\t\t.eq(\"type\", \"sms\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (smsError) {\n\t\t\tthrow smsError;\n\t\t}\n\n\t\t// Calculate aggregates\n\t\tconst calls = callStats || [];\n\t\tconst sms = smsStats || [];\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats([...calls, ...sms], days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Get company-wide usage statistics\n */\nasync function getCompanyUsageStats(companyId: string, days = 30) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get all communications for the company\n\t\tconst { data: communications, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.in(\"type\", [\"phone\", \"sms\"])\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst items = communications || [];\n\t\tconst calls = items.filter((i) => i.type === \"phone\");\n\t\tconst sms = items.filter((i) => i.type === \"sms\");\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\taverageCallDuration:\n\t\t\t\t\tcalls.length > 0 ? totalCallDuration / calls.length : 0,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats(items, days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Helper function to aggregate daily statistics\n */\nfunction aggregateDailyStats(\n\titems: Array<{ created_at: string; type: string; call_duration?: number }>,\n\tdays: number,\n) {\n\tconst dailyStats: Record<\n\t\tstring,\n\t\t{ date: string; calls: number; sms: number; duration: number }\n\t> = {};\n\n\t// Initialize all days\n\tfor (let i = 0; i < days; i++) {\n\t\tconst date = new Date();\n\t\tdate.setDate(date.getDate() - i);\n\t\tconst dateStr = date.toISOString().split(\"T\")[0];\n\t\tdailyStats[dateStr] = { date: dateStr, calls: 0, sms: 0, duration: 0 };\n\t}\n\n\t// Aggregate data\n\titems.forEach((item) => {\n\t\tconst dateStr = item.created_at.split(\"T\")[0];\n\t\tif (dailyStats[dateStr]) {\n\t\t\tif (item.type === \"phone\") {\n\t\t\t\tdailyStats[dateStr].calls += 1;\n\t\t\t\tdailyStats[dateStr].duration += item.call_duration || 0;\n\t\t\t} else if (item.type === \"sms\") {\n\t\t\t\tdailyStats[dateStr].sms += 1;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Object.values(dailyStats).sort((a, b) => a.date.localeCompare(b.date));\n}\n"],"names":[],"mappings":";;;;;;;IA6lBsB,WAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 1903, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/badge.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1911, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/button.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1919, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/command.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1927, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/dropdown-menu.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1935, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/input.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1943, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/popover.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1951, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/select.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1959, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/switch.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1967, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/tooltip.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 1975, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-dialer-customers.ts"],"sourcesContent":["/**\n * Dialer Customers Hook - Client-Side Lazy Loading\n *\n * PERFORMANCE CRITICAL:\n * Previously, AppHeader fetched ALL customers on EVERY page load (~400-800ms).\n * Now customers are only fetched when the dialer is opened.\n *\n * Features:\n * - Lazy load on first dialer open\n * - 5-minute cache in memory\n * - No server-side overhead on page loads\n *\n * Expected savings: 400-800ms per page load\n */\n\nimport { useEffect, useState } from \"react\";\n\ntype DialerCustomer = {\n\tid: string;\n\tfirst_name: string | null;\n\tlast_name: string | null;\n\tdisplay_name: string | null;\n\temail: string | null;\n\tphone: string | null;\n\tcompany_name: string | null;\n\tsecondary_phone?: string | null;\n\taddress: string | null;\n\taddress2: string | null;\n\tcity: string | null;\n\tstate: string | null;\n\tzip_code: string | null;\n};\n\n// In-memory cache with 5-minute TTL\nlet cachedCustomers: DialerCustomer[] | null = null;\nlet cacheTimestamp = 0;\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport function useDialerCustomers(shouldFetch = false) {\n\tconst [customers, setCustomers] = useState<DialerCustomer[]>([]);\n\tconst [isLoading, setIsLoading] = useState(false);\n\tconst [error, setError] = useState<string | null>(null);\n\n\tuseEffect(() => {\n\t\t// Only fetch if explicitly requested (e.g., dialer opened)\n\t\tif (!shouldFetch) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Serve from cache when available\n\t\tconst now = Date.now();\n\t\tif (cachedCustomers && now - cacheTimestamp < CACHE_TTL) {\n\t\t\tsetCustomers(cachedCustomers);\n\t\t\treturn;\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\tconst fetchCustomers = async () => {\n\t\t\tsetIsLoading(true);\n\t\t\tsetError(null);\n\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(\"/api/dialer/customers\", {\n\t\t\t\t\tsignal: controller.signal,\n\t\t\t\t\tcache: \"no-store\",\n\t\t\t\t});\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tconst payload = await response.json().catch(() => ({}));\n\t\t\t\t\tthrow new Error(payload.error || \"Failed to load customers\");\n\t\t\t\t}\n\n\t\t\t\tconst payload = (await response.json()) as {\n\t\t\t\t\tcustomers: DialerCustomer[];\n\t\t\t\t};\n\t\t\t\tcachedCustomers = payload.customers;\n\t\t\t\tcacheTimestamp = Date.now();\n\t\t\t\tsetCustomers(payload.customers);\n\t\t\t} catch (err) {\n\t\t\t\tif (controller.signal.aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetError(\n\t\t\t\t\terr instanceof Error ? err.message : \"Failed to load customers\",\n\t\t\t\t);\n\t\t\t} finally {\n\t\t\t\tif (!controller.signal.aborted) {\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfetchCustomers();\n\n\t\treturn () => {\n\t\t\tcontroller.abort();\n\t\t};\n\t}, [shouldFetch]);\n\n\treturn { customers, isLoading, error };\n}\n\n// Helper to invalidate cache (call after creating/updating customers)\nfunction invalidateDialerCustomersCache() {\n\tcachedCustomers = null;\n\tcacheTimestamp = 0;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;CAaC;;;;AAED;;AAkBA,oCAAoC;AACpC,IAAI,kBAA2C;AAC/C,IAAI,iBAAiB;AACrB,MAAM,YAAY,IAAI,KAAK,MAAM,YAAY;AAEtC,SAAS,mBAAmB,cAAc,KAAK;IACrD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,wXAAQ,EAAmB,EAAE;IAC/D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,wXAAQ,EAAC;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,wXAAQ,EAAgB;IAElD,IAAA,yXAAS,EAAC;QACT,2DAA2D;QAC3D,IAAI,CAAC,aAAa;YACjB;QACD;QAEA,kCAAkC;QAClC,MAAM,MAAM,KAAK,GAAG;QACpB,IAAI,mBAAmB,MAAM,iBAAiB,WAAW;YACxD,aAAa;YACb;QACD;QAEA,MAAM,aAAa,IAAI;QACvB,MAAM,iBAAiB;YACtB,aAAa;YACb,SAAS;YAET,IAAI;gBACH,MAAM,WAAW,MAAM,MAAM,yBAAyB;oBACrD,QAAQ,WAAW,MAAM;oBACzB,OAAO;gBACR;gBAEA,IAAI,CAAC,SAAS,EAAE,EAAE;oBACjB,MAAM,UAAU,MAAM,SAAS,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;oBACrD,MAAM,IAAI,MAAM,QAAQ,KAAK,IAAI;gBAClC;gBAEA,MAAM,UAAW,MAAM,SAAS,IAAI;gBAGpC,kBAAkB,QAAQ,SAAS;gBACnC,iBAAiB,KAAK,GAAG;gBACzB,aAAa,QAAQ,SAAS;YAC/B,EAAE,OAAO,KAAK;gBACb,IAAI,WAAW,MAAM,CAAC,OAAO,EAAE;oBAC9B;gBACD;gBACA,SACC,eAAe,QAAQ,IAAI,OAAO,GAAG;YAEvC,SAAU;gBACT,IAAI,CAAC,WAAW,MAAM,CAAC,OAAO,EAAE;oBAC/B,aAAa;gBACd;YACD;QACD;QAEA;QAEA,OAAO;YACN,WAAW,KAAK;QACjB;IACD,GAAG;QAAC;KAAY;IAEhB,OAAO;QAAE;QAAW;QAAW;IAAM;AACtC;AAEA,sEAAsE;AACtE,SAAS;IACR,kBAAkB;IAClB,iBAAiB;AAClB"}},
    {"offset": {"line": 2063, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-telnyx-webrtc.ts"],"sourcesContent":["/**\n * Telnyx WebRTC Hook\n *\n * Provides WebRTC calling functionality using the Telnyx WebRTC SDK.\n * Compatible with both web browsers and React Native.\n *\n * Features:\n * - Make and receive calls\n * - Call controls (mute, hold, end)\n * - Real-time call state management\n * - Audio device selection\n * - Connection status monitoring\n * - Auto-reconnection with exponential backoff\n */\n\n\"use client\";\n\nimport type { Call, INotification } from \"@telnyx/webrtc\";\nimport { TelnyxRTC } from \"@telnyx/webrtc\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n// =============================================================================\n// AUTO-RECONNECTION CONFIGURATION\n// =============================================================================\n\nconst RECONNECT_CONFIG = {\n\t// Maximum number of reconnection attempts\n\tmaxAttempts: 5,\n\t// Base delay in milliseconds (doubles with each attempt)\n\tbaseDelayMs: 1000,\n\t// Maximum delay between attempts\n\tmaxDelayMs: 30000,\n\t// Jitter factor (0-1) to add randomness\n\tjitterFactor: 0.3,\n};\n\n/**\n * Call state types\n */\nexport type CallState =\n\t| \"idle\"\n\t| \"connecting\"\n\t| \"ringing\"\n\t| \"active\"\n\t| \"held\"\n\t| \"ended\";\n\n/**\n * Call direction\n */\nexport type CallDirection = \"inbound\" | \"outbound\";\n\n/**\n * WebRTC call information\n */\nexport type WebRTCCall = {\n\tid: string;\n\tstate: CallState;\n\tdirection: CallDirection;\n\tremoteNumber: string;\n\tremoteName?: string;\n\tlocalNumber: string;\n\tstartTime?: Date;\n\tduration: number;\n\tisMuted: boolean;\n\tisHeld: boolean;\n\tisRecording: boolean;\n};\n\n/**\n * Hook options\n */\nexport type UseTelnyxWebRTCOptions = {\n\tusername: string;\n\tpassword: string;\n\tautoConnect?: boolean;\n\tdebug?: boolean;\n\tonIncomingCall?: (call: WebRTCCall) => void;\n\tonCallEnded?: (call: WebRTCCall) => void;\n};\n\n/**\n * Hook return type\n */\nexport type UseTelnyxWebRTCReturn = {\n\t// Connection state\n\tisConnected: boolean;\n\tisConnecting: boolean;\n\tisReconnecting: boolean;\n\tconnectionError: string | null;\n\treconnectAttempts: number;\n\n\t// Current call\n\tcurrentCall: WebRTCCall | null;\n\n\t// Call actions\n\tmakeCall: (destination: string, callerIdNumber?: string) => Promise<Call>;\n\tanswerCall: () => Promise<void>;\n\tendCall: () => Promise<void>;\n\tmuteCall: () => Promise<void>;\n\tunmuteCall: () => Promise<void>;\n\tholdCall: () => Promise<void>;\n\tunholdCall: () => Promise<void>;\n\tsendDTMF: (digit: string) => Promise<void>;\n\n\t// Connection actions\n\tconnect: () => Promise<void>;\n\tdisconnect: () => void;\n\treconnect: () => Promise<void>;\n\n\t// Audio devices\n\taudioDevices: MediaDeviceInfo[];\n\tsetAudioDevice: (deviceId: string) => Promise<void>;\n};\n\n/**\n * Telnyx WebRTC Hook\n *\n * Manages WebRTC connection and call state\n */\nexport function useTelnyxWebRTC(\n\toptions: UseTelnyxWebRTCOptions,\n): UseTelnyxWebRTCReturn {\n\t// Connection state\n\tconst [isConnected, setIsConnected] = useState(false);\n\tconst [isConnecting, setIsConnecting] = useState(false);\n\tconst [isReconnecting, setIsReconnecting] = useState(false);\n\tconst [connectionError, setConnectionError] = useState<string | null>(null);\n\tconst [reconnectAttempts, setReconnectAttempts] = useState(0);\n\n\t// Call state\n\tconst [currentCall, setCurrentCall] = useState<WebRTCCall | null>(null);\n\n\t// Audio devices\n\tconst [audioDevices, setAudioDevices] = useState<MediaDeviceInfo[]>([]);\n\n\t// Refs\n\tconst clientRef = useRef<TelnyxRTC | null>(null);\n\tconst activeCallRef = useRef<Call | null>(null);\n\tconst optionsRef = useRef(options);\n\tconst reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\tconst shouldReconnectRef = useRef(true);\n\n\t// Keep options ref up to date\n\tuseEffect(() => {\n\t\toptionsRef.current = options;\n\t}, [options]);\n\n\t/**\n\t * Calculate reconnection delay with exponential backoff and jitter\n\t */\n\tconst calculateReconnectDelay = useCallback((attempt: number): number => {\n\t\t// Exponential backoff: baseDelay * 2^attempt\n\t\tconst exponentialDelay =\n\t\t\tRECONNECT_CONFIG.baseDelayMs * Math.pow(2, attempt);\n\n\t\t// Cap at maxDelay\n\t\tconst cappedDelay = Math.min(exponentialDelay, RECONNECT_CONFIG.maxDelayMs);\n\n\t\t// Add jitter to prevent thundering herd\n\t\tconst jitter =\n\t\t\tcappedDelay * RECONNECT_CONFIG.jitterFactor * Math.random();\n\n\t\treturn Math.round(cappedDelay + jitter);\n\t}, []);\n\n\t/**\n\t * Schedule a reconnection attempt\n\t */\n\tconst scheduleReconnect = useCallback(() => {\n\t\t// Clear any existing timeout\n\t\tif (reconnectTimeoutRef.current) {\n\t\t\tclearTimeout(reconnectTimeoutRef.current);\n\t\t}\n\n\t\tsetReconnectAttempts((prev) => {\n\t\t\tconst nextAttempt = prev + 1;\n\n\t\t\tif (nextAttempt > RECONNECT_CONFIG.maxAttempts) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t` WebRTC: Max reconnection attempts (${RECONNECT_CONFIG.maxAttempts}) reached`\n\t\t\t\t);\n\t\t\t\tsetIsReconnecting(false);\n\t\t\t\tsetConnectionError(\n\t\t\t\t\t`Connection lost. Max reconnection attempts (${RECONNECT_CONFIG.maxAttempts}) exceeded.`\n\t\t\t\t);\n\t\t\t\treturn prev;\n\t\t\t}\n\n\t\t\tconst delay = calculateReconnectDelay(nextAttempt - 1);\n\t\t\tconsole.log(\n\t\t\t\t` WebRTC: Scheduling reconnection attempt ${nextAttempt}/${RECONNECT_CONFIG.maxAttempts} in ${delay}ms`\n\t\t\t);\n\n\t\t\tsetIsReconnecting(true);\n\n\t\t\treconnectTimeoutRef.current = setTimeout(async () => {\n\t\t\t\tconsole.log(\n\t\t\t\t\t` WebRTC: Attempting reconnection ${nextAttempt}/${RECONNECT_CONFIG.maxAttempts}`\n\t\t\t\t);\n\n\t\t\t\t// Clear the old client before reconnecting\n\t\t\t\tif (clientRef.current) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclientRef.current.disconnect();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignore disconnect errors\n\t\t\t\t\t}\n\t\t\t\t\tclientRef.current = null;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to reconnect\n\t\t\t\ttry {\n\t\t\t\t\tconst currentOptions = optionsRef.current;\n\t\t\t\t\tif (currentOptions.username && currentOptions.password) {\n\t\t\t\t\t\t// Create new client and connect\n\t\t\t\t\t\tconst client = new TelnyxRTC({\n\t\t\t\t\t\t\tlogin: currentOptions.username,\n\t\t\t\t\t\t\tpassword: currentOptions.password,\n\t\t\t\t\t\t\tdebug: currentOptions.debug,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Re-setup event handlers\n\t\t\t\t\t\tclient.on(\"telnyx.ready\", () => {\n\t\t\t\t\t\t\tconsole.log(\" WebRTC: Reconnection successful!\");\n\t\t\t\t\t\t\tsetIsConnected(true);\n\t\t\t\t\t\t\tsetIsConnecting(false);\n\t\t\t\t\t\t\tsetIsReconnecting(false);\n\t\t\t\t\t\t\tsetConnectionError(null);\n\t\t\t\t\t\t\tsetReconnectAttempts(0);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclient.on(\"telnyx.error\", (error: any) => {\n\t\t\t\t\t\t\tconsole.error(\" WebRTC: Reconnection error:\", error);\n\t\t\t\t\t\t\tscheduleReconnect();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclient.on(\"telnyx.socket.error\", () => {\n\t\t\t\t\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\t\t\t\t\tscheduleReconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclient.on(\"telnyx.socket.close\", () => {\n\t\t\t\t\t\t\tsetIsConnected(false);\n\t\t\t\t\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\t\t\t\t\tscheduleReconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tclientRef.current = client;\n\t\t\t\t\t\tawait client.connect();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(\" WebRTC: Reconnection attempt failed:\", error);\n\t\t\t\t\t// Will be retried by the socket close handler\n\t\t\t\t}\n\t\t\t}, delay);\n\n\t\t\treturn nextAttempt;\n\t\t});\n\t}, [calculateReconnectDelay]);\n\n\t/**\n\t * Manual reconnect function\n\t */\n\tconst reconnect = useCallback(async () => {\n\t\tconsole.log(\" WebRTC: Manual reconnection requested\");\n\t\tsetReconnectAttempts(0);\n\t\tshouldReconnectRef.current = true;\n\n\t\t// Clear existing client\n\t\tif (clientRef.current) {\n\t\t\ttry {\n\t\t\t\tclientRef.current.disconnect();\n\t\t\t} catch {\n\t\t\t\t// Ignore disconnect errors\n\t\t\t}\n\t\t\tclientRef.current = null;\n\t\t}\n\n\t\t// Clear any pending reconnect timeout\n\t\tif (reconnectTimeoutRef.current) {\n\t\t\tclearTimeout(reconnectTimeoutRef.current);\n\t\t\treconnectTimeoutRef.current = null;\n\t\t}\n\n\t\tsetIsReconnecting(false);\n\n\t\t// Use the normal connect flow\n\t\tconst currentOptions = optionsRef.current;\n\t\tif (currentOptions.username && currentOptions.password) {\n\t\t\tsetIsConnecting(true);\n\t\t\tsetConnectionError(null);\n\n\t\t\ttry {\n\t\t\t\tconst client = initializeClient();\n\t\t\t\tif (client) {\n\t\t\t\t\tawait client.connect();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\" WebRTC: Manual reconnection failed:\", error);\n\t\t\t\tsetConnectionError(\n\t\t\t\t\terror instanceof Error ? error.message : \"Reconnection failed\"\n\t\t\t\t);\n\t\t\t\tsetIsConnecting(false);\n\t\t\t}\n\t\t}\n\t}, []);\n\n\t/**\n\t * Initialize WebRTC client\n\t * Uses ref to avoid circular dependencies\n\t */\n\tconst initializeClient = useCallback(() => {\n\t\tif (clientRef.current) {\n\t\t\tconsole.log(\" WebRTC: Reusing existing client instance\");\n\t\t\treturn clientRef.current;\n\t\t}\n\n\t\tconst currentOptions = optionsRef.current;\n\t\tconst hasCredentials =\n\t\t\tBoolean(currentOptions.username) && Boolean(currentOptions.password);\n\n\t\tconsole.log(\" WebRTC: Initializing client with credentials:\", {\n\t\t\thasUsername: Boolean(currentOptions.username),\n\t\t\thasPassword: Boolean(currentOptions.password),\n\t\t\tusername: currentOptions.username,\n\t\t\tdebug: currentOptions.debug,\n\t\t});\n\n\t\tif (!hasCredentials) {\n\t\t\tconsole.error(\" WebRTC: Missing credentials, cannot initialize\");\n\t\t\t// Don't initialize if credentials are missing\n\t\t\treturn null;\n\t\t}\n\n\t\tconsole.log(\" WebRTC: Creating new TelnyxRTC instance...\");\n\t\tconst client = new TelnyxRTC({\n\t\t\tlogin: currentOptions.username,\n\t\t\tpassword: currentOptions.password,\n\t\t\tringtoneFile: undefined, // Use browser default\n\t\t\tringbackFile: undefined,\n\t\t\tdebug: currentOptions.debug,\n\t\t});\n\t\tconsole.log(\n\t\t\t\" WebRTC: TelnyxRTC instance created, SDK version:\",\n\t\t\t(client as any).version || \"unknown\",\n\t\t);\n\n\t\t// Handle ready event\n\t\tclient.on(\"telnyx.ready\", () => {\n\t\t\tconsole.log(\" WebRTC: telnyx.ready event - Connection successful!\");\n\t\t\tsetIsConnected(true);\n\t\t\tsetIsConnecting(false);\n\t\t\tsetIsReconnecting(false);\n\t\t\tsetConnectionError(null);\n\t\t\tsetReconnectAttempts(0); // Reset on successful connection\n\t\t});\n\n\t\t// Handle error event\n\t\tclient.on(\"telnyx.error\", (error: any) => {\n\t\t\tconsole.error(\" WebRTC: telnyx.error event:\", error);\n\t\t\tconst errorMessage =\n\t\t\t\terror?.error?.message ||\n\t\t\t\terror?.message ||\n\t\t\t\terror?.description ||\n\t\t\t\t\"Connection error\";\n\t\t\tconsole.error(\" WebRTC: Error message:\", errorMessage);\n\t\t\tsetConnectionError(errorMessage);\n\t\t\tsetIsConnecting(false);\n\t\t});\n\n\t\t// Handle socket error - trigger reconnection\n\t\tclient.on(\"telnyx.socket.error\", (socketError: any) => {\n\t\t\tconsole.error(\" WebRTC: telnyx.socket.error event:\", socketError);\n\t\t\tsetConnectionError(\"Socket connection failed\");\n\t\t\tsetIsConnecting(false);\n\t\t\tsetIsConnected(false);\n\n\t\t\t// Trigger auto-reconnection\n\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\tscheduleReconnect();\n\t\t\t}\n\t\t});\n\n\t\t// Handle socket close - trigger reconnection\n\t\tclient.on(\"telnyx.socket.close\", (closeEvent: any) => {\n\t\t\tconsole.warn(\" WebRTC: telnyx.socket.close event:\", closeEvent);\n\t\t\tsetIsConnected(false);\n\n\t\t\t// Trigger auto-reconnection (unless manually disconnected)\n\t\t\tif (shouldReconnectRef.current) {\n\t\t\t\tscheduleReconnect();\n\t\t\t}\n\t\t});\n\n\t\t// Handle incoming call\n\t\tclient.on(\"telnyx.notification\", (notification: INotification) => {\n\t\t\tconsole.log(\" WebRTC notification:\", notification.type);\n\n\t\t\tif (notification.type !== \"callUpdate\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst call = notification.call as Call | undefined;\n\n\t\t\tif (!call) {\n\t\t\t\t// Guard against undefined call object\n\t\t\t\tconsole.warn(\" WebRTC: callUpdate notification with undefined call\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.log(\" WebRTC callUpdate:\", {\n\t\t\t\tcallId: call.id,\n\t\t\t\tstate: call.state,\n\t\t\t\tdirection: call.direction,\n\t\t\t\tcause: (call as any).cause,\n\t\t\t\tsipCode: (call as any).sipCode,\n\t\t\t});\n\n\t\t\t// Update call state\n\t\t\tconst callState = mapTelnyxCallState(call.state);\n\t\t\tconst callInfo: WebRTCCall = {\n\t\t\t\tid: call.id || \"unknown\",\n\t\t\t\tstate: callState,\n\t\t\t\tdirection: call.direction === \"inbound\" ? \"inbound\" : \"outbound\",\n\t\t\t\tremoteNumber:\n\t\t\t\t\t(call as any).remoteNumber || (call as any).to || \"Unknown\",\n\t\t\t\tremoteName: (call as any).remoteName,\n\t\t\t\tlocalNumber: ((call as any).localNumber as string) || \"\",\n\t\t\t\tstartTime: callState === \"active\" ? new Date() : undefined,\n\t\t\t\tduration: 0,\n\t\t\t\tisMuted: false,\n\t\t\t\tisHeld: call.state === \"held\",\n\t\t\t\tisRecording: false,\n\t\t\t};\n\n\t\t\tsetCurrentCall(callInfo);\n\t\t\tactiveCallRef.current = call;\n\n\t\t\t// Notify parent component\n\t\t\tif (call.direction === \"inbound\" && call.state === \"ringing\") {\n\t\t\t\toptionsRef.current.onIncomingCall?.(callInfo);\n\t\t\t}\n\n\t\t\t// Handle call ended\n\t\t\tif (call.state === \"destroy\" || call.state === \"hangup\") {\n\t\t\t\toptionsRef.current.onCallEnded?.(callInfo);\n\t\t\t\tsetCurrentCall(null);\n\t\t\t\tactiveCallRef.current = null;\n\t\t\t}\n\t\t});\n\n\t\tclientRef.current = client;\n\t\treturn client;\n\t}, []); //  No dependencies - uses ref\n\n\t/**\n\t * Connect to Telnyx\n\t */\n\tconst connect = useCallback(async () => {\n\t\ttry {\n\t\t\tconsole.log(\" WebRTC: Starting connection...\");\n\t\t\tsetIsConnecting(true);\n\t\t\tsetConnectionError(null);\n\n\t\t\tconst client = initializeClient();\n\n\t\t\t// If client is null (no credentials), silently fail\n\t\t\tif (!client) {\n\t\t\t\tconsole.warn(\" WebRTC: No credentials available, aborting connection\");\n\t\t\t\tsetIsConnecting(false);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.log(\" WebRTC: Client initialized, calling connect()...\");\n\t\t\tawait client.connect();\n\t\t\tconsole.log(\" WebRTC: client.connect() completed\");\n\t\t} catch (error) {\n\t\t\tconsole.error(\" WebRTC: Connection error in connect():\", error);\n\t\t\tsetConnectionError(\n\t\t\t\terror instanceof Error ? error.message : \"Connection failed\",\n\t\t\t);\n\t\t\tsetIsConnecting(false);\n\t\t}\n\t}, [initializeClient]);\n\n\t/**\n\t * Disconnect from Telnyx\n\t */\n\tconst disconnect = useCallback(() => {\n\t\t// Disable auto-reconnection\n\t\tshouldReconnectRef.current = false;\n\n\t\t// Clear any pending reconnect timeout\n\t\tif (reconnectTimeoutRef.current) {\n\t\t\tclearTimeout(reconnectTimeoutRef.current);\n\t\t\treconnectTimeoutRef.current = null;\n\t\t}\n\n\t\tif (clientRef.current) {\n\t\t\tclientRef.current.disconnect();\n\t\t\tclientRef.current = null;\n\t\t}\n\t\tsetIsConnected(false);\n\t\tsetIsConnecting(false);\n\t\tsetIsReconnecting(false);\n\t\tsetReconnectAttempts(0);\n\t\tsetCurrentCall(null);\n\t\tactiveCallRef.current = null;\n\t}, []);\n\n\t/**\n\t * Make an outbound call\n\t */\n\tconst makeCall = useCallback(\n\t\tasync (destination: string, callerIdNumber?: string) => {\n\t\t\t// Normalize phone numbers to E.164 format\n\t\t\tconst normalizeToE164 = (phone: string): string => {\n\t\t\t\tconst digits = phone.replace(/\\D/g, \"\");\n\t\t\t\tif (digits.length === 10) {\n\t\t\t\t\treturn `+1${digits}`;\n\t\t\t\t}\n\t\t\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\t\t\treturn `+${digits}`;\n\t\t\t\t}\n\t\t\t\tif (digits.length > 10 && !phone.startsWith(\"+\")) {\n\t\t\t\t\treturn `+${digits}`;\n\t\t\t\t}\n\t\t\t\treturn phone.startsWith(\"+\") ? phone : `+${digits}`;\n\t\t\t};\n\n\t\t\tconst normalizedDestination = normalizeToE164(destination);\n\t\t\tconst normalizedCallerId = callerIdNumber ? normalizeToE164(callerIdNumber) : undefined;\n\n\t\t\tconsole.log(\" WebRTC makeCall:\", {\n\t\t\t\tdestination,\n\t\t\t\tnormalizedDestination,\n\t\t\t\tcallerIdNumber,\n\t\t\t\tnormalizedCallerId,\n\t\t\t\tisConnected,\n\t\t\t\thasClient: !!clientRef.current,\n\t\t\t});\n\n\t\t\tif (!(clientRef.current && isConnected)) {\n\t\t\t\tconsole.error(\" WebRTC makeCall: Not connected to Telnyx\");\n\t\t\t\tthrow new Error(\"Not connected to Telnyx\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconsole.log(\" WebRTC: Calling newCall()...\");\n\t\t\t\tconst call = await clientRef.current.newCall({\n\t\t\t\t\tdestinationNumber: normalizedDestination,\n\t\t\t\t\tcallerNumber: normalizedCallerId,\n\t\t\t\t});\n\n\t\t\t\tconsole.log(\" WebRTC: newCall() returned:\", {\n\t\t\t\t\tcallId: call?.id,\n\t\t\t\t\tcallState: (call as any)?.state,\n\t\t\t\t});\n\n\t\t\t\tactiveCallRef.current = call;\n\n\t\t\t\t// Set initial call state immediately\n\t\t\t\tconst callInfo: WebRTCCall = {\n\t\t\t\t\tid: call.id,\n\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\tdirection: \"outbound\",\n\t\t\t\t\tremoteNumber: destination,\n\t\t\t\t\tlocalNumber: callerIdNumber || \"\",\n\t\t\t\t\tduration: 0,\n\t\t\t\t\tisMuted: false,\n\t\t\t\t\tisHeld: false,\n\t\t\t\t\tisRecording: false,\n\t\t\t\t};\n\t\t\t\tsetCurrentCall(callInfo);\n\n\t\t\t\treturn call;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\" WebRTC makeCall error:\", error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\t\t[isConnected],\n\t);\n\n\t/**\n\t * Answer incoming call\n\t */\n\tconst answerCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to answer\");\n\t\t}\n\t\tawait activeCallRef.current.answer();\n\t}, []);\n\n\t/**\n\t * End active call\n\t */\n\tconst endCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to end\");\n\t\t}\n\t\tawait activeCallRef.current.hangup();\n\t\tsetCurrentCall(null);\n\t\tactiveCallRef.current = null;\n\t}, []);\n\n\t/**\n\t * Mute call\n\t */\n\tconst muteCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to mute\");\n\t\t}\n\t\tawait activeCallRef.current.muteAudio();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isMuted: true } : null));\n\t}, []);\n\n\t/**\n\t * Unmute call\n\t */\n\tconst unmuteCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to unmute\");\n\t\t}\n\t\tawait activeCallRef.current.unmuteAudio();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isMuted: false } : null));\n\t}, []);\n\n\t/**\n\t * Hold call\n\t */\n\tconst holdCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to hold\");\n\t\t}\n\t\tawait activeCallRef.current.hold();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isHeld: true } : null));\n\t}, []);\n\n\t/**\n\t * Unhold call\n\t */\n\tconst unholdCall = useCallback(async () => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call to unhold\");\n\t\t}\n\t\tawait activeCallRef.current.unhold();\n\t\tsetCurrentCall((prev) => (prev ? { ...prev, isHeld: false } : null));\n\t}, []);\n\n\t/**\n\t * Send DTMF tone\n\t */\n\tconst sendDTMF = useCallback(async (digit: string) => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call\");\n\t\t}\n\t\tawait activeCallRef.current.dtmf(digit);\n\t}, []);\n\n\t/**\n\t * Set audio output device\n\t */\n\tconst setAudioDevice = useCallback(async (deviceId: string) => {\n\t\tif (!activeCallRef.current) {\n\t\t\tthrow new Error(\"No active call\");\n\t\t}\n\t\tawait activeCallRef.current.setAudioOutDevice(deviceId);\n\t}, []);\n\n\t/**\n\t * Load audio devices\n\t */\n\tconst loadAudioDevices = useCallback(async () => {\n\t\t// Check if MediaDevices API is available\n\t\tif (\n\t\t\ttypeof navigator === \"undefined\" ||\n\t\t\t!navigator.mediaDevices ||\n\t\t\t!navigator.mediaDevices.enumerateDevices\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst devices = await navigator.mediaDevices.enumerateDevices();\n\t\t\tconst audioOutputDevices = devices.filter(\n\t\t\t\t(d) => d.kind === \"audiooutput\",\n\t\t\t);\n\t\t\tsetAudioDevices(audioOutputDevices);\n\t\t} catch {\n\t\t\t// Ignore audio device loading errors\n\t\t}\n\t}, []);\n\n\t/**\n\t * Auto-connect on mount if enabled\n\t * Uses ref pattern to prevent infinite loop from dependency chain\n\t */\n\tuseEffect(() => {\n\t\t// Check if MediaDevices API is available\n\t\tif (\n\t\t\ttypeof navigator === \"undefined\" ||\n\t\t\t!navigator.mediaDevices ||\n\t\t\t!navigator.mediaDevices.enumerateDevices\n\t\t) {\n\t\t\treturn () => {\n\t\t\t\t// No-op cleanup when MediaDevices API is not available\n\t\t\t};\n\t\t}\n\n\t\t// Load audio devices on mount\n\t\tloadAudioDevices();\n\n\t\t// Listen for device changes\n\t\tconst deviceChangeHandler = () => {\n\t\t\tloadAudioDevices();\n\t\t};\n\t\tnavigator.mediaDevices.addEventListener(\n\t\t\t\"devicechange\",\n\t\t\tdeviceChangeHandler,\n\t\t);\n\n\t\treturn () => {\n\t\t\tif (navigator.mediaDevices) {\n\t\t\t\tnavigator.mediaDevices.removeEventListener(\n\t\t\t\t\t\"devicechange\",\n\t\t\t\t\tdeviceChangeHandler,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [\n\t\t// Load audio devices on mount\n\t\tloadAudioDevices,\n\t]); //  Runs once on mount only - loadAudioDevices is stable (useCallback with no deps)\n\n\t/**\n\t * Separate effect for auto-connect to prevent dependency loop\n\t */\n\tuseEffect(() => {\n\t\tif (optionsRef.current.autoConnect) {\n\t\t\tconnect();\n\t\t}\n\n\t\treturn () => {\n\t\t\t// Cleanup on unmount\n\t\t\tdisconnect();\n\t\t};\n\t}, [\n\t\tconnect, // Cleanup on unmount\n\t\tdisconnect,\n\t]); //  Runs once - uses ref for options\n\n\treturn {\n\t\t// Connection state\n\t\tisConnected,\n\t\tisConnecting,\n\t\tisReconnecting,\n\t\tconnectionError,\n\t\treconnectAttempts,\n\n\t\t// Current call\n\t\tcurrentCall,\n\n\t\t// Call actions\n\t\tmakeCall,\n\t\tanswerCall,\n\t\tendCall,\n\t\tmuteCall,\n\t\tunmuteCall,\n\t\tholdCall,\n\t\tunholdCall,\n\t\tsendDTMF,\n\n\t\t// Connection actions\n\t\tconnect,\n\t\tdisconnect,\n\t\treconnect,\n\n\t\t// Audio devices\n\t\taudioDevices,\n\t\tsetAudioDevice,\n\t};\n}\n\n/**\n * Map Telnyx call state to our call state\n */\nfunction mapTelnyxCallState(telnyxState: string): CallState {\n\tswitch (telnyxState) {\n\t\tcase \"new\":\n\t\tcase \"requesting\":\n\t\t\treturn \"connecting\";\n\t\tcase \"trying\":\n\t\tcase \"recovering\":\n\t\tcase \"ringing\":\n\t\t\treturn \"ringing\";\n\t\tcase \"active\":\n\t\t\treturn \"active\";\n\t\tcase \"held\":\n\t\t\treturn \"held\";\n\t\tcase \"hangup\":\n\t\tcase \"destroy\":\n\t\t\treturn \"ended\";\n\t\tdefault:\n\t\t\treturn \"idle\";\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2663, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-toast.ts"],"sourcesContent":["/**\n * Toast Hook - Wrapper around Sonner\n *\n * Provides a consistent interface for displaying toast notifications\n * across the application with success, error, loading, and promise states.\n *\n * @example\n * const { toast } = useToast();\n *\n * // Success\n * toast.success(\"Customer created successfully!\");\n *\n * // Error\n * toast.error(\"Failed to save changes\");\n *\n * // Loading\n * const id = toast.loading(\"Saving...\");\n * toast.success(\"Saved!\", { id });\n *\n * // Promise\n * toast.promise(createCustomer(data), {\n *   loading: \"Creating customer...\",\n *   success: \"Customer created!\",\n *   error: \"Failed to create customer\"\n * });\n */\n\nimport { toast as sonnerToast } from \"sonner\";\n\nexport function useToast() {\n\treturn {\n\t\ttoast: {\n\t\t\tsuccess: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.success(message, {\n\t\t\t\t\tduration: 3000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\terror: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.error(message, {\n\t\t\t\t\tduration: 5000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\tloading: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.loading(message, options),\n\n\t\t\tinfo: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.info(message, {\n\t\t\t\t\tduration: 3000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\twarning: (message: string, options?: any) =>\n\t\t\t\tsonnerToast.warning(message, {\n\t\t\t\t\tduration: 4000,\n\t\t\t\t\t...options,\n\t\t\t\t}),\n\n\t\t\tpromise: <T>(\n\t\t\t\tpromise: Promise<T>,\n\t\t\t\tmessages: {\n\t\t\t\t\tloading: string;\n\t\t\t\t\tsuccess: string | ((data: T) => string);\n\t\t\t\t\terror: string | ((error: any) => string);\n\t\t\t\t},\n\t\t\t) => sonnerToast.promise(promise, messages),\n\n\t\t\tdismiss: (id?: string | number) => {\n\t\t\t\tsonnerToast.dismiss(id);\n\t\t\t},\n\n\t\t\t// Shorthand for Server Action responses\n\t\t\tfromActionResult: (result: {\n\t\t\t\tsuccess: boolean;\n\t\t\t\terror?: string;\n\t\t\t\tmessage?: string;\n\t\t\t}) => {\n\t\t\t\tif (result.success) {\n\t\t\t\t\tsonnerToast.success(\n\t\t\t\t\t\tresult.message || \"Operation completed successfully\",\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tsonnerToast.error(result.error || \"Operation failed\");\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t};\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;CAyBC;;;;AAED;;AAEO,SAAS;IACf,OAAO;QACN,OAAO;YACN,SAAS,CAAC,SAAiB,UAC1B,iRAAW,CAAC,OAAO,CAAC,SAAS;oBAC5B,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,OAAO,CAAC,SAAiB,UACxB,iRAAW,CAAC,KAAK,CAAC,SAAS;oBAC1B,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,SAAS,CAAC,SAAiB,UAC1B,iRAAW,CAAC,OAAO,CAAC,SAAS;YAE9B,MAAM,CAAC,SAAiB,UACvB,iRAAW,CAAC,IAAI,CAAC,SAAS;oBACzB,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,SAAS,CAAC,SAAiB,UAC1B,iRAAW,CAAC,OAAO,CAAC,SAAS;oBAC5B,UAAU;oBACV,GAAG,OAAO;gBACX;YAED,SAAS,CACR,SACA,WAKI,iRAAW,CAAC,OAAO,CAAC,SAAS;YAElC,SAAS,CAAC;gBACT,iRAAW,CAAC,OAAO,CAAC;YACrB;YAEA,wCAAwC;YACxC,kBAAkB,CAAC;gBAKlB,IAAI,OAAO,OAAO,EAAE;oBACnB,iRAAW,CAAC,OAAO,CAClB,OAAO,OAAO,IAAI;gBAEpB,OAAO;oBACN,iRAAW,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;gBACnC;YACD;QACD;IACD;AACD"}},
    {"offset": {"line": 2733, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/telnyx.ts"],"sourcesContent":["/**\n * Telnyx Server Actions\n *\n * Server-side actions for Telnyx VoIP operations:\n * - Phone number management\n * - Call operations\n * - SMS operations\n * - Voicemail operations\n *\n * All actions include proper authentication and authorization checks.\n */\n\n\"use server\";\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { revalidatePath } from \"next/cache\";\nimport { headers } from \"next/headers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tanswerCall,\n\thangupCall,\n\tinitiateCall,\n\trejectCall,\n\tstartRecording,\n\tstopRecording,\n} from \"@/lib/telnyx/calls\";\nimport { TELNYX_CONFIG } from \"@/lib/telnyx/client\";\nimport {\n\tvalidateCallConfig,\n\tvalidateSmsConfig,\n} from \"@/lib/telnyx/config-validator\";\nimport { verifyConnection } from \"@/lib/telnyx/connection-setup\";\nimport { formatPhoneNumber, sendMMS, sendSMS } from \"@/lib/telnyx/messaging\";\nimport { verifyMessagingProfile } from \"@/lib/telnyx/messaging-profile-setup\";\nimport {\n\ttype NumberFeature,\n\ttype NumberType,\n\tpurchaseNumber,\n\treleaseNumber,\n\tsearchAvailableNumbers,\n} from \"@/lib/telnyx/numbers\";\nimport {\n\tverifySmsCapability,\n\tverifyVoiceCapability,\n} from \"@/lib/telnyx/phone-number-setup\";\nimport {\n\ttype CompanyTelnyxSettingsRow,\n\tensureCompanyTelnyxSetup,\n\tfetchCompanyTelnyxSettings,\n} from \"@/lib/telnyx/provision-company\";\nimport type { Database, Json } from \"@/types/supabase\";\nimport { ensureMessagingCampaign } from \"./messaging-branding\";\n\ntype TypedSupabaseClient = SupabaseClient<Database>;\n\nfunction normalizePhoneNumber(phoneNumber: string): string {\n\treturn formatPhoneNumber(phoneNumber);\n}\n\nfunction extractAreaCode(phoneNumber: string): string | null {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn digits.slice(1, 4);\n\t}\n\tif (digits.length === 10) {\n\t\treturn digits.slice(0, 3);\n\t}\n\treturn null;\n}\n\nconst DEFAULT_MESSAGING_PROFILE_ID =\n\tprocess.env.TELNYX_DEFAULT_MESSAGING_PROFILE_ID ||\n\tprocess.env.NEXT_PUBLIC_TELNYX_MESSAGING_PROFILE_ID ||\n\t\"\";\n\nconst DEFAULT_PHONE_NUMBER_FEATURES: Json = [\"voice\", \"sms\", \"mms\"];\n\nfunction formatDisplayPhoneNumber(phoneNumber: string): string {\n\tconst digits = phoneNumber.replace(/\\D/g, \"\");\n\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\treturn `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\n\t}\n\tif (digits.length === 10) {\n\t\treturn `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n\t}\n\treturn phoneNumber;\n}\n\nasync function getCompanyTelnyxSettings(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string | null,\n): Promise<CompanyTelnyxSettingsRow | null> {\n\tif (!companyId) {\n\t\treturn null;\n\t}\n\n\tconst existing = await fetchCompanyTelnyxSettings(supabase, companyId);\n\tif (existing && existing.status === \"ready\") {\n\t\treturn existing;\n\t}\n\n\tconst provisionResult = await ensureCompanyTelnyxSetup({\n\t\tcompanyId,\n\t\tsupabase,\n\t});\n\n\tif (!provisionResult.success) {\n\t\treturn null;\n\t}\n\n\treturn provisionResult.settings ?? null;\n}\n\nfunction normalizeBaseUrl(url: string): string {\n\tconst trimmed = url.trim().replace(/\\/+$/, \"\");\n\tif (/^https?:\\/\\//i.test(trimmed)) {\n\t\tif (/^http:\\/\\//i.test(trimmed) && !isLocalUrl(trimmed)) {\n\t\t\treturn trimmed.replace(/^http:\\/\\//i, \"https://\");\n\t\t}\n\t\treturn trimmed;\n\t}\n\treturn `https://${trimmed}`;\n}\n\nfunction isLocalUrl(url: string): boolean {\n\tconst lowered = url.toLowerCase();\n\treturn (\n\t\tlowered.includes(\"localhost\") ||\n\t\tlowered.includes(\"127.0.0.1\") ||\n\t\tlowered.includes(\"0.0.0.0\") ||\n\t\tlowered.endsWith(\".local\") ||\n\t\tlowered.includes(\"://local\")\n\t);\n}\n\nfunction shouldUseUrl(url: string): boolean {\n\tif (!url) {\n\t\treturn false;\n\t}\n\tconst trimmed = url.trim();\n\tif (!trimmed) {\n\t\treturn false;\n\t}\n\tconst isHostedProduction =\n\t\t(process.env.VERCEL === \"1\" && process.env.VERCEL_ENV === \"production\") ||\n\t\tprocess.env.DEPLOYMENT_ENV === \"production\";\n\n\tif (isHostedProduction && isLocalUrl(trimmed)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nasync function getBaseAppUrl(): Promise<string | undefined> {\n\tconst candidates = [\n\t\tprocess.env.NEXT_PUBLIC_SITE_URL,\n\t\tprocess.env.SITE_URL,\n\t\tprocess.env.NEXT_PUBLIC_APP_URL,\n\t\tprocess.env.APP_URL,\n\t];\n\tfor (const candidate of candidates) {\n\t\tif (candidate && shouldUseUrl(candidate)) {\n\t\t\treturn normalizeBaseUrl(candidate);\n\t\t}\n\t}\n\n\tconst vercelUrl = process.env.VERCEL_URL;\n\tif (vercelUrl && shouldUseUrl(vercelUrl)) {\n\t\treturn normalizeBaseUrl(\n\t\t\tvercelUrl.startsWith(\"http\") ? vercelUrl : `https://${vercelUrl}`,\n\t\t);\n\t}\n\n\ttry {\n\t\tconst hdrs = await headers();\n\t\tconst origin = hdrs.get(\"origin\");\n\t\tif (origin && shouldUseUrl(origin)) {\n\t\t\treturn normalizeBaseUrl(origin);\n\t\t}\n\t\tconst host = hdrs.get(\"host\");\n\t\tif (host && shouldUseUrl(host)) {\n\t\t\tconst protocol = host.includes(\"localhost\") ? \"http\" : \"https\";\n\t\t\treturn normalizeBaseUrl(`${protocol}://${host}`);\n\t\t}\n\t} catch {\n\t\t// headers() not available outside of a request context\n\t}\n\n\treturn undefined;\n}\n\nasync function buildAbsoluteUrl(path: string): Promise<string | undefined> {\n\tconst base = await getBaseAppUrl();\n\tif (!base) {\n\t\treturn undefined;\n\t}\n\tconst normalizedPath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${base}${normalizedPath}`;\n}\n\nasync function getTelnyxWebhookUrl(\n\tcompanyId?: string,\n): Promise<string | undefined> {\n\tif (companyId) {\n\t\treturn buildAbsoluteUrl(`/api/webhooks/telnyx?company=${companyId}`);\n\t}\n\treturn buildAbsoluteUrl(\"/api/webhooks/telnyx\");\n}\n\nasync function getPhoneNumberId(\n\tsupabase: TypedSupabaseClient,\n\tphoneNumber: string,\n): Promise<string | null> {\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"phone_number\", normalized)\n\t\t.is(\"deleted_at\", null)\n\t\t.maybeSingle();\n\n\treturn data?.id ?? null;\n}\n\nasync function ensurePhoneNumberRecordExists(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\tphoneNumber: string | null,\n): Promise<void> {\n\tif (!phoneNumber) {\n\t\treturn;\n\t}\n\n\tconst normalized = normalizePhoneNumber(phoneNumber);\n\tconst { data } = await supabase\n\t\t.from(\"phone_numbers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"phone_number\", normalized)\n\t\t.limit(1);\n\n\tif (data && data.length > 0) {\n\t\treturn;\n\t}\n\n\tawait supabase.from(\"phone_numbers\").insert({\n\t\tcompany_id: companyId,\n\t\tphone_number: normalized,\n\t\tformatted_number: formatDisplayPhoneNumber(normalized),\n\t\tcountry_code: \"US\",\n\t\tarea_code: extractAreaCode(normalized),\n\t\tnumber_type: \"local\",\n\t\tstatus: \"active\",\n\t\tfeatures: DEFAULT_PHONE_NUMBER_FEATURES,\n\t});\n}\n\nasync function resolveOutboundPhoneNumber(\n\tsupabase: TypedSupabaseClient,\n\tcompanyId: string,\n\texplicitFrom?: string | null,\n\tdefaultNumber?: string | null,\n): Promise<string | null> {\n\tif (explicitFrom) {\n\t\treturn normalizePhoneNumber(explicitFrom);\n\t}\n\n\tconst normalizedDefault = defaultNumber\n\t\t? normalizePhoneNumber(defaultNumber)\n\t\t: null;\n\n\ttry {\n\t\tconst { data } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number, number_type\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (data && data.length > 0) {\n\t\t\tconst tollFree = data.find((n) => n.number_type === \"toll-free\");\n\t\t\tif (tollFree) {\n\t\t\t\treturn normalizePhoneNumber(tollFree.phone_number);\n\t\t\t}\n\n\t\t\tif (normalizedDefault) {\n\t\t\t\tconst defaultExists = data.some(\n\t\t\t\t\t(n) => normalizePhoneNumber(n.phone_number) === normalizedDefault,\n\t\t\t\t);\n\t\t\t\tif (defaultExists) {\n\t\t\t\t\treturn normalizedDefault;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn normalizePhoneNumber(data[0].phone_number);\n\t\t}\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"Failed to load company phone numbers for outbound selection:\",\n\t\t\terror,\n\t\t);\n\t}\n\n\treturn normalizedDefault;\n}\n\nasync function mergeProviderMetadata(\n\tsupabase: TypedSupabaseClient,\n\tcommunicationId: string,\n\tpatch: Record<string, Json>,\n): Promise<void> {\n\tconst { data } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"provider_metadata\")\n\t\t.eq(\"id\", communicationId)\n\t\t.maybeSingle();\n\n\tconst currentMetadata =\n\t\t(data?.provider_metadata as Record<string, Json> | null) ?? {};\n\tconst mergedMetadata: Record<string, Json> = {\n\t\t...currentMetadata,\n\t\t...patch,\n\t};\n\n\tawait supabase\n\t\t.from(\"communications\")\n\t\t.update({\n\t\t\tprovider_metadata: mergedMetadata,\n\t\t})\n\t\t.eq(\"id\", communicationId);\n}\n\n// =====================================================================================\n// PHONE NUMBER MANAGEMENT ACTIONS\n// =====================================================================================\n\n/**\n * Search for available phone numbers to purchase\n */\nexport async function searchPhoneNumbers(params: {\n\tareaCode?: string;\n\tnumberType?: NumberType;\n\tfeatures?: NumberFeature[];\n\tlimit?: number;\n}) {\n\ttry {\n\t\tconst result = await searchAvailableNumbers({\n\t\t\tcountryCode: \"US\",\n\t\t\tareaCode: params.areaCode,\n\t\t\tnumberType: params.numberType,\n\t\t\tfeatures: params.features,\n\t\t\tlimit: params.limit || 10,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to search phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Purchase a phone number and associate it with the current company\n */\nexport async function purchasePhoneNumber(params: {\n\tphoneNumber: string;\n\tcompanyId: string;\n\tbillingGroupId?: string;\n}) {\n\ttry {\n\t\t// Validate configuration\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tconst callConfig = validateCallConfig();\n\t\tif (!smsConfig.valid || !callConfig.valid) {\n\t\t\tlet errorMessage =\n\t\t\t\t\"Telnyx configuration is incomplete. Please configure all required environment variables.\";\n\n\t\t\t// If we have a suggested profile ID, include it in the error\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} to use it.`;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst normalizedPhoneNumber = normalizePhoneNumber(params.phoneNumber);\n\t\tconst formattedNumber = formatDisplayPhoneNumber(normalizedPhoneNumber);\n\t\tconst areaCode = extractAreaCode(normalizedPhoneNumber);\n\n\t\t// Purchase number from Telnyx\n\t\tconst messagingProfileId = DEFAULT_MESSAGING_PROFILE_ID || undefined;\n\n\t\tconst result = await purchaseNumber({\n\t\t\tphoneNumber: normalizedPhoneNumber,\n\t\t\tconnectionId: TELNYX_CONFIG.connectionId,\n\t\t\tmessagingProfileId,\n\t\t\tbillingGroupId: params.billingGroupId,\n\t\t\tcustomerReference: `company_${params.companyId}`,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Store in database\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\ttelnyx_phone_number_id: result.orderId,\n\t\t\t\ttelnyx_connection_id: TELNYX_CONFIG.connectionId,\n\t\t\t\tphone_number: normalizedPhoneNumber,\n\t\t\t\tformatted_number: formattedNumber,\n\t\t\t\tcountry_code: \"US\",\n\t\t\t\tarea_code: areaCode,\n\t\t\t\tnumber_type: \"local\",\n\t\t\t\tfeatures: [\"voice\", \"sms\"],\n\t\t\t\tstatus: \"pending\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\ttry {\n\t\t\tawait ensureMessagingCampaign(\n\t\t\t\tparams.companyId,\n\t\t\t\t{ id: data.id, e164: normalizedPhoneNumber },\n\t\t\t\t{ supabase },\n\t\t\t);\n\t\t} catch (_campaignError) {}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to purchase phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Get all phone numbers for a company\n */\nexport async function getCompanyPhoneNumbers(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get phone numbers\",\n\t\t};\n\t}\n}\n\n/**\n * Update phone number configuration\n */\nasync function updatePhoneNumber(params: {\n\tphoneNumberId: string;\n\troutingRuleId?: string;\n\tforwardToNumber?: string;\n\tvoicemailEnabled?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tcall_routing_rule_id: params.routingRuleId,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tvoicemail_enabled: params.voicemailEnabled,\n\t\t\t})\n\t\t\t.eq(\"id\", params.phoneNumberId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update phone number\",\n\t\t};\n\t}\n}\n\n/**\n * Release (delete) a phone number\n */\nasync function deletePhoneNumber(phoneNumberId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get phone number details\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", phoneNumberId)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) {\n\t\t\treturn { success: false, error: \"Phone number not found\" };\n\t\t}\n\n\t\t// Release from Telnyx if we have the ID\n\t\tif (phoneNumber.telnyx_phone_number_id) {\n\t\t\tawait releaseNumber(phoneNumber.telnyx_phone_number_id);\n\t\t}\n\n\t\t// Soft delete in database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tstatus: \"deleted\",\n\t\t\t})\n\t\t\t.eq(\"id\", phoneNumberId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/phone-numbers\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete phone number\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Initiate an outbound call\n */\nexport async function makeCall(params: {\n\tto: string;\n\tfrom: string;\n\tcompanyId: string;\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconsole.log(\" makeCall called with params:\", params);\n\n\t\tconst callConfig = validateCallConfig();\n\t\tconsole.log(\" Call config validation:\", callConfig);\n\t\tif (!callConfig.valid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: callConfig.error || \"Call configuration is invalid\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t);\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tconst connectionOverride =\n\t\t\tcompanySettings?.call_control_application_id ||\n\t\t\tTELNYX_CONFIG.connectionId;\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tparams.companyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings?.default_outbound_number || null,\n\t\t);\n\n\t\tif (!connectionOverride) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"No Telnyx connection configured for this company.\",\n\t\t\t};\n\t\t}\n\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\n\t\t// TEMP: Skip connection verification - Level 2 required for API access\n\t\t// const connectionStatus = await verifyConnection(connectionOverride);\n\t\t// if (connectionStatus.needsFix) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror: `Connection configuration issue: ${connectionStatus.issues.join(\", \")}. Run fixConnection() to auto-fix.`,\n\t\t// \t};\n\t\t// }\n\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\t// TEMP: Skip voice capability check - Level 2 required for API access\n\t\t// const voiceCapability = await verifyVoiceCapability(fromAddress);\n\t\t// if (!voiceCapability.hasVoice) {\n\t\t// \treturn {\n\t\t// \t\tsuccess: false,\n\t\t// \t\terror:\n\t\t// \t\t\tvoiceCapability.error || \"Phone number does not support voice calls\",\n\t\t// \t};\n\t\t// }\n\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl(params.companyId);\n\t\tconsole.log(\" Webhook URL:\", telnyxWebhookUrl);\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\" Initiating call:\", {\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\tconst result = await initiateCall({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\tconnectionId: connectionOverride,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t\tansweringMachineDetection: \"premium\",\n\t\t});\n\n\t\tconsole.log(\" Telnyx API response:\", result);\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"phone\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: \"\",\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_call_control_id: result.callControlId,\n\t\t\t\ttelnyx_call_session_id: result.callSessionId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconsole.log(\" Call created successfully:\", {\n\t\t\tcallControlId: result.callControlId,\n\t\t\tcommunicationId: data.id,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcallControlId: result.callControlId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\" makeCall error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to make call\",\n\t\t};\n\t}\n}\n\n/**\n * Answer an incoming call\n/**\n * Answer an incoming call\n */\nasync function acceptCall(callControlId: string) {\n\ttry {\n\t\tconst telnyxWebhookUrl = await getTelnyxWebhookUrl();\n\t\tif (!telnyxWebhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconst result = await answerCall({\n\t\t\tcallControlId,\n\t\t\twebhookUrl: telnyxWebhookUrl,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to answer call\",\n\t\t};\n\t}\n}\n\n/**\n * Reject an incoming call\n */\nasync function declineCall(callControlId: string) {\n\ttry {\n\t\tconst result = await rejectCall({\n\t\t\tcallControlId,\n\t\t\tcause: \"CALL_REJECTED\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to reject call\",\n\t\t};\n\t}\n}\n\n/**\n * End an active call\n */\nasync function endCall(callControlId: string) {\n\ttry {\n\t\tconst result = await hangupCall({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to end call\",\n\t\t};\n\t}\n}\n\n/**\n * Start recording a call\n */\nexport async function startCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await startRecording({\n\t\t\tcallControlId,\n\t\t\tformat: \"mp3\",\n\t\t\tchannels: \"single\",\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to start recording\",\n\t\t};\n\t}\n}\n\n/**\n * Stop recording a call\n */\nexport async function stopCallRecording(callControlId: string) {\n\ttry {\n\t\tconst result = await stopRecording({ callControlId });\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to stop recording\",\n\t\t};\n\t}\n}\n\n/**\n * Transfer an active call to another number\n */\nexport async function transferActiveCall(params: {\n\tcallControlId: string;\n\tto: string;\n\tfrom: string;\n}) {\n\ttry {\n\t\tconst { transferCall } = await import(\"@/lib/telnyx/calls\");\n\t\tconst result = await transferCall({\n\t\t\tcallControlId: params.callControlId,\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t});\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to transfer call\",\n\t\t};\n\t}\n}\n\n/**\n * Transcribe a call recording using AssemblyAI\n *\n * Submits the recording URL to AssemblyAI for post-call transcription.\n * AssemblyAI will process the audio and send the transcript via webhook.\n *\n * @param recordingUrl - URL of the call recording (from Telnyx)\n * @param communicationId - Database ID of the communication record\n * @returns Success/error response with transcription job ID\n */\nexport async function transcribeCallRecording(params: {\n\trecordingUrl: string;\n\tcommunicationId: string;\n}) {\n\ttry {\n\t\tconst { submitTranscription } = await import(\"@/lib/assemblyai/client\");\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst webhookUrl = await buildAbsoluteUrl(\"/api/webhooks/assemblyai\");\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL.\",\n\t\t\t};\n\t\t}\n\n\t\t// Submit to AssemblyAI\n\t\tconst result = await submitTranscription({\n\t\t\taudio_url: params.recordingUrl,\n\t\t\tspeaker_labels: true, // Enable speaker diarization\n\t\t\twebhook_url: webhookUrl,\n\t\t});\n\n\t\tif (!(result.success && result.data)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error || \"Failed to submit transcription\",\n\t\t\t};\n\t\t}\n\n\t\t// Store transcription job ID in database\n\t\tawait mergeProviderMetadata(supabase, params.communicationId, {\n\t\t\tassemblyai_transcription_id: result.data.id,\n\t\t\tassemblyai_status: result.data.status,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttranscriptionId: result.data.id,\n\t\t\tstatus: result.data.status,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to transcribe recording\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// SMS OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Send an SMS message\n */\nexport async function sendTextMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext: string;\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tconsole.error(\" Supabase client unavailable\");\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\" SMS Send Request:\", {\n\t\t\tto: params.to,\n\t\t\tfrom: params.from,\n\t\t\tcompanyId,\n\t\t});\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\tconsole.error(\" Company settings not found\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify the company's onboarding is complete and try again.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Company settings loaded:\", {\n\t\t\tmessagingProfileId: companySettings.messaging_profile_id,\n\t\t\tdefaultNumber: companySettings.default_outbound_number,\n\t\t});\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings?.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or provision company-specific settings.`;\n\t\t\t}\n\t\t\tconsole.error(\" SMS config invalid:\", errorMessage);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS config valid\");\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings?.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\tconsole.error(\" No messaging profile ID\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending SMS.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Using messaging profile:\", messagingProfileId);\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t\" Messaging profile needs fix:\",\n\t\t\t\t\tmessagingProfileStatus.issues,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconsole.log(\" Messaging profile verified\");\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\tconsole.error(\" No from number available\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured. Please provision numbers first.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\t\tconsole.log(\" Phone numbers normalized:\", {\n\t\t\tfrom: fromAddress,\n\t\t\tto: toAddress,\n\t\t});\n\n\t\t// Verify phone number has SMS capability\n\t\tconsole.log(\" Verifying SMS capability for:\", fromAddress);\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\tconsole.error(\" SMS capability check failed:\", smsCapability.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" SMS capability verified\");\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\tconsole.error(\" No webhook URL\");\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\" Webhook URL:\", webhookUrl);\n\n\t\t// Send SMS via Telnyx\n\t\tconsole.log(\" Sending SMS via Telnyx API...\");\n\t\tconst result = await sendSMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\tconsole.error(\" Telnyx API failed:\", result.error);\n\n\t\t\t// Check if error is 10DLC registration required\n\t\t\tif (\n\t\t\t\tresult.error &&\n\t\t\t\t(result.error.includes(\"10DLC\") ||\n\t\t\t\t\tresult.error.includes(\"Not 10DLC registered\") ||\n\t\t\t\t\tresult.error.includes(\"A2P\"))\n\t\t\t) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\" Detected 10DLC registration required, attempting auto-registration...\",\n\t\t\t\t);\n\n\t\t\t\t// Import 10DLC registration function\n\t\t\t\tconst { registerCompanyFor10DLC } = await import(\n\t\t\t\t\t\"@/actions/ten-dlc-registration\"\n\t\t\t\t);\n\n\t\t\t\tconst registrationResult = await registerCompanyFor10DLC(\n\t\t\t\t\tcompanyId,\n\t\t\t\t);\n\n\t\t\t\tif (registrationResult.success) {\n\t\t\t\t\tconsole.log(\" 10DLC registration successful, retrying SMS send...\");\n\n\t\t\t\t\t// Retry the SMS send now that 10DLC is registered\n\t\t\t\t\tconst retryResult = await sendSMS({\n\t\t\t\t\t\tto: toAddress,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\ttext: params.text,\n\t\t\t\t\t\twebhookUrl,\n\t\t\t\t\t\tmessagingProfileId,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!retryResult.success) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\terror: `10DLC registration completed but SMS still failed: ${retryResult.error}. The campaign may need additional approval time.`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update result with retry success\n\t\t\t\t\tresult.success = true;\n\t\t\t\t\tresult.messageId = retryResult.messageId;\n\t\t\t\t\tconsole.log(\" SMS retry successful after 10DLC registration\");\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: `10DLC registration failed: ${registrationResult.error}. Original error: ${result.error}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tconsole.log(\" Telnyx API success:\", result.messageId);\n\n\t\t// Create communication record\n\t\tconsole.log(\" Creating communication record in database...\");\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"SMS send error:\", error);\n\t\tconsole.error(\"Error details:\", {\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\ttype: typeof error,\n\t\t\tstringified: JSON.stringify(error, null, 2),\n\t\t});\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to send SMS: ${String(error)}`,\n\t\t};\n\t}\n}\n\n/**\n * Send an MMS message with media\n */\nexport async function sendMMSMessage(params: {\n\tto: string;\n\tfrom: string;\n\ttext?: string;\n\tmediaUrls: string[];\n\tcompanyId?: string; // Optional - will be fetched if not provided\n\tcustomerId?: string;\n\tjobId?: string;\n\tpropertyId?: string;\n\tinvoiceId?: string;\n\testimateId?: string;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get company ID if not provided\n\t\tlet companyId = params.companyId;\n\t\tif (!companyId) {\n\t\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\t\tcompanyId = await getActiveCompanyId();\n\t\t\tif (!companyId) {\n\t\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t\t}\n\t\t}\n\n\t\tconst companySettings = await getCompanyTelnyxSettings(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\t\tif (!companySettings) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to provision Telnyx resources for this company. Please verify onboarding is complete.\",\n\t\t\t};\n\t\t}\n\n\t\tawait ensurePhoneNumberRecordExists(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\n\t\tconst smsConfig = await validateSmsConfig();\n\t\tif (!smsConfig.valid && !companySettings.messaging_profile_id) {\n\t\t\tlet errorMessage = smsConfig.error || \"SMS configuration is invalid\";\n\t\t\tif (smsConfig.suggestedProfileId) {\n\t\t\t\terrorMessage += ` Found messaging profile \"${smsConfig.suggestedProfileId}\" in your Telnyx account. Set TELNYX_DEFAULT_MESSAGING_PROFILE_ID=${smsConfig.suggestedProfileId} or reprovision the company.`;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorMessage,\n\t\t\t};\n\t\t}\n\n\t\tconst messagingProfileId =\n\t\t\tcompanySettings.messaging_profile_id || DEFAULT_MESSAGING_PROFILE_ID;\n\t\tif (!messagingProfileId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Messaging profile is not configured for this company. Please provision communications before sending MMS.\",\n\t\t\t};\n\t\t}\n\n\t\tconst fromAddress = await resolveOutboundPhoneNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tparams.from,\n\t\t\tcompanySettings.default_outbound_number,\n\t\t);\n\t\tif (!fromAddress) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Company does not have a default outbound phone number configured.\",\n\t\t\t};\n\t\t}\n\t\tconst toAddress = normalizePhoneNumber(params.to);\n\n\t\tconst webhookUrl = await getTelnyxWebhookUrl(companyId);\n\t\tif (!webhookUrl) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Site URL is not configured. Set NEXT_PUBLIC_SITE_URL or SITE_URL to a public https domain.\",\n\t\t\t};\n\t\t}\n\n\t\tif (messagingProfileId) {\n\t\t\tconst messagingProfileStatus =\n\t\t\t\tawait verifyMessagingProfile(messagingProfileId);\n\t\t\tif (messagingProfileStatus.needsFix) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Messaging profile configuration issue: ${messagingProfileStatus.issues.join(\", \")}. Run fixMessagingProfile() or reprovision the company.`,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst smsCapability = await verifySmsCapability(fromAddress);\n\t\tif (!smsCapability.hasSms) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: smsCapability.error || \"Phone number does not support SMS/MMS\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await sendMMS({\n\t\t\tto: toAddress,\n\t\t\tfrom: fromAddress,\n\t\t\ttext: params.text,\n\t\t\tmediaUrls: params.mediaUrls,\n\t\t\twebhookUrl,\n\t\t\tmessagingProfileId,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst phoneNumberId = await getPhoneNumberId(supabase, fromAddress);\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tjob_id: params.jobId ?? null,\n\t\t\t\tproperty_id: params.propertyId ?? null,\n\t\t\t\tinvoice_id: params.invoiceId ?? null,\n\t\t\t\testimate_id: params.estimateId ?? null,\n\t\t\t\ttype: \"sms\",\n\t\t\t\tchannel: \"telnyx\",\n\t\t\t\tdirection: \"outbound\",\n\t\t\t\tfrom_address: fromAddress,\n\t\t\t\tto_address: toAddress,\n\t\t\t\tbody: params.text || \"\",\n\t\t\t\tattachments: params.mediaUrls.map((url) => ({ url, type: \"image\" })),\n\t\t\t\tattachment_count: params.mediaUrls.length,\n\t\t\t\tstatus: \"queued\",\n\t\t\t\tpriority: \"normal\",\n\t\t\t\tphone_number_id: phoneNumberId,\n\t\t\t\tis_archived: false,\n\t\t\t\tis_automated: false,\n\t\t\t\tis_internal: false,\n\t\t\t\tis_thread_starter: true,\n\t\t\t\ttelnyx_message_id: result.messageId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.messageId,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to send MMS\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// WEBRTC OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Generate WebRTC credentials for browser calling\n */\nexport async function getWebRTCCredentials() {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: userError,\n\t\t} = await supabase.auth.getUser();\n\t\tif (userError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User not authenticated\",\n\t\t\t};\n\t\t}\n\n\t\t// OPTION 1: Use static credentials from environment (recommended for production)\n\t\tconst staticUsername = process.env.TELNYX_WEBRTC_USERNAME;\n\t\tconst staticPassword = process.env.TELNYX_WEBRTC_PASSWORD;\n\n\t\tif (staticUsername && staticPassword) {\n\t\t\tconst credential = {\n\t\t\t\tusername: staticUsername,\n\t\t\t\tpassword: staticPassword,\n\t\t\t\texpires_at: Date.now() + 86_400 * 1000, // 24 hours from now\n\t\t\t\trealm: \"sip.telnyx.com\",\n\t\t\t\tsip_uri: `sip:${staticUsername}@sip.telnyx.com`,\n\t\t\t\tstun_servers: [\n\t\t\t\t\t\"stun:stun.telnyx.com:3478\",\n\t\t\t\t\t\"stun:stun.telnyx.com:3479\",\n\t\t\t\t],\n\t\t\t\tturn_servers: [\n\t\t\t\t\t{\n\t\t\t\t\t\turls: [\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=udp\",\n\t\t\t\t\t\t\t\"turn:turn.telnyx.com:3478?transport=tcp\",\n\t\t\t\t\t\t],\n\t\t\t\t\t\tusername: staticUsername,\n\t\t\t\t\t\tcredential: staticPassword,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tcredential,\n\t\t\t};\n\t\t}\n\n\t\tconst { generateWebRTCToken } = await import(\"@/lib/telnyx/webrtc\");\n\t\tconst result = await generateWebRTCToken({\n\t\t\tusername: user.email || user.id,\n\t\t\tttl: 86_400, // 24 hours\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcredential: result.credential,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get WebRTC credentials\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// VOICEMAIL OPERATIONS ACTIONS\n// =====================================================================================\n\n/**\n * Get all voicemails for a company\n */\nasync function getVoicemails(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        customer:customers(id, first_name, last_name, email, phone),\n        phone_number:phone_numbers(phone_number, formatted_number)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"received_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get voicemails\",\n\t\t};\n\t}\n}\n\n/**\n * Mark voicemail as read\n */\nasync function markVoicemailAsRead(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tis_read: true,\n\t\t\t\tread_at: new Date().toISOString(),\n\t\t\t\tread_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to mark voicemail as read\",\n\t\t};\n\t}\n}\n\n/**\n * Delete voicemail\n */\nasync function deleteVoicemail(voicemailId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", voicemailId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/communication\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to delete voicemail\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// CALL ROUTING RULES ACTIONS\n// =====================================================================================\n\n/**\n * Get all call routing rules for a company\n */\nexport async function getCallRoutingRules(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        created_by_user:users!call_routing_rules_created_by_fkey(id, name, email),\n        forward_to_user:users!call_routing_rules_forward_to_user_id_fkey(id, name, email)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"priority\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get call routing rules\",\n\t\t};\n\t}\n}\n\n/**\n * Create a new call routing rule\n */\nasync function createCallRoutingRule(params: {\n\tcompanyId: string;\n\tuserId: string;\n\tname: string;\n\tdescription?: string;\n\troutingType:\n\t\t| \"direct\"\n\t\t| \"round_robin\"\n\t\t| \"ivr\"\n\t\t| \"business_hours\"\n\t\t| \"conditional\";\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: params.companyId,\n\t\t\t\tcreated_by: params.userId,\n\t\t\t\tname: params.name,\n\t\t\t\tdescription: params.description,\n\t\t\t\trouting_type: params.routingType,\n\t\t\t\tpriority: params.priority || 0,\n\t\t\t\tbusiness_hours: params.businessHours,\n\t\t\t\ttimezone: params.timezone || \"America/Los_Angeles\",\n\t\t\t\tafter_hours_action: params.afterHoursAction,\n\t\t\t\tafter_hours_forward_to: params.afterHoursForwardTo,\n\t\t\t\tteam_members: params.teamMembers,\n\t\t\t\tring_timeout: params.ringTimeout || 20,\n\t\t\t\tivr_menu: params.ivrMenu,\n\t\t\t\tivr_greeting_url: params.ivrGreetingUrl,\n\t\t\t\tforward_to_number: params.forwardToNumber,\n\t\t\t\tforward_to_user_id: params.forwardToUserId,\n\t\t\t\tenable_voicemail: params.enableVoicemail !== false,\n\t\t\t\tvoicemail_greeting_url: params.voicemailGreetingUrl,\n\t\t\t\tvoicemail_transcription_enabled:\n\t\t\t\t\tparams.voicemailTranscriptionEnabled !== false,\n\t\t\t\tvoicemail_email_notifications:\n\t\t\t\t\tparams.voicemailEmailNotifications !== false,\n\t\t\t\trecord_calls: params.recordCalls,\n\t\t\t\tis_active: true,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to create call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Update an existing call routing rule\n */\nexport async function updateCallRoutingRule(params: {\n\truleId: string;\n\tname?: string;\n\tdescription?: string;\n\tpriority?: number;\n\tbusinessHours?: Record<string, unknown>;\n\ttimezone?: string;\n\tafterHoursAction?: \"voicemail\" | \"forward\" | \"hangup\";\n\tafterHoursForwardTo?: string;\n\tteamMembers?: string[];\n\tringTimeout?: number;\n\tivrMenu?: Record<string, unknown>;\n\tivrGreetingUrl?: string;\n\tforwardToNumber?: string;\n\tforwardToUserId?: string;\n\tenableVoicemail?: boolean;\n\tvoicemailGreetingUrl?: string;\n\tvoicemailTranscriptionEnabled?: boolean;\n\tvoicemailEmailNotifications?: boolean;\n\trecordCalls?: boolean;\n\tisActive?: boolean;\n}) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst updateData: Record<string, unknown> = {};\n\n\t\tif (params.name !== undefined) {\n\t\t\tupdateData.name = params.name;\n\t\t}\n\t\tif (params.description !== undefined) {\n\t\t\tupdateData.description = params.description;\n\t\t}\n\t\tif (params.priority !== undefined) {\n\t\t\tupdateData.priority = params.priority;\n\t\t}\n\t\tif (params.businessHours !== undefined) {\n\t\t\tupdateData.business_hours = params.businessHours;\n\t\t}\n\t\tif (params.timezone !== undefined) {\n\t\t\tupdateData.timezone = params.timezone;\n\t\t}\n\t\tif (params.afterHoursAction !== undefined) {\n\t\t\tupdateData.after_hours_action = params.afterHoursAction;\n\t\t}\n\t\tif (params.afterHoursForwardTo !== undefined) {\n\t\t\tupdateData.after_hours_forward_to = params.afterHoursForwardTo;\n\t\t}\n\t\tif (params.teamMembers !== undefined) {\n\t\t\tupdateData.team_members = params.teamMembers;\n\t\t}\n\t\tif (params.ringTimeout !== undefined) {\n\t\t\tupdateData.ring_timeout = params.ringTimeout;\n\t\t}\n\t\tif (params.ivrMenu !== undefined) {\n\t\t\tupdateData.ivr_menu = params.ivrMenu;\n\t\t}\n\t\tif (params.ivrGreetingUrl !== undefined) {\n\t\t\tupdateData.ivr_greeting_url = params.ivrGreetingUrl;\n\t\t}\n\t\tif (params.forwardToNumber !== undefined) {\n\t\t\tupdateData.forward_to_number = params.forwardToNumber;\n\t\t}\n\t\tif (params.forwardToUserId !== undefined) {\n\t\t\tupdateData.forward_to_user_id = params.forwardToUserId;\n\t\t}\n\t\tif (params.enableVoicemail !== undefined) {\n\t\t\tupdateData.enable_voicemail = params.enableVoicemail;\n\t\t}\n\t\tif (params.voicemailGreetingUrl !== undefined) {\n\t\t\tupdateData.voicemail_greeting_url = params.voicemailGreetingUrl;\n\t\t}\n\t\tif (params.voicemailTranscriptionEnabled !== undefined) {\n\t\t\tupdateData.voicemail_transcription_enabled =\n\t\t\t\tparams.voicemailTranscriptionEnabled;\n\t\t}\n\t\tif (params.voicemailEmailNotifications !== undefined) {\n\t\t\tupdateData.voicemail_email_notifications =\n\t\t\t\tparams.voicemailEmailNotifications;\n\t\t}\n\t\tif (params.recordCalls !== undefined) {\n\t\t\tupdateData.record_calls = params.recordCalls;\n\t\t}\n\t\tif (params.isActive !== undefined) {\n\t\t\tupdateData.is_active = params.isActive;\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", params.ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to update call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a call routing rule\n */\nexport async function deleteCallRoutingRule(ruleId: string, userId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: userId,\n\t\t\t})\n\t\t\t.eq(\"id\", ruleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to delete call routing rule\",\n\t\t};\n\t}\n}\n\n/**\n * Toggle call routing rule active status\n */\nexport async function toggleCallRoutingRule(ruleId: string, isActive: boolean) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"call_routing_rules\")\n\t\t\t.update({ is_active: isActive })\n\t\t\t.eq(\"id\", ruleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/communications/call-routing\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to toggle call routing rule\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// PHONE NUMBER USAGE STATISTICS ACTIONS\n// =====================================================================================\n\n/**\n * Get usage statistics for a phone number\n */\nasync function getPhoneNumberUsageStats(\n\tphoneNumberId: string,\n\tdays = 30,\n) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get call statistics\n\t\tconst { data: callStats, error: callError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"type\", \"phone\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (callError) {\n\t\t\tthrow callError;\n\t\t}\n\n\t\t// Get SMS statistics\n\t\tconst { data: smsStats, error: smsError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, created_at\")\n\t\t\t.eq(\"type\", \"sms\")\n\t\t\t.eq(\"phone_number_id\", phoneNumberId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (smsError) {\n\t\t\tthrow smsError;\n\t\t}\n\n\t\t// Calculate aggregates\n\t\tconst calls = callStats || [];\n\t\tconst sms = smsStats || [];\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats([...calls, ...sms], days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Get company-wide usage statistics\n */\nasync function getCompanyUsageStats(companyId: string, days = 30) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t// Get all communications for the company\n\t\tconst { data: communications, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"type, direction, status, call_duration, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.in(\"type\", [\"phone\", \"sms\"])\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst items = communications || [];\n\t\tconst calls = items.filter((i) => i.type === \"phone\");\n\t\tconst sms = items.filter((i) => i.type === \"sms\");\n\n\t\tconst incomingCalls = calls.filter((c) => c.direction === \"inbound\").length;\n\t\tconst outgoingCalls = calls.filter(\n\t\t\t(c) => c.direction === \"outbound\",\n\t\t).length;\n\t\tconst totalCallDuration = calls.reduce(\n\t\t\t(sum, c) => sum + (c.call_duration || 0),\n\t\t\t0,\n\t\t);\n\t\tconst incomingSms = sms.filter((s) => s.direction === \"inbound\").length;\n\t\tconst outgoingSms = sms.filter((s) => s.direction === \"outbound\").length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tincomingCalls,\n\t\t\t\toutgoingCalls,\n\t\t\t\ttotalCalls: incomingCalls + outgoingCalls,\n\t\t\t\ttotalCallDuration,\n\t\t\t\taverageCallDuration:\n\t\t\t\t\tcalls.length > 0 ? totalCallDuration / calls.length : 0,\n\t\t\t\tincomingSms,\n\t\t\t\toutgoingSms,\n\t\t\t\ttotalSms: incomingSms + outgoingSms,\n\t\t\t\tdailyStats: aggregateDailyStats(items, days),\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to get usage statistics\",\n\t\t};\n\t}\n}\n\n/**\n * Helper function to aggregate daily statistics\n */\nfunction aggregateDailyStats(\n\titems: Array<{ created_at: string; type: string; call_duration?: number }>,\n\tdays: number,\n) {\n\tconst dailyStats: Record<\n\t\tstring,\n\t\t{ date: string; calls: number; sms: number; duration: number }\n\t> = {};\n\n\t// Initialize all days\n\tfor (let i = 0; i < days; i++) {\n\t\tconst date = new Date();\n\t\tdate.setDate(date.getDate() - i);\n\t\tconst dateStr = date.toISOString().split(\"T\")[0];\n\t\tdailyStats[dateStr] = { date: dateStr, calls: 0, sms: 0, duration: 0 };\n\t}\n\n\t// Aggregate data\n\titems.forEach((item) => {\n\t\tconst dateStr = item.created_at.split(\"T\")[0];\n\t\tif (dailyStats[dateStr]) {\n\t\t\tif (item.type === \"phone\") {\n\t\t\t\tdailyStats[dateStr].calls += 1;\n\t\t\t\tdailyStats[dateStr].duration += item.call_duration || 0;\n\t\t\t} else if (item.type === \"sms\") {\n\t\t\t\tdailyStats[dateStr].sms += 1;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Object.values(dailyStats).sort((a, b) => a.date.localeCompare(b.date));\n}\n"],"names":[],"mappings":";;;;;;;IAk5CsB,uBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 2745, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/telnyx/web-credentials-client.ts"],"sourcesContent":["\"use client\";\n\nimport { getWebRTCCredentials } from \"@/actions/telnyx\";\n\ntype WebRTCCredentialsResult = Awaited<ReturnType<typeof getWebRTCCredentials>>;\ntype Credential = NonNullable<WebRTCCredentialsResult[\"credential\"]>;\n\nconst STORAGE_KEY = \"telnyx-webrtc-credential\";\n// Refresh 5 minutes before expiration (Telnyx recommended buffer)\n// This prevents credential expiry during active calls\nconst EXPIRY_BUFFER_MS = 5 * 60 * 1000;\n\nlet credentialsPromise: Promise<WebRTCCredentialsResult> | null = null;\n\nfunction getExpiresAtMs(expiresAt: Credential[\"expires_at\"]): number | null {\n\tif (typeof expiresAt === \"number\") {\n\t\treturn expiresAt;\n\t}\n\tif (typeof expiresAt === \"string\") {\n\t\tconst parsed = Date.parse(expiresAt);\n\t\treturn Number.isNaN(parsed) ? null : parsed;\n\t}\n\treturn null;\n}\n\nfunction loadFromStorage(): Credential | null {\n\tif (typeof window === \"undefined\") {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst raw = window.localStorage.getItem(STORAGE_KEY);\n\t\tif (!raw) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst parsed = JSON.parse(raw) as { credential?: Credential } | null;\n\t\tif (!parsed?.credential) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst expiresAtMs = getExpiresAtMs(parsed.credential.expires_at);\n\t\tif (!expiresAtMs || expiresAtMs - EXPIRY_BUFFER_MS <= Date.now()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn parsed.credential;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nfunction persistCredential(credential: Credential) {\n\tif (typeof window === \"undefined\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\twindow.localStorage.setItem(\n\t\t\tSTORAGE_KEY,\n\t\t\tJSON.stringify({\n\t\t\t\tcredential,\n\t\t\t}),\n\t\t);\n\t} catch {\n\t\t// Ignore storage errors (e.g., Safari private mode)\n\t}\n}\n\nfunction createPromise() {\n\tconst cached = loadFromStorage();\n\tif (cached) {\n\t\tconsole.log(\" Using cached WebRTC credentials:\", {\n\t\t\tusername: cached.username,\n\t\t\texpiresAt: new Date(cached.expires_at).toISOString(),\n\t\t\tisExpired: cached.expires_at <= Date.now(),\n\t\t});\n\t\tconst cachedResult: WebRTCCredentialsResult = {\n\t\t\tsuccess: true,\n\t\t\tcredential: cached,\n\t\t};\n\t\tconst promise = Promise.resolve(cachedResult);\n\t\tcredentialsPromise = promise;\n\t\treturn promise;\n\t}\n\n\tconsole.log(\" Fetching WebRTC credentials from server...\");\n\tconst promise = getWebRTCCredentials()\n\t\t.then((result) => {\n\t\t\tconsole.log(\" WebRTC credentials response:\", result);\n\t\t\tif (result?.success && result.credential) {\n\t\t\t\tconsole.log(\" Persisting new credentials to localStorage\");\n\t\t\t\tpersistCredential(result.credential);\n\t\t\t} else {\n\t\t\t\tconsole.warn(\" Failed to get credentials, clearing cache\");\n\t\t\t\tcredentialsPromise = null;\n\t\t\t}\n\t\t\treturn result;\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error(\" WebRTC credentials fetch error:\", error);\n\t\t\tcredentialsPromise = null;\n\t\t\tthrow error;\n\t\t});\n\n\tcredentialsPromise = promise;\n\treturn promise;\n}\n\nexport function fetchWebRTCCredentialsOnce() {\n\treturn credentialsPromise ?? createPromise();\n}\n\nexport function resetWebRTCCredentialsCache() {\n\tcredentialsPromise = null;\n\tif (typeof window !== \"undefined\") {\n\t\ttry {\n\t\t\twindow.localStorage.removeItem(STORAGE_KEY);\n\t\t} catch {\n\t\t\t// Ignore storage removal errors\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;;AAEA;AAFA;;AAOA,MAAM,cAAc;AACpB,kEAAkE;AAClE,sDAAsD;AACtD,MAAM,mBAAmB,IAAI,KAAK;AAElC,IAAI,qBAA8D;AAElE,SAAS,eAAe,SAAmC;IAC1D,IAAI,OAAO,cAAc,UAAU;QAClC,OAAO;IACR;IACA,IAAI,OAAO,cAAc,UAAU;QAClC,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,OAAO,OAAO,KAAK,CAAC,UAAU,OAAO;IACtC;IACA,OAAO;AACR;AAEA,SAAS;IACR,wCAAmC;QAClC,OAAO;IACR;;;AAsBD;AAEA,SAAS,kBAAkB,UAAsB;IAChD,wCAAmC;QAClC;IACD;;;AAYD;AAEA,SAAS;IACR,MAAM,SAAS;IACf,IAAI,QAAQ;QACX,QAAQ,GAAG,CAAC,uCAAuC;YAClD,UAAU,OAAO,QAAQ;YACzB,WAAW,IAAI,KAAK,OAAO,UAAU,EAAE,WAAW;YAClD,WAAW,OAAO,UAAU,IAAI,KAAK,GAAG;QACzC;QACA,MAAM,eAAwC;YAC7C,SAAS;YACT,YAAY;QACb;QACA,MAAM,UAAU,QAAQ,OAAO,CAAC;QAChC,qBAAqB;QACrB,OAAO;IACR;IAEA,QAAQ,GAAG,CAAC;IACZ,MAAM,UAAU,IAAA,6LAAoB,IAClC,IAAI,CAAC,CAAC;QACN,QAAQ,GAAG,CAAC,mCAAmC;QAC/C,IAAI,QAAQ,WAAW,OAAO,UAAU,EAAE;YACzC,QAAQ,GAAG,CAAC;YACZ,kBAAkB,OAAO,UAAU;QACpC,OAAO;YACN,QAAQ,IAAI,CAAC;YACb,qBAAqB;QACtB;QACA,OAAO;IACR,GACC,KAAK,CAAC,CAAC;QACP,QAAQ,KAAK,CAAC,sCAAsC;QACpD,qBAAqB;QACrB,MAAM;IACP;IAED,qBAAqB;IACrB,OAAO;AACR;AAEO,SAAS;IACf,OAAO,sBAAsB;AAC9B;AAEO,SAAS;IACf,qBAAqB;IACrB;;AAOD"}},
    {"offset": {"line": 2830, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACzC,OAAO,IAAA,oOAAO,EAAC,IAAA,8LAAI,EAAC;AACrB"}},
    {"offset": {"line": 2845, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/phone-dropdown.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * PhoneDropdown - Enterprise Phone Dialer\n *\n * Full-featured dialer with:\n * - WebRTC primary mode (browser audio)\n * - Call Control API fallback (opens call window)\n * - Connection status monitoring\n * - Automatic reconnection\n * - Customer search\n *\n * References:\n * - https://developers.telnyx.com/docs/voice/webrtc/js-sdk/quickstart\n * - https://developers.telnyx.com/docs/voice/webrtc/js-sdk/error-handling\n */\n\nimport type { Call as TelnyxCall } from \"@telnyx/webrtc\";\nimport {\n\tAlertCircle,\n\tCheck,\n\tChevronDown,\n\tClock,\n\tExternalLink,\n\tHeadphones,\n\tLoader2,\n\tMessageSquare,\n\tMic,\n\tMicOff,\n\tPause,\n\tPhone,\n\tPhoneCall,\n\tPhoneIncoming,\n\tPhoneMissed,\n\tPhoneOff,\n\tPhoneOutgoing,\n\tPlay,\n\tRefreshCw,\n\tServer,\n\tUser,\n\tWifi,\n\tWifiOff,\n\tX,\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { useCallback, useEffect, useMemo, useRef, useState, useTransition } from \"react\";\nimport { makeCall } from \"@/actions/telnyx\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tCommand,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList,\n} from \"@/components/ui/command\";\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuSeparator,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n\tPopover,\n\tPopoverContent,\n\tPopoverTrigger,\n} from \"@/components/ui/popover\";\nimport {\n\tSelect,\n\tSelectContent,\n\tSelectItem,\n\tSelectTrigger,\n\tSelectValue,\n} from \"@/components/ui/select\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n\tTooltip,\n\tTooltipContent,\n\tTooltipProvider,\n\tTooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { useDialerCustomers } from \"@/hooks/use-dialer-customers\";\nimport { useTelnyxWebRTC, type WebRTCCall, type CallState } from \"@/hooks/use-telnyx-webrtc\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useDialerStore } from \"@/lib/stores/dialer-store\";\nimport { useUIStore } from \"@/lib/stores/ui-store\";\nimport { fetchWebRTCCredentialsOnce, resetWebRTCCredentialsCache } from \"@/lib/telnyx/web-credentials-client\";\nimport { cn } from \"@/lib/utils\";\n\ntype Customer = {\n\tid: string;\n\tfirst_name: string | null;\n\tlast_name: string | null;\n\tdisplay_name: string | null;\n\temail: string | null;\n\tphone: string | null;\n\tsecondary_phone?: string | null;\n\tcompany_name?: string | null;\n};\n\ntype CompanyPhone = {\n\tid: string;\n\tnumber: string;\n\tlabel?: string;\n};\n\ntype PhoneDropdownProps = {\n\tcompanyId: string;\n\tcompanyPhones?: CompanyPhone[];\n\tincomingCallsCount?: number;\n};\n\ntype ConnectionStatus = \"disconnected\" | \"connecting\" | \"connected\" | \"error\";\ntype CallMode = \"webrtc\" | \"api\";\n\n// Constants\nconst WEBRTC_CONNECTION_TIMEOUT = 15000; // 15 seconds\nconst WEBRTC_RETRY_DELAY = 3000; // 3 seconds\n\n// Helper functions\nconst cleanValue = (v?: string | null) => (v ?? \"\").trim();\n\nconst getCustomerName = (c: Customer) => {\n\tif (c.display_name?.trim()) return c.display_name.trim();\n\tconst name = [c.first_name, c.last_name].map(cleanValue).filter(Boolean).join(\" \");\n\treturn name || c.email?.trim() || \"Unknown\";\n};\n\nconst formatPhone = (phone: string) => {\n\tconst d = phone.replace(/\\D/g, \"\");\n\tif (d.length === 11 && d[0] === \"1\") {\n\t\treturn `+1 (${d.slice(1, 4)}) ${d.slice(4, 7)}-${d.slice(7)}`;\n\t}\n\tif (d.length === 10) {\n\t\treturn `(${d.slice(0, 3)}) ${d.slice(3, 6)}-${d.slice(6)}`;\n\t}\n\treturn phone;\n};\n\n/**\n * Connection Status Badge\n */\nfunction ConnectionStatusBadge({\n\tstatus,\n\tmode,\n\tonRetry,\n\tclassName,\n}: {\n\tstatus: ConnectionStatus;\n\tmode: CallMode;\n\tonRetry?: () => void;\n\tclassName?: string;\n}) {\n\tif (mode === \"api\") {\n\t\treturn (\n\t\t\t<Badge variant=\"outline\" className={cn(\"gap-1 text-[10px]\", className)}>\n\t\t\t\t<Server className=\"h-3 w-3\" />\n\t\t\t\tAPI Mode\n\t\t\t</Badge>\n\t\t);\n\t}\n\n\tconst statusConfig: Record<ConnectionStatus, {\n\t\ticon: typeof WifiOff;\n\t\tlabel: string;\n\t\tvariant: \"outline\" | \"destructive\";\n\t\tclassName: string;\n\t\tanimate?: boolean;\n\t}> = {\n\t\tdisconnected: {\n\t\t\ticon: WifiOff,\n\t\t\tlabel: \"Disconnected\",\n\t\t\tvariant: \"outline\",\n\t\t\tclassName: \"text-muted-foreground\",\n\t\t},\n\t\tconnecting: {\n\t\t\ticon: Loader2,\n\t\t\tlabel: \"Connecting...\",\n\t\t\tvariant: \"outline\",\n\t\t\tclassName: \"text-warning\",\n\t\t\tanimate: true,\n\t\t},\n\t\tconnected: {\n\t\t\ticon: Wifi,\n\t\t\tlabel: \"WebRTC Ready\",\n\t\t\tvariant: \"outline\",\n\t\t\tclassName: \"text-success border-success/30\",\n\t\t},\n\t\terror: {\n\t\t\ticon: AlertCircle,\n\t\t\tlabel: \"Connection Error\",\n\t\t\tvariant: \"destructive\",\n\t\t\tclassName: \"\",\n\t\t},\n\t};\n\n\tconst config = statusConfig[status];\n\tconst Icon = config.icon;\n\n\treturn (\n\t\t<div className={cn(\"flex items-center gap-1\", className)}>\n\t\t\t<Badge variant={config.variant} className={cn(\"gap-1 text-[10px]\", config.className)}>\n\t\t\t\t<Icon className={cn(\"h-3 w-3\", config.animate === true && \"animate-spin\")} />\n\t\t\t\t{config.label}\n\t\t\t</Badge>\n\t\t\t{(status === \"error\" || status === \"disconnected\") && onRetry && (\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\tclassName=\"h-5 w-5\"\n\t\t\t\t\tonClick={onRetry}\n\t\t\t\t>\n\t\t\t\t\t<RefreshCw className=\"h-3 w-3\" />\n\t\t\t\t</Button>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n\n/**\n * Active Call Card - Shows when a call is in progress\n */\nfunction ActiveCallCard({\n\tcall,\n\tonMute,\n\tonHold,\n\tonEnd,\n\tclassName,\n}: {\n\tcall: WebRTCCall;\n\tonMute: () => void;\n\tonHold: () => void;\n\tonEnd: () => void;\n\tclassName?: string;\n}) {\n\tconst [duration, setDuration] = useState(0);\n\n\t// Update duration timer\n\tuseEffect(() => {\n\t\tif (call.state !== \"active\") {\n\t\t\tsetDuration(0);\n\t\t\treturn;\n\t\t}\n\n\t\tconst startTime = call.startTime?.getTime() || Date.now();\n\t\tconst interval = setInterval(() => {\n\t\t\tsetDuration(Math.floor((Date.now() - startTime) / 1000));\n\t\t}, 1000);\n\n\t\treturn () => clearInterval(interval);\n\t}, [call.state, call.startTime]);\n\n\tconst formatDuration = (seconds: number) => {\n\t\tconst mins = Math.floor(seconds / 60);\n\t\tconst secs = seconds % 60;\n\t\treturn `${mins}:${secs.toString().padStart(2, \"0\")}`;\n\t};\n\n\tconst stateConfig: Record<CallState, { label: string; color: string; icon: typeof Phone }> = {\n\t\tidle: { label: \"Idle\", color: \"text-muted-foreground\", icon: Phone },\n\t\tconnecting: { label: \"Connecting...\", color: \"text-warning\", icon: PhoneOutgoing },\n\t\tringing: { label: \"Ringing...\", color: \"text-primary\", icon: PhoneOutgoing },\n\t\tactive: { label: \"Active\", color: \"text-success\", icon: PhoneCall },\n\t\theld: { label: \"On Hold\", color: \"text-warning\", icon: Pause },\n\t\tended: { label: \"Call Ended\", color: \"text-muted-foreground\", icon: PhoneOff },\n\t};\n\n\tconst config = stateConfig[call.state];\n\tconst StateIcon = config.icon;\n\n\treturn (\n\t\t<div className={cn(\"rounded-lg border bg-card p-3\", className)}>\n\t\t\t{/* Call info header */}\n\t\t\t<div className=\"mb-3 flex items-center justify-between\">\n\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t<div className={cn(\"rounded-full bg-primary/10 p-2\", config.color)}>\n\t\t\t\t\t\t<StateIcon className=\"h-4 w-4\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<p className=\"text-sm font-medium\">\n\t\t\t\t\t\t\t{call.remoteName || formatPhone(call.remoteNumber)}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p className={cn(\"text-xs\", config.color)}>{config.label}</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t{call.state === \"active\" && (\n\t\t\t\t\t<Badge variant=\"outline\" className=\"text-xs tabular-nums\">\n\t\t\t\t\t\t{formatDuration(duration)}\n\t\t\t\t\t</Badge>\n\t\t\t\t)}\n\t\t\t</div>\n\n\t\t\t{/* Call controls */}\n\t\t\t{(call.state === \"active\" || call.state === \"held\") && (\n\t\t\t\t<div className=\"flex items-center justify-center gap-2\">\n\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant={call.isMuted ? \"destructive\" : \"outline\"}\n\t\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\t\tclassName=\"h-9 w-9 rounded-full\"\n\t\t\t\t\t\t\t\tonClick={onMute}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{call.isMuted ? (\n\t\t\t\t\t\t\t\t\t<MicOff className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t<Mic className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t<TooltipContent>{call.isMuted ? \"Unmute\" : \"Mute\"}</TooltipContent>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant={call.isHeld ? \"secondary\" : \"outline\"}\n\t\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\t\tclassName=\"h-9 w-9 rounded-full\"\n\t\t\t\t\t\t\t\tonClick={onHold}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{call.isHeld ? (\n\t\t\t\t\t\t\t\t\t<Play className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t<Pause className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t<TooltipContent>{call.isHeld ? \"Resume\" : \"Hold\"}</TooltipContent>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\t\tclassName=\"h-9 w-9 rounded-full\"\n\t\t\t\t\t\t\t\tonClick={onEnd}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<PhoneOff className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t<TooltipContent>End Call</TooltipContent>\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{/* Connecting/Ringing state */}\n\t\t\t{(call.state === \"connecting\" || call.state === \"ringing\") && (\n\t\t\t\t<div className=\"flex items-center justify-center gap-2\">\n\t\t\t\t\t<Button\n\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\tclassName=\"gap-2\"\n\t\t\t\t\t\tonClick={onEnd}\n\t\t\t\t\t>\n\t\t\t\t\t\t<PhoneOff className=\"h-4 w-4\" />\n\t\t\t\t\t\tCancel\n\t\t\t\t\t</Button>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n\nexport function PhoneDropdown({\n\tcompanyId,\n\tcompanyPhones = [],\n\tincomingCallsCount,\n}: PhoneDropdownProps) {\n\tconst { toast } = useToast();\n\tconst [mounted, setMounted] = useState(false);\n\tconst [isPending, startTransition] = useTransition();\n\n\t// Dropdown & customer state\n\tconst [open, setOpen] = useState(false);\n\tconst { customers, isLoading: customersLoading } = useDialerCustomers(open);\n\tconst dialerStore = useDialerStore();\n\n\t// Form state\n\tconst [toNumber, setToNumber] = useState(\"\");\n\tconst [fromNumber, setFromNumber] = useState(companyPhones[0]?.number || \"\");\n\tconst [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);\n\tconst [customerSearchOpen, setCustomerSearchOpen] = useState(false);\n\tconst [customerSearchQuery, setCustomerSearchQuery] = useState(\"\");\n\n\t// WebRTC state\n\tconst [callMode, setCallMode] = useState<CallMode>(\"webrtc\");\n\tconst [webrtcCredentials, setWebrtcCredentials] = useState<{\n\t\tusername: string;\n\t\tpassword: string;\n\t} | null>(null);\n\tconst [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>(\"disconnected\");\n\tconst [connectionError, setConnectionError] = useState<string | null>(null);\n\tconst connectionTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\tconst retryCountRef = useRef(0);\n\tconst maxRetries = 3;\n\n\t// Audio element for WebRTC\n\tconst audioRef = useRef<HTMLAudioElement | null>(null);\n\n\t// Call state from UI store\n\tconst callStatus = useUIStore((s) => s.call.status);\n\tconst caller = useUIStore((s) => s.call.caller);\n\tconst hasIncomingCall = callStatus === \"incoming\";\n\tconst displayCount = incomingCallsCount ?? (hasIncomingCall ? 1 : 0);\n\n\t// WebRTC hook\n\tconst webrtc = useTelnyxWebRTC({\n\t\tusername: webrtcCredentials?.username || \"\",\n\t\tpassword: webrtcCredentials?.password || \"\",\n\t\tautoConnect: false,\n\t\tdebug: process.env.NODE_ENV === \"development\",\n\t\tonIncomingCall: (call) => {\n\t\t\ttoast.info(`Incoming call from ${call.remoteName || call.remoteNumber}`);\n\t\t},\n\t\tonCallEnded: () => {\n\t\t\ttoast.info(\"Call ended\");\n\t\t},\n\t});\n\n\t// Mount\n\tuseEffect(() => {\n\t\tsetMounted(true);\n\t\t// Create audio element for WebRTC\n\t\tif (typeof window !== \"undefined\" && !audioRef.current) {\n\t\t\tconst audio = document.createElement(\"audio\");\n\t\t\taudio.id = \"telnyx-remote-audio\";\n\t\t\taudio.autoplay = true;\n\t\t\taudio.style.display = \"none\";\n\t\t\tdocument.body.appendChild(audio);\n\t\t\taudioRef.current = audio;\n\t\t}\n\n\t\treturn () => {\n\t\t\tif (audioRef.current) {\n\t\t\t\taudioRef.current.remove();\n\t\t\t\taudioRef.current = null;\n\t\t\t}\n\t\t};\n\t}, []);\n\n\t// Sync from number\n\tuseEffect(() => {\n\t\tif (!fromNumber && companyPhones.length > 0) {\n\t\t\tsetFromNumber(companyPhones[0].number);\n\t\t}\n\t}, [companyPhones, fromNumber]);\n\n\t// Sync dialer store\n\tuseEffect(() => setOpen(dialerStore.isOpen), [dialerStore.isOpen]);\n\tuseEffect(() => setToNumber(dialerStore.phoneNumber), [dialerStore.phoneNumber]);\n\tuseEffect(() => {\n\t\tif (dialerStore.customerId && customers.length > 0) {\n\t\t\tconst c = customers.find((x) => x.id === dialerStore.customerId);\n\t\t\tif (c && c.id !== selectedCustomer?.id) setSelectedCustomer(c);\n\t\t}\n\t}, [dialerStore.customerId, customers, selectedCustomer?.id]);\n\n\t// Fetch WebRTC credentials on mount\n\tuseEffect(() => {\n\t\tif (!mounted) return;\n\n\t\tconst fetchCredentials = async () => {\n\t\t\ttry {\n\t\t\t\tconst result = await fetchWebRTCCredentialsOnce();\n\t\t\t\tif (result.success && result.credential) {\n\t\t\t\t\tsetWebrtcCredentials({\n\t\t\t\t\t\tusername: result.credential.username,\n\t\t\t\t\t\tpassword: result.credential.password,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"Failed to get WebRTC credentials, using API mode\");\n\t\t\t\t\tsetCallMode(\"api\");\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Failed to fetch WebRTC credentials:\", error);\n\t\t\t\tsetCallMode(\"api\");\n\t\t\t}\n\t\t};\n\n\t\tfetchCredentials();\n\t}, [mounted]);\n\n\t// Connect WebRTC when credentials are available\n\tuseEffect(() => {\n\t\tif (!webrtcCredentials || callMode !== \"webrtc\") return;\n\n\t\tconst connectWebRTC = async () => {\n\t\t\t// Clear any existing timeout\n\t\t\tif (connectionTimeoutRef.current) {\n\t\t\t\tclearTimeout(connectionTimeoutRef.current);\n\t\t\t}\n\n\t\t\tsetConnectionStatus(\"connecting\");\n\t\t\tsetConnectionError(null);\n\n\t\t\t// Set connection timeout\n\t\t\tconnectionTimeoutRef.current = setTimeout(() => {\n\t\t\t\tif (connectionStatus === \"connecting\") {\n\t\t\t\t\tsetConnectionStatus(\"error\");\n\t\t\t\t\tsetConnectionError(\"Connection timeout - WebRTC may require Level 2 verification\");\n\n\t\t\t\t\t// Auto-fallback to API mode after timeout\n\t\t\t\t\tif (retryCountRef.current >= maxRetries) {\n\t\t\t\t\t\ttoast.warning(\"WebRTC unavailable, switching to API mode\");\n\t\t\t\t\t\tsetCallMode(\"api\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, WEBRTC_CONNECTION_TIMEOUT);\n\n\t\t\ttry {\n\t\t\t\tawait webrtc.connect();\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"WebRTC connection error:\", error);\n\t\t\t\tsetConnectionStatus(\"error\");\n\t\t\t\tsetConnectionError(error instanceof Error ? error.message : \"Connection failed\");\n\t\t\t}\n\t\t};\n\n\t\tconnectWebRTC();\n\n\t\treturn () => {\n\t\t\tif (connectionTimeoutRef.current) {\n\t\t\t\tclearTimeout(connectionTimeoutRef.current);\n\t\t\t}\n\t\t};\n\t}, [webrtcCredentials, callMode]);\n\n\t// Sync WebRTC connection state\n\tuseEffect(() => {\n\t\tif (webrtc.isConnected) {\n\t\t\tif (connectionTimeoutRef.current) {\n\t\t\t\tclearTimeout(connectionTimeoutRef.current);\n\t\t\t}\n\t\t\tsetConnectionStatus(\"connected\");\n\t\t\tsetConnectionError(null);\n\t\t\tretryCountRef.current = 0;\n\t\t} else if (webrtc.connectionError) {\n\t\t\tsetConnectionStatus(\"error\");\n\t\t\tsetConnectionError(webrtc.connectionError);\n\t\t} else if (webrtc.isConnecting) {\n\t\t\tsetConnectionStatus(\"connecting\");\n\t\t}\n\t}, [webrtc.isConnected, webrtc.isConnecting, webrtc.connectionError]);\n\n\t// Handlers\n\tconst handleOpenChange = useCallback((newOpen: boolean) => {\n\t\tsetOpen(newOpen);\n\t\tif (newOpen) {\n\t\t\tdialerStore.openDialer();\n\t\t} else {\n\t\t\tdialerStore.closeDialer();\n\t\t\tsetToNumber(\"\");\n\t\t\tsetSelectedCustomer(null);\n\t\t\tsetCustomerSearchQuery(\"\");\n\t\t}\n\t}, [dialerStore]);\n\n\tconst handleCustomerSelect = useCallback((c: Customer | null) => {\n\t\tsetSelectedCustomer(c);\n\t\tif (c?.phone) setToNumber(c.phone);\n\t\tsetCustomerSearchQuery(\"\");\n\t\tsetCustomerSearchOpen(false);\n\t}, []);\n\n\tconst handleRetryConnection = useCallback(() => {\n\t\tretryCountRef.current += 1;\n\n\t\tif (retryCountRef.current > maxRetries) {\n\t\t\ttoast.warning(\"Max retries reached, switching to API mode\");\n\t\t\tsetCallMode(\"api\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Reset credentials cache and refetch\n\t\tresetWebRTCCredentialsCache();\n\t\tsetWebrtcCredentials(null);\n\t\tsetConnectionStatus(\"disconnected\");\n\t\tsetConnectionError(null);\n\n\t\t// Refetch credentials\n\t\tfetchWebRTCCredentialsOnce().then((result) => {\n\t\t\tif (result.success && result.credential) {\n\t\t\t\tsetWebrtcCredentials({\n\t\t\t\t\tusername: result.credential.username,\n\t\t\t\t\tpassword: result.credential.password,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}, [toast]);\n\n\tconst handleModeToggle = useCallback((checked: boolean) => {\n\t\tsetCallMode(checked ? \"webrtc\" : \"api\");\n\t}, []);\n\n\t// Filter customers\n\tconst filteredCustomers = useMemo(() => {\n\t\tconst q = customerSearchQuery.trim().toLowerCase();\n\t\tif (!q) return customers.slice(0, 50);\n\n\t\tconst qDigits = q.replace(/\\D/g, \"\");\n\t\treturn customers.filter((c) => {\n\t\t\tconst searchable = [\n\t\t\t\tc.first_name, c.last_name, c.display_name,\n\t\t\t\tc.email, c.phone, c.secondary_phone, c.company_name,\n\t\t\t].map((v) => cleanValue(v).toLowerCase());\n\n\t\t\tif (searchable.some((s) => s.includes(q))) return true;\n\t\t\tif (qDigits) {\n\t\t\t\tconst phones = [c.phone, c.secondary_phone]\n\t\t\t\t\t.map((p) => cleanValue(p).replace(/\\D/g, \"\"))\n\t\t\t\t\t.filter(Boolean);\n\t\t\t\tif (phones.some((p) => p.includes(qDigits))) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}, [customers, customerSearchQuery]);\n\n\t// Make call via API (used for fallback and API mode)\n\tconst handleAPICall = useCallback(async () => {\n\t\tif (isPending) return;\n\n\t\tif (!companyId) {\n\t\t\ttoast.error(\"No company selected. Please select a company first.\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst to = toNumber.replace(/\\D/g, \"\");\n\t\tif (!to) {\n\t\t\ttoast.error(\"Please enter a valid phone number\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!fromNumber) {\n\t\t\ttoast.error(\"Please select a company phone number\");\n\t\t\treturn;\n\t\t}\n\n\t\tstartTransition(async () => {\n\t\t\ttry {\n\t\t\t\tconst result = await makeCall({\n\t\t\t\t\tto,\n\t\t\t\t\tfrom: fromNumber,\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tcustomerId: selectedCustomer?.id,\n\t\t\t\t});\n\n\t\t\t\tif (!result.success) {\n\t\t\t\t\ttoast.error(result.error || \"Failed to start call\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttoast.success(\n\t\t\t\t\tselectedCustomer\n\t\t\t\t\t\t? `Calling ${getCustomerName(selectedCustomer)}`\n\t\t\t\t\t\t: `Calling ${formatPhone(toNumber)}`\n\t\t\t\t);\n\n\t\t\t\t// Open call window\n\t\t\t\tconst params = new URLSearchParams({\n\t\t\t\t\tcallControlId: result.callControlId || \"\",\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tto,\n\t\t\t\t\tfrom: fromNumber,\n\t\t\t\t\tdirection: \"outbound\",\n\t\t\t\t\t...(selectedCustomer?.id && { customerId: selectedCustomer.id }),\n\t\t\t\t});\n\n\t\t\t\twindow.open(`/call?${params}`, \"_blank\", \"noopener,noreferrer\");\n\n\t\t\t\t// Reset\n\t\t\t\thandleOpenChange(false);\n\t\t\t} catch {\n\t\t\t\ttoast.error(\"Failed to start call. Please try again.\");\n\t\t\t}\n\t\t});\n\t}, [companyId, toNumber, fromNumber, selectedCustomer, isPending, toast, handleOpenChange]);\n\n\t// Make call via WebRTC (primary mode)\n\tconst handleWebRTCCall = useCallback(async () => {\n\t\tconst to = toNumber.replace(/\\D/g, \"\");\n\t\tif (!to) {\n\t\t\ttoast.error(\"Please enter a valid phone number\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!webrtc.isConnected) {\n\t\t\ttoast.error(\"WebRTC not connected. Trying API mode...\");\n\t\t\thandleAPICall();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!fromNumber) {\n\t\t\ttoast.error(\"Please select a company phone number\");\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait webrtc.makeCall(to, fromNumber);\n\t\t\ttoast.success(\n\t\t\t\tselectedCustomer\n\t\t\t\t\t? `Calling ${getCustomerName(selectedCustomer)}`\n\t\t\t\t\t: `Calling ${formatPhone(toNumber)}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"WebRTC call error:\", error);\n\t\t\ttoast.error(\"Failed to start call via WebRTC\");\n\n\t\t\t// Fallback to API\n\t\t\ttoast.info(\"Falling back to API mode...\");\n\t\t\thandleAPICall();\n\t\t}\n\t}, [toNumber, fromNumber, selectedCustomer, webrtc, toast, handleAPICall]);\n\n\t// Start call based on mode\n\tconst handleStartCall = useCallback(() => {\n\t\tif (callMode === \"webrtc\" && webrtc.isConnected) {\n\t\t\thandleWebRTCCall();\n\t\t} else {\n\t\t\thandleAPICall();\n\t\t}\n\t}, [callMode, webrtc.isConnected, handleWebRTCCall, handleAPICall]);\n\n\t// Handle WebRTC call controls\n\tconst handleMuteToggle = useCallback(async () => {\n\t\ttry {\n\t\t\tif (webrtc.currentCall?.isMuted) {\n\t\t\t\tawait webrtc.unmuteCall();\n\t\t\t} else {\n\t\t\t\tawait webrtc.muteCall();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Mute toggle error:\", error);\n\t\t}\n\t}, [webrtc]);\n\n\tconst handleHoldToggle = useCallback(async () => {\n\t\ttry {\n\t\t\tif (webrtc.currentCall?.isHeld) {\n\t\t\t\tawait webrtc.unholdCall();\n\t\t\t} else {\n\t\t\t\tawait webrtc.holdCall();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Hold toggle error:\", error);\n\t\t}\n\t}, [webrtc]);\n\n\tconst handleEndCall = useCallback(async () => {\n\t\ttry {\n\t\t\tawait webrtc.endCall();\n\t\t} catch (error) {\n\t\t\tconsole.error(\"End call error:\", error);\n\t\t}\n\t}, [webrtc]);\n\n\tconst canCall = Boolean(toNumber.trim() && fromNumber && companyPhones.length > 0);\n\tconst isWebRTCReady = callMode === \"webrtc\" && connectionStatus === \"connected\";\n\tconst hasActiveCall = webrtc.currentCall && webrtc.currentCall.state !== \"idle\" && webrtc.currentCall.state !== \"ended\";\n\n\t// SSR placeholder\n\tif (!mounted) {\n\t\treturn (\n\t\t\t<button\n\t\t\t\tclassName=\"flex h-8 w-8 items-center justify-center rounded-md border border-transparent opacity-50\"\n\t\t\t\tdisabled\n\t\t\t\ttype=\"button\"\n\t\t\t>\n\t\t\t\t<Phone className=\"h-4 w-4\" />\n\t\t\t</button>\n\t\t);\n\t}\n\n\treturn (\n\t\t<TooltipProvider delayDuration={200}>\n\t\t\t<DropdownMenu open={open} onOpenChange={handleOpenChange}>\n\t\t\t\t<Tooltip>\n\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\"relative flex h-8 w-8 items-center justify-center rounded-md\",\n\t\t\t\t\t\t\t\t\t\"border border-transparent transition-all\",\n\t\t\t\t\t\t\t\t\t\"hover:border-primary/20 hover:bg-primary/10 hover:text-primary\",\n\t\t\t\t\t\t\t\t\t\"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring/50\",\n\t\t\t\t\t\t\t\t\thasIncomingCall && \"animate-pulse text-primary\",\n\t\t\t\t\t\t\t\t\thasActiveCall && \"text-success\"\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{hasActiveCall ? (\n\t\t\t\t\t\t\t\t\t<PhoneCall className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t) : hasIncomingCall ? (\n\t\t\t\t\t\t\t\t\t<PhoneIncoming className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t<Phone className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{displayCount > 0 && (\n\t\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\t\t\t\tclassName=\"absolute -right-1 -top-1 flex h-5 w-5 items-center justify-center rounded-full p-0 text-[10px]\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{displayCount > 9 ? \"9+\" : displayCount}\n\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t<TooltipContent side=\"bottom\">\n\t\t\t\t\t\t{hasActiveCall ? \"Call in Progress\" : hasIncomingCall ? \"Incoming Call\" : \"Make a Call\"}\n\t\t\t\t\t</TooltipContent>\n\t\t\t\t</Tooltip>\n\n\t\t\t\t<DropdownMenuContent align=\"end\" className=\"w-80 p-0\">\n\t\t\t\t\t<div className=\"space-y-3 p-4\">\n\t\t\t\t\t\t{/* Header */}\n\t\t\t\t\t\t<div className=\"flex items-center justify-between\">\n\t\t\t\t\t\t\t<div className=\"flex items-center gap-3\">\n\t\t\t\t\t\t\t\t<div className=\"flex h-10 w-10 shrink-0 items-center justify-center rounded-full bg-primary/10\">\n\t\t\t\t\t\t\t\t\t<PhoneCall className=\"h-5 w-5 text-primary\" />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t<h3 className=\"text-sm font-semibold\">Make a Call</h3>\n\t\t\t\t\t\t\t\t\t<ConnectionStatusBadge\n\t\t\t\t\t\t\t\t\t\tstatus={connectionStatus}\n\t\t\t\t\t\t\t\t\t\tmode={callMode}\n\t\t\t\t\t\t\t\t\t\tonRetry={handleRetryConnection}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t{/* Mode toggle */}\n\t\t\t\t\t\t<div className=\"flex items-center justify-between rounded-lg border bg-muted/30 p-2\">\n\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t<Server className=\"h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<span className=\"text-xs text-muted-foreground\">API Mode</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<Switch\n\t\t\t\t\t\t\t\tchecked={callMode === \"webrtc\"}\n\t\t\t\t\t\t\t\tonCheckedChange={handleModeToggle}\n\t\t\t\t\t\t\t\tdisabled={!webrtcCredentials}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t<span className=\"text-xs text-muted-foreground\">Browser Audio</span>\n\t\t\t\t\t\t\t\t<Headphones className=\"h-4 w-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t{/* Active call card */}\n\t\t\t\t\t\t{hasActiveCall && webrtc.currentCall && (\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t<ActiveCallCard\n\t\t\t\t\t\t\t\t\tcall={webrtc.currentCall}\n\t\t\t\t\t\t\t\t\tonMute={handleMuteToggle}\n\t\t\t\t\t\t\t\t\tonHold={handleHoldToggle}\n\t\t\t\t\t\t\t\t\tonEnd={handleEndCall}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* Incoming call alert */}\n\t\t\t\t\t\t{hasIncomingCall && (\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-3 rounded-lg border border-destructive/30 bg-destructive/10 p-3\">\n\t\t\t\t\t\t\t\t\t<PhoneIncoming className=\"h-5 w-5 shrink-0 animate-pulse text-destructive\" />\n\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm font-semibold text-destructive\">Incoming Call</p>\n\t\t\t\t\t\t\t\t\t\t<p className=\"truncate text-xs text-destructive/80\">\n\t\t\t\t\t\t\t\t\t\t\t{caller?.name || caller?.number || \"Unknown\"}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* Connection error message */}\n\t\t\t\t\t\t{connectionError && callMode === \"webrtc\" && (\n\t\t\t\t\t\t\t<div className=\"rounded-lg border border-warning/30 bg-warning/10 p-2\">\n\t\t\t\t\t\t\t\t<p className=\"text-xs text-warning\">{connectionError}</p>\n\t\t\t\t\t\t\t\t<p className=\"mt-1 text-xs text-muted-foreground\">\n\t\t\t\t\t\t\t\t\tCalls will use API mode (opens in new window)\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* Customer search */}\n\t\t\t\t\t\t{!hasActiveCall && (\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t<div className=\"space-y-1.5\">\n\t\t\t\t\t\t\t\t\t<label className=\"text-xs font-medium text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\tCustomer (optional)\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t<Popover open={customerSearchOpen} onOpenChange={setCustomerSearchOpen}>\n\t\t\t\t\t\t\t\t\t\t<PopoverTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"h-9 w-full justify-start gap-2 px-3 font-normal\"\n\t\t\t\t\t\t\t\t\t\t\t\tdisabled={customersLoading}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t<User className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"min-w-0 flex-1 truncate text-left\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{selectedCustomer ? getCustomerName(selectedCustomer) : \"Search...\"}\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t{selectedCustomer && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<X\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"h-4 w-4 shrink-0 text-muted-foreground hover:text-foreground\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={(e) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thandleCustomerSelect(null);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t<PopoverContent align=\"start\" className=\"w-80 p-0\" sideOffset={4}>\n\t\t\t\t\t\t\t\t\t\t\t<Command shouldFilter={false}>\n\t\t\t\t\t\t\t\t\t\t\t\t<CommandInput\n\t\t\t\t\t\t\t\t\t\t\t\t\tplaceholder=\"Name, phone, or email...\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue={customerSearchQuery}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonValueChange={setCustomerSearchQuery}\n\t\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t\t<CommandList className=\"max-h-[200px]\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandEmpty className=\"py-4 text-center text-sm text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tNo customers found\n\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandEmpty>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{filteredCustomers.map((c) => (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey={c.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue={c.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => handleCustomerSelect(c)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"flex cursor-pointer items-center gap-2 px-3 py-2\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"truncate text-sm font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{getCustomerName(c)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{c.phone && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"truncate text-xs text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{formatPhone(c.phone)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{selectedCustomer?.id === c.id && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Check className=\"h-4 w-4 shrink-0 text-primary\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t</CommandList>\n\t\t\t\t\t\t\t\t\t\t\t</Command>\n\t\t\t\t\t\t\t\t\t\t</PopoverContent>\n\t\t\t\t\t\t\t\t\t</Popover>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t{/* Phone number */}\n\t\t\t\t\t\t\t\t<div className=\"space-y-1.5\">\n\t\t\t\t\t\t\t\t\t<label htmlFor=\"phone-to\" className=\"text-xs font-medium text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\tPhone Number\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\t\tid=\"phone-to\"\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"(555) 123-4567\"\n\t\t\t\t\t\t\t\t\t\tvalue={toNumber}\n\t\t\t\t\t\t\t\t\t\tonChange={(e) => setToNumber(e.target.value)}\n\t\t\t\t\t\t\t\t\t\tclassName=\"h-9\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t{/* From number */}\n\t\t\t\t\t\t\t\t<div className=\"space-y-1.5\">\n\t\t\t\t\t\t\t\t\t<label htmlFor=\"phone-from\" className=\"text-xs font-medium text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\tYour Company Line\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t<Select value={fromNumber} onValueChange={setFromNumber}>\n\t\t\t\t\t\t\t\t\t\t<SelectTrigger id=\"phone-from\" className=\"h-9\">\n\t\t\t\t\t\t\t\t\t\t\t<SelectValue placeholder=\"Select line...\" />\n\t\t\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t\t\t{companyPhones.map((p) => (\n\t\t\t\t\t\t\t\t\t\t\t\t<SelectItem key={p.id} value={p.number}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{p.label || formatPhone(p.number)}\n\t\t\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t\t\t\t{companyPhones.length === 0 && (\n\t\t\t\t\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\t\tNo phone numbers configured\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t{/* Call button */}\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tclassName=\"w-full gap-2\"\n\t\t\t\t\t\t\t\t\tdisabled={!canCall || isPending}\n\t\t\t\t\t\t\t\t\tonClick={handleStartCall}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{isPending ? (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t<Loader2 className=\"h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t\t\t\t\t\tStarting...\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t) : isWebRTCReady ? (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t<Headphones className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\tCall (Browser Audio)\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t<PhoneOutgoing className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\tCall (Opens Window)\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* Quick links */}\n\t\t\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t\t\t<div className=\"flex gap-2\">\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\thref=\"/dashboard/communication?filter=calls\"\n\t\t\t\t\t\t\t\tonClick={() => handleOpenChange(false)}\n\t\t\t\t\t\t\t\tclassName=\"flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1.5 text-xs font-medium text-muted-foreground transition-colors hover:bg-muted hover:text-foreground\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<Clock className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\tHistory\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\thref=\"/dashboard/communication\"\n\t\t\t\t\t\t\t\tonClick={() => handleOpenChange(false)}\n\t\t\t\t\t\t\t\tclassName=\"flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1.5 text-xs font-medium text-muted-foreground transition-colors hover:bg-muted hover:text-foreground\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<MessageSquare className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\tMessages\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</DropdownMenuContent>\n\t\t\t</DropdownMenu>\n\t\t</TooltipProvider>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4421, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/quick-add-dropdown.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * QuickAddDropdown - Client Component\n *\n * Quick access dropdown menu for creating new records across the application.\n * Provides one-click access to common creation actions from the main header.\n *\n * Client-side features:\n * - Dropdown menu with grouped actions by category\n * - Keyboard shortcuts display for power users\n * - Icon-based visual hierarchy\n * - Accessible with screen reader support\n *\n * Performance:\n * - Uses shadcn/ui DropdownMenu (Radix UI primitives)\n * - No data fetching - purely navigation-based\n * - Minimal bundle impact (~2KB)\n * - Client-only rendering to prevent hydration mismatch\n */\n\nimport {\n\tBriefcase,\n\tCalendar,\n\tDollarSign,\n\tFileSignature,\n\tFileSpreadsheet,\n\tFileText,\n\tPlus,\n\tTag,\n\tUserPlus,\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { useEffect, useState } from \"react\";\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuGroup,\n\tDropdownMenuItem,\n\tDropdownMenuLabel,\n\tDropdownMenuSeparator,\n\tDropdownMenuShortcut,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\n\ntype QuickAddAction = {\n\tlabel: string;\n\thref: string;\n\ticon: typeof Plus;\n\tshortcut?: string;\n\tdescription?: string;\n};\n\nconst quickAddActions: Record<string, QuickAddAction[]> = {\n\tWork: [\n\t\t{\n\t\t\tlabel: \"New Job\",\n\t\t\thref: \"/dashboard/work/new\",\n\t\t\ticon: Briefcase,\n\t\t\tshortcut: \"J\",\n\t\t\tdescription: \"Create a new work order\",\n\t\t},\n\t\t{\n\t\t\tlabel: \"New Invoice\",\n\t\t\thref: \"/dashboard/work/invoices/new\",\n\t\t\ticon: FileText,\n\t\t\tshortcut: \"I\",\n\t\t\tdescription: \"Generate an invoice\",\n\t\t},\n\t\t{\n\t\t\tlabel: \"New Estimate\",\n\t\t\thref: \"/dashboard/work/estimates/new\",\n\t\t\ticon: FileSpreadsheet,\n\t\t\tshortcut: \"E\",\n\t\t\tdescription: \"Create a quote\",\n\t\t},\n\t\t{\n\t\t\tlabel: \"New Contract\",\n\t\t\thref: \"/dashboard/work/contracts/new\",\n\t\t\ticon: FileSignature,\n\t\t\tdescription: \"Draft a service contract\",\n\t\t},\n\t],\n\tCustomers: [\n\t\t{\n\t\t\tlabel: \"New Customer\",\n\t\t\thref: \"/dashboard/customers/new\",\n\t\t\ticon: UserPlus,\n\t\t\tshortcut: \"K\",\n\t\t\tdescription: \"Add a customer\",\n\t\t},\n\t],\n\tFinance: [\n\t\t{\n\t\t\tlabel: \"Record Payment\",\n\t\t\thref: \"/dashboard/finance/payments/new\",\n\t\t\ticon: DollarSign,\n\t\t\tdescription: \"Log a payment\",\n\t\t},\n\t],\n\tOther: [\n\t\t{\n\t\t\tlabel: \"Schedule Job\",\n\t\t\thref: \"/dashboard/schedule/new\",\n\t\t\ticon: Calendar,\n\t\t\tdescription: \"Add to schedule\",\n\t\t},\n\t\t{\n\t\t\tlabel: \"Price Book Item\",\n\t\t\thref: \"/dashboard/work/pricebook/new\",\n\t\t\ticon: Tag,\n\t\t\tdescription: \"Add inventory item\",\n\t\t},\n\t],\n};\n\nexport function QuickAddDropdown() {\n\tconst [mounted, setMounted] = useState(false);\n\n\t// Only render on client to prevent hydration mismatch with Radix UI IDs\n\tuseEffect(() => {\n\t\tsetMounted(true);\n\t}, []);\n\n\tif (!mounted) {\n\t\t// Render placeholder button during SSR that matches client button dimensions\n\t\treturn (\n\t\t\t<button\n\t\t\t\tclassName=\"hover-gradient hover:border-primary/20 hover:bg-primary/10 hover:text-primary focus-visible:ring-ring/50 flex h-8 w-8 items-center justify-center rounded-md border border-transparent transition-all outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50\"\n\t\t\t\tdisabled\n\t\t\t\ttitle=\"Quick Add\"\n\t\t\t\ttype=\"button\"\n\t\t\t>\n\t\t\t\t<Plus className=\"size-4\" />\n\t\t\t\t<span className=\"sr-only\">Quick Add Menu</span>\n\t\t\t</button>\n\t\t);\n\t}\n\n\treturn (\n\t\t<DropdownMenu>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"hover-gradient hover:border-primary/20 hover:bg-primary/10 hover:text-primary focus-visible:ring-ring/50 flex h-8 w-8 items-center justify-center rounded-md border border-transparent transition-all outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50\"\n\t\t\t\t\ttitle=\"Quick Add\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t>\n\t\t\t\t\t<Plus className=\"size-4\" />\n\t\t\t\t\t<span className=\"sr-only\">Quick Add Menu</span>\n\t\t\t\t</button>\n\t\t\t</DropdownMenuTrigger>\n\t\t\t<DropdownMenuContent align=\"end\" className=\"w-64 rounded-lg\">\n\t\t\t\t<DropdownMenuLabel className=\"font-semibold\">\n\t\t\t\t\tQuick Add\n\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t<DropdownMenuSeparator />\n\n\t\t\t\t{Object.entries(quickAddActions).map(([category, actions], index) => (\n\t\t\t\t\t<div key={category}>\n\t\t\t\t\t\t{index > 0 && <DropdownMenuSeparator />}\n\t\t\t\t\t\t<DropdownMenuLabel className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t{category}\n\t\t\t\t\t\t</DropdownMenuLabel>\n\t\t\t\t\t\t<DropdownMenuGroup>\n\t\t\t\t\t\t\t{actions.map((action) => {\n\t\t\t\t\t\t\t\tconst Icon = action.icon;\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<DropdownMenuItem asChild key={action.href}>\n\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"flex items-center gap-2\"\n\t\t\t\t\t\t\t\t\t\t\thref={action.href}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<Icon className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex flex-1 flex-col\">\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-sm\">{action.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t{action.description && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{action.description}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t{action.shortcut && (\n\t\t\t\t\t\t\t\t\t\t\t\t<DropdownMenuShortcut>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{action.shortcut}\n\t\t\t\t\t\t\t\t\t\t\t\t</DropdownMenuShortcut>\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</DropdownMenuGroup>\n\t\t\t\t\t</div>\n\t\t\t\t))}\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;;;;;;;;;;;CAiBC,GAED;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAAA;AAlCA;;;;;;AAqDA,MAAM,kBAAoD;IACzD,MAAM;QACL;YACC,OAAO;YACP,MAAM;YACN,MAAM,6SAAS;YACf,UAAU;YACV,aAAa;QACd;QACA;YACC,OAAO;YACP,MAAM;YACN,MAAM,8SAAQ;YACd,UAAU;YACV,aAAa;QACd;QACA;YACC,OAAO;YACP,MAAM;YACN,MAAM,mUAAe;YACrB,UAAU;YACV,aAAa;QACd;QACA;YACC,OAAO;YACP,MAAM;YACN,MAAM,+TAAa;YACnB,aAAa;QACd;KACA;IACD,WAAW;QACV;YACC,OAAO;YACP,MAAM;YACN,MAAM,8SAAQ;YACd,UAAU;YACV,aAAa;QACd;KACA;IACD,SAAS;QACR;YACC,OAAO;YACP,MAAM;YACN,MAAM,oTAAU;YAChB,aAAa;QACd;KACA;IACD,OAAO;QACN;YACC,OAAO;YACP,MAAM;YACN,MAAM,0SAAQ;YACd,aAAa;QACd;QACA;YACC,OAAO;YACP,MAAM;YACN,MAAM,2RAAG;YACT,aAAa;QACd;KACA;AACF;AAEO,SAAS;IACf,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,wXAAQ,EAAC;IAEvC,wEAAwE;IACxE,IAAA,yXAAS,EAAC;QACT,WAAW;IACZ,GAAG,EAAE;IAEL,IAAI,CAAC,SAAS;QACb,6EAA6E;QAC7E,qBACC,qZAAC;YACA,WAAU;YACV,QAAQ;YACR,OAAM;YACN,MAAK;;8BAEL,qZAAC,8RAAI;oBAAC,WAAU;;;;;;8BAChB,qZAAC;oBAAK,WAAU;8BAAU;;;;;;;;;;;;IAG7B;IAEA,qBACC,qZAAC,0JAAY;;0BACZ,qZAAC,iKAAmB;gBAAC,OAAO;0BAC3B,cAAA,qZAAC;oBACA,WAAU;oBACV,OAAM;oBACN,MAAK;;sCAEL,qZAAC,8RAAI;4BAAC,WAAU;;;;;;sCAChB,qZAAC;4BAAK,WAAU;sCAAU;;;;;;;;;;;;;;;;;0BAG5B,qZAAC,iKAAmB;gBAAC,OAAM;gBAAM,WAAU;;kCAC1C,qZAAC,+JAAiB;wBAAC,WAAU;kCAAgB;;;;;;kCAG7C,qZAAC,mKAAqB;;;;;oBAErB,OAAO,OAAO,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAC,UAAU,QAAQ,EAAE,sBAC1D,qZAAC;;gCACC,QAAQ,mBAAK,qZAAC,mKAAqB;;;;;8CACpC,qZAAC,+JAAiB;oCAAC,WAAU;8CAC3B;;;;;;8CAEF,qZAAC,+JAAiB;8CAChB,QAAQ,GAAG,CAAC,CAAC;wCACb,MAAM,OAAO,OAAO,IAAI;wCACxB,qBACC,qZAAC,8JAAgB;4CAAC,OAAO;sDACxB,cAAA,qZAAC,8UAAI;gDACJ,WAAU;gDACV,MAAM,OAAO,IAAI;;kEAEjB,qZAAC;wDAAK,WAAU;;;;;;kEAChB,qZAAC;wDAAI,WAAU;;0EACd,qZAAC;gEAAK,WAAU;0EAAW,OAAO,KAAK;;;;;;4DACtC,OAAO,WAAW,kBAClB,qZAAC;gEAAK,WAAU;0EACd,OAAO,WAAW;;;;;;;;;;;;oDAIrB,OAAO,QAAQ,kBACf,qZAAC,kKAAoB;kEACnB,OAAO,QAAQ;;;;;;;;;;;;2CAhBW,OAAO,IAAI;;;;;oCAsB5C;;;;;;;2BA/BQ;;;;;;;;;;;;;;;;;AAsCf"}},
    {"offset": {"line": 4715, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { AuthApiError, AuthUnknownError } from \"@supabase/supabase-js\";\nimport { Buffer } from \"node:buffer\";\nimport { extname } from \"node:path\";\n// import { checkBotId } from \"botid/server\";\nimport { clearActiveCompany } from \"@/lib/auth/company-context\";\nimport {\n    createEmailVerificationToken,\n    verifyAndConsumeToken,\n} from \"@/lib/auth/tokens\";\nimport { emailConfig } from \"@/lib/email/resend-client\";\nimport { clearCSRFToken } from \"@/lib/security/csrf\";\nimport {\n    authRateLimiter,\n    checkRateLimit,\n    passwordResetRateLimiter,\n    RateLimitError,\n} from \"@/lib/security/rate-limit\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n    createServiceSupabaseClient,\n    type ServiceSupabaseClient,\n} from \"@/lib/supabase/service-client\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { z } from \"zod\";\nimport {\n    sendEmailVerification,\n    sendPasswordChanged,\n    sendWelcomeEmail,\n} from \"./emails\";\n\nconst NAME_MIN_LENGTH = 2;\nconst NAME_MAX_LENGTH = 100;\nconst COMPANY_NAME_MIN_LENGTH = 2;\nconst COMPANY_NAME_MAX_LENGTH = 200;\nconst PHONE_MIN_DIGITS = 10;\nconst PASSWORD_MIN_LENGTH = 8;\nconst PASSWORD_MAX_LENGTH = 100;\nconst CONFIRMATION_TOKEN_TTL_HOURS = 24;\nconst COUNTRY_CODE_US = \"1\";\nconst NATIONAL_NUMBER_DIGITS = 10;\nconst EXTENDED_US_NUMBER_DIGITS = 11;\nconst BYTES_PER_KILOBYTE = 1024;\nconst BYTES_PER_MEGABYTE = BYTES_PER_KILOBYTE * BYTES_PER_KILOBYTE;\nconst AVATAR_SIZE_LIMIT_MB = 5;\nconst MAX_AVATAR_FILE_SIZE = AVATAR_SIZE_LIMIT_MB * BYTES_PER_MEGABYTE;\n\n/**\n * Authentication Server Actions - Supabase Auth + Resend Email Integration\n *\n * Performance optimizations:\n * - Server Actions for secure authentication\n * - Supabase Auth handles password hashing and session management\n * - Custom emails via Resend with branded templates\n * - Zod validation for input sanitization\n * - Proper error handling with user-friendly messages\n */\n\n// Validation Schemas\nconst signUpSchema = z.object({\n\tname: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(NAME_MIN_LENGTH, \"Name must be at least 2 characters\")\n\t\t.max(NAME_MAX_LENGTH, \"Name is too long\"),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(PHONE_MIN_DIGITS, \"Phone number is required\")\n\t\t.refine(\n\t\t\t(value) => value.replace(/\\D/g, \"\").length >= PHONE_MIN_DIGITS,\n\t\t\t\"Enter a valid phone number\",\n\t\t),\n\tpassword: z\n\t\t.string()\n\t\t.min(PASSWORD_MIN_LENGTH, \"Password must be at least 8 characters\")\n\t\t.max(PASSWORD_MAX_LENGTH, \"Password is too long\")\n\t\t.regex(\n\t\t\t/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/,\n\t\t\t\"Password must contain uppercase, lowercase, and number\",\n\t\t),\n\tcompanyName: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(COMPANY_NAME_MIN_LENGTH, \"Company name must be at least 2 characters\")\n\t\t.max(COMPANY_NAME_MAX_LENGTH, \"Company name is too long\")\n\t\t.optional(),\n\tterms: z\n\t\t.boolean()\n\t\t.refine((val) => val === true, \"You must accept the terms and conditions\"),\n});\n\nconst signInSchema = z.object({\n\temail: z.string().email(\"Invalid email address\"),\n\tpassword: z.string().min(1, \"Password is required\"),\n});\n\nconst forgotPasswordSchema = z.object({\n\temail: z.string().email(\"Invalid email address\"),\n});\n\nconst resetPasswordSchema = z\n\t.object({\n\t\tpassword: z\n\t\t\t.string()\n\t\t\t.min(PASSWORD_MIN_LENGTH, \"Password must be at least 8 characters\")\n\t\t\t.max(PASSWORD_MAX_LENGTH, \"Password is too long\")\n\t\t\t.regex(\n\t\t\t\t/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/,\n\t\t\t\t\"Password must contain uppercase, lowercase, and number\",\n\t\t\t),\n\t\tconfirmPassword: z.string(),\n\t})\n\t.refine((data) => data.password === data.confirmPassword, {\n\t\tmessage: \"Passwords don't match\",\n\t\tpath: [\"confirmPassword\"],\n\t});\n\nconst AVATAR_STORAGE_BUCKET = \"avatars\";\nconst SUPABASE_RATE_LIMIT_MAX_RETRIES = 3;\nconst SUPABASE_RATE_LIMIT_BACKOFF_MS = 200;\n\nconst delay = (ms: number) =>\n\tnew Promise((resolve) => {\n\t\tsetTimeout(resolve, ms);\n\t});\n\nconst withSupabaseRateLimitRetry = async <T extends { error?: unknown }>(\n\toperation: () => Promise<T>,\n): Promise<T> => {\n\tfor (\n\t\tlet attempt = 1;\n\t\tattempt <= SUPABASE_RATE_LIMIT_MAX_RETRIES;\n\t\tattempt += 1\n\t) {\n\t\ttry {\n\t\t\tconst result = await operation();\n\n\t\t\tif (\n\t\t\t\tresult &&\n\t\t\t\ttypeof result === \"object\" &&\n\t\t\t\t\"error\" in result &&\n\t\t\t\tresult.error instanceof AuthApiError &&\n\t\t\t\tresult.error.code === \"over_request_rate_limit\"\n\t\t\t) {\n\t\t\t\tif (attempt === SUPABASE_RATE_LIMIT_MAX_RETRIES) {\n\t\t\t\t\tthrow result.error;\n\t\t\t\t}\n\n\t\t\t\tawait delay(SUPABASE_RATE_LIMIT_BACKOFF_MS * attempt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror instanceof AuthApiError &&\n\t\t\t\terror.code === \"over_request_rate_limit\" &&\n\t\t\t\tattempt < SUPABASE_RATE_LIMIT_MAX_RETRIES\n\t\t\t) {\n\t\t\t\tawait delay(SUPABASE_RATE_LIMIT_BACKOFF_MS * attempt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tthrow new Error(\"Supabase auth operation failed after retries\");\n};\n\ntype SignUpFormInput = z.infer<typeof signUpSchema>;\n\ntype SupabaseBrowserClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nfunction normalizePhoneNumber(input: string): string {\n\tconst trimmed = input.trim();\n\tconst digitsOnly = trimmed.replace(/\\D/g, \"\");\n\n\tif (!digitsOnly) {\n\t\treturn trimmed;\n\t}\n\n\tif (trimmed.startsWith(\"+\")) {\n\t\treturn `+${digitsOnly}`;\n\t}\n\n\tif (\n\t\tdigitsOnly.length === EXTENDED_US_NUMBER_DIGITS &&\n\t\tdigitsOnly.startsWith(COUNTRY_CODE_US)\n\t) {\n\t\treturn `+${digitsOnly}`;\n\t}\n\n\tif (digitsOnly.length === NATIONAL_NUMBER_DIGITS) {\n\t\treturn `+${COUNTRY_CODE_US}${digitsOnly}`;\n\t}\n\n\treturn `+${digitsOnly}`;\n}\n\nconst reportAuthIssue = (_message: string, _error?: unknown) => {\n\t// TODO: Integrate structured logging/monitoring\n};\n\nconst getMetadataString = (\n\tmetadata: unknown,\n\tkey: string,\n): string | undefined => {\n\tif (metadata && typeof metadata === \"object\") {\n\t\tconst value = (metadata as Record<string, unknown>)[key];\n\t\tif (typeof value === \"string\") {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn;\n};\n\nasync function uploadAvatarForNewUser(\n\tsupabase: ServiceSupabaseClient,\n\tfile: File,\n\tuserId: string,\n): Promise<string | null> {\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\tif (!file.type.startsWith(\"image/\")) {\n\t\tthrow new Error(\"Avatar must be an image\");\n\t}\n\n\tif (file.size > MAX_AVATAR_FILE_SIZE) {\n\t\tthrow new Error(`Avatar must be smaller than ${AVATAR_SIZE_LIMIT_MB}MB`);\n\t}\n\n\tconst arrayBuffer = await file.arrayBuffer();\n\tconst extension = extname(file.name) || \".jpg\";\n\tconst filePath = `${userId}/profile${extension}`;\n\n\tconst { error: uploadError } = await supabase.storage\n\t\t.from(AVATAR_STORAGE_BUCKET)\n\t\t.upload(filePath, Buffer.from(arrayBuffer), {\n\t\t\tcacheControl: \"3600\",\n\t\t\tcontentType: file.type || \"image/jpeg\",\n\t\t\tupsert: true,\n\t\t});\n\n\tif (uploadError) {\n\t\tthrow new Error(uploadError.message);\n\t}\n\n\tconst {\n\t\tdata: { publicUrl },\n\t} = supabase.storage.from(AVATAR_STORAGE_BUCKET).getPublicUrl(filePath);\n\n\treturn publicUrl;\n}\n\nconst createServiceClientLoader = () => {\n\tlet client: ServiceSupabaseClient | null = null;\n\treturn async () => {\n\t\tif (client) {\n\t\t\treturn client;\n\t\t}\n\t\tclient = await createServiceSupabaseClient();\n\t\treturn client;\n\t};\n};\n\ntype ParsedSignUpForm = {\n\tvalidated: SignUpFormInput;\n\tnormalizedPhone: string;\n\tcompanyName?: string;\n\tavatarFile: File | null;\n};\n\nconst parseSignUpFormData = (formData: FormData): ParsedSignUpForm => {\n\tconst companyNameEntry = formData.get(\"companyName\");\n\tconst normalizedCompanyName =\n\t\ttypeof companyNameEntry === \"string\" && companyNameEntry.trim().length > 0\n\t\t\t? companyNameEntry\n\t\t\t: undefined;\n\n\tconst rawData = {\n\t\tname: (formData.get(\"name\") as string) ?? \"\",\n\t\temail: (formData.get(\"email\") as string) ?? \"\",\n\t\tphone: (formData.get(\"phone\") as string) ?? \"\",\n\t\tpassword: (formData.get(\"password\") as string) ?? \"\",\n\t\tcompanyName: normalizedCompanyName,\n\t\tterms: formData.get(\"terms\") === \"on\" || formData.get(\"terms\") === \"true\",\n\t};\n\n\tconst validated = signUpSchema.parse(rawData);\n\tconst avatarEntry = formData.get(\"avatar\");\n\tconst avatarFile =\n\t\tavatarEntry instanceof File && avatarEntry.size > 0 ? avatarEntry : null;\n\n\treturn {\n\t\tvalidated,\n\t\tnormalizedPhone: normalizePhoneNumber(validated.phone),\n\t\tcompanyName: validated.companyName?.trim() || undefined,\n\t\tavatarFile,\n\t};\n};\n\nconst requireSupabaseBrowserClient =\n\tasync (): Promise<SupabaseBrowserClient> => {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Authentication service is not configured. Please check your environment variables.\",\n\t\t\t);\n\t\t}\n\n\t\treturn supabase as SupabaseBrowserClient;\n\t};\n\ntype RegisterSupabaseUserParams = {\n\tsupabase: SupabaseBrowserClient;\n\tvalidated: SignUpFormInput;\n\tnormalizedPhone: string;\n\tcompanyName?: string;\n};\n\nconst registerSupabaseUser = async ({\n\tsupabase,\n\tvalidated,\n\tnormalizedPhone,\n\tcompanyName,\n}: RegisterSupabaseUserParams) => {\n\tconst { data, error } = await withSupabaseRateLimitRetry(() =>\n\t\tsupabase.auth.signUp({\n\t\t\temail: validated.email,\n\t\t\tpassword: validated.password,\n\t\t\toptions: {\n\t\t\t\tdata: {\n\t\t\t\t\tname: validated.name,\n\t\t\t\t\tphone: normalizedPhone,\n\t\t\t\t\tcompanyName: companyName ?? null,\n\t\t\t\t},\n\t\t\t\temailRedirectTo: `${emailConfig.siteUrl}/auth/callback`,\n\t\t\t},\n\t\t}),\n\t);\n\n\tif (error) {\n\t\tthrow new Error(error.message);\n\t}\n\n\tif (!data.user) {\n\t\tthrow new Error(\"Failed to create user account\");\n\t}\n\n\treturn data;\n};\n\ntype SyncSignUpProfileParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tnormalizedPhone: string;\n\tname: string;\n\tcompanyName?: string;\n\tavatarFile: File | null;\n};\n\nconst syncSignUpProfile = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tnormalizedPhone,\n\tname,\n\tcompanyName,\n\tavatarFile,\n}: SyncSignUpProfileParams) => {\n\tlet avatarUrl: string | null = null;\n\n\tif (avatarFile) {\n\t\ttry {\n\t\t\tconst adminClient = await ensureServiceSupabase();\n\t\t\tavatarUrl = await uploadAvatarForNewUser(adminClient, avatarFile, userId);\n\t\t} catch (avatarUploadError) {\n\t\t\treportAuthIssue(\"Avatar upload failed\", avatarUploadError);\n\t\t}\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tconst updatePayload: Record<string, string | null> = {\n\t\t\tphone: normalizedPhone,\n\t\t};\n\n\t\tif (avatarUrl) {\n\t\t\tupdatePayload.avatar_url = avatarUrl;\n\t\t}\n\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tawait adminClient.from(\"profiles\").update(updatePayload).eq(\"id\", userId);\n\t} catch (profileUpdateError) {\n\t\treportAuthIssue(\"Failed to update user profile\", profileUpdateError);\n\t}\n\n\tif (!avatarUrl) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tawait adminClient.auth.admin.updateUserById(userId, {\n\t\t\tuser_metadata: {\n\t\t\t\tname,\n\t\t\t\tphone: normalizedPhone,\n\t\t\t\tcompanyName: companyName ?? null,\n\t\t\t\tavatarUrl,\n\t\t\t},\n\t\t});\n\t} catch (metadataError) {\n\t\treportAuthIssue(\"Failed to sync avatar metadata\", metadataError);\n\t}\n};\n\ntype PostSignUpEmailParams = {\n\temail: string;\n\tname: string;\n\trequiresConfirmation: boolean;\n\tuserId: string;\n};\n\nconst handlePostSignUpEmails = async ({\n\temail,\n\tname,\n\trequiresConfirmation,\n\tuserId,\n}: PostSignUpEmailParams): Promise<AuthActionResult | null> => {\n\tif (requiresConfirmation) {\n\t\tconst { token, expiresAt } = await createEmailVerificationToken(\n\t\t\temail,\n\t\t\tuserId,\n\t\t\tCONFIRMATION_TOKEN_TTL_HOURS,\n\t\t);\n\n\t\tconst verificationUrl = `${emailConfig.siteUrl}/auth/verify-email?token=${token}`;\n\t\tconst verificationResult = await sendEmailVerification(email, {\n\t\t\tname,\n\t\t\tverificationUrl,\n\t\t});\n\n\t\tif (!verificationResult.success) {\n\t\t\treportAuthIssue(\n\t\t\t\t\"Failed to send verification email\",\n\t\t\t\tverificationResult.error,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\trequiresEmailConfirmation: true,\n\t\t\t\tmessage:\n\t\t\t\t\t\"Account created! Please check your email to verify your account.\",\n\t\t\t\texpiresAt: expiresAt.toISOString(),\n\t\t\t},\n\t\t};\n\t}\n\n\tconst emailResult = await sendWelcomeEmail(email, {\n\t\tname,\n\t\tloginUrl: `${emailConfig.siteUrl}/welcome`,\n\t});\n\n\tif (!emailResult.success) {\n\t\treportAuthIssue(\"Failed to send welcome email\", emailResult.error);\n\t}\n\n\treturn null;\n};\n\nconst normalizeOptionalPhone = (phone: string | null): string | null => {\n\tif (!phone) {\n\t\treturn null;\n\t}\n\n\tconst digitsOnly = phone.replace(/\\D/g, \"\");\n\tif (digitsOnly.length < PHONE_MIN_DIGITS) {\n\t\tthrow new Error(\n\t\t\t\"Please enter a valid phone number with at least 10 digits.\",\n\t\t);\n\t}\n\n\treturn normalizePhoneNumber(phone);\n};\n\ntype CompleteProfileForm = {\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarFile: File | null;\n};\n\nconst parseCompleteProfileForm = (formData: FormData): CompleteProfileForm => {\n\tconst avatarEntry = formData.get(\"avatar\");\n\tconst avatarFile =\n\t\tavatarEntry instanceof File && avatarEntry.size > 0 ? avatarEntry : null;\n\n\tconst name = (formData.get(\"name\") as string | null) ?? null;\n\tconst phone = (formData.get(\"phone\") as string | null) ?? null;\n\n\treturn {\n\t\tname,\n\t\tnormalizedPhone: normalizeOptionalPhone(phone),\n\t\tavatarFile,\n\t};\n};\n\nconst requireAuthenticatedUser = async (supabase: SupabaseBrowserClient) => {\n\tconst {\n\t\tdata: { user },\n\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\tif (!user) {\n\t\tthrow new Error(\"You must be signed in to complete your profile.\");\n\t}\n\n\treturn user;\n};\n\ntype UpdateCompleteProfileRecordsParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarFile: File | null;\n\texistingAvatar: string | null;\n\texistingMetadata?: Record<string, unknown>;\n};\n\nconst uploadAvatarWithFallback = async ({\n\tensureServiceSupabase,\n\tavatarFile,\n\tuserId,\n\tfallbackAvatar,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tavatarFile: File | null;\n\tuserId: string;\n\tfallbackAvatar: string | null;\n}): Promise<string | null> => {\n\tif (!avatarFile) {\n\t\treturn fallbackAvatar;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\treturn await uploadAvatarForNewUser(adminClient, avatarFile, userId);\n\t} catch (avatarUploadError) {\n\t\treportAuthIssue(\"Avatar upload failed\", avatarUploadError);\n\t\treturn fallbackAvatar;\n\t}\n};\n\nconst updateUserTableRecord = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarUrl,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarUrl: string | null;\n}): Promise<AuthActionResult | null> => {\n\tconst updatePayload: Record<string, string | null> = {};\n\n\tif (name) {\n\t\tupdatePayload.name = name;\n\t}\n\tif (normalizedPhone) {\n\t\tupdatePayload.phone = normalizedPhone;\n\t}\n\tif (avatarUrl) {\n\t\tupdatePayload.avatar = avatarUrl;\n\t}\n\n\tif (Object.keys(updatePayload).length === 0) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tconst { error } = await adminClient\n\t\t\t.from(\"profiles\")\n\t\t\t.update({\n\t\t\t\tfull_name: name || undefined,\n\t\t\t\tphone: normalizedPhone || undefined,\n\t\t\t\tavatar_url: avatarUrl || undefined,\n\t\t\t})\n\t\t\t.eq(\"id\", userId);\n\n\t\tif (error) {\n\t\t\treportAuthIssue(\"Failed to update user profile\", error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Failed to update your profile: ${error.message}`,\n\t\t\t};\n\t\t}\n\t} catch (profileUpdateError) {\n\t\treportAuthIssue(\"Failed to update user profile\", profileUpdateError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Failed to update your profile. Please try again.\",\n\t\t};\n\t}\n\n\treturn null;\n};\n\nconst syncUserMetadataProfile = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarUrl,\n\texistingMetadata,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarUrl: string | null;\n\texistingMetadata?: Record<string, unknown>;\n}) => {\n\tconst hasMetadataChanges = Boolean(name || normalizedPhone || avatarUrl);\n\tif (!hasMetadataChanges) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tconst metadata: Record<string, string | null> = {\n\t\t\t...(existingMetadata as Record<string, string | null>),\n\t\t};\n\n\t\tif (name) {\n\t\t\tmetadata.name = name;\n\t\t}\n\t\tif (normalizedPhone) {\n\t\t\tmetadata.phone = normalizedPhone;\n\t\t}\n\t\tif (avatarUrl) {\n\t\t\tmetadata.avatarUrl = avatarUrl;\n\t\t}\n\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\n\t\tawait adminClient.auth.admin.updateUserById(userId, {\n\t\t\tuser_metadata: metadata,\n\t\t});\n\t} catch (metadataError) {\n\t\treportAuthIssue(\"Failed to sync user metadata\", metadataError);\n\t}\n};\n\nconst updateCompleteProfileRecords = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarFile,\n\texistingAvatar,\n\texistingMetadata,\n}: UpdateCompleteProfileRecordsParams): Promise<AuthActionResult | null> => {\n\tconst avatarUrl = await uploadAvatarWithFallback({\n\t\tensureServiceSupabase,\n\t\tavatarFile,\n\t\tuserId,\n\t\tfallbackAvatar: existingAvatar,\n\t});\n\n\tconst userUpdateResult = await updateUserTableRecord({\n\t\tensureServiceSupabase,\n\t\tuserId,\n\t\tname,\n\t\tnormalizedPhone,\n\t\tavatarUrl,\n\t});\n\n\tif (userUpdateResult) {\n\t\treturn userUpdateResult;\n\t}\n\n\tawait syncUserMetadataProfile({\n\t\tensureServiceSupabase,\n\t\tuserId,\n\t\tname,\n\t\tnormalizedPhone,\n\t\tavatarUrl,\n\t\texistingMetadata,\n\t});\n\n\treturn null;\n};\n\ntype ResolveProfileRedirectParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n};\n\nconst resolveProfileRedirectPath = async ({\n\tensureServiceSupabase,\n\tuserId,\n}: ResolveProfileRedirectParams): Promise<string> => {\n\tconst adminClient = await ensureServiceSupabase();\n\tif (!adminClient) {\n\t\tthrow new Error(\"Admin client not configured\");\n\t}\n\tconst { data: hasCompany } = await adminClient\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.eq(\"status\", \"active\")\n\t\t.limit(1)\n\t\t.maybeSingle();\n\n\treturn hasCompany ? \"/dashboard\" : \"/welcome\";\n};\n// Internal return type (not exported - Next.js 16 \"use server\" restriction)\ntype AuthActionResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tdata?: Record<string, unknown>;\n};\n\n/**\n * Sign Up - Create new user account with Supabase Auth + Custom Resend Email\n *\n * Features:\n * - Email/password authentication\n * - Custom welcome email via Resend with branded template\n * - Creates user profile in users table via database trigger\n * - Validates input with Zod\n * - Disables Supabase's built-in emails (using custom Resend templates instead)\n */\nexport async function signUp(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst parsedForm = parseSignUpFormData(formData);\n\n\t\tawait checkRateLimit(parsedForm.validated.email, authRateLimiter);\n\n\t\tconst supabase = await requireSupabaseBrowserClient();\n\t\tconst authResult = await registerSupabaseUser({\n\t\t\tsupabase,\n\t\t\tvalidated: parsedForm.validated,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tcompanyName: parsedForm.companyName,\n\t\t});\n\n\t\tconst userId = authResult.user?.id;\n\t\tif (!userId) {\n\t\t\tthrow new Error(\"Failed to create user account\");\n\t\t}\n\n\t\tconst ensureServiceSupabase = createServiceClientLoader();\n\t\tawait syncSignUpProfile({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tname: parsedForm.validated.name,\n\t\t\tcompanyName: parsedForm.companyName,\n\t\t\tavatarFile: parsedForm.avatarFile,\n\t\t});\n\n\t\tconst postSignUpResult = await handlePostSignUpEmails({\n\t\t\temail: parsedForm.validated.email,\n\t\t\tname: parsedForm.validated.name,\n\t\t\trequiresConfirmation: !authResult.session,\n\t\t\tuserId,\n\t\t});\n\n\t\tif (postSignUpResult) {\n\t\t\treturn postSignUpResult;\n\t\t}\n\n\t\t// Revalidate and redirect to onboarding\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/dashboard\");\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Re-throw redirect errors\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Complete Profile - Update missing user information after OAuth signup\n *\n * Features:\n * - Collects missing required fields (phone, name)\n * - Optional avatar upload\n * - Updates both auth metadata and public.users table\n * - Company name is collected during onboarding, not here\n */\nexport async function completeProfile(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await requireSupabaseBrowserClient();\n\t\tconst user = await requireAuthenticatedUser(supabase);\n\t\tconst parsedForm = parseCompleteProfileForm(formData);\n\t\tconst ensureServiceSupabase = createServiceClientLoader();\n\n\t\tconst profileUpdateResult = await updateCompleteProfileRecords({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId: user.id,\n\t\t\tname: parsedForm.name,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tavatarFile: parsedForm.avatarFile,\n\t\t\texistingAvatar:\n\t\t\t\tuser.user_metadata?.avatar_url || user.user_metadata?.picture || null,\n\t\t\texistingMetadata: user.user_metadata,\n\t\t});\n\n\t\tif (profileUpdateResult) {\n\t\t\treturn profileUpdateResult;\n\t\t}\n\n\t\tconst redirectPath = await resolveProfileRedirectPath({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId: user.id,\n\t\t}).catch((redirectError) => {\n\t\t\treportAuthIssue(\"Error checking company status\", redirectError);\n\t\t\treturn \"/welcome\";\n\t\t});\n\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(redirectPath);\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign In - Authenticate existing user with Supabase Auth\n *\n * Features:\n * - Email/password authentication\n * - Session management handled by Supabase\n * - Validates input with Zod\n * - Redirects to dashboard on success\n */\nexport async function signIn(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\temail: formData.get(\"email\") as string,\n\t\t\tpassword: formData.get(\"password\") as string,\n\t\t};\n\n\t\tconst validatedData = signInSchema.parse(rawData);\n\n\t\t// Rate limit sign-in attempts by email\n\t\ttry {\n\t\t\tawait checkRateLimit(validatedData.email, authRateLimiter);\n\t\t} catch (rateLimitError) {\n\t\t\tif (rateLimitError instanceof RateLimitError) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitError.message,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow rateLimitError;\n\t\t}\n\n\t\t// Create Supabase client\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Authentication service is not configured. Please check your environment variables.\",\n\t\t\t};\n\t\t}\n\n\t\t// Sign in with Supabase Auth\n\t\tconst { data, error: signInError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signInWithPassword({\n\t\t\t\temail: validatedData.email,\n\t\t\t\tpassword: validatedData.password,\n\t\t\t}),\n\t\t);\n\n\t\tif (signInError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: signInError.message,\n\t\t\t};\n\t\t}\n\n\t\tif (!data.session) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to create session. Please try again.\",\n\t\t\t};\n\t\t}\n\n\t\t// Revalidate and redirect to dashboard\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/dashboard\");\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\t// Handle AuthUnknownError (usually network/service issues)\n\t\tif (caughtError instanceof AuthUnknownError) {\n\t\t\tconsole.error(\"AuthUnknownError during sign in:\", caughtError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to connect to authentication service. Please check your internet connection and try again.\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\t// Log non-redirect errors for debugging\n\t\t\tconsole.error(\"Sign in error:\", caughtError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign Out - End user session\n *\n * Features:\n * - Clears Supabase session (cookie-based)\n * - Clears CSRF token cookie\n * - Clears active company cookie\n * - Revalidates all cached data\n * - Redirects to login page\n *\n * Security:\n * - Ensures all authentication and security cookies are removed\n * - Prevents session reuse or CSRF attacks after logout\n */\nexport async function signOut(): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Sign out from Supabase (clears auth cookies)\n\t\tconst { error: signOutError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signOut(),\n\t\t);\n\n\t\tif (signOutError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: signOutError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Clear all security-related cookies\n\t\tawait clearCSRFToken();\n\t\tawait clearActiveCompany();\n\n\t\t// Revalidate and redirect to login\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/login\");\n\t} catch (caughtError) {\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign In with OAuth - Authenticate with Google or other providers\n *\n * Features:\n * - OAuth provider authentication\n * - Handles both new signups and existing user logins automatically\n * - Supabase determines if user exists and signs them in or creates new account\n * - Redirects to provider login page\n * - After callback, checks if profile is complete (phone, name)\n */\nexport async function signInWithOAuth(\n\tprovider: \"google\" | \"facebook\",\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\t\tif (!siteUrl) {\n\t\t\tthrow new Error(\"NEXT_PUBLIC_SITE_URL is not configured\");\n\t\t}\n\n\t\tconst { data, error: oauthError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signInWithOAuth({\n\t\t\t\tprovider,\n\t\t\t\toptions: {\n\t\t\t\t\tredirectTo: `${siteUrl}/auth/callback`,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\tif (oauthError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: oauthError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Redirect to OAuth provider\n\t\tif (data.url) {\n\t\t\tredirect(data.url);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t} catch (caughtError) {\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Forgot Password - Send custom password reset email via Resend\n *\n * Features:\n * - Sends custom branded password reset email via Resend\n * - Secure token generation via Supabase\n * - Custom email template with security information\n */\nasync function forgotPassword(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst rawData = {\n\t\t\temail: formData.get(\"email\") as string,\n\t\t};\n\n\t\tconst validatedData = forgotPasswordSchema.parse(rawData);\n\n\t\t// Rate limit password reset requests by email (stricter limit)\n\t\ttry {\n\t\t\tawait checkRateLimit(validatedData.email, passwordResetRateLimiter);\n\t\t} catch (rateLimitError) {\n\t\t\tif (rateLimitError instanceof RateLimitError) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitError.message,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow rateLimitError;\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Generate password reset token via Supabase\n\t\tconst { error: resetPasswordError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.resetPasswordForEmail(validatedData.email, {\n\t\t\t\tredirectTo: `${emailConfig.siteUrl}/auth/reset-password`,\n\t\t\t}),\n\t\t);\n\n\t\tif (resetPasswordError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: resetPasswordError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Note: Supabase will send its own email with the reset link.\n\t\t// To use custom Resend email instead, you need to:\n\t\t// 1. Disable Supabase's password reset email in the dashboard\n\t\t// 2. Generate your own secure token\n\t\t// 3. Send custom email with that token\n\t\t// For now, we're using Supabase's reset flow but you can customize this\n\n\t\t// TODO: Replace with custom token generation + Resend email\n\t\t// For full custom implementation, see the commented code below:\n\t\t/*\n    const resetToken = generateSecureToken(); // Implement your own token generation\n    await storeResetToken(validatedData.email, resetToken); // Store in your database\n\n    await sendPasswordReset(validatedData.email, {\n      resetUrl: `${emailConfig.siteUrl}/auth/reset-password?token=${resetToken}`,\n      expiresInMinutes: 60,\n    });\n    */\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"Password reset email sent. Please check your inbox.\",\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to send reset email\",\n\t\t};\n\t}\n}\n\n/**\n * Reset Password - Update password with reset token + Send confirmation email\n *\n * Features:\n * - Updates user password\n * - Validates password strength\n * - Invalidates reset token after use\n * - Sends custom password changed confirmation via Resend\n */\nasync function resetPassword(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst rawData = {\n\t\t\tpassword: formData.get(\"password\") as string,\n\t\t\tconfirmPassword: formData.get(\"confirmPassword\") as string,\n\t\t};\n\n\t\tconst validatedData = resetPasswordSchema.parse(rawData);\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current user before updating password\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\t\tconst { error: updateUserError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.updateUser({\n\t\t\t\tpassword: validatedData.password,\n\t\t\t}),\n\t\t);\n\n\t\tif (updateUserError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: updateUserError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Send password changed confirmation email via Resend\n\t\tif (user?.email) {\n\t\t\tconst emailResult = await sendPasswordChanged(user.email, {\n\t\t\t\tname: user.user_metadata?.name || \"User\",\n\t\t\t\tchangedAt: new Date(),\n\t\t\t});\n\n\t\t\t// Log email send failure but don't block password reset\n\t\t\tif (!emailResult.success) {\n\t\t\t\treportAuthIssue(\n\t\t\t\t\t\"Failed to send password changed email\",\n\t\t\t\t\temailResult.error,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage:\n\t\t\t\t\t\"Password updated successfully. A confirmation email has been sent.\",\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to reset password\",\n\t\t};\n\t}\n}\n\n/**\n * Get Current User - Retrieve authenticated user data\n *\n * Features:\n * - Returns user session data\n * - Returns null if not authenticated\n * - Can be used in Server Components\n */\nasync function getCurrentUser() {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\t\treturn user;\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error getting current user\", caughtError);\n\t\treturn null;\n\t}\n}\n\n/**\n * Get Session - Retrieve current session\n *\n * Features:\n * - Returns session data including access token\n * - Returns null if no active session\n * - Can be used in Server Components\n */\nasync function getSession() {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { session },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getSession());\n\n\t\treturn session;\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error getting session\", caughtError);\n\t\treturn null;\n\t}\n}\n\n/**\n * Verify Email - Verify user's email with custom token\n *\n * Features:\n * - Validates custom verification token\n * - Updates Supabase user's email_confirmed_at\n * - One-time use tokens with expiration\n * - Sends welcome email after successful verification\n */\nexport async function verifyEmail(token: string): Promise<AuthActionResult> {\n\ttry {\n\t\t// Verify and consume the token\n\t\tconst tokenRecord = await verifyAndConsumeToken(\n\t\t\ttoken,\n\t\t\t\"email_verification\",\n\t\t);\n\n\t\tif (!tokenRecord) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Invalid or expired verification link. Please request a new one.\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Update Supabase user to mark email as verified\n\t\tif (tokenRecord.userId) {\n\t\t\t// Note: profiles table doesn't have email_verified field\n\t\t\t// Email verification is handled through auth.users.email_confirmed_at\n\t\t\t// which is set automatically by Supabase Auth\n\t\t\t// We don't need to manually update profiles table\n\n\t\t\t// Send welcome email after successful verification\n\t\t\tconst welcomeResult = await sendWelcomeEmail(tokenRecord.email, {\n\t\t\t\tname: getMetadataString(tokenRecord.metadata, \"name\") || \"User\",\n\t\t\t\tloginUrl: `${emailConfig.siteUrl}/login`,\n\t\t\t});\n\n\t\t\tif (!welcomeResult.success) {\n\t\t\t\treportAuthIssue(\"Failed to send welcome email\", welcomeResult.error);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"Email verified successfully! You can now sign in.\",\n\t\t\t\temail: tokenRecord.email,\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error verifying email\", caughtError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to verify email\",\n\t\t};\n\t}\n}\n\n/**\n * Resend Verification Email - Send a new verification email\n *\n * Features:\n * - Generates new verification token\n * - Deletes old tokens for the email\n * - Sends fresh verification email\n */\nasync function resendVerificationEmail(\n\temail: string,\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Check if user exists\n\t\tconst { data: userData } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"id, full_name, email\")\n\t\t\t.eq(\"email\", email)\n\t\t\t.single();\n\n\t\tif (!userData) {\n\t\t\t// Don't reveal if user exists or not for security\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t\"If an account exists with this email, a verification link has been sent.\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Generate new verification token\n\t\tconst { token, expiresAt } = await createEmailVerificationToken(\n\t\t\temail,\n\t\t\tuserData.id,\n\t\t\tCONFIRMATION_TOKEN_TTL_HOURS,\n\t\t);\n\n\t\t// Send verification email\n\t\tconst verificationUrl = `${emailConfig.siteUrl}/auth/verify-email?token=${token}`;\n\n\t\tconst emailResult = await sendEmailVerification(email, {\n\t\t\tname: userData.full_name || \"User\",\n\t\t\tverificationUrl,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treportAuthIssue(\"Failed to send verification email\", emailResult.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to send verification email. Please try again.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"A new verification link has been sent to your email.\",\n\t\t\t\texpiresAt: expiresAt.toISOString(),\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error resending verification email\", caughtError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to resend verification email\",\n\t\t};\n\t}\n}\n\n/**\n * Get Active Company ID Action\n *\n * Server action to get the currently active company ID for client components.\n */\nexport async function getCompanyIdAction(): Promise<{\n\tsuccess: boolean;\n\tcompanyId?: string;\n\terror?: string;\n}> {\n\t\"use server\";\n\n\ttry {\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\treturn { success: true, companyId };\n\t} catch (error) {\n\t\tconsole.error(\"Error getting company ID:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAigCsB,UAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 4727, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/company-context.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Company Context Server Actions\n *\n * Server Actions for managing active company context.\n * Used by company switcher UI components.\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport {\n\tclearActiveCompany,\n\tgetActiveCompany,\n\tgetUserCompanies,\n\tsetActiveCompany,\n} from \"@/lib/auth/company-context\";\n\n/**\n * Action Result Type\n */\ntype ActionResult<T = void> =\n\t| {\n\t\t\tsuccess: true;\n\t\t\tdata?: T;\n\t\t\tmessage?: string;\n\t  }\n\t| {\n\t\t\tsuccess: false;\n\t\t\terror: string;\n\t  };\n\n/**\n * Switch Company\n *\n * Changes the user's active company context.\n * Revalidates the entire layout to update company-scoped data.\n *\n * @param companyId - Company ID to switch to\n * @returns ActionResult indicating success or failure\n */\nexport async function switchCompany(\n\tcompanyId: string,\n): Promise<ActionResult<void>> {\n\ttry {\n\t\tawait setActiveCompany(companyId);\n\n\t\t// Revalidate everything to ensure all company-scoped data is refreshed\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Company switched successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to switch company\",\n\t\t};\n\t}\n}\n\n/**\n * Clear Active Company\n *\n * Removes the active company context.\n * Useful for logout or company removal flows.\n *\n * @returns ActionResult indicating success or failure\n */\nasync function clearCompany(): Promise<ActionResult<void>> {\n\ttry {\n\t\tawait clearActiveCompany();\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Company context cleared\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to clear company context\",\n\t\t};\n\t}\n}\n\n/**\n * Get User's Companies\n *\n * Returns all companies the user has access to.\n * Useful for populating company switcher dropdowns.\n *\n * @returns ActionResult with array of companies\n */\nasync function getCompanies(): Promise<\n\tActionResult<Array<{ id: string; name: string; logo?: string | null }>>\n> {\n\ttry {\n\t\tconst companies = await getUserCompanies();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: companies,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to get companies\",\n\t\t};\n\t}\n}\n\n/**\n * Get Active Company Details\n *\n * Returns details about the currently active company.\n *\n * @returns ActionResult with company details or null\n */\nasync function getActiveCompanyDetails(): Promise<\n\tActionResult<{ id: string; name: string; logo?: string | null } | null>\n> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: company,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get active company\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAwCsB,gBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 4739, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/user-status.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n/**\n * Update user status action\n * Allows users to change their availability status (online, available, busy)\n */\n\nexport type UserStatus = \"online\" | \"available\" | \"busy\";\n\nexport async function updateUserStatus(status: UserStatus) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Database connection failed\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unauthorized\",\n\t\t\t};\n\t\t}\n\n\t\t// Update user status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", user.id);\n\n\t\tif (updateError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update status\",\n\t\t\t};\n\t\t}\n\n\t\t// Revalidate all pages to reflect the new status\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tstatus,\n\t\t};\n\t} catch (_error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"An unexpected error occurred\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAYsB,mBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 4751, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/avatar.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 4759, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/user-menu.tsx"],"sourcesContent":["\"use client\";\n\nimport { signOut } from \"@/actions/auth\";\nimport { switchCompany } from \"@/actions/company-context\";\nimport { type UserStatus, updateUserStatus } from \"@/actions/user-status\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\";\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { cn } from \"@/lib/utils\";\nimport {\n\tBuilding2,\n\tCheck,\n\tChevronRight,\n\tCreditCard,\n\tHelpCircle,\n\tKeyboard,\n\tLogOut,\n\tMonitor,\n\tMoon,\n\tPlus,\n\tSettings,\n\tSun,\n\tUser,\n} from \"lucide-react\";\nimport { useTheme } from \"next-themes\";\nimport Image from \"next/image\";\nimport Link from \"next/link\";\nimport { useEffect, useState } from \"react\";\n\ntype UserMenuProps = {\n\tuser: {\n\t\tname: string;\n\t\temail: string;\n\t\tavatar: string;\n\t\tstatus?: UserStatus;\n\t};\n\tteams: {\n\t\tid: string;\n\t\tname: string;\n\t\tlogo?: string | null;\n\t\tplan: string;\n\t\tonboardingComplete?: boolean;\n\t\thasPayment?: boolean;\n\t}[];\n\tactiveCompanyId?: string | null;\n};\n\nconst STATUS_CONFIG: Record<\n\tUserStatus,\n\t{ label: string; color: string; description: string }\n> = {\n\tonline: {\n\t\tlabel: \"Online\",\n\t\tcolor: \"bg-green-500\",\n\t\tdescription: \"Available for work\",\n\t},\n\tavailable: {\n\t\tlabel: \"Away\",\n\t\tcolor: \"bg-yellow-500\",\n\t\tdescription: \"Temporarily unavailable\",\n\t},\n\tbusy: {\n\t\tlabel: \"Do not disturb\",\n\t\tcolor: \"bg-red-500\",\n\t\tdescription: \"Only urgent matters\",\n\t},\n\toffline: {\n\t\tlabel: \"Offline\",\n\t\tcolor: \"bg-gray-400\",\n\t\tdescription: \"Appear offline\",\n\t},\n};\n\nexport function UserMenu({ user, teams, activeCompanyId }: UserMenuProps) {\n\tconst { theme, setTheme } = useTheme();\n\tconst [mounted, setMounted] = useState(false);\n\tconst [userStatus, setUserStatus] = useState<UserStatus>(\n\t\tuser.status || \"online\"\n\t);\n\tconst [isUpdatingStatus, setIsUpdatingStatus] = useState(false);\n\tconst [isOpen, setIsOpen] = useState(false);\n\n\tconst initialActiveTeam =\n\t\tteams.find((t) => t.id === activeCompanyId) || teams[0];\n\tconst [activeTeam, setActiveTeam] = useState(initialActiveTeam);\n\n\tuseEffect(() => {\n\t\tsetMounted(true);\n\t}, []);\n\n\tconst handleCompanySwitch = async (team: (typeof teams)[0]) => {\n\t\tif (activeTeam?.id === team.id) return;\n\t\tconst result = await switchCompany(team.id);\n\t\tif (result.success) {\n\t\t\tsetActiveTeam(team);\n\t\t}\n\t};\n\n\tconst handleLogout = async () => {\n\t\tawait signOut();\n\t};\n\n\tconst handleStatusChange = async (status: UserStatus) => {\n\t\tsetIsUpdatingStatus(true);\n\t\ttry {\n\t\t\tconst result = await updateUserStatus(status);\n\t\t\tif (result.success) {\n\t\t\t\tsetUserStatus(status);\n\t\t\t}\n\t\t} finally {\n\t\t\tsetIsUpdatingStatus(false);\n\t\t}\n\t};\n\n\tconst getCurrentTheme = () => {\n\t\tif (!mounted) return \"system\";\n\t\treturn theme === \"light\" ? \"light\" : theme === \"dark\" ? \"dark\" : \"system\";\n\t};\n\n\tconst getInitials = (name?: string, email?: string) => {\n\t\tif (name) {\n\t\t\treturn name\n\t\t\t\t.split(\" \")\n\t\t\t\t.map((n) => n[0])\n\t\t\t\t.join(\"\")\n\t\t\t\t.toUpperCase()\n\t\t\t\t.slice(0, 2);\n\t\t}\n\t\treturn email?.substring(0, 2).toUpperCase() || \"U\";\n\t};\n\n\tconst statusConfig = STATUS_CONFIG[userStatus];\n\n\treturn (\n\t\t<DropdownMenu open={isOpen} onOpenChange={setIsOpen}>\n\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t<button\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"flex h-8 items-center gap-2 rounded-lg px-2 transition-all duration-150\",\n\t\t\t\t\t\t\"hover:bg-accent/80 focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n\t\t\t\t\t\t\"outline-none disabled:pointer-events-none disabled:opacity-50\",\n\t\t\t\t\t\tisOpen && \"bg-accent\"\n\t\t\t\t\t)}\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t>\n\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t<Avatar className=\"size-6 rounded-md ring-1 ring-border/50\">\n\t\t\t\t\t\t\t<AvatarImage alt={user.name || user.email} src={user.avatar} />\n\t\t\t\t\t\t\t<AvatarFallback className=\"rounded-md text-[10px] font-medium bg-muted\">\n\t\t\t\t\t\t\t\t{getInitials(user.name, user.email)}\n\t\t\t\t\t\t\t</AvatarFallback>\n\t\t\t\t\t\t</Avatar>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\"absolute -bottom-0.5 -right-0.5 size-2.5 rounded-full ring-2 ring-background\",\n\t\t\t\t\t\t\t\tstatusConfig.color\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<span className=\"hidden text-sm font-medium md:inline-block truncate max-w-28\">\n\t\t\t\t\t\t{user.name?.split(\" \")[0] || user.email?.split(\"@\")[0] || \"User\"}\n\t\t\t\t\t</span>\n\t\t\t\t\t<span className=\"sr-only\">Open user menu</span>\n\t\t\t\t</button>\n\t\t\t</DropdownMenuTrigger>\n\n\t\t\t<DropdownMenuContent\n\t\t\t\talign=\"end\"\n\t\t\t\tsideOffset={8}\n\t\t\t\tclassName=\"w-80 p-0 overflow-hidden\"\n\t\t\t>\n\t\t\t\t{/* Profile Header */}\n\t\t\t\t<div className=\"bg-muted/30 border-b border-border/50 p-4\">\n\t\t\t\t\t<div className=\"flex items-start gap-3\">\n\t\t\t\t\t\t<div className=\"relative shrink-0\">\n\t\t\t\t\t\t\t<Avatar className=\"size-11 rounded-xl ring-2 ring-background shadow-sm\">\n\t\t\t\t\t\t\t\t<AvatarImage alt={user.name || user.email} src={user.avatar} />\n\t\t\t\t\t\t\t\t<AvatarFallback className=\"rounded-xl text-sm font-semibold bg-primary/10 text-primary\">\n\t\t\t\t\t\t\t\t\t{getInitials(user.name, user.email)}\n\t\t\t\t\t\t\t\t</AvatarFallback>\n\t\t\t\t\t\t\t</Avatar>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\"absolute -bottom-0.5 -right-0.5 size-3 rounded-full ring-2 ring-background\",\n\t\t\t\t\t\t\t\t\tstatusConfig.color\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"flex-1 min-w-0 space-y-0.5\">\n\t\t\t\t\t\t\t<p className=\"text-sm font-semibold truncate\">\n\t\t\t\t\t\t\t\t{user.name || user.email?.split(\"@\")[0] || \"User\"}\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground truncate\">\n\t\t\t\t\t\t\t\t{user.email}\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t{activeTeam && (\n\t\t\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground truncate flex items-center gap-1\">\n\t\t\t\t\t\t\t\t\t<Building2 className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t{activeTeam.name}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Status Section */}\n\t\t\t\t<div className=\"p-2 border-b border-border/50\">\n\t\t\t\t\t<p className=\"text-[11px] font-medium text-muted-foreground uppercase tracking-wider px-2 py-1.5\">\n\t\t\t\t\t\tSet Status\n\t\t\t\t\t</p>\n\t\t\t\t\t<div className=\"space-y-0.5\">\n\t\t\t\t\t\t{(\n\t\t\t\t\t\t\tObject.entries(STATUS_CONFIG) as [\n\t\t\t\t\t\t\t\tUserStatus,\n\t\t\t\t\t\t\t\t(typeof STATUS_CONFIG)[UserStatus],\n\t\t\t\t\t\t\t][]\n\t\t\t\t\t\t).map(([status, config]) => (\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tkey={status}\n\t\t\t\t\t\t\t\tdisabled={isUpdatingStatus}\n\t\t\t\t\t\t\t\tonClick={() => handleStatusChange(status)}\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\"flex w-full items-center gap-3 rounded-md px-2 py-2 text-sm transition-colors\",\n\t\t\t\t\t\t\t\t\t\"hover:bg-accent disabled:opacity-50\",\n\t\t\t\t\t\t\t\t\tuserStatus === status && \"bg-accent\"\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclassName={cn(\"size-2.5 rounded-full shrink-0\", config.color)}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<div className=\"flex-1 text-left\">\n\t\t\t\t\t\t\t\t\t<span className=\"font-medium\">{config.label}</span>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t{userStatus === status && (\n\t\t\t\t\t\t\t\t\t<Check className=\"size-4 text-primary shrink-0\" />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Workspace Section */}\n\t\t\t\t<div className=\"p-2 border-b border-border/50\">\n\t\t\t\t\t<div className=\"flex items-center justify-between px-2 py-1.5\">\n\t\t\t\t\t\t<p className=\"text-[11px] font-medium text-muted-foreground uppercase tracking-wider\">\n\t\t\t\t\t\t\tWorkspaces\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\thref=\"/welcome?new=true\"\n\t\t\t\t\t\t\tclassName=\"text-[11px] font-medium text-primary hover:underline flex items-center gap-0.5\"\n\t\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Plus className=\"size-3\" />\n\t\t\t\t\t\t\tAdd\n\t\t\t\t\t\t</Link>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"max-h-36 overflow-y-auto space-y-0.5\">\n\t\t\t\t\t\t{teams.map((team) => {\n\t\t\t\t\t\t\tconst isActive = activeTeam?.id === team.id;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tkey={team.id}\n\t\t\t\t\t\t\t\t\tonClick={() => handleCompanySwitch(team)}\n\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\"flex w-full items-center gap-3 rounded-md px-2 py-2 transition-colors\",\n\t\t\t\t\t\t\t\t\t\t\"hover:bg-accent\",\n\t\t\t\t\t\t\t\t\t\tisActive && \"bg-accent\"\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div className=\"flex size-8 items-center justify-center rounded-lg bg-muted shrink-0\">\n\t\t\t\t\t\t\t\t\t\t{team.logo ? (\n\t\t\t\t\t\t\t\t\t\t\t<Image\n\t\t\t\t\t\t\t\t\t\t\t\tsrc={team.logo}\n\t\t\t\t\t\t\t\t\t\t\t\talt={team.name}\n\t\t\t\t\t\t\t\t\t\t\t\twidth={20}\n\t\t\t\t\t\t\t\t\t\t\t\theight={20}\n\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"size-5 object-contain\"\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t<Building2 className=\"size-4 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div className=\"flex-1 min-w-0 text-left\">\n\t\t\t\t\t\t\t\t\t\t<p\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\"text-sm truncate\",\n\t\t\t\t\t\t\t\t\t\t\t\tisActive && \"font-medium\"\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{team.name}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-1.5\">\n\t\t\t\t\t\t\t\t\t\t\t{team.onboardingComplete === false ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-[10px] text-amber-600 dark:text-amber-400\">\n\t\t\t\t\t\t\t\t\t\t\t\t\tSetup required\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-[10px] text-muted-foreground capitalize\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{team.plan}\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t{isActive && (\n\t\t\t\t\t\t\t\t\t\t<div className=\"size-1.5 rounded-full bg-primary shrink-0\" />\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Navigation Links */}\n\t\t\t\t<div className=\"p-2 border-b border-border/50\">\n\t\t\t\t\t<NavItem\n\t\t\t\t\t\thref=\"/dashboard/settings/profile/personal\"\n\t\t\t\t\t\ticon={User}\n\t\t\t\t\t\tlabel=\"Profile & Account\"\n\t\t\t\t\t\tshortcut=\"P\"\n\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t/>\n\t\t\t\t\t<NavItem\n\t\t\t\t\t\thref=\"/dashboard/settings/billing\"\n\t\t\t\t\t\ticon={CreditCard}\n\t\t\t\t\t\tlabel=\"Plans & Billing\"\n\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t/>\n\t\t\t\t\t<NavItem\n\t\t\t\t\t\thref=\"/dashboard/settings\"\n\t\t\t\t\t\ticon={Settings}\n\t\t\t\t\t\tlabel=\"Settings\"\n\t\t\t\t\t\tshortcut=\",\"\n\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Theme & Preferences */}\n\t\t\t\t<div className=\"p-2 border-b border-border/50\">\n\t\t\t\t\t<p className=\"text-[11px] font-medium text-muted-foreground uppercase tracking-wider px-2 py-1.5\">\n\t\t\t\t\t\tAppearance\n\t\t\t\t\t</p>\n\t\t\t\t\t<div className=\"px-2 py-1\">\n\t\t\t\t\t\t<div className=\"flex items-center gap-1 p-0.5 rounded-lg bg-muted/50\">\n\t\t\t\t\t\t\t{[\n\t\t\t\t\t\t\t\t{ value: \"light\", icon: Sun, label: \"Light\" },\n\t\t\t\t\t\t\t\t{ value: \"dark\", icon: Moon, label: \"Dark\" },\n\t\t\t\t\t\t\t\t{ value: \"system\", icon: Monitor, label: \"System\" },\n\t\t\t\t\t\t\t].map((option) => {\n\t\t\t\t\t\t\t\tconst Icon = option.icon;\n\t\t\t\t\t\t\t\tconst isSelected = getCurrentTheme() === option.value;\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\tkey={option.value}\n\t\t\t\t\t\t\t\t\t\tdisabled={!mounted}\n\t\t\t\t\t\t\t\t\t\tonClick={() => setTheme(option.value)}\n\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\"flex flex-1 items-center justify-center gap-1.5 rounded-md px-3 py-1.5 text-xs font-medium transition-all\",\n\t\t\t\t\t\t\t\t\t\t\tisSelected\n\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-background text-foreground shadow-sm\"\n\t\t\t\t\t\t\t\t\t\t\t\t: \"text-muted-foreground hover:text-foreground\"\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Icon className=\"size-3.5\" />\n\t\t\t\t\t\t\t\t\t\t{option.label}\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Help & Support */}\n\t\t\t\t<div className=\"p-2 border-b border-border/50\">\n\t\t\t\t\t<NavItem\n\t\t\t\t\t\thref=\"/help\"\n\t\t\t\t\t\ticon={HelpCircle}\n\t\t\t\t\t\tlabel=\"Help & Support\"\n\t\t\t\t\t\texternal\n\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t/>\n\t\t\t\t\t<NavItem\n\t\t\t\t\t\thref=\"/dashboard/settings/shortcuts\"\n\t\t\t\t\t\ticon={Keyboard}\n\t\t\t\t\t\tlabel=\"Keyboard Shortcuts\"\n\t\t\t\t\t\tshortcut=\"/\"\n\t\t\t\t\t\tonClick={() => setIsOpen(false)}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Sign Out */}\n\t\t\t\t<div className=\"p-2\">\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={handleLogout}\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\"flex w-full items-center gap-3 rounded-md px-2 py-2 text-sm transition-colors\",\n\t\t\t\t\t\t\t\"text-muted-foreground hover:bg-destructive/10 hover:text-destructive\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<LogOut className=\"size-4\" />\n\t\t\t\t\t\t<span>Sign out</span>\n\t\t\t\t\t\t<kbd className=\"ml-auto hidden sm:inline-flex h-5 items-center rounded border border-border/50 bg-muted/50 px-1.5 font-mono text-[10px] text-muted-foreground\">\n\t\t\t\t\t\t\tQ\n\t\t\t\t\t\t</kbd>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</DropdownMenuContent>\n\t\t</DropdownMenu>\n\t);\n}\n\nfunction NavItem({\n\thref,\n\ticon: Icon,\n\tlabel,\n\tshortcut,\n\texternal,\n\tonClick,\n}: {\n\thref: string;\n\ticon: React.ElementType;\n\tlabel: string;\n\tshortcut?: string;\n\texternal?: boolean;\n\tonClick?: () => void;\n}) {\n\treturn (\n\t\t<Link\n\t\t\thref={href}\n\t\t\tonClick={onClick}\n\t\t\tclassName={cn(\n\t\t\t\t\"flex items-center gap-3 rounded-md px-2 py-2 text-sm transition-colors\",\n\t\t\t\t\"text-foreground/80 hover:bg-accent hover:text-foreground\"\n\t\t\t)}\n\t\t\t{...(external && { target: \"_blank\", rel: \"noopener noreferrer\" })}\n\t\t>\n\t\t\t<Icon className=\"size-4 text-muted-foreground\" />\n\t\t\t<span className=\"flex-1\">{label}</span>\n\t\t\t{shortcut && (\n\t\t\t\t<kbd className=\"hidden sm:inline-flex h-5 items-center rounded border border-border/50 bg-muted/50 px-1.5 font-mono text-[10px] text-muted-foreground\">\n\t\t\t\t\t{shortcut}\n\t\t\t\t</kbd>\n\t\t\t)}\n\t\t\t{external && <ChevronRight className=\"size-3.5 text-muted-foreground\" />}\n\t\t</Link>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5497, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/email-actions.ts"],"sourcesContent":["\"use server\";\n\nimport {\n    archiveAllEmails,\n    getCompanyEmails,\n    getEmailById,\n    getEmailStats,\n    getEmailThreads,\n    markEmailAsRead,\n    type CompanyEmail,\n} from \"@/lib/email/email-service\";\nimport { z } from \"zod\";\n\nconst getEmailsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  inboxType: z.enum([\"personal\", \"company\"]).optional(),\n  folder: z.enum([\"inbox\", \"drafts\", \"sent\", \"archive\", \"snoozed\", \"spam\", \"trash\", \"bin\", \"starred\", \"all\"]).optional(),\n  category: z.enum([\"support\", \"sales\", \"billing\", \"general\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\", \"subject\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst getEmailThreadsSchema = z.object({\n  limit: z.number().min(1).max(50).optional().default(20),\n  offset: z.number().min(0).optional().default(0),\n  search: z.string().optional(),\n});\n\nconst markEmailReadSchema = z.object({\n  emailId: z.string().min(1),\n});\n\nexport type GetEmailsInput = z.infer<typeof getEmailsSchema>;\nexport type GetEmailThreadsInput = z.infer<typeof getEmailThreadsSchema>;\nexport type MarkEmailReadInput = z.infer<typeof markEmailReadSchema>;\n\n// Re-export email types from email-service\nexport type { CompanyEmail };\n\nexport type GetEmailsResult = Awaited<ReturnType<typeof getCompanyEmails>>;\nexport type GetEmailThreadsResult = Awaited<ReturnType<typeof getEmailThreads>>;\nexport type GetEmailStatsResult = Awaited<ReturnType<typeof getEmailStats>>;\n\n/**\n * Get emails for the active company\n */\nexport async function getEmailsAction(\n  input: GetEmailsInput\n): Promise<GetEmailsResult> {\n  try {\n    const parseResult = getEmailsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      console.error(\" Zod validation error:\", parseResult.error.issues);\n      throw new Error(`Invalid input parameters: ${parseResult.error.issues.map((e) => `${e.path.map(String).join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    // Convert null to undefined for search field\n    const sanitizedInput = {\n      ...validatedInput,\n      search: validatedInput.search ?? undefined,\n    };\n    return await getCompanyEmails(companyId, sanitizedInput);\n  } catch (error) {\n    console.error(\" getEmailsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get email threads for the active company\n */\nasync function getEmailThreadsAction(\n  input: GetEmailThreadsInput\n): Promise<GetEmailThreadsResult> {\n  try {\n    const validatedInput = getEmailThreadsSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailThreads(companyId, validatedInput);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Get a specific email by ID\n */\nexport async function getEmailByIdAction(emailId: string): Promise<{\n  success: boolean;\n  email?: CompanyEmail;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const email = await getEmailById(companyId, emailId);\n    \n    if (!email) {\n      return { success: false, error: \"Email not found\" };\n    }\n\n    return { success: true, email };\n  } catch (error) {\n    console.error(\"Error getting email by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an email as read\n */\nexport async function markEmailAsReadAction(\n  input: MarkEmailReadInput\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const validatedInput = markEmailReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const result = await markEmailAsRead(companyId, validatedInput.emailId);\n    if (!result) {\n      return { success: false, error: \"Failed to mark email as read - check server logs for details\" };\n    }\n    return { success: true };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, error: `Invalid input: ${error.issues.map((e: { message: string }) => e.message).join(\", \")}` };\n    }\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    console.error(\"Error marking email as read:\", error);\n    return { success: false, error: errorMessage };\n  }\n}\n\n/**\n * Get email statistics for the active company\n */\nasync function getEmailStatsAction(): Promise<GetEmailStatsResult> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailStats();\n  } catch (error) {\n    console.error(\"Error getting email stats:\", error);\n    return {\n      totalEmails: 0,\n      sentEmails: 0,\n      receivedEmails: 0,\n      unreadEmails: 0,\n      threadsCount: 0,\n    };\n  }\n}\n\n/**\n * Get total unread email count for the active company\n * Used for displaying notification badges in the header\n */\nexport async function getTotalUnreadCountAction(): Promise<{\n  success: boolean;\n  count?: number;\n  error?: string\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const stats = await getEmailStats();\n    return { success: true, count: stats.unreadEmails };\n  } catch (error) {\n    console.error(\"Error getting unread count:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Fetch email content from Resend API or update with provided content\n */\nexport async function fetchEmailContentAction(\n  emailId: string,\n  _resendEmailId?: string,\n  providedContent?: { html?: string | null; text?: string | null }\n): Promise<{\n  success: boolean;\n  html?: string | null;\n  text?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    let html: string | null = null;\n    let text: string | null = null;\n\n    // If content is provided directly, use it\n    if (providedContent) {\n      html = providedContent.html || null;\n      text = providedContent.text || null;\n    } else {\n      // First, try to get email from database to check for content in metadata\n      const { data: email, error: emailError } = await supabase\n        .from(\"communications\")\n        .select(\"provider_message_id, provider_metadata, body, body_html\")\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId)\n        .single();\n\n      if (emailError) {\n        // Don't return error for PGRST errors that might be expected\n        if (emailError.code === 'PGRST116') {\n          return { success: false, error: \"Email not found in database\" };\n        }\n        return { success: false, error: `Database error: ${emailError.message}` };\n      }\n\n      if (!email) {\n        return { success: false, error: \"Email not found in database\" };\n      }\n\n      // Check if email already has content stored\n      if (email.body_html || email.body) {\n        html = email.body_html || null;\n        text = email.body || null;\n      } else if (email.provider_metadata) {\n        // Try to extract content from provider_metadata\n        const metadata = email.provider_metadata as Record<string, unknown>;\n        \n        // PRIORITY 1: Check webhook_content first (webhook payload - most reliable source)\n        const webhookContent = metadata.webhook_content as Record<string, unknown> | undefined;\n        if (webhookContent) {\n          const htmlValue = webhookContent.html || webhookContent.body_html;\n          const textValue = webhookContent.text || webhookContent.body;\n          \n          if (htmlValue && typeof htmlValue === \"string\") {\n            const content = htmlValue.trim();\n            if (content.length > 0) {\n              html = content;\n            }\n          }\n          if (!html && textValue && typeof textValue === \"string\") {\n            const content = textValue.trim();\n            if (content.length > 0) {\n              text = content;\n            }\n          }\n        }\n\n        // PRIORITY 2: Check full_content (API response) if webhook didn't have content\n        if (!html && !text) {\n          const fullContent = metadata.full_content as Record<string, unknown> | undefined;\n          if (fullContent) {\n            const htmlFields = [\"html\", \"body_html\", \"bodyHtml\"];\n            const textFields = [\"text\", \"body\", \"plain_text\", \"plainText\"];\n\n            // Try HTML fields first\n            for (const field of htmlFields) {\n              if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                const content = (fullContent[field] as string).trim();\n                if (content.length > 0) {\n                  html = content;\n                  break;\n                }\n              }\n            }\n\n            // If no HTML, try text fields\n            if (!html) {\n              for (const field of textFields) {\n                if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                  const content = (fullContent[field] as string).trim();\n                  if (content.length > 0) {\n                    text = content;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // PRIORITY 3: Check top-level metadata.data for content (webhook payload structure)\n        if (!html && !text) {\n          const webhookData = metadata.data as Record<string, unknown> | undefined;\n          if (webhookData) {\n            const htmlValue = webhookData.html || webhookData.body_html;\n            const textValue = webhookData.text || webhookData.body;\n            \n            if (htmlValue && typeof htmlValue === \"string\") {\n              const content = htmlValue.trim();\n              if (content.length > 0) {\n                html = content;\n              }\n            }\n            if (!html && textValue && typeof textValue === \"string\") {\n              const content = textValue.trim();\n              if (content.length > 0) {\n                text = content;\n              }\n            }\n          }\n        }\n\n        // PRIORITY 4: Check top-level metadata fields directly\n        if (!html && !text) {\n          const htmlFields = [\"html\", \"body_html\"];\n          const textFields = [\"text\", \"body\"];\n          \n          for (const field of htmlFields) {\n            if (metadata[field] && typeof metadata[field] === \"string\") {\n              const content = (metadata[field] as string).trim();\n              if (content.length > 0) {\n                html = content;\n                break;\n              }\n            }\n          }\n          \n          if (!html) {\n            for (const field of textFields) {\n              if (metadata[field] && typeof metadata[field] === \"string\") {\n                const content = (metadata[field] as string).trim();\n                if (content.length > 0) {\n                  text = content;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // If we found content in metadata, use it and return early\n        if (html || text) {\n          // Update database with extracted content\n          if ((html || text) && supabase) {\n            const { error: updateError } = await supabase\n              .from(\"communications\")\n              .update({\n                body: text || \"\",\n                body_html: html,\n              })\n              .eq(\"id\", emailId)\n              .eq(\"company_id\", companyId);\n\n            if (updateError) {\n              console.warn(\"  Failed to update email content in database:\", updateError.message);\n            }\n          }\n          return { success: true, html, text };\n        } else {\n          // No content found in metadata\n          return {\n            success: false,\n            error: \"No email content available in metadata\"\n          };\n        }\n      } else {\n        // No metadata at all, can't fetch content\n        return { success: false, error: \"No email metadata available\" };\n      }\n    }\n\n    // Update the database with the content\n    // Try to update, but don't fail if the email doesn't exist - we still return the content\n    if (supabase) {\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update({\n          body: text || \"\",\n          body_html: html,\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      if (updateError) {\n        console.warn(\"  Failed to update email content in database (this is OK, content still returned):\", updateError.message);\n      }\n    }\n\n    return { success: true, html, text };\n  } catch (error) {\n    console.error(\"Error fetching email content:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Sync inbound email routes from database to Resend\n * Creates routes in Resend that don't have a resend_route_id\n */\nexport async function syncInboundRoutesToResendAction(): Promise<{\n  success: boolean;\n  synced: number;\n  errors: string[];\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { createInboundRoute } = await import(\"@/lib/email/resend-domains\");\n    const { createServiceSupabaseClient } = await import(\"@/lib/supabase/service-client\");\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, synced: 0, errors: [\"Database connection failed\"] };\n    }\n\n    const serviceSupabase = await createServiceSupabaseClient();\n    if (!serviceSupabase) {\n      return { success: false, synced: 0, errors: [\"Service database connection failed\"] };\n    }\n\n    // Get all routes that don't have a resend_route_id\n    // Note: This table may not be in the type definitions, so we use type assertion\n    const { data: routes, error } = await (serviceSupabase\n      .from(\"communication_email_inbound_routes\" as any)\n      .select(\"id, company_id, route_address, name, enabled\")\n      .is(\"resend_route_id\", null)\n      .eq(\"enabled\", true) as any);\n\n    if (error) {\n      console.error(\"Failed to fetch routes:\", error);\n      return { success: false, synced: 0, errors: [error.message] };\n    }\n\n    if (!routes || routes.length === 0) {\n      return { success: true, synced: 0, errors: [] };\n    }\n\n    // Construct webhook URL\n    let webhookUrl = process.env.NEXT_PUBLIC_SITE_URL;\n    if (!webhookUrl && process.env.VERCEL_URL) {\n      webhookUrl = `https://${process.env.VERCEL_URL}`;\n    }\n    if (!webhookUrl) {\n      return { success: false, synced: 0, errors: [\"Webhook URL not configured. Set NEXT_PUBLIC_SITE_URL or VERCEL_URL\"] };\n    }\n    webhookUrl = `${webhookUrl}/api/webhooks/resend`;\n\n    const errors: string[] = [];\n    let synced = 0;\n\n    for (const route of (routes || []) as Array<{ id: string; company_id: string; route_address: string; name: string | null; enabled: boolean }>) {\n      try {\n        // Handle catch-all routes (e.g., @biezru.resend.app)\n        // Resend doesn't support true catch-all, so we'll create a route for the domain\n        // For now, we'll skip catch-all routes and handle them differently\n        if (route.route_address.startsWith(\"@\")) {\n          errors.push(`Catch-all routes (${route.route_address}) need to be configured manually in Resend dashboard`);\n          continue;\n        }\n\n        // Create route in Resend\n        const result = await createInboundRoute({\n          name: route.name || `Route for ${route.route_address}`,\n          recipients: [route.route_address],\n          url: webhookUrl,\n        });\n\n        if (!result.success) {\n          console.error(` Failed to create Resend route for ${route.route_address}:`, result.error);\n          errors.push(`${route.route_address}: ${result.error}`);\n          continue;\n        }\n\n        // Update database with resend_route_id\n        const { error: updateError } = await (serviceSupabase\n          .from(\"communication_email_inbound_routes\" as any)\n          .update({\n            resend_route_id: result.data.id,\n            signing_secret: result.data.secret || null,\n            last_synced_at: new Date().toISOString(),\n          })\n          .eq(\"id\", route.id) as any);\n\n        if (updateError) {\n          console.error(` Failed to update route ${route.route_address}:`, updateError);\n          errors.push(`${route.route_address}: Database update failed`);\n          continue;\n        }\n\n        synced++;\n      } catch (error) {\n        console.error(` Error syncing route ${route.route_address}:`, error);\n        errors.push(`${route.route_address}: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      synced,\n      errors,\n    };\n  } catch (error) {\n    console.error(\"Error syncing inbound routes:\", error);\n    return {\n      success: false,\n      synced: 0,\n      errors: [error instanceof Error ? error.message : \"Unknown error\"],\n    };\n  }\n}\n\n/**\n * Archive an email\n */\nexport async function archiveEmailAction(emailId: string): Promise<{ success: boolean; error?: string }> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const { error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n    \n    if (error) {\n      return { success: false, error: error.message };\n    }\n    \n    return { success: true };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk archive multiple emails by their IDs\n */\nexport async function bulkArchiveEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  archived: number;\n  error?: string\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, archived: 0, error: \"No email IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, archived: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, archived: 0, error: error.message };\n    }\n\n    const archivedCount = data?.length ?? 0;\n    return { success: true, archived: archivedCount };\n  } catch (error) {\n    return { success: false, archived: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Archive all emails in a folder\n */\nexport async function archiveAllEmailsAction(folder?: string): Promise<{ \n  success: boolean; \n  archived: number;\n  error?: string \n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n    \n    const result = await archiveAllEmails(companyId, folder);\n    \n    if (!result.success) {\n      return { success: false, archived: 0, error: result.error };\n    }\n    \n    return { success: true, archived: result.count };\n  } catch (error) {\n    return {\n      success: false,\n      archived: 0,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Get email folder counts for the active company\n * Returns count of emails in each folder (inbox, sent, drafts, etc.)\n */\nexport async function getEmailFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    all: number;\n    inbox: number;\n    drafts: number;\n    sent: number;\n    archive: number;\n    snoozed: number;\n    spam: number;\n    trash: number;\n    starred: number;\n    [key: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get counts for each folder type using parallel queries\n    // All counts show UNREAD emails only (read_at IS NULL)\n    const [\n      allResult,\n      inboxResult,\n      draftsResult,\n      sentResult,\n      archiveResult,\n      snoozedResult,\n      spamResult,\n      trashResult,\n      starredResult\n    ] = await Promise.all([\n      // All Mail: all non-deleted, unread emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Inbox: inbound, not archived, not deleted, not draft, not spam, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\")\n        .or(\"category.is.null,category.neq.spam\")\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n\n      // Drafts - always count all drafts (read_at not relevant for drafts)\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"status\", \"draft\")\n        .is(\"deleted_at\", null),\n\n      // Sent: outbound, not archived, not deleted, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\"),\n\n      // Archive - unread archived emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"is_archived\", true)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Snoozed - unread snoozed emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"snoozed_until\", \"is\", null)\n        .gt(\"snoozed_until\", new Date().toISOString())\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Spam - fetch category, tags, and read_at to count unread spam\n      supabase\n        .from(\"communications\")\n        .select(\"category, tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Trash - unread deleted emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"deleted_at\", \"is\", null)\n        .is(\"read_at\", null),\n\n      // Starred - fetch tags and read_at, count unread starred in memory\n      supabase\n        .from(\"communications\")\n        .select(\"tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n    ]);\n\n    // Count spam emails in memory (category=spam OR spam tag)\n    const spamCount = (spamResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      const hasSpamTag = Array.isArray(tags) && tags.includes(\"spam\");\n      return email.category === \"spam\" || hasSpamTag;\n    }).length;\n\n    // Count starred emails in memory\n    const starredCount = (starredResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      return Array.isArray(tags) && tags.includes(\"starred\");\n    }).length;\n\n    return {\n      success: true,\n      counts: {\n        all: allResult.count ?? 0,\n        inbox: inboxResult.count ?? 0,\n        drafts: draftsResult.count ?? 0,\n        sent: sentResult.count ?? 0,\n        archive: archiveResult.count ?? 0,\n        snoozed: snoozedResult.count ?? 0,\n        spam: spamCount,\n        trash: trashResult.count ?? 0,\n        starred: starredCount,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting email folder counts:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Toggle star status on an email\n * Adds or removes \"starred\" tag from the email's tags array\n */\nexport async function toggleStarEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isStarred?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlyStarred = currentTags.includes(\"starred\");\n\n    // Toggle the starred tag\n    const newTags = isCurrentlyStarred\n      ? currentTags.filter(tag => tag !== \"starred\")\n      : [...currentTags, \"starred\"];\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ tags: newTags.length > 0 ? newTags : null })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isStarred: !isCurrentlyStarred };\n  } catch (error) {\n    console.error(\"Error toggling star on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Toggle spam status on an email\n * Adds or removes \"spam\" tag and updates category field\n */\nexport async function toggleSpamEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isSpam?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags and category\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags, category\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlySpam = currentTags.includes(\"spam\") || email?.category === \"spam\";\n\n    // Toggle the spam tag and category\n    const newTags = isCurrentlySpam\n      ? currentTags.filter(tag => tag !== \"spam\")\n      : [...currentTags, \"spam\"];\n\n    const newCategory = isCurrentlySpam ? null : \"spam\";\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        tags: newTags.length > 0 ? newTags : null,\n        category: newCategory\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isSpam: !isCurrentlySpam };\n  } catch (error) {\n    console.error(\"Error toggling spam on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Snooze an email until a specific time\n * The email will reappear in inbox after the snooze time\n */\nexport async function snoozeEmailAction(\n  emailId: string,\n  snoozeUntil: string | null\n): Promise<{\n  success: boolean;\n  snoozedUntil?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Update the snoozed_until field\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ snoozed_until: snoozeUntil })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, snoozedUntil: snoozeUntil };\n  } catch (error) {\n    console.error(\"Error snoozing email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Unsnooze an email (remove snooze time)\n */\nexport async function unsnoozeEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  return snoozeEmailAction(emailId, null);\n}\n\n/**\n * Bulk mark emails as read or unread\n */\nexport async function bulkMarkReadUnreadAction(\n  emailIds: string[],\n  markAsRead: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ read_at: markAsRead ? new Date().toISOString() : null })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, updated: 0, error: error.message };\n    }\n\n    // Dispatch event to refresh counts\n    return { success: true, updated: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk marking emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk toggle star on emails\n */\nexport async function bulkStarEmailsAction(\n  emailIds: string[],\n  addStar: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Group emails by what changes need to be made\n    const toUpdate: Array<{ id: string; newTags: string[] | null }> = [];\n\n    for (const email of emails) {\n      const currentTags = (email.tags as string[]) || [];\n      const hasStarred = currentTags.includes(\"starred\");\n\n      let newTags: string[];\n      if (addStar && !hasStarred) {\n        newTags = [...currentTags, \"starred\"];\n      } else if (!addStar && hasStarred) {\n        newTags = currentTags.filter((t) => t !== \"starred\");\n      } else {\n        continue; // No change needed\n      }\n\n      toUpdate.push({ id: email.id, newTags: newTags.length > 0 ? newTags : null });\n    }\n\n    if (toUpdate.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      toUpdate.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const updatedCount = results.filter((r) => !r.error).length;\n    return { success: true, updated: updatedCount };\n  } catch (error) {\n    console.error(\"Error bulk starring emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk delete emails (move to trash)\n */\nexport async function bulkDeleteEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  deleted: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, deleted: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, deleted: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, deleted: 0, error: \"Database connection failed\" };\n    }\n\n    // Soft delete by setting deleted_at\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ deleted_at: new Date().toISOString() })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, deleted: 0, error: error.message };\n    }\n\n    return { success: true, deleted: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk deleting emails:\", error);\n    return { success: false, deleted: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk move emails to spam\n */\nexport async function bulkMoveToSpamAction(emailIds: string[]): Promise<{\n  success: boolean;\n  moved: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, moved: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, moved: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, moved: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, moved: 0 };\n    }\n\n    // Prepare updates with new tags\n    const updates = emails.map((email) => {\n      const currentTags = (email.tags as string[]) || [];\n      const newTags = currentTags.includes(\"spam\")\n        ? currentTags\n        : [...currentTags, \"spam\"];\n      return { id: email.id, newTags };\n    });\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      updates.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ category: \"spam\", tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const movedCount = results.filter((r) => !r.error).length;\n    return { success: true, moved: movedCount };\n  } catch (error) {\n    console.error(\"Error moving emails to spam:\", error);\n    return { success: false, moved: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// DRAFT ACTIONS\n// ============================================================================\n\nconst saveDraftSchema = z.object({\n  id: z.string().uuid().optional(), // If provided, update existing draft\n  to: z.array(z.string().email()).optional().default([]),\n  cc: z.array(z.string().email()).optional().default([]),\n  bcc: z.array(z.string().email()).optional().default([]),\n  subject: z.string().optional().default(\"\"),\n  body: z.string().optional().default(\"\"),\n  bodyHtml: z.string().optional(),\n  customerId: z.string().uuid().optional(),\n  attachments: z.array(z.object({\n    filename: z.string(),\n    content: z.string(),\n    contentType: z.string().optional(),\n  })).optional(),\n});\n\nexport type SaveDraftInput = z.infer<typeof saveDraftSchema>;\n\n/**\n * Save or update an email draft\n * If id is provided, updates existing draft; otherwise creates a new one\n */\nexport async function saveDraftAction(input: SaveDraftInput): Promise<{\n  success: boolean;\n  draftId?: string;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const parseResult = saveDraftSchema.safeParse(input);\n    if (!parseResult.success) {\n      return { success: false, error: `Invalid input: ${parseResult.error.message}` };\n    }\n\n    const { id, to, cc, bcc, subject, body, bodyHtml, customerId, attachments } = parseResult.data;\n\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the company's default email address for from_address\n    const { data: companySettings } = await supabase\n      .from(\"company_communication_settings\")\n      .select(\"email_from_address, email_from_name\")\n      .eq(\"company_id\", companyId)\n      .single();\n\n    const fromAddress = companySettings?.email_from_address || \"noreply@example.com\";\n    const fromName = companySettings?.email_from_name || \"Draft\";\n\n    const draftData = {\n      company_id: companyId,\n      customer_id: customerId || null,\n      type: \"email\" as const,\n      direction: \"outbound\" as const,\n      from_address: fromAddress,\n      from_name: fromName,\n      to_address: to.length > 0 ? to.join(\", \") : \"draft@placeholder.local\",\n      cc_address: cc.length > 0 ? cc.join(\", \") : null,\n      bcc_address: bcc.length > 0 ? bcc.join(\", \") : null,\n      subject: subject || \"(No subject)\",\n      body: body || \"\",\n      body_html: bodyHtml || null,\n      attachments: attachments && attachments.length > 0 ? attachments : null,\n      attachment_count: attachments?.length || 0,\n      status: \"draft\" as const,\n      is_automated: false,\n      is_internal: false,\n      is_archived: false,\n      is_thread_starter: true,\n      priority: \"normal\" as const,\n      updated_at: new Date().toISOString(),\n    };\n\n    if (id) {\n      // Update existing draft\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update(draftData)\n        .eq(\"id\", id)\n        .eq(\"company_id\", companyId)\n        .eq(\"status\", \"draft\");\n\n      if (updateError) {\n        console.error(\"Error updating draft:\", updateError);\n        return { success: false, error: updateError.message };\n      }\n\n      return { success: true, draftId: id };\n    } else {\n      // Create new draft\n      const { data: newDraft, error: insertError } = await supabase\n        .from(\"communications\")\n        .insert({\n          ...draftData,\n          created_at: new Date().toISOString(),\n        })\n        .select(\"id\")\n        .single();\n\n      if (insertError) {\n        console.error(\"Error creating draft:\", insertError);\n        return { success: false, error: insertError.message };\n      }\n\n      return { success: true, draftId: newDraft.id };\n    }\n  } catch (error) {\n    console.error(\"Error saving draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Get a draft by ID\n */\nexport async function getDraftAction(draftId: string): Promise<{\n  success: boolean;\n  draft?: {\n    id: string;\n    to: string[];\n    cc: string[];\n    bcc: string[];\n    subject: string;\n    body: string;\n    bodyHtml?: string | null;\n    customerId?: string | null;\n    attachments?: Array<{ filename: string; content: string; contentType?: string }> | null;\n    updatedAt: string;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const { data: draft, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"id, to_address, cc_address, bcc_address, subject, body, body_html, customer_id, attachments, updated_at\")\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!draft) {\n      return { success: false, error: \"Draft not found\" };\n    }\n\n    // Parse addresses from comma-separated strings to arrays\n    const parseAddresses = (addr: string | null): string[] => {\n      if (!addr || addr === \"draft@placeholder.local\") return [];\n      return addr.split(\",\").map(a => a.trim()).filter(Boolean);\n    };\n\n    return {\n      success: true,\n      draft: {\n        id: draft.id,\n        to: parseAddresses(draft.to_address),\n        cc: parseAddresses(draft.cc_address),\n        bcc: parseAddresses(draft.bcc_address),\n        subject: draft.subject === \"(No subject)\" ? \"\" : (draft.subject || \"\"),\n        body: draft.body || \"\",\n        bodyHtml: draft.body_html,\n        customerId: draft.customer_id,\n        attachments: draft.attachments as Array<{ filename: string; content: string; contentType?: string }> | null,\n        updatedAt: draft.updated_at,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Delete a draft\n */\nexport async function deleteDraftAction(draftId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Hard delete drafts (they don't need to go to trash)\n    const { error: deleteError } = await supabase\n      .from(\"communications\")\n      .delete()\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\");\n\n    if (deleteError) {\n      return { success: false, error: deleteError.message };\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// RETRY ACTIONS\n// ============================================================================\n\n/**\n * Retry sending a failed email\n * Fetches the failed email, resets its status, and attempts to resend\n */\nexport async function retryFailedEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const { sendEmail } = await import(\"@/lib/email/email-sender\");\n    const { PlainTextEmail } = await import(\"@/emails/plain-text-email\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the failed email\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"*\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .eq(\"status\", \"failed\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!email) {\n      return { success: false, error: \"Failed email not found\" };\n    }\n\n    // Reset status to queued\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        status: \"queued\",\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    if (updateError) {\n      return { success: false, error: `Failed to reset email status: ${updateError.message}` };\n    }\n\n    // Parse recipients\n    const parseAddresses = (addr: string | null): string | string[] => {\n      if (!addr) return [];\n      const addresses = addr.split(\",\").map(a => a.trim()).filter(Boolean);\n      return addresses.length === 1 ? addresses[0] : addresses;\n    };\n\n    const to = parseAddresses(email.to_address);\n    const cc = parseAddresses(email.cc_address);\n    const bcc = parseAddresses(email.bcc_address);\n\n    // Get attachments from metadata if stored (for scheduled emails)\n    const metadata = email.provider_metadata as Record<string, unknown> | null;\n    const attachments = metadata?.scheduled_attachments as Array<{\n      filename: string;\n      content: string;\n      contentType?: string;\n    }> | undefined;\n\n    // Attempt to resend\n    const sendResult = await sendEmail({\n      to,\n      subject: email.subject || \"(No subject)\",\n      template: PlainTextEmail({ message: email.body || \"\" }),\n      templateType: \"generic\" as any,\n      companyId,\n      communicationId: emailId,\n      cc: cc.length > 0 ? cc : undefined,\n      bcc: bcc.length > 0 ? bcc : undefined,\n      attachments,\n    });\n\n    if (!sendResult.success) {\n      // Update status back to failed\n      await supabase\n        .from(\"communications\")\n        .update({\n          status: \"failed\",\n          failure_reason: sendResult.error || \"Email send failed on retry\",\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      return {\n        success: false,\n        error: sendResult.error || \"Failed to send email on retry\",\n      };\n    }\n\n    // Update status to sent\n    await supabase\n      .from(\"communications\")\n      .update({\n        status: \"sent\",\n        sent_at: new Date().toISOString(),\n        provider_message_id: sendResult.data?.id || null,\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error retrying failed email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IAoMsB,4BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 5509, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/scroll-area.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 5517, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/separator.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 5525, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/ai-approval.ts"],"sourcesContent":["/**\n * AI Action Approval Server Actions\n *\n * Server actions for owner-only approval of destructive AI actions.\n * These actions wrap the action-approval service for use in React components.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tapproveAction,\n\trejectAction,\n\tgetPendingActionsForCompany,\n\tgetPendingActionsForChat,\n\tgetPendingAction,\n\tisCompanyOwner,\n\texpireOldActions,\n\ttype PendingAction,\n} from \"@/lib/ai/action-approval\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type { PendingAction };\n\nexport interface ApprovalActionResult {\n\tsuccess: boolean;\n\terror?: string;\n\tactionId?: string;\n\ttoolName?: string;\n\ttoolArgs?: Record<string, unknown>;\n\t// Execution fields (for approval responses)\n\texecuted?: boolean;\n\texecutionResult?: unknown;\n\texecutionError?: string;\n}\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst approveActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n});\n\nconst rejectActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n\treason: z.string().max(500, \"Reason too long\").optional(),\n});\n\nconst getPendingActionsSchema = z.object({\n\tstatus: z.enum([\"pending\", \"approved\", \"rejected\", \"expired\"]).optional(),\n\tlimit: z.number().min(1).max(100).default(50),\n});\n\nconst getChatActionsSchema = z.object({\n\tchatId: z.string().uuid(\"Invalid chat ID\"),\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nasync function getAuthenticatedUserWithCompany() {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tassertAuthenticated(user?.id);\n\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id, role\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t403,\n\t\t);\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\trole: teamMember.role,\n\t};\n}\n\n// ============================================================================\n// Server Actions\n// ============================================================================\n\n/**\n * Approve a pending AI action - OWNER ONLY\n * This action will be executed immediately after approval\n */\nexport async function approveAIAction(\n\tinput: z.infer<typeof approveActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = approveActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner (double-check even though DB function enforces this)\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can approve destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the approval function (which calls the DB RPC)\n\t\tconst result = await approveAction(validated.actionId, userId);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to approve action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Automatically execute the approved action\n\t\tlet executionResult: { success: boolean; result?: unknown; error?: string } | null = null;\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`${process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\"}/api/ai/execute-approved`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tactionId: validated.actionId,\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t);\n\t\t\texecutionResult = await response.json();\n\t\t} catch (execError) {\n\t\t\tconsole.error(\"Failed to auto-execute approved action:\", execError);\n\t\t\t// Don't fail the approval - execution can be retried\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: result.actionId,\n\t\t\ttoolName: result.toolName,\n\t\t\ttoolArgs: result.toolArgs,\n\t\t\texecuted: executionResult?.success || false,\n\t\t\texecutionResult: executionResult?.result,\n\t\t\texecutionError: executionResult?.error,\n\t\t};\n\t});\n}\n\n/**\n * Reject a pending AI action - OWNER ONLY\n * The AI will not execute this action\n */\nexport async function rejectAIAction(\n\tinput: z.infer<typeof rejectActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = rejectActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can reject destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the rejection function\n\t\tconst result = await rejectAction(\n\t\t\tvalidated.actionId,\n\t\t\tuserId,\n\t\t\tvalidated.reason,\n\t\t);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to reject action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: validated.actionId,\n\t\t};\n\t});\n}\n\n/**\n * Get all pending actions for the current company\n * Used by the owner dashboard to review pending approvals\n */\nexport async function getCompanyPendingActions(\n\tinput?: z.infer<typeof getPendingActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = input ? getPendingActionsSchema.parse(input) : { limit: 50 };\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: validated.status,\n\t\t\tlimit: validated.limit,\n\t\t});\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get pending actions for a specific chat session\n * Used to show approval banners in the AI chat\n */\nexport async function getChatPendingActions(\n\tinput: z.infer<typeof getChatActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = getChatActionsSchema.parse(input);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions for the chat\n\t\tconst actions = await getPendingActionsForChat(companyId, validated.chatId);\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get a specific pending action by ID\n */\nexport async function getPendingActionById(\n\tactionId: string,\n): Promise<ActionResult<PendingAction | null>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = z.string().uuid(\"Invalid action ID\").parse(actionId);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\tconst action = await getPendingAction(companyId, validated);\n\t\treturn action;\n\t});\n}\n\n/**\n * Check if current user is a company owner\n * Used by UI to determine if approval buttons should be enabled\n */\nexport async function checkIsCompanyOwner(): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\t\tconst isOwner = await isCompanyOwner(companyId, userId);\n\t\treturn isOwner;\n\t});\n}\n\n/**\n * Get pending action counts for notifications\n */\nexport async function getPendingActionCounts(): Promise<\n\tActionResult<{\n\t\ttotal: number;\n\t\tbyRiskLevel: Record<string, number>;\n\t}>\n> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: \"pending\",\n\t\t\tlimit: 100,\n\t\t});\n\n\t\t// Group by risk level\n\t\tconst byRiskLevel: Record<string, number> = {\n\t\t\tlow: 0,\n\t\t\tmedium: 0,\n\t\t\thigh: 0,\n\t\t\tcritical: 0,\n\t\t};\n\n\t\tfor (const action of actions) {\n\t\t\tbyRiskLevel[action.riskLevel] = (byRiskLevel[action.riskLevel] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: actions.length,\n\t\t\tbyRiskLevel,\n\t\t};\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAwOsB,2BAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 5537, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/ai-approval.ts"],"sourcesContent":["/**\n * AI Action Approval Server Actions\n *\n * Server actions for owner-only approval of destructive AI actions.\n * These actions wrap the action-approval service for use in React components.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tapproveAction,\n\trejectAction,\n\tgetPendingActionsForCompany,\n\tgetPendingActionsForChat,\n\tgetPendingAction,\n\tisCompanyOwner,\n\texpireOldActions,\n\ttype PendingAction,\n} from \"@/lib/ai/action-approval\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type { PendingAction };\n\nexport interface ApprovalActionResult {\n\tsuccess: boolean;\n\terror?: string;\n\tactionId?: string;\n\ttoolName?: string;\n\ttoolArgs?: Record<string, unknown>;\n\t// Execution fields (for approval responses)\n\texecuted?: boolean;\n\texecutionResult?: unknown;\n\texecutionError?: string;\n}\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst approveActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n});\n\nconst rejectActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n\treason: z.string().max(500, \"Reason too long\").optional(),\n});\n\nconst getPendingActionsSchema = z.object({\n\tstatus: z.enum([\"pending\", \"approved\", \"rejected\", \"expired\"]).optional(),\n\tlimit: z.number().min(1).max(100).default(50),\n});\n\nconst getChatActionsSchema = z.object({\n\tchatId: z.string().uuid(\"Invalid chat ID\"),\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nasync function getAuthenticatedUserWithCompany() {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tassertAuthenticated(user?.id);\n\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id, role\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t403,\n\t\t);\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\trole: teamMember.role,\n\t};\n}\n\n// ============================================================================\n// Server Actions\n// ============================================================================\n\n/**\n * Approve a pending AI action - OWNER ONLY\n * This action will be executed immediately after approval\n */\nexport async function approveAIAction(\n\tinput: z.infer<typeof approveActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = approveActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner (double-check even though DB function enforces this)\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can approve destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the approval function (which calls the DB RPC)\n\t\tconst result = await approveAction(validated.actionId, userId);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to approve action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Automatically execute the approved action\n\t\tlet executionResult: { success: boolean; result?: unknown; error?: string } | null = null;\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`${process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\"}/api/ai/execute-approved`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tactionId: validated.actionId,\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t);\n\t\t\texecutionResult = await response.json();\n\t\t} catch (execError) {\n\t\t\tconsole.error(\"Failed to auto-execute approved action:\", execError);\n\t\t\t// Don't fail the approval - execution can be retried\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: result.actionId,\n\t\t\ttoolName: result.toolName,\n\t\t\ttoolArgs: result.toolArgs,\n\t\t\texecuted: executionResult?.success || false,\n\t\t\texecutionResult: executionResult?.result,\n\t\t\texecutionError: executionResult?.error,\n\t\t};\n\t});\n}\n\n/**\n * Reject a pending AI action - OWNER ONLY\n * The AI will not execute this action\n */\nexport async function rejectAIAction(\n\tinput: z.infer<typeof rejectActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = rejectActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can reject destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the rejection function\n\t\tconst result = await rejectAction(\n\t\t\tvalidated.actionId,\n\t\t\tuserId,\n\t\t\tvalidated.reason,\n\t\t);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to reject action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: validated.actionId,\n\t\t};\n\t});\n}\n\n/**\n * Get all pending actions for the current company\n * Used by the owner dashboard to review pending approvals\n */\nexport async function getCompanyPendingActions(\n\tinput?: z.infer<typeof getPendingActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = input ? getPendingActionsSchema.parse(input) : { limit: 50 };\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: validated.status,\n\t\t\tlimit: validated.limit,\n\t\t});\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get pending actions for a specific chat session\n * Used to show approval banners in the AI chat\n */\nexport async function getChatPendingActions(\n\tinput: z.infer<typeof getChatActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = getChatActionsSchema.parse(input);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions for the chat\n\t\tconst actions = await getPendingActionsForChat(companyId, validated.chatId);\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get a specific pending action by ID\n */\nexport async function getPendingActionById(\n\tactionId: string,\n): Promise<ActionResult<PendingAction | null>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = z.string().uuid(\"Invalid action ID\").parse(actionId);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\tconst action = await getPendingAction(companyId, validated);\n\t\treturn action;\n\t});\n}\n\n/**\n * Check if current user is a company owner\n * Used by UI to determine if approval buttons should be enabled\n */\nexport async function checkIsCompanyOwner(): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\t\tconst isOwner = await isCompanyOwner(companyId, userId);\n\t\treturn isOwner;\n\t});\n}\n\n/**\n * Get pending action counts for notifications\n */\nexport async function getPendingActionCounts(): Promise<\n\tActionResult<{\n\t\ttotal: number;\n\t\tbyRiskLevel: Record<string, number>;\n\t}>\n> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: \"pending\",\n\t\t\tlimit: 100,\n\t\t});\n\n\t\t// Group by risk level\n\t\tconst byRiskLevel: Record<string, number> = {\n\t\t\tlow: 0,\n\t\t\tmedium: 0,\n\t\t\thigh: 0,\n\t\t\tcritical: 0,\n\t\t};\n\n\t\tfor (const action of actions) {\n\t\t\tbyRiskLevel[action.riskLevel] = (byRiskLevel[action.riskLevel] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: actions.length,\n\t\t\tbyRiskLevel,\n\t\t};\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAoSsB,sBAAA,WAAA,GAAA,IAAA,sZAAA,EAAA,8CAAA,2YAAA,EAAA,KAAA,GAAA,iZAAA,EAAA"}},
    {"offset": {"line": 5549, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ai/pending-actions-indicator.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tPopover,\n\tPopoverContent,\n\tPopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { Separator } from \"@/components/ui/separator\";\nimport {\n\tShield,\n\tAlertTriangle,\n\tBell,\n\tClock,\n\tMail,\n\tDollarSign,\n\tCalendar,\n\tUser,\n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport {\n\tgetCompanyPendingActions,\n\tcheckIsCompanyOwner,\n\ttype PendingAction,\n} from \"@/actions/ai-approval\";\n\ninterface PendingActionsIndicatorProps {\n\tclassName?: string;\n\tshowPopover?: boolean;\n\tonActionClick?: (action: PendingAction) => void;\n}\n\nconst riskLevelColors = {\n\tlow: \"bg-blue-500\",\n\tmedium: \"bg-yellow-500\",\n\thigh: \"bg-orange-500\",\n\tcritical: \"bg-red-500\",\n};\n\nconst actionTypeIcons: Record<string, typeof Mail> = {\n\tsend_communication: Mail,\n\tfinancial: DollarSign,\n\tscheduling: Calendar,\n\tcustomer: User,\n};\n\nfunction getActionIcon(actionType: string) {\n\treturn actionTypeIcons[actionType] || AlertTriangle;\n}\n\nfunction formatTimeRemaining(expiresAt: string): string {\n\tconst now = new Date();\n\tconst expires = new Date(expiresAt);\n\tconst diff = expires.getTime() - now.getTime();\n\n\tif (diff <= 0) return \"Expired\";\n\n\tconst hours = Math.floor(diff / (1000 * 60 * 60));\n\tconst minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n\n\tif (hours > 0) return `${hours}h ${minutes}m`;\n\treturn `${minutes}m`;\n}\n\nexport function PendingActionsIndicator({\n\tclassName,\n\tshowPopover = true,\n\tonActionClick,\n}: PendingActionsIndicatorProps) {\n\tconst [pendingActions, setPendingActions] = useState<PendingAction[]>([]);\n\tconst [isOwner, setIsOwner] = useState(false);\n\tconst [isLoading, setIsLoading] = useState(true);\n\n\t// Fetch pending actions\n\tuseEffect(() => {\n\t\tconst fetchData = async () => {\n\t\t\tsetIsLoading(true);\n\t\t\ttry {\n\t\t\t\tconst [ownerResult, actionsResult] = await Promise.all([\n\t\t\t\t\tcheckIsCompanyOwner(),\n\t\t\t\t\tgetCompanyPendingActions({ status: \"pending\", limit: 10 }),\n\t\t\t\t]);\n\n\t\t\t\tif (ownerResult.success && ownerResult.data) {\n\t\t\t\t\tsetIsOwner(ownerResult.data);\n\t\t\t\t}\n\n\t\t\t\tif (actionsResult.success && actionsResult.data) {\n\t\t\t\t\tsetPendingActions(actionsResult.data);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Failed to fetch pending actions:\", error);\n\t\t\t} finally {\n\t\t\t\tsetIsLoading(false);\n\t\t\t}\n\t\t};\n\n\t\tfetchData();\n\n\t\t// Poll every 30 seconds\n\t\tconst interval = setInterval(fetchData, 30000);\n\t\treturn () => clearInterval(interval);\n\t}, []);\n\n\t// Don't show if not owner or no pending actions\n\tif (!isOwner || pendingActions.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst criticalCount = pendingActions.filter((a) => a.riskLevel === \"critical\").length;\n\tconst highCount = pendingActions.filter((a) => a.riskLevel === \"high\").length;\n\n\tconst indicatorContent = (\n\t\t<div className={cn(\"relative inline-flex\", className)}>\n\t\t\t<Button\n\t\t\t\tvariant=\"ghost\"\n\t\t\t\tsize=\"icon\"\n\t\t\t\tclassName=\"relative h-9 w-9\"\n\t\t\t>\n\t\t\t\t<Shield className=\"h-5 w-5\" />\n\t\t\t\t<span\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"absolute -top-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full text-[10px] font-bold text-white\",\n\t\t\t\t\t\tcriticalCount > 0\n\t\t\t\t\t\t\t? \"bg-red-500\"\n\t\t\t\t\t\t\t: highCount > 0\n\t\t\t\t\t\t\t\t? \"bg-orange-500\"\n\t\t\t\t\t\t\t\t: \"bg-yellow-500\"\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{pendingActions.length}\n\t\t\t\t</span>\n\t\t\t</Button>\n\t\t</div>\n\t);\n\n\tif (!showPopover) {\n\t\treturn indicatorContent;\n\t}\n\n\treturn (\n\t\t<Popover>\n\t\t\t<PopoverTrigger asChild>{indicatorContent}</PopoverTrigger>\n\t\t\t<PopoverContent className=\"w-80 p-0\" align=\"end\">\n\t\t\t\t<div className=\"flex items-center justify-between p-3 border-b\">\n\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t<Shield className=\"h-4 w-4 text-primary\" />\n\t\t\t\t\t\t<span className=\"font-semibold text-sm\">Pending Approvals</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Badge variant=\"secondary\">{pendingActions.length}</Badge>\n\t\t\t\t</div>\n\n\t\t\t\t<ScrollArea className=\"max-h-[300px]\">\n\t\t\t\t\t<div className=\"divide-y\">\n\t\t\t\t\t\t{pendingActions.map((action) => {\n\t\t\t\t\t\t\tconst ActionIcon = getActionIcon(action.actionType);\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tkey={action.id}\n\t\t\t\t\t\t\t\t\tclassName=\"w-full p-3 text-left hover:bg-muted/50 transition-colors\"\n\t\t\t\t\t\t\t\t\tonClick={() => onActionClick?.(action)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div className=\"flex items-start gap-3\">\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\"rounded-full p-1.5\",\n\t\t\t\t\t\t\t\t\t\t\t\triskLevelColors[action.riskLevel] + \"/10\"\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"h-4 w-4\",\n\t\t\t\t\t\t\t\t\t\t\t\t\triskLevelColors[action.riskLevel].replace(\"bg-\", \"text-\")\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex-1 min-w-0\">\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm font-medium truncate\">\n\t\t\t\t\t\t\t\t\t\t\t\t{action.toolName\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(/([A-Z])/g, \" $1\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(/^./, (s) => s.toUpperCase())}\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground truncate\">\n\t\t\t\t\t\t\t\t\t\t\t\t{action.affectedEntityType.replace(/_/g, \" \")}\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2 mt-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"text-[10px] px-1.5 py-0\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\triskLevelColors[action.riskLevel].replace(\"bg-\", \"border-\"),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\triskLevelColors[action.riskLevel].replace(\"bg-\", \"text-\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{action.riskLevel}\n\t\t\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-1 text-[10px] text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Clock className=\"h-3 w-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t{formatTimeRemaining(action.expiresAt)}\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t</ScrollArea>\n\n\t\t\t\t{pendingActions.length > 0 && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<Separator />\n\t\t\t\t\t\t<div className=\"p-2\">\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\tclassName=\"w-full text-xs\"\n\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t// Navigate to AI settings or pending actions page\n\t\t\t\t\t\t\t\t\twindow.location.href = \"/dashboard/settings/ai\";\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tView All Pending Actions\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t</PopoverContent>\n\t\t</Popover>\n\t);\n}\n\n/**\n * Simple badge indicator for use in navigation items\n */\nexport function PendingActionsBadge({ className }: { className?: string }) {\n\tconst [count, setCount] = useState(0);\n\tconst [isOwner, setIsOwner] = useState(false);\n\n\tuseEffect(() => {\n\t\tconst fetchData = async () => {\n\t\t\ttry {\n\t\t\t\tconst [ownerResult, actionsResult] = await Promise.all([\n\t\t\t\t\tcheckIsCompanyOwner(),\n\t\t\t\t\tgetCompanyPendingActions({ status: \"pending\", limit: 100 }),\n\t\t\t\t]);\n\n\t\t\t\tif (ownerResult.success && ownerResult.data) {\n\t\t\t\t\tsetIsOwner(ownerResult.data);\n\t\t\t\t}\n\n\t\t\t\tif (actionsResult.success && actionsResult.data) {\n\t\t\t\t\tsetCount(actionsResult.data.length);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Failed to fetch pending action count:\", error);\n\t\t\t}\n\t\t};\n\n\t\tfetchData();\n\t\tconst interval = setInterval(fetchData, 30000);\n\t\treturn () => clearInterval(interval);\n\t}, []);\n\n\tif (!isOwner || count === 0) return null;\n\n\treturn (\n\t\t<Badge\n\t\t\tvariant=\"destructive\"\n\t\t\tclassName={cn(\"ml-auto h-5 min-w-5 px-1.5 text-[10px]\", className)}\n\t\t>\n\t\t\t{count}\n\t\t</Badge>\n\t);\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAAA;AAvBA;;;;;;;;;;;AAmCA,MAAM,kBAAkB;IACvB,KAAK;IACL,QAAQ;IACR,MAAM;IACN,UAAU;AACX;AAEA,MAAM,kBAA+C;IACpD,oBAAoB,8RAAI;IACxB,WAAW,oTAAU;IACrB,YAAY,0SAAQ;IACpB,UAAU,8RAAI;AACf;AAEA,SAAS,cAAc,UAAkB;IACxC,OAAO,eAAe,CAAC,WAAW,IAAI,6TAAa;AACpD;AAEA,SAAS,oBAAoB,SAAiB;IAC7C,MAAM,MAAM,IAAI;IAChB,MAAM,UAAU,IAAI,KAAK;IACzB,MAAM,OAAO,QAAQ,OAAO,KAAK,IAAI,OAAO;IAE5C,IAAI,QAAQ,GAAG,OAAO;IAEtB,MAAM,QAAQ,KAAK,KAAK,CAAC,OAAO,CAAC,OAAO,KAAK,EAAE;IAC/C,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,OAAO,CAAC,OAAO,KAAK,EAAE,IAAK,CAAC,OAAO,EAAE;IAEjE,IAAI,QAAQ,GAAG,OAAO,GAAG,MAAM,EAAE,EAAE,QAAQ,CAAC,CAAC;IAC7C,OAAO,GAAG,QAAQ,CAAC,CAAC;AACrB;AAEO,SAAS,wBAAwB,EACvC,SAAS,EACT,cAAc,IAAI,EAClB,aAAa,EACiB;IAC9B,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,wXAAQ,EAAkB,EAAE;IACxE,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,wXAAQ,EAAC;IACvC,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,wXAAQ,EAAC;IAE3C,wBAAwB;IACxB,IAAA,yXAAS,EAAC;QACT,MAAM,YAAY;YACjB,aAAa;YACb,IAAI;gBACH,MAAM,CAAC,aAAa,cAAc,GAAG,MAAM,QAAQ,GAAG,CAAC;oBACtD,IAAA,4LAAmB;oBACnB,IAAA,iMAAwB,EAAC;wBAAE,QAAQ;wBAAW,OAAO;oBAAG;iBACxD;gBAED,IAAI,YAAY,OAAO,IAAI,YAAY,IAAI,EAAE;oBAC5C,WAAW,YAAY,IAAI;gBAC5B;gBAEA,IAAI,cAAc,OAAO,IAAI,cAAc,IAAI,EAAE;oBAChD,kBAAkB,cAAc,IAAI;gBACrC;YACD,EAAE,OAAO,OAAO;gBACf,QAAQ,KAAK,CAAC,oCAAoC;YACnD,SAAU;gBACT,aAAa;YACd;QACD;QAEA;QAEA,wBAAwB;QACxB,MAAM,WAAW,YAAY,WAAW;QACxC,OAAO,IAAM,cAAc;IAC5B,GAAG,EAAE;IAEL,gDAAgD;IAChD,IAAI,CAAC,WAAW,eAAe,MAAM,KAAK,GAAG;QAC5C,OAAO;IACR;IAEA,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAC,IAAM,EAAE,SAAS,KAAK,YAAY,MAAM;IACrF,MAAM,YAAY,eAAe,MAAM,CAAC,CAAC,IAAM,EAAE,SAAS,KAAK,QAAQ,MAAM;IAE7E,MAAM,iCACL,qZAAC;QAAI,WAAW,IAAA,wIAAE,EAAC,wBAAwB;kBAC1C,cAAA,qZAAC,0IAAM;YACN,SAAQ;YACR,MAAK;YACL,WAAU;;8BAEV,qZAAC,oSAAM;oBAAC,WAAU;;;;;;8BAClB,qZAAC;oBACA,WAAW,IAAA,wIAAE,EACZ,mHACA,gBAAgB,IACb,eACA,YAAY,IACX,kBACA;8BAGJ,eAAe,MAAM;;;;;;;;;;;;;;;;;IAM1B,IAAI,CAAC,aAAa;QACjB,OAAO;IACR;IAEA,qBACC,qZAAC,4IAAO;;0BACP,qZAAC,mJAAc;gBAAC,OAAO;0BAAE;;;;;;0BACzB,qZAAC,mJAAc;gBAAC,WAAU;gBAAW,OAAM;;kCAC1C,qZAAC;wBAAI,WAAU;;0CACd,qZAAC;gCAAI,WAAU;;kDACd,qZAAC,oSAAM;wCAAC,WAAU;;;;;;kDAClB,qZAAC;wCAAK,WAAU;kDAAwB;;;;;;;;;;;;0CAEzC,qZAAC,wIAAK;gCAAC,SAAQ;0CAAa,eAAe,MAAM;;;;;;;;;;;;kCAGlD,qZAAC,sJAAU;wBAAC,WAAU;kCACrB,cAAA,qZAAC;4BAAI,WAAU;sCACb,eAAe,GAAG,CAAC,CAAC;gCACpB,MAAM,aAAa,cAAc,OAAO,UAAU;gCAClD,qBACC,qZAAC;oCAEA,WAAU;oCACV,SAAS,IAAM,gBAAgB;8CAE/B,cAAA,qZAAC;wCAAI,WAAU;;0DACd,qZAAC;gDACA,WAAW,IAAA,wIAAE,EACZ,sBACA,eAAe,CAAC,OAAO,SAAS,CAAC,GAAG;0DAGrC,cAAA,qZAAC;oDACA,WAAW,IAAA,wIAAE,EACZ,WACA,eAAe,CAAC,OAAO,SAAS,CAAC,CAAC,OAAO,CAAC,OAAO;;;;;;;;;;;0DAIpD,qZAAC;gDAAI,WAAU;;kEACd,qZAAC;wDAAE,WAAU;kEACX,OAAO,QAAQ,CACd,OAAO,CAAC,YAAY,OACpB,OAAO,CAAC,MAAM,CAAC,IAAM,EAAE,WAAW;;;;;;kEAErC,qZAAC;wDAAE,WAAU;kEACX,OAAO,kBAAkB,CAAC,OAAO,CAAC,MAAM;;;;;;kEAE1C,qZAAC;wDAAI,WAAU;;0EACd,qZAAC,wIAAK;gEACL,SAAQ;gEACR,WAAW,IAAA,wIAAE,EACZ,2BACA,eAAe,CAAC,OAAO,SAAS,CAAC,CAAC,OAAO,CAAC,OAAO,YACjD,eAAe,CAAC,OAAO,SAAS,CAAC,CAAC,OAAO,CAAC,OAAO;0EAGjD,OAAO,SAAS;;;;;;0EAElB,qZAAC;gEAAK,WAAU;;kFACf,qZAAC,iSAAK;wEAAC,WAAU;;;;;;oEAChB,oBAAoB,OAAO,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;mCAxCpC,OAAO,EAAE;;;;;4BA+CjB;;;;;;;;;;;oBAID,eAAe,MAAM,GAAG,mBACxB;;0CACC,qZAAC,gJAAS;;;;;0CACV,qZAAC;gCAAI,WAAU;0CACd,cAAA,qZAAC,0IAAM;oCACN,SAAQ;oCACR,MAAK;oCACL,WAAU;oCACV,SAAS;wCACR,kDAAkD;wCAClD,OAAO,QAAQ,CAAC,IAAI,GAAG;oCACxB;8CACA;;;;;;;;;;;;;;;;;;;;;;;;;AASR;AAKO,SAAS,oBAAoB,EAAE,SAAS,EAA0B;IACxE,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,wXAAQ,EAAC;IACnC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,wXAAQ,EAAC;IAEvC,IAAA,yXAAS,EAAC;QACT,MAAM,YAAY;YACjB,IAAI;gBACH,MAAM,CAAC,aAAa,cAAc,GAAG,MAAM,QAAQ,GAAG,CAAC;oBACtD,IAAA,4LAAmB;oBACnB,IAAA,iMAAwB,EAAC;wBAAE,QAAQ;wBAAW,OAAO;oBAAI;iBACzD;gBAED,IAAI,YAAY,OAAO,IAAI,YAAY,IAAI,EAAE;oBAC5C,WAAW,YAAY,IAAI;gBAC5B;gBAEA,IAAI,cAAc,OAAO,IAAI,cAAc,IAAI,EAAE;oBAChD,SAAS,cAAc,IAAI,CAAC,MAAM;gBACnC;YACD,EAAE,OAAO,OAAO;gBACf,QAAQ,KAAK,CAAC,yCAAyC;YACxD;QACD;QAEA;QACA,MAAM,WAAW,YAAY,WAAW;QACxC,OAAO,IAAM,cAAc;IAC5B,GAAG,EAAE;IAEL,IAAI,CAAC,WAAW,UAAU,GAAG,OAAO;IAEpC,qBACC,qZAAC,wIAAK;QACL,SAAQ;QACR,WAAW,IAAA,wIAAE,EAAC,0CAA0C;kBAEvD;;;;;;AAGJ"}},
    {"offset": {"line": 5936, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/app-header-client.tsx"],"sourcesContent":["\"use client\";\n\nimport { GalleryVerticalEnd, HelpCircle, Tv } from \"lucide-react\";\nimport Image from \"next/image\";\nimport Link from \"next/link\";\nimport { usePathname } from \"next/navigation\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useDialerShortcut } from \"@/hooks/use-dialer-shortcut\";\nimport type { UserProfile } from \"@/lib/auth/user-data\";\nimport { HelpDropdown } from \"./help-dropdown\";\nimport { NotificationsDropdown } from \"./notifications-dropdown\";\nimport { PhoneDropdown } from \"./phone-dropdown\";\nimport { QuickAddDropdown } from \"./quick-add-dropdown\";\nimport { UserMenu } from \"./user-menu\";\nimport { getTotalUnreadCountAction } from \"@/actions/email-actions\";\nimport { PendingActionsIndicator } from \"@/components/ai/pending-actions-indicator\";\n\n/**\n * AppHeaderClient - Client Component (Minimal Interactivity Only)\n *\n * Performance optimizations:\n * - ONLY client-side code (mobile menu state, active nav detection)\n * - NO data fetching (userProfile passed from server component)\n * - NO loading states (data already available)\n * - Smaller JavaScript bundle\n *\n * Client-side features:\n * - Mobile menu open/close state\n * - Active navigation highlighting with usePathname\n * - Click outside to close mobile menu\n */\n\ntype AppHeaderClientProps = {\n\tuserProfile: UserProfile;\n\tcompanies: Array<{\n\t\tid: string;\n\t\tname: string;\n\t\tplan: string;\n\t\tonboardingComplete?: boolean;\n\t\thasPayment?: boolean;\n\t}>;\n\tactiveCompanyId?: string | null;\n\tcompanyPhones?: Array<{\n\t\tid: string;\n\t\tnumber: string;\n\t\tlabel?: string;\n\t}>;\n\thasPhoneNumbers?: boolean;\n\thasPayrixAccount?: boolean;\n\tpayrixStatus?: string | null;\n\tsubHeader?: React.ReactNode;\n};\n\ntype NavItemStatus = \"beta\" | \"new\" | \"updated\" | \"coming-soon\" | null;\n\ntype NavItem = {\n\tlabel: string;\n\thref: string;\n\tstatus?: NavItemStatus;\n\tisSpecial?: boolean; // For Ask Thorbis gradient style\n};\n\ntype NavItemWithMobile = NavItem & {\n\tmobileIcon?: string;\n\tmobileIconBg?: string;\n\tmobileIconColor?: string;\n};\n\nconst navigationItems: NavItemWithMobile[] = [\n\t{\n\t\tlabel: \"Ask Thorbis\",\n\t\thref: \"/dashboard/ai\",\n\t\tstatus: \"beta\",\n\t\tisSpecial: true,\n\t\tmobileIcon: \"AI\",\n\t\tmobileIconBg: \"bg-primary/10\",\n\t\tmobileIconColor: \"text-primary\",\n\t},\n\t{\n\t\tlabel: \"Today\",\n\t\thref: \"/dashboard\",\n\t\tmobileIcon: \"T\",\n\t\tmobileIconBg: \"bg-primary/10\",\n\t\tmobileIconColor: \"text-primary\",\n\t},\n\t{\n\t\tlabel: \"Schedule\",\n\t\thref: \"/dashboard/schedule\",\n\t\tmobileIcon: \"S\",\n\t\tmobileIconBg: \"bg-accent/10\",\n\t\tmobileIconColor: \"text-accent-foreground\",\n\t},\n\t{\n\t\tlabel: \"Communication\",\n\t\thref: \"/dashboard/communication\",\n\t\tmobileIcon: \"C\",\n\t\tmobileIconBg: \"bg-success/10\",\n\t\tmobileIconColor: \"text-success\",\n\t},\n\t{\n\t\tlabel: \"Work\",\n\t\thref: \"/dashboard/work\",\n\t\tstatus: \"beta\",\n\t\tmobileIcon: \"W\",\n\t\tmobileIconBg: \"bg-teal-500/10\",\n\t\tmobileIconColor: \"text-teal-600\",\n\t},\n\t{\n\t\tlabel: \"Finances\",\n\t\thref: \"/dashboard/finance\",\n\t\tstatus: \"coming-soon\",\n\t\tmobileIcon: \"F\",\n\t\tmobileIconBg: \"bg-emerald-500/10\",\n\t\tmobileIconColor: \"text-emerald-600\",\n\t},\n\t{\n\t\tlabel: \"Reporting\",\n\t\thref: \"/dashboard/reporting\",\n\t\tstatus: \"coming-soon\",\n\t\tmobileIcon: \"R\",\n\t\tmobileIconBg: \"bg-primary/10\",\n\t\tmobileIconColor: \"text-primary\",\n\t},\n\t{\n\t\tlabel: \"Marketing\",\n\t\thref: \"/dashboard/marketing\",\n\t\tstatus: \"coming-soon\",\n\t\tmobileIcon: \"M\",\n\t\tmobileIconBg: \"bg-accent/10\",\n\t\tmobileIconColor: \"text-accent-foreground\",\n\t},\n\t{\n\t\tlabel: \"Training\",\n\t\thref: \"/dashboard/training\",\n\t\tstatus: \"coming-soon\",\n\t\tmobileIcon: \"T\",\n\t\tmobileIconBg: \"bg-accent/10\",\n\t\tmobileIconColor: \"text-accent-foreground\",\n\t},\n];\n\n// Default logo for all companies\nconst defaultLogo = GalleryVerticalEnd;\n\nfunction StatusIndicator({ status }: { status?: NavItemStatus }) {\n\tif (!status) {\n\t\treturn null;\n\t}\n\n\t// For beta and coming-soon, show badge\n\tif (status === \"beta\") {\n\t\treturn (\n\t\t\t<span className=\"absolute -top-1.5 right-0 rounded bg-blue-500 px-1 py-0.5 text-[0.5rem] leading-none font-semibold tracking-wide text-white uppercase shadow-sm\">\n\t\t\t\tBeta\n\t\t\t</span>\n\t\t);\n\t}\n\n\tif (status === \"coming-soon\") {\n\t\treturn (\n\t\t\t<span className=\"absolute -top-1.5 right-0 rounded bg-purple-500 px-1 py-0.5 text-[0.5rem] leading-none font-semibold tracking-wide whitespace-nowrap text-white uppercase shadow-sm\">\n\t\t\t\tSoon\n\t\t\t</span>\n\t\t);\n\t}\n\n\t// Badge for \"new\" and \"updated\"\n\tif (status === \"new\") {\n\t\treturn (\n\t\t\t<span className=\"absolute -top-1.5 right-0 rounded bg-green-500 px-1 py-0.5 text-[0.5rem] leading-none font-semibold tracking-wide text-white uppercase shadow-sm\">\n\t\t\t\tNew\n\t\t\t</span>\n\t\t);\n\t}\n\n\treturn (\n\t\t<span\n\t\t\tclassName=\"absolute -top-1 right-0 size-2 rounded-full bg-blue-500 shadow-sm\"\n\t\t\ttitle=\"Updated\"\n\t\t/>\n\t);\n}\n\nfunction MobileStatusBadge({ status }: { status?: NavItemStatus }) {\n\tif (!status) {\n\t\treturn null;\n\t}\n\n\tconst styles = {\n\t\tbeta: \"bg-blue-500 text-white shadow-sm\",\n\t\tnew: \"bg-green-500 text-white shadow-sm\",\n\t\tupdated: \"bg-purple-500 text-white shadow-sm\",\n\t\t\"coming-soon\": \"bg-purple-500 text-white shadow-sm\",\n\t};\n\n\tconst labels = {\n\t\tbeta: \"Beta\",\n\t\tnew: \"New\",\n\t\tupdated: \"Updated\",\n\t\t\"coming-soon\": \"Soon\",\n\t};\n\n\treturn (\n\t\t<span\n\t\t\tclassName={`inline-flex items-center rounded-full px-2 py-0.5 text-[0.65rem] font-semibold tracking-wide uppercase ${styles[status]}`}\n\t\t>\n\t\t\t{labels[status]}\n\t\t</span>\n\t);\n}\n\nfunction formatBadgeCount(count: number): string {\n\tif (count <= 9) {\n\t\treturn count.toString();\n\t}\n\tif (count <= 99) {\n\t\treturn \"99+\";\n\t}\n\tif (count <= 999) {\n\t\treturn \"999+\";\n\t}\n\treturn \"1K+\";\n}\n\nfunction UnreadBadge({ count }: { count: number }) {\n\tif (count === 0) {\n\t\treturn null;\n\t}\n\treturn (\n\t\t<span className=\"absolute -top-1.5 right-0 rounded bg-red-500 px-1 py-0.5 text-[0.5rem] leading-none font-semibold tracking-wide text-white shadow-sm whitespace-nowrap\">\n\t\t\t{formatBadgeCount(count)}\n\t\t</span>\n\t);\n}\n\nexport function AppHeaderClient({\n\tuserProfile,\n\tcompanies,\n\tactiveCompanyId,\n\tcustomers = [],\n\tcompanyPhones = [],\n\thasPhoneNumbers = false,\n\thasPayrixAccount = false,\n\tpayrixStatus = null,\n\tsubHeader: _subHeader, // Ignore the server-passed subHeader\n}: AppHeaderClientProps) {\n\tconst pathname = usePathname();\n\n\t// Hide header completely on TV display route (not settings)\n\t// Check this early to avoid hooks issues\n\tconst isTVRoute = pathname === \"/dashboard/tv\";\n\n\t// Enable global keyboard shortcut for dialer (Ctrl+Shift+D or Cmd+Shift+D)\n\tuseDialerShortcut();\n\n\tconst [unreadCount, setUnreadCount] = useState(0);\n\n\t// Fetch unread count on mount, when pathname changes, and periodically\n\tuseEffect(() => {\n\t\tconst fetchUnreadCount = async () => {\n\t\t\ttry {\n\t\t\t\tconst result = await getTotalUnreadCountAction();\n\t\t\t\tif (result.success && result.count !== undefined) {\n\t\t\t\t\tsetUnreadCount(result.count);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Failed to fetch unread count:\", error);\n\t\t\t}\n\t\t};\n\n\t\t// Fetch immediately\n\t\tfetchUnreadCount();\n\n\t\t// Refresh every 30 seconds\n\t\tconst interval = setInterval(fetchUnreadCount, 30000);\n\n\t\treturn () => clearInterval(interval);\n\t}, [pathname]); // Refresh when pathname changes (e.g., navigating to/from communication page)\n\n\t// Return null for TV route AFTER all hooks have been called\n\tif (isTVRoute) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t<header className=\"safe-top bg-header-bg sticky top-0 z-50 w-full\">\n\t\t\t\t<div className=\"flex h-14 items-center gap-2 px-4 md:px-6\">\n\n\t\t\t\t{/* Logo */}\n\t\t\t\t<Link\n\t\t\t\t\tclassName=\"hover:border-primary/20 hover:bg-primary/10 hover:text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 dark:hover:bg-accent/50 flex shrink-0 items-center justify-center gap-2 rounded-md text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 size-10 md:size-8\"\n\t\t\t\t\tdata-slot=\"button\"\n\t\t\t\t\thref=\"/\"\n\t\t\t\t>\n\t\t\t\t\t<Image\n\t\t\t\t\t\talt=\"Thorbis\"\n\t\t\t\t\t\tclassName=\"size-5\"\n\t\t\t\t\t\theight={20}\n\t\t\t\t\t\tsrc=\"/ThorbisLogo.webp\"\n\t\t\t\t\t\twidth={20}\n\t\t\t\t\t/>\n\t\t\t\t\t<span className=\"sr-only\">Thorbis</span>\n\t\t\t\t</Link>\n\n\t\t\t\t{/* Main Navigation - Desktop only, mobile uses bottom tabs */}\n\t\t\t\t<nav className=\"hidden items-center gap-0.5 ml-2 lg:flex\">\n\t\t\t\t\t{navigationItems.map((item) => {\n\t\t\t\t\t\tconst isActive =\n\t\t\t\t\t\t\titem.href === \"/dashboard\"\n\t\t\t\t\t\t\t\t? pathname === \"/dashboard\"\n\t\t\t\t\t\t\t\t: pathname?.startsWith(item.href);\n\n\t\t\t\t\t\tif (item.isSpecial) {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div className=\"relative\" key={item.href}>\n\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\tclassName={`focus-visible:ring-ring/50 relative inline-flex h-8 shrink-0 items-center justify-center gap-1.5 rounded-md px-3 text-sm font-medium whitespace-nowrap transition-all duration-150 outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 ${\n\t\t\t\t\t\t\t\t\t\t\tisActive\n\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-primary/15 text-primary dark:bg-primary/25 shadow-sm\"\n\t\t\t\t\t\t\t\t\t\t\t\t: \"text-muted-foreground hover:bg-muted/70 hover:text-foreground\"\n\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\tdata-slot=\"button\"\n\t\t\t\t\t\t\t\t\t\thref={item.href}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{item.label}\n\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t\t<StatusIndicator status={item.status} />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div className=\"relative\" key={item.href}>\n\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\tclassName={`focus-visible:ring-ring/50 relative inline-flex h-8 shrink-0 items-center justify-center gap-1.5 rounded-md px-3 text-sm font-medium whitespace-nowrap transition-all duration-150 outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 ${\n\t\t\t\t\t\t\t\t\t\tisActive\n\t\t\t\t\t\t\t\t\t\t\t? \"bg-primary/15 text-primary dark:bg-primary/25 shadow-sm\"\n\t\t\t\t\t\t\t\t\t\t\t: \"text-muted-foreground hover:bg-muted/70 hover:text-foreground\"\n\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\tdata-slot=\"button\"\n\t\t\t\t\t\t\t\t\thref={item.href}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{item.label}\n\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t<StatusIndicator status={item.status} />\n\t\t\t\t\t\t\t\t{item.href === \"/dashboard/communication\" && (\n\t\t\t\t\t\t\t\t\t<UnreadBadge count={unreadCount} />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</nav>\n\n\t\t\t\t{/* Right side controls */}\n\t\t\t\t<div className=\"ml-auto flex items-center gap-2 overflow-visible md:flex-1 md:justify-end\">\n\t\t\t\t\t{/* Quick Add Menu */}\n\t\t\t\t\t<QuickAddDropdown />\n\n\t\t\t\t\t{/* Phone/Calls */}\n\t\t\t\t\t<PhoneDropdown\n\t\t\t\t\t\tcompanyId={activeCompanyId || \"\"}\n\t\t\t\t\t\tcompanyPhones={companyPhones}\n\t\t\t\t\t/>\n\n\t\t\t\t\t{/* TV Display */}\n\t\t\t\t\t<Link href=\"/dashboard/tv\" title=\"TV Display\">\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName=\"hover-gradient hover:border-primary/20 hover:bg-primary/10 hover:text-primary focus-visible:ring-ring/50 flex items-center justify-center rounded-md border border-transparent transition-all outline-none focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 size-10 md:size-8\"\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Tv className=\"size-4\" />\n\t\t\t\t\t\t\t<span className=\"sr-only\">TV Display</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</Link>\n\n\t\t\t\t\t{/* AI Pending Actions (Owner Approval) */}\n\t\t\t\t\t<PendingActionsIndicator />\n\n\t\t\t\t\t{/* Notifications */}\n\t\t\t\t\t<NotificationsDropdown\n\t\t\t\t\t\thasPhoneNumbers={hasPhoneNumbers}\n\t\t\t\t\t\thasPayrixAccount={hasPayrixAccount}\n\t\t\t\t\t\tpayrixStatus={payrixStatus}\n\t\t\t\t\t/>\n\n\t\t\t\t\t{/* Help */}\n\t\t\t\t\t<HelpDropdown />\n\n\t\t\t\t\t{/* User Menu - Data passed from server, no loading state needed */}\n\t\t\t\t\t{/* Deduplicate companies by ID to prevent duplicates */}\n\t\t\t\t\t<UserMenu\n\t\t\t\t\t\tactiveCompanyId={activeCompanyId}\n\t\t\t\t\t\tteams={Array.from(\n\t\t\t\t\t\t\tnew Map(\n\t\t\t\t\t\t\t\tcompanies.map((company) => [\n\t\t\t\t\t\t\t\t\tcompany.id,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tid: company.id,\n\t\t\t\t\t\t\t\t\t\tname: company.name,\n\t\t\t\t\t\t\t\t\t\tlogo: company.logo,\n\t\t\t\t\t\t\t\t\t\tplan: company.plan,\n\t\t\t\t\t\t\t\t\t\tonboardingComplete: company.onboardingComplete,\n\t\t\t\t\t\t\t\t\t\thasPayment: company.hasPayment,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t).values(),\n\t\t\t\t\t\t)}\n\t\t\t\t\t\tuser={{\n\t\t\t\t\t\t\tname: userProfile.name,\n\t\t\t\t\t\t\temail: userProfile.email,\n\t\t\t\t\t\t\tavatar: userProfile.avatar,\n\t\t\t\t\t\t\tstatus: userProfile.status,\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</header>\n\t</>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6393, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/app-header-error-boundary.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * AppHeaderErrorBoundary - Error boundary for AppHeader\n *\n * Catches runtime errors in AppHeader and displays a fallback UI\n * that matches the header design, preventing the entire page from crashing.\n *\n * Features:\n * - Catches all errors in AppHeader component tree\n * - Displays user-friendly error message\n * - Provides retry button to attempt recovery\n * - Logs errors for monitoring\n * - Matches header styling for visual consistency\n */\n\nimport { AlertCircle, RefreshCw } from \"lucide-react\";\nimport { Component, type ReactNode } from \"react\";\nimport { Button } from \"@/components/ui/button\";\n\ntype ErrorBoundaryProps = {\n\tchildren: ReactNode;\n};\n\ntype ErrorBoundaryState = {\n\thasError: boolean;\n\terror: Error | null;\n};\n\nexport class AppHeaderErrorBoundary extends Component<\n\tErrorBoundaryProps,\n\tErrorBoundaryState\n> {\n\tconstructor(props: ErrorBoundaryProps) {\n\t\tsuper(props);\n\t\tthis.state = { hasError: false, error: null };\n\t}\n\n\tstatic getDerivedStateFromError(error: Error): ErrorBoundaryState {\n\t\treturn { hasError: true, error };\n\t}\n\n\tcomponentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n\t\t// Log error to monitoring service (e.g., Sentry)\n\t\tconsole.error(\"AppHeader Error:\", error, errorInfo);\n\t}\n\n\thandleReset = () => {\n\t\tthis.setState({ hasError: false, error: null });\n\t\t// Force page reload to attempt recovery\n\t\twindow.location.reload();\n\t};\n\n\trender() {\n\t\tif (this.state.hasError) {\n\t\t\treturn <HeaderErrorFallback onReset={this.handleReset} />;\n\t\t}\n\n\t\treturn this.props.children;\n\t}\n}\n\n/**\n * HeaderErrorFallback - Error state UI for AppHeader\n *\n * Displays when AppHeader encounters a runtime error.\n * Styled to match the header design for visual consistency.\n */\nfunction HeaderErrorFallback({ onReset }: { onReset: () => void }) {\n\treturn (\n\t\t<header className=\"border-border/40 bg-background/95 supports-[backdrop-filter]:bg-background/60 sticky top-0 z-50 w-full border-b backdrop-blur\">\n\t\t\t<div className=\"flex h-14 items-center justify-between px-4\">\n\t\t\t\t<div className=\"flex items-center gap-3\">\n\t\t\t\t\t<div className=\"bg-destructive/10 flex h-8 w-8 items-center justify-center rounded-md\">\n\t\t\t\t\t\t<AlertCircle className=\"text-destructive h-4 w-4\" aria-hidden=\"true\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"flex flex-col\">\n\t\t\t\t\t\t<span className=\"text-sm font-medium\">\n\t\t\t\t\t\t\tUnable to load header\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs hidden sm:inline\">\n\t\t\t\t\t\t\tAn error occurred while loading the navigation\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\tonClick={onReset}\n\t\t\t\t\tclassName=\"gap-2\"\n\t\t\t\t\taria-label=\"Retry loading header\"\n\t\t\t\t>\n\t\t\t\t\t<RefreshCw className=\"h-3.5 w-3.5\" aria-hidden=\"true\" />\n\t\t\t\t\t<span className=\"hidden sm:inline\">Retry</span>\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</header>\n\t);\n}\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;;;;;;CAYC,GAED;AAAA;AACA;AACA;AAAA;AAlBA;;;;;AA6BO,MAAM,+BAA+B,yXAAS;IAIpD,YAAY,KAAyB,CAAE;QACtC,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;YAAE,UAAU;YAAO,OAAO;QAAK;IAC7C;IAEA,OAAO,yBAAyB,KAAY,EAAsB;QACjE,OAAO;YAAE,UAAU;YAAM;QAAM;IAChC;IAEA,kBAAkB,KAAY,EAAE,SAA0B,EAAE;QAC3D,iDAAiD;QACjD,QAAQ,KAAK,CAAC,oBAAoB,OAAO;IAC1C;IAEA,cAAc;QACb,IAAI,CAAC,QAAQ,CAAC;YAAE,UAAU;YAAO,OAAO;QAAK;QAC7C,wCAAwC;QACxC,OAAO,QAAQ,CAAC,MAAM;IACvB,EAAE;IAEF,SAAS;QACR,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;YACxB,qBAAO,qZAAC;gBAAoB,SAAS,IAAI,CAAC,WAAW;;;;;;QACtD;QAEA,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAC3B;AACD;AAEA;;;;;CAKC,GACD,SAAS,oBAAoB,EAAE,OAAO,EAA2B;IAChE,qBACC,qZAAC;QAAO,WAAU;kBACjB,cAAA,qZAAC;YAAI,WAAU;;8BACd,qZAAC;oBAAI,WAAU;;sCACd,qZAAC;4BAAI,WAAU;sCACd,cAAA,qZAAC,uTAAW;gCAAC,WAAU;gCAA2B,eAAY;;;;;;;;;;;sCAE/D,qZAAC;4BAAI,WAAU;;8CACd,qZAAC;oCAAK,WAAU;8CAAsB;;;;;;8CAGtC,qZAAC;oCAAK,WAAU;8CAAiD;;;;;;;;;;;;;;;;;;8BAMnE,qZAAC,0IAAM;oBACN,SAAQ;oBACR,MAAK;oBACL,SAAS;oBACT,WAAU;oBACV,cAAW;;sCAEX,qZAAC,iTAAS;4BAAC,WAAU;4BAAc,eAAY;;;;;;sCAC/C,qZAAC;4BAAK,WAAU;sCAAmB;;;;;;;;;;;;;;;;;;;;;;;AAKxC"}},
    {"offset": {"line": 6564, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/incoming-call-notification-wrapper.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * Incoming Call Notification Wrapper\n *\n * Performance optimization wrapper that lazy-loads the heavy IncomingCallNotification component.\n *\n * Benefits:\n * - Reduces initial page load by ~700KB+ (component + dependencies)\n * - Only loads when needed (when checking for active calls)\n * - Improves Time to Interactive (TTI) significantly\n * - Does not block initial page render\n *\n * This wrapper checks for active calls and only loads the full component when needed.\n */\n\nimport dynamic from \"next/dynamic\";\nimport { Suspense } from \"react\";\n\n// Lazy load the heavy IncomingCallNotification component\n// Client-only because it uses browser APIs and WebRTC\nconst IncomingCallNotification = dynamic(\n\t() =>\n\t\timport(\"@/components/layout/incoming-call-notification\").then(\n\t\t\t(mod) => mod.IncomingCallNotification,\n\t\t),\n\t{\n\t\tloading: () => null, // No loading UI needed, it's invisible until there's a call\n\t\tssr: false, // Prevent server rendering to avoid hydration mismatches\n\t},\n);\n\n/**\n * Wrapper component that lazy-loads the incoming call notification\n */\nexport function IncomingCallNotificationWrapper() {\n\treturn (\n\t\t<Suspense fallback={null}>\n\t\t\t<IncomingCallNotification />\n\t\t</Suspense>\n\t);\n}\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;;;;;;CAYC,GAED;AACA;;AAjBA;;;;AAmBA,yDAAyD;AACzD,sDAAsD;AACtD,MAAM,2BAA2B,IAAA,iVAAO;;;;;;IAMtC,SAAS,IAAM;IACf,KAAK;;AAOA,SAAS;IACf,qBACC,qZAAC,wXAAQ;QAAC,UAAU;kBACnB,cAAA,qZAAC;;;;;;;;;;AAGJ"}},
    {"offset": {"line": 6617, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/mobile-bottom-tabs.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n\tCalendar,\n\tHome,\n\tMessageSquare,\n\tMoreHorizontal,\n\tBriefcase,\n\tX,\n\tSparkles,\n\tDollarSign,\n\tBarChart3,\n\tMegaphone,\n\tGraduationCap,\n\tSettings,\n\tHelpCircle,\n\tChevronRight,\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { usePathname } from \"next/navigation\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport * as Dialog from \"@radix-ui/react-dialog\";\n\ntype NavItemStatus = \"beta\" | \"new\" | \"updated\" | \"coming-soon\" | null;\n\ntype MoreNavItem = {\n\tlabel: string;\n\thref: string;\n\ticon: React.ElementType;\n\tstatus?: NavItemStatus;\n\ticonBg: string;\n\ticonColor: string;\n\tdescription?: string;\n};\n\nconst moreNavigationItems: MoreNavItem[] = [\n\t{\n\t\tlabel: \"Ask Thorbis\",\n\t\thref: \"/dashboard/ai\",\n\t\ticon: Sparkles,\n\t\tstatus: \"beta\",\n\t\ticonBg: \"bg-primary/10\",\n\t\ticonColor: \"text-primary\",\n\t\tdescription: \"AI-powered assistant\",\n\t},\n\t{\n\t\tlabel: \"Finances\",\n\t\thref: \"/dashboard/finance\",\n\t\ticon: DollarSign,\n\t\tstatus: \"coming-soon\",\n\t\ticonBg: \"bg-emerald-500/10\",\n\t\ticonColor: \"text-emerald-600\",\n\t\tdescription: \"Financial management\",\n\t},\n\t{\n\t\tlabel: \"Reporting\",\n\t\thref: \"/dashboard/reporting\",\n\t\ticon: BarChart3,\n\t\tstatus: \"coming-soon\",\n\t\ticonBg: \"bg-primary/10\",\n\t\ticonColor: \"text-primary\",\n\t\tdescription: \"Analytics and reports\",\n\t},\n\t{\n\t\tlabel: \"Marketing\",\n\t\thref: \"/dashboard/marketing\",\n\t\ticon: Megaphone,\n\t\tstatus: \"coming-soon\",\n\t\ticonBg: \"bg-accent/10\",\n\t\ticonColor: \"text-accent-foreground\",\n\t\tdescription: \"Marketing campaigns\",\n\t},\n\t{\n\t\tlabel: \"Training\",\n\t\thref: \"/dashboard/training\",\n\t\ticon: GraduationCap,\n\t\tstatus: \"coming-soon\",\n\t\ticonBg: \"bg-accent/10\",\n\t\ticonColor: \"text-accent-foreground\",\n\t\tdescription: \"Learning center\",\n\t},\n\t{\n\t\tlabel: \"Settings\",\n\t\thref: \"/dashboard/settings\",\n\t\ticon: Settings,\n\t\ticonBg: \"bg-muted/50\",\n\t\ticonColor: \"text-muted-foreground\",\n\t\tdescription: \"App preferences\",\n\t},\n\t{\n\t\tlabel: \"Help\",\n\t\thref: \"/help\",\n\t\ticon: HelpCircle,\n\t\ticonBg: \"bg-muted/50\",\n\t\ticonColor: \"text-muted-foreground\",\n\t\tdescription: \"Get support\",\n\t},\n];\n\nfunction StatusBadge({ status }: { status?: NavItemStatus }) {\n\tif (!status) {\n\t\treturn null;\n\t}\n\n\tconst styles = {\n\t\tbeta: \"bg-blue-500 text-white\",\n\t\tnew: \"bg-green-500 text-white\",\n\t\tupdated: \"bg-purple-500 text-white\",\n\t\t\"coming-soon\": \"bg-purple-500 text-white\",\n\t};\n\n\tconst labels = {\n\t\tbeta: \"Beta\",\n\t\tnew: \"New\",\n\t\tupdated: \"Updated\",\n\t\t\"coming-soon\": \"Soon\",\n\t};\n\n\treturn (\n\t\t<span\n\t\t\tclassName={`inline-flex items-center rounded-full px-2 py-0.5 text-[0.65rem] font-semibold tracking-wide uppercase ${styles[status]}`}\n\t\t>\n\t\t\t{labels[status]}\n\t\t</span>\n\t);\n}\n\nfunction formatBadgeCount(count: number): string {\n\tif (count <= 9) {\n\t\treturn count.toString();\n\t}\n\tif (count <= 99) {\n\t\treturn \"99+\";\n\t}\n\tif (count <= 999) {\n\t\treturn \"999+\";\n\t}\n\treturn \"1K+\";\n}\n\ntype MobileBottomTabsProps = {\n\tunreadCount?: number;\n};\n\nexport function MobileBottomTabs({ unreadCount = 0 }: MobileBottomTabsProps) {\n\tconst pathname = usePathname();\n\tconst [isMoreOpen, setIsMoreOpen] = useState(false);\n\n\t// Hide bottom tabs on TV route and welcome route\n\tconst isTVRoute = pathname === \"/dashboard/tv\";\n\tconst isWelcomeRoute = pathname === \"/welcome\";\n\n\t// Don't render on TV or welcome routes\n\tif (isTVRoute || isWelcomeRoute) {\n\t\treturn null;\n\t}\n\n\t// Define primary tabs (always visible at bottom)\n\t// Use mobile-optimized dashboard pages for Work and Communication tabs\n\tconst tabs = [\n\t\t{\n\t\t\tlabel: \"Today\",\n\t\t\thref: \"/dashboard\",\n\t\t\ticon: Home,\n\t\t},\n\t\t{\n\t\t\tlabel: \"Messages\",\n\t\t\thref: \"/dashboard/communication/mobile\",\n\t\t\ticon: MessageSquare,\n\t\t\tbadge: unreadCount,\n\t\t},\n\t\t{\n\t\t\tlabel: \"Work\",\n\t\t\thref: \"/dashboard/work/mobile\",\n\t\t\ticon: Briefcase,\n\t\t},\n\t\t{\n\t\t\tlabel: \"Schedule\",\n\t\t\thref: \"/dashboard/schedule\",\n\t\t\ticon: Calendar,\n\t\t},\n\t\t{\n\t\t\tlabel: \"More\",\n\t\t\ticon: MoreHorizontal,\n\t\t\tonClick: () => setIsMoreOpen(true),\n\t\t},\n\t];\n\n\treturn (\n\t\t<>\n\t\t\t{/* Mobile Bottom Tab Bar - iOS/Android style */}\n\t\t\t<nav className=\"safe-bottom bg-background fixed bottom-0 left-0 right-0 z-40 border-t border-border lg:hidden\">\n\t\t\t\t<div className=\"grid h-16 grid-cols-5\">\n\t\t\t\t\t{tabs.map((tab) => {\n\t\t\t\t\t\t// Determine if tab is active\n\t\t\t\t\t\tlet isActive = false;\n\t\t\t\t\t\tif (tab.href) {\n\t\t\t\t\t\t\tif (tab.href === \"/dashboard\") {\n\t\t\t\t\t\t\t\t// Today tab - exact match only\n\t\t\t\t\t\t\t\tisActive = pathname === \"/dashboard\";\n\t\t\t\t\t\t\t} else if (tab.href === \"/dashboard/communication/mobile\") {\n\t\t\t\t\t\t\t\t// Communication tab - match /dashboard/communication/* (including /mobile)\n\t\t\t\t\t\t\t\tisActive = pathname?.startsWith(\"/dashboard/communication\");\n\t\t\t\t\t\t\t} else if (tab.href === \"/dashboard/work/mobile\") {\n\t\t\t\t\t\t\t\t// Work tab - match /dashboard/work/* (including /mobile) or /dashboard/customers\n\t\t\t\t\t\t\t\tisActive =\n\t\t\t\t\t\t\t\t\tpathname?.startsWith(\"/dashboard/work\") ||\n\t\t\t\t\t\t\t\t\tpathname?.startsWith(\"/dashboard/customers\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Other tabs - standard prefix match\n\t\t\t\t\t\t\t\tisActive = pathname?.startsWith(tab.href);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst Icon = tab.icon;\n\n\t\t\t\t\t\t// If tab has onClick (More button), render as button\n\t\t\t\t\t\tif (tab.onClick) {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tclassName={`flex flex-col items-center justify-center gap-1 transition-colors ${\n\t\t\t\t\t\t\t\t\t\tisMoreOpen\n\t\t\t\t\t\t\t\t\t\t\t? \"text-primary\"\n\t\t\t\t\t\t\t\t\t\t\t: \"text-muted-foreground hover:text-foreground active:text-primary\"\n\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\tkey={tab.label}\n\t\t\t\t\t\t\t\t\tonClick={tab.onClick}\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\taria-label=\"Open more menu\"\n\t\t\t\t\t\t\t\t\taria-expanded={isMoreOpen}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t\t\t\t\t<Icon className=\"h-6 w-6\" />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<span className=\"text-[0.65rem] font-medium leading-tight\">{tab.label}</span>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Regular tab with link\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\tclassName={`flex flex-col items-center justify-center gap-1 transition-colors ${\n\t\t\t\t\t\t\t\t\tisActive\n\t\t\t\t\t\t\t\t\t\t? \"text-primary\"\n\t\t\t\t\t\t\t\t\t\t: \"text-muted-foreground hover:text-foreground active:text-primary\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\thref={tab.href!}\n\t\t\t\t\t\t\t\tkey={tab.label}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t\t\t\t<Icon className=\"h-6 w-6\" />\n\t\t\t\t\t\t\t\t\t{typeof tab.badge === 'number' && tab.badge > 0 && (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"absolute top-0 right-0 flex h-2 w-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75\"></span>\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"relative inline-flex rounded-full h-2 w-2 bg-red-500\"></span>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"sr-only\">{tab.badge} unread {tab.badge === 1 ? 'message' : 'messages'}</span>\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t{isActive && (\n\t\t\t\t\t\t\t\t\t\t<div className=\"absolute -bottom-1.5 left-1/2 h-1 w-1 -translate-x-1/2 rounded-full bg-primary\" />\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<span className=\"text-[0.65rem] font-medium leading-tight\">{tab.label}</span>\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</nav>\n\n\t\t\t{/* More Menu - Full Screen Overlay with Dialog (includes focus trap) */}\n\t\t\t<Dialog.Root open={isMoreOpen} onOpenChange={setIsMoreOpen}>\n\t\t\t\t<Dialog.Portal>\n\t\t\t\t\t<Dialog.Overlay className=\"fixed inset-0 z-50 bg-background/95 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 lg:hidden\" />\n\t\t\t\t\t<Dialog.Content className=\"fixed inset-0 z-50 flex flex-col bg-background lg:hidden data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\">\n\t\t\t\t\t\t{/* Header with Close Button */}\n\t\t\t\t\t\t<div className=\"sticky top-0 z-10 bg-background/95 backdrop-blur-sm border-b border-border\">\n\t\t\t\t\t\t\t<div className=\"flex items-center justify-between px-4 h-14\">\n\t\t\t\t\t\t\t\t<Dialog.Title className=\"text-lg font-bold tracking-tight\">\n\t\t\t\t\t\t\t\t\tMore\n\t\t\t\t\t\t\t\t</Dialog.Title>\n\t\t\t\t\t\t\t\t<Dialog.Close\n\t\t\t\t\t\t\t\t\tclassName=\"flex h-10 w-10 items-center justify-center rounded-full hover:bg-accent/80 transition-colors active:scale-95\"\n\t\t\t\t\t\t\t\t\taria-label=\"Close menu\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<X className=\"h-6 w-6\" />\n\t\t\t\t\t\t\t\t</Dialog.Close>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t{/* Scrollable Content */}\n\t\t\t\t\t\t<div className=\"h-[calc(100vh-3.5rem)] overflow-y-auto px-4 py-6\">\n\t\t\t\t\t\t\t<div className=\"space-y-3 pb-safe\">\n\t\t\t\t\t\t\t\t{moreNavigationItems.map((item) => {\n\t\t\t\t\t\t\t\t\tconst isActive = pathname?.startsWith(item.href);\n\t\t\t\t\t\t\t\t\tconst Icon = item.icon;\n\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\t\tclassName={`group flex items-center gap-4 rounded-2xl border-2 p-5 transition-all duration-200 active:scale-[0.98] ${\n\t\t\t\t\t\t\t\t\t\t\t\tisActive\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"border-primary/40 bg-primary/10 text-primary shadow-lg shadow-primary/20\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"border-border bg-card text-card-foreground hover:border-primary/30 hover:bg-primary/5 hover:shadow-md\"\n\t\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\t\thref={item.href}\n\t\t\t\t\t\t\t\t\t\t\tkey={item.href}\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => setIsMoreOpen(false)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={`flex h-14 w-14 shrink-0 items-center justify-center rounded-xl transition-all duration-200 ${item.iconBg} ${\n\t\t\t\t\t\t\t\t\t\t\t\t\tisActive ? \"scale-105\" : \"group-hover:scale-105\"\n\t\t\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t<Icon className={`h-7 w-7 ${item.iconColor}`} />\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex-1 min-w-0\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2 mb-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-semibold text-base\">{item.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{item.status && <StatusBadge status={item.status} />}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t{item.description && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-sm leading-snug\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{item.description}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<ChevronRight\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={`h-5 w-5 text-muted-foreground/50 transition-all ${\n\t\t\t\t\t\t\t\t\t\t\t\t\tisActive ? \"text-primary\" : \"group-hover:translate-x-1\"\n\t\t\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</Dialog.Content>\n\t\t\t\t</Dialog.Portal>\n\t\t\t</Dialog.Root>\n\t\t</>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7111, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/mobile-bottom-tabs-wrapper.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { usePathname } from \"next/navigation\";\nimport { getTotalUnreadCountAction } from \"@/actions/email-actions\";\nimport { MobileBottomTabs } from \"./mobile-bottom-tabs\";\n\n/**\n * MobileBottomTabsWrapper - Client Component\n *\n * Fetches unread count and passes it to MobileBottomTabs.\n * Separate wrapper to keep the main component clean.\n */\nexport function MobileBottomTabsWrapper() {\n\tconst pathname = usePathname();\n\tconst [unreadCount, setUnreadCount] = useState(0);\n\n\t// Fetch unread count on mount, when pathname changes, and periodically\n\tuseEffect(() => {\n\t\tconst fetchUnreadCount = async () => {\n\t\t\ttry {\n\t\t\t\tconst result = await getTotalUnreadCountAction();\n\t\t\t\tif (result.success && result.count !== undefined) {\n\t\t\t\t\tsetUnreadCount(result.count);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Failed to fetch unread count:\", error);\n\t\t\t}\n\t\t};\n\n\t\t// Fetch immediately\n\t\tfetchUnreadCount();\n\n\t\t// Refresh every 30 seconds\n\t\tconst interval = setInterval(fetchUnreadCount, 30000);\n\n\t\treturn () => clearInterval(interval);\n\t}, [pathname]);\n\n\treturn <MobileBottomTabs unreadCount={unreadCount} />;\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAaO,SAAS;IACf,MAAM,WAAW,IAAA,wTAAW;IAC5B,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,wXAAQ,EAAC;IAE/C,uEAAuE;IACvE,IAAA,yXAAS,EAAC;QACT,MAAM,mBAAmB;YACxB,IAAI;gBACH,MAAM,SAAS,MAAM,IAAA,kMAAyB;gBAC9C,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,KAAK,WAAW;oBACjD,eAAe,OAAO,KAAK;gBAC5B;YACD,EAAE,OAAO,OAAO;gBACf,QAAQ,KAAK,CAAC,iCAAiC;YAChD;QACD;QAEA,oBAAoB;QACpB;QAEA,2BAA2B;QAC3B,MAAM,WAAW,YAAY,kBAAkB;QAE/C,OAAO,IAAM,cAAc;IAC5B,GAAG;QAAC;KAAS;IAEb,qBAAO,qZAAC,2LAAgB;QAAC,aAAa;;;;;;AACvC"}},
    {"offset": {"line": 7161, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/stores/communication-notifications-store.ts"],"sourcesContent":["/**\n * Communication Notifications Store - Zustand State Management\n *\n * Handles real-time toast notifications for:\n * - Phone calls (incoming, missed, completed)\n * - Voicemails (new messages)\n * - Text messages/SMS (incoming)\n * - Emails (incoming)\n *\n * Performance optimizations:\n * - Lightweight state management with Zustand\n * - Automatic toast display on new communications\n * - Integrated with existing notifications system\n * - Sound and desktop notification support\n */\n\nimport { toast } from \"sonner\";\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport {\n\tCOMMUNICATION_MARK_AS_READ_EVENT,\n\ttype CommunicationMarkAsReadDetail,\n} from \"./notification-events\";\nimport type { Notification } from \"./notifications-types\";\n\n// =====================================================================================\n// Types\n// =====================================================================================\n\nexport type CommunicationType = \"call\" | \"sms\" | \"email\" | \"voicemail\";\n\nexport type CommunicationToastOptions = {\n\tid?: string;\n\tduration?: number;\n\tcloseButton?: boolean;\n\tdismissible?: boolean;\n\taction?: {\n\t\tlabel: string;\n\t\tonClick: () => void;\n\t};\n};\n\ntype CommunicationNotificationsState = {\n\t// State\n\ttoastQueue: string[]; // Track active toast IDs\n\tsoundEnabled: boolean;\n\tdesktopNotificationsEnabled: boolean;\n\ttoastDuration: number;\n\n\t// Actions\n\tshowCommunicationToast: (\n\t\tnotification: Notification,\n\t\toptions?: CommunicationToastOptions,\n\t) => string | number;\n\tshowCallToast: (\n\t\tcustomerName: string,\n\t\tphoneNumber: string,\n\t\tstatus: \"incoming\" | \"missed\" | \"completed\",\n\t\tmetadata?: Record<string, any>,\n\t) => void;\n\tshowVoicemailToast: (\n\t\tcustomerName: string,\n\t\tphoneNumber: string,\n\t\tduration?: number,\n\t) => void;\n\tshowSMSToast: (\n\t\tcustomerName: string,\n\t\tphoneNumber: string,\n\t\tmessage: string,\n\t) => void;\n\tshowEmailToast: (\n\t\tcustomerName: string,\n\t\tfromAddress: string,\n\t\tsubject: string,\n\t) => void;\n\tdismissToast: (id: string | number) => void;\n\tdismissAllToasts: () => void;\n\n\t// Settings\n\tsetSoundEnabled: (enabled: boolean) => void;\n\tsetDesktopNotificationsEnabled: (enabled: boolean) => void;\n\tsetToastDuration: (duration: number) => void;\n\n\t// Utility\n\tplayNotificationSound: () => void;\n\trequestDesktopNotificationPermission: () => Promise<boolean>;\n\tshowDesktopNotification: (\n\t\ttitle: string,\n\t\tbody: string,\n\t\tdata?: Record<string, any>,\n\t) => void;\n};\n\n// Initial state (load from localStorage if available)\nconst loadSettings = () => {\n\tif (typeof window === \"undefined\") {\n\t\treturn {\n\t\t\tsoundEnabled: true,\n\t\t\tdesktopNotificationsEnabled: true,\n\t\t\ttoastDuration: 5000,\n\t\t};\n\t}\n\n\treturn {\n\t\tsoundEnabled:\n\t\t\tlocalStorage.getItem(\"communication_sound_enabled\") !== \"false\",\n\t\tdesktopNotificationsEnabled:\n\t\t\tlocalStorage.getItem(\"communication_desktop_enabled\") !== \"false\",\n\t\ttoastDuration: Number.parseInt(\n\t\t\tlocalStorage.getItem(\"communication_toast_duration\") || \"5000\",\n\t\t\t10,\n\t\t),\n\t};\n};\n\n// =====================================================================================\n// Zustand Store\n// =====================================================================================\n\nexport const useCommunicationNotificationsStore =\n\tcreate<CommunicationNotificationsState>()(\n\t\tdevtools(\n\t\t\t(set, get) => ({\n\t\t\t\t...loadSettings(),\n\t\t\t\ttoastQueue: [],\n\n\t\t\t\t// ===============================================================================\n\t\t\t\t// Toast Display\n\t\t\t\t// ===============================================================================\n\n\t\t\t\tshowCommunicationToast: (notification, options = {}) => {\n\t\t\t\t\tconst { metadata } = notification;\n\t\t\t\t\tconst communicationType = metadata?.communication_type as\n\t\t\t\t\t\t| CommunicationType\n\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\t// Determine toast appearance based on communication type\n\t\t\t\t\tlet icon = \"\"; // Default\n\t\t\t\t\tlet _toastType: \"info\" | \"success\" | \"error\" = \"info\";\n\n\t\t\t\t\tswitch (communicationType) {\n\t\t\t\t\t\tcase \"call\":\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tif (notification.priority === \"high\") {\n\t\t\t\t\t\t\t\ticon = \"\"; // Missed call\n\t\t\t\t\t\t\t\t_toastType = \"error\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"sms\":\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"email\":\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"voicemail\":\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tif (notification.priority === \"urgent\") {\n\t\t\t\t\t\t\t\t_toastType = \"error\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Play sound if enabled\n\t\t\t\t\tconst { soundEnabled } = get();\n\t\t\t\t\tif (soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Show desktop notification if enabled\n\t\t\t\t\tconst { desktopNotificationsEnabled } = get();\n\t\t\t\t\tif (desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(\n\t\t\t\t\t\t\tnotification.title,\n\t\t\t\t\t\t\tnotification.message,\n\t\t\t\t\t\t\tmetadata ?? undefined,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create toast with custom styling\n\t\t\t\t\tconst toastId = toast(notification.title, {\n\t\t\t\t\t\tdescription: notification.message,\n\t\t\t\t\t\tduration: options.duration || get().toastDuration,\n\t\t\t\t\t\ticon,\n\t\t\t\t\t\tcloseButton: options.closeButton ?? true,\n\t\t\t\t\t\tdismissible: options.dismissible ?? true,\n\t\t\t\t\t\taction: notification.action_url\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tlabel: notification.action_label || \"View\",\n\t\t\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\t\t\t\t\t\tconst detail: CommunicationMarkAsReadDetail = {\n\t\t\t\t\t\t\t\t\t\t\t\tnotificationId: notification.id,\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\t\t\t\t\t\t\t\tnew CustomEvent(COMMUNICATION_MARK_AS_READ_EVENT, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdetail,\n\t\t\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (notification.action_url) {\n\t\t\t\t\t\t\t\t\t\t\twindow.location.href = notification.action_url;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: options.action,\n\t\t\t\t\t\tclassName:\n\t\t\t\t\t\t\tnotification.priority === \"urgent\"\n\t\t\t\t\t\t\t\t? \"border-destructive bg-destructive/10\"\n\t\t\t\t\t\t\t\t: \"\",\n\t\t\t\t\t});\n\n\t\t\t\t\t// Track toast ID\n\t\t\t\t\tset((state) => ({\n\t\t\t\t\t\ttoastQueue: [...state.toastQueue, String(toastId)],\n\t\t\t\t\t}));\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowCallToast: (customerName, phoneNumber, status, metadata = {}) => {\n\t\t\t\t\tlet title = \"\";\n\t\t\t\t\tlet message = \"\";\n\t\t\t\t\tlet _priority: \"low\" | \"medium\" | \"high\" = \"medium\";\n\t\t\t\t\tlet icon = \"\";\n\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase \"incoming\":\n\t\t\t\t\t\t\ttitle = `Incoming call from ${customerName}`;\n\t\t\t\t\t\t\tmessage = phoneNumber;\n\t\t\t\t\t\t\t_priority = \"high\";\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"missed\":\n\t\t\t\t\t\t\ttitle = `Missed call from ${customerName}`;\n\t\t\t\t\t\t\tmessage = phoneNumber;\n\t\t\t\t\t\t\t_priority = \"high\";\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"completed\":\n\t\t\t\t\t\t\ttitle = `Call with ${customerName}`;\n\t\t\t\t\t\t\tmessage = `Duration: ${metadata.duration || \"Unknown\"}`;\n\t\t\t\t\t\t\t_priority = \"low\";\n\t\t\t\t\t\t\ticon = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: message,\n\t\t\t\t\t\ticon,\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"View\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=calls\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclassName: status === \"missed\" ? \"border-destructive\" : \"\",\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, message, {\n\t\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t\t...metadata,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowVoicemailToast: (customerName, phoneNumber, duration) => {\n\t\t\t\t\tconst title = `New voicemail from ${customerName}`;\n\t\t\t\t\tconst message = duration\n\t\t\t\t\t\t? `${phoneNumber}  ${duration}s`\n\t\t\t\t\t\t: phoneNumber;\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: message,\n\t\t\t\t\t\ticon: \"\",\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"Listen\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=voicemails\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, message, {\n\t\t\t\t\t\t\ttype: \"voicemail\",\n\t\t\t\t\t\t\tduration,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowSMSToast: (customerName, phoneNumber, message) => {\n\t\t\t\t\tconst title = `Text from ${customerName}`;\n\t\t\t\t\tconst preview =\n\t\t\t\t\t\tmessage.length > 100 ? `${message.substring(0, 100)}...` : message;\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: preview,\n\t\t\t\t\t\ticon: \"\",\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"Reply\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=sms\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, preview, {\n\t\t\t\t\t\t\ttype: \"sms\",\n\t\t\t\t\t\t\tfrom: phoneNumber,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tshowEmailToast: (customerName, fromAddress, subject) => {\n\t\t\t\t\tconst title = `Email from ${customerName}`;\n\t\t\t\t\tconst message = subject || \"No subject\";\n\n\t\t\t\t\tconst toastId = toast(title, {\n\t\t\t\t\t\tdescription: message,\n\t\t\t\t\t\ticon: \"\",\n\t\t\t\t\t\tduration: get().toastDuration,\n\t\t\t\t\t\tcloseButton: true,\n\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\tlabel: \"View\",\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\twindow.location.href =\n\t\t\t\t\t\t\t\t\t\"/dashboard/customers/communication?filter=emails\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (get().soundEnabled) {\n\t\t\t\t\t\tget().playNotificationSound();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (get().desktopNotificationsEnabled) {\n\t\t\t\t\t\tget().showDesktopNotification(title, message, {\n\t\t\t\t\t\t\ttype: \"email\",\n\t\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn toastId;\n\t\t\t\t},\n\n\t\t\t\tdismissToast: (id) => {\n\t\t\t\t\ttoast.dismiss(id);\n\t\t\t\t\tset((state) => ({\n\t\t\t\t\t\ttoastQueue: state.toastQueue.filter(\n\t\t\t\t\t\t\t(toastId) => toastId !== String(id),\n\t\t\t\t\t\t),\n\t\t\t\t\t}));\n\t\t\t\t},\n\n\t\t\t\tdismissAllToasts: () => {\n\t\t\t\t\ttoast.dismiss();\n\t\t\t\t\tset({ toastQueue: [] });\n\t\t\t\t},\n\n\t\t\t\t// ===============================================================================\n\t\t\t\t// Settings\n\t\t\t\t// ===============================================================================\n\n\t\t\t\tsetSoundEnabled: (enabled) => {\n\t\t\t\t\tset({ soundEnabled: enabled });\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t\t\"communication_sound_enabled\",\n\t\t\t\t\t\t\tenabled.toString(),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetDesktopNotificationsEnabled: (enabled) => {\n\t\t\t\t\tset({ desktopNotificationsEnabled: enabled });\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t\t\"communication_desktop_enabled\",\n\t\t\t\t\t\t\tenabled.toString(),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Request permission if enabling\n\t\t\t\t\tif (enabled) {\n\t\t\t\t\t\tget().requestDesktopNotificationPermission();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetToastDuration: (duration) => {\n\t\t\t\t\tset({ toastDuration: duration });\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t\t\"communication_toast_duration\",\n\t\t\t\t\t\t\tduration.toString(),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// ===============================================================================\n\t\t\t\t// Utility\n\t\t\t\t// ===============================================================================\n\n\t\t\t\tplayNotificationSound: () => {\n\t\t\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Create audio element for notification sound\n\t\t\t\t\t\tconst audio = new Audio(\"/sounds/notification.mp3\");\n\t\t\t\t\t\taudio.volume = 0.4;\n\t\t\t\t\t\taudio.play().catch((_error) => {});\n\t\t\t\t\t} catch (_error) {}\n\t\t\t\t},\n\n\t\t\t\trequestDesktopNotificationPermission: async () => {\n\t\t\t\t\tif (typeof window === \"undefined\" || !(\"Notification\" in window)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission === \"granted\") {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission !== \"denied\") {\n\t\t\t\t\t\tconst permission = await Notification.requestPermission();\n\t\t\t\t\t\treturn permission === \"granted\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\tshowDesktopNotification: (title, body, data = {}) => {\n\t\t\t\t\tif (typeof window === \"undefined\" || !(\"Notification\" in window)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Notification.permission !== \"granted\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst notification = new Notification(title, {\n\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t\ticon: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\tbadge: \"/icon-192x192.svg\",\n\t\t\t\t\t\t\ttag: `communication-${data.type || \"general\"}`,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\trequireInteraction:\n\t\t\t\t\t\t\t\tdata.type === \"call\" && data.status === \"incoming\",\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Handle notification click\n\t\t\t\t\t\tnotification.onclick = () => {\n\t\t\t\t\t\t\twindow.focus();\n\t\t\t\t\t\t\tif (data.action_url) {\n\t\t\t\t\t\t\t\twindow.location.href = data.action_url;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnotification.close();\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (_error) {}\n\t\t\t\t},\n\t\t\t}),\n\t\t\t{ name: \"CommunicationNotificationsStore\" },\n\t\t),\n\t);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7468, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/layout/notifications-initializer.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * NotificationsInitializer\n *\n * Ensures realtime notifications and desktop permissions are ready globally.\n * - Subscribes to the notifications store as soon as the dashboard mounts\n * - Requests desktop notification permission once per browser\n * - Keeps communication toasts (SMS, calls, voicemail) in sync with desktop alerts\n */\n\nimport { useEffect, useRef } from \"react\";\nimport { useCommunicationNotificationsStore } from \"@/lib/stores/communication-notifications-store\";\nimport { useNotificationsStore } from \"@/lib/stores/notifications-store\";\nimport { createClient } from \"@/lib/supabase/client\";\n\nconst DESKTOP_PROMPT_KEY = \"communication_desktop_prompted\";\n\nexport function NotificationsInitializer() {\n\tconst subscribe = useNotificationsStore((state) => state.subscribe);\n\tconst unsubscribe = useNotificationsStore((state) => state.unsubscribe);\n\n\tconst requestDesktopPermission = useCommunicationNotificationsStore(\n\t\t(state) => state.requestDesktopNotificationPermission,\n\t);\n\tconst desktopNotificationsEnabled = useCommunicationNotificationsStore(\n\t\t(state) => state.desktopNotificationsEnabled,\n\t);\n\tconst setDesktopNotificationsEnabled = useCommunicationNotificationsStore(\n\t\t(state) => state.setDesktopNotificationsEnabled,\n\t);\n\n\tconst hasSubscribedRef = useRef(false);\n\n\t// Start realtime notifications subscription immediately\n\tuseEffect(() => {\n\t\tif (hasSubscribedRef.current) {\n\t\t\treturn;\n\t\t}\n\t\thasSubscribedRef.current = true;\n\n\t\tlet cancelled = false;\n\t\tconst supabase = createClient();\n\n\t\t(async () => {\n\t\t\tif (!supabase) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tdata: { user },\n\t\t\t} = await supabase.auth.getUser();\n\n\t\t\tif (!user || cancelled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait subscribe(user.id);\n\t\t})();\n\n\t\treturn () => {\n\t\t\tcancelled = true;\n\t\t\tunsubscribe();\n\t\t};\n\t}, [subscribe, unsubscribe]);\n\n\t// Ask for desktop notification permission once\n\tuseEffect(() => {\n\t\tif (typeof window === \"undefined\" || !(\"Notification\" in window)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst alreadyPrompted =\n\t\t\twindow.localStorage.getItem(DESKTOP_PROMPT_KEY) === \"true\";\n\n\t\tconst finalizePrompt = (granted: boolean) => {\n\t\t\twindow.localStorage.setItem(DESKTOP_PROMPT_KEY, \"true\");\n\t\t\tif (!granted && desktopNotificationsEnabled) {\n\t\t\t\tsetDesktopNotificationsEnabled(false);\n\t\t\t}\n\t\t};\n\n\t\t// Permission already decided\n\t\tif (Notification.permission === \"granted\") {\n\t\t\tif (!alreadyPrompted) {\n\t\t\t\twindow.localStorage.setItem(DESKTOP_PROMPT_KEY, \"true\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (Notification.permission === \"denied\") {\n\t\t\tif (!alreadyPrompted) {\n\t\t\t\twindow.localStorage.setItem(DESKTOP_PROMPT_KEY, \"true\");\n\t\t\t}\n\t\t\tif (desktopNotificationsEnabled) {\n\t\t\t\tsetDesktopNotificationsEnabled(false);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Only prompt once while permission is \"default\"\n\t\tif (alreadyPrompted) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst timer = window.setTimeout(() => {\n\t\t\trequestDesktopPermission()\n\t\t\t\t.then((granted) => finalizePrompt(granted))\n\t\t\t\t.catch(() => finalizePrompt(false));\n\t\t}, 1500);\n\n\t\treturn () => window.clearTimeout(timer);\n\t}, [\n\t\tdesktopNotificationsEnabled,\n\t\trequestDesktopPermission,\n\t\tsetDesktopNotificationsEnabled,\n\t]);\n\n\treturn null;\n}\n"],"names":[],"mappings":";;;;AAEA;;;;;;;CAOC,GAED;AACA;AACA;AACA;AAdA;;;;;AAgBA,MAAM,qBAAqB;AAEpB,SAAS;IACf,MAAM,YAAY,IAAA,sLAAqB,EAAC,CAAC,QAAU,MAAM,SAAS;IAClE,MAAM,cAAc,IAAA,sLAAqB,EAAC,CAAC,QAAU,MAAM,WAAW;IAEtE,MAAM,2BAA2B,IAAA,oNAAkC,EAClE,CAAC,QAAU,MAAM,oCAAoC;IAEtD,MAAM,8BAA8B,IAAA,oNAAkC,EACrE,CAAC,QAAU,MAAM,2BAA2B;IAE7C,MAAM,iCAAiC,IAAA,oNAAkC,EACxE,CAAC,QAAU,MAAM,8BAA8B;IAGhD,MAAM,mBAAmB,IAAA,sXAAM,EAAC;IAEhC,wDAAwD;IACxD,IAAA,yXAAS,EAAC;QACT,IAAI,iBAAiB,OAAO,EAAE;YAC7B;QACD;QACA,iBAAiB,OAAO,GAAG;QAE3B,IAAI,YAAY;QAChB,MAAM,WAAW,IAAA,qJAAY;QAE7B,CAAC;YACA,IAAI,CAAC,UAAU;gBACd;YACD;YAEA,MAAM,EACL,MAAM,EAAE,IAAI,EAAE,EACd,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;YAE/B,IAAI,CAAC,QAAQ,WAAW;gBACvB;YACD;YAEA,MAAM,UAAU,KAAK,EAAE;QACxB,CAAC;QAED,OAAO;YACN,YAAY;YACZ;QACD;IACD,GAAG;QAAC;QAAW;KAAY;IAE3B,+CAA+C;IAC/C,IAAA,yXAAS,EAAC;QACT,IAAI,kDAAkB,eAAe,CAAC,CAAC,kBAAkB,MAAM,GAAG;YACjE;QACD;;;QAEA,MAAM;QAGN,MAAM;QA8BN,MAAM;IAOP,GAAG;QACF;QACA;QACA;KACA;IAED,OAAO;AACR"}}]
}