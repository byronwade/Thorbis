{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA+VsB,oBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA6GsB,oBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAsWsB,mBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAyPsB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA2VsB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/shadcn-io/kanban/index.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n\tclosestCorners,\n\tDndContext,\n\ttype DragEndEvent,\n\tDragOverlay,\n\ttype DragStartEvent,\n\tKeyboardSensor,\n\tPointerSensor,\n\ttype PointerSensorOptions,\n\ttype UniqueIdentifier,\n\tuseDroppable,\n\tuseSensor,\n\tuseSensors,\n} from \"@dnd-kit/core\";\nimport {\n\tSortableContext,\n\tsortableKeyboardCoordinates,\n\tuseSortable,\n\tverticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport type { ReactNode } from \"react\";\nimport {\n\tcreateContext,\n\tuseCallback,\n\tuseContext,\n\tuseEffect,\n\tuseMemo,\n\tuseRef,\n\tuseState,\n} from \"react\";\nimport { Card, ScrollArea, cn } from \"@stratos/ui\";\n\nexport type KanbanColumn = {\n\tid: string;\n\tname: string;\n\taccentColor?: string;\n};\n\nexport type KanbanItemBase = {\n\tid: string;\n\tcolumnId: string;\n\tposition?: number;\n};\n\nexport type KanbanMoveEvent<T extends KanbanItemBase> = {\n\titem: T;\n\tfromColumnId: string;\n\ttoColumnId: string;\n\ttoIndex: number;\n};\n\ntype KanbanProviderProps<T extends KanbanItemBase> = {\n\tcolumns: KanbanColumn[];\n\tdata: T[];\n\tonDataChange?: (items: T[]) => void;\n\tonItemMove?: (event: KanbanMoveEvent<T>) => void | Promise<void>;\n\tgetColumnId?: (item: T) => string;\n\tchildren: ReactNode;\n\tclassName?: string;\n\tpointerSensorOptions?: PointerSensorOptions;\n\trenderDragOverlay?: (item: T) => ReactNode;\n};\n\ntype KanbanContextValue<T extends KanbanItemBase> = {\n\tcolumns: KanbanColumn[];\n\tgetItems: (columnId: string) => T[];\n\tfindItem: (\n\t\tid: UniqueIdentifier,\n\t) => { item: T; columnId: string; index: number } | null;\n\tactiveItem: { item: T; columnId: string } | null;\n};\n\nconst KanbanContext = createContext<KanbanContextValue<KanbanItemBase> | null>(\n\tnull,\n);\n\nconst KanbanColumnContext = createContext<KanbanColumn | null>(null);\n\nconst COLUMN_DROPPABLE_PREFIX = \"kanban-column-\";\n\nfunction buildState<T extends KanbanItemBase>(\n\tcolumns: KanbanColumn[],\n\tdata: T[],\n\tgetColumnId: (item: T) => string,\n) {\n\tconst initialState = Object.fromEntries(\n\t\tcolumns.map((column) => [column.id, [] as T[]]),\n\t);\n\n\treturn data.reduce<Record<string, T[]>>((state, item) => {\n\t\tconst columnId = getColumnId(item);\n\t\tif (!state[columnId]) {\n\t\t\tstate[columnId] = [];\n\t\t}\n\n\t\tstate[columnId] = [...state[columnId], item];\n\t\treturn state;\n\t}, initialState);\n}\n\nfunction flattenState<T extends KanbanItemBase>(\n\tcolumns: KanbanColumn[],\n\tstate: Record<string, T[]>,\n) {\n\treturn columns.flatMap((column) => state[column.id] ?? []);\n}\n\nfunction cloneState<T extends KanbanItemBase>(\n\tstate: Record<string, T[]>,\n): Record<string, T[]> {\n\treturn Object.fromEntries(\n\t\tObject.entries(state).map(([columnId, items]) => [columnId, items.slice()]),\n\t);\n}\n\nexport function KanbanProvider<T extends KanbanItemBase>({\n\tcolumns,\n\tdata,\n\tonDataChange,\n\tonItemMove,\n\tgetColumnId,\n\tchildren,\n\tclassName,\n\tpointerSensorOptions,\n\trenderDragOverlay,\n}: KanbanProviderProps<T>) {\n\tconst columnIdGetter = useCallback(\n\t\tgetColumnId ?? ((item: T) => item.columnId),\n\t\t[],\n\t);\n\tconst [itemsByColumn, setItemsByColumn] = useState<Record<string, T[]>>(() =>\n\t\tbuildState(columns, data, columnIdGetter),\n\t);\n\tconst [activeItem, setActiveItem] = useState<{\n\t\titem: T;\n\t\tcolumnId: string;\n\t} | null>(null);\n\tconst latestColumnsRef = useRef(columns);\n\n\tuseEffect(() => {\n\t\tlatestColumnsRef.current = columns;\n\t}, [columns]);\n\n\tuseEffect(() => {\n\t\tsetItemsByColumn(buildState(columns, data, columnIdGetter));\n\t}, [columns, data, columnIdGetter]);\n\n\tconst sensors = useSensors(\n\t\tuseSensor(PointerSensor, {\n\t\t\tactivationConstraint: {\n\t\t\t\tdistance: 6,\n\t\t\t},\n\t\t\t...pointerSensorOptions,\n\t\t}),\n\t\tuseSensor(KeyboardSensor, {\n\t\t\tcoordinateGetter: sortableKeyboardCoordinates,\n\t\t}),\n\t);\n\n\tconst findItem = useCallback(\n\t\t(id: UniqueIdentifier) => {\n\t\t\tfor (const column of latestColumnsRef.current) {\n\t\t\t\tconst items = itemsByColumn[column.id] ?? [];\n\t\t\t\tconst index = items.findIndex((item) => item.id === id);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\treturn { columnId: column.id, item: items[index], index };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\t[itemsByColumn],\n\t);\n\n\tconst handleDragStart = useCallback(\n\t\t(event: DragStartEvent) => {\n\t\t\tconst result = findItem(event.active.id);\n\t\t\tif (result) {\n\t\t\t\tsetActiveItem({ item: result.item, columnId: result.columnId });\n\t\t\t}\n\t\t},\n\t\t[findItem],\n\t);\n\n\tconst handleDragEnd = useCallback(\n\t\t(event: DragEndEvent) => {\n\t\t\tconst { active, over } = event;\n\t\t\tsetActiveItem(null);\n\n\t\t\tif (!over) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst origin = findItem(active.id);\n\t\t\tif (!origin) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet destinationColumnId: string | null = null;\n\t\t\tlet destinationIndex: number | null = null;\n\n\t\t\tif (\n\t\t\t\ttypeof over.id === \"string\" &&\n\t\t\t\tover.id.startsWith(COLUMN_DROPPABLE_PREFIX)\n\t\t\t) {\n\t\t\t\tdestinationColumnId = over.id.replace(COLUMN_DROPPABLE_PREFIX, \"\");\n\t\t\t\tdestinationIndex = (itemsByColumn[destinationColumnId] ?? []).length;\n\t\t\t} else {\n\t\t\t\tconst destination = findItem(over.id);\n\t\t\t\tif (destination) {\n\t\t\t\t\tdestinationColumnId = destination.columnId;\n\t\t\t\t\tconst columnItems = itemsByColumn[destination.columnId] ?? [];\n\t\t\t\t\tdestinationIndex = columnItems.findIndex(\n\t\t\t\t\t\t(item) => item.id === destination.item.id,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tdestinationColumnId === null ||\n\t\t\t\tdestinationIndex === null ||\n\t\t\t\t(destinationColumnId === origin.columnId &&\n\t\t\t\t\tdestinationIndex === origin.index)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst updatedState = cloneState(itemsByColumn);\n\t\t\tconst originItems = updatedState[origin.columnId] ?? [];\n\t\t\tconst [movedItem] = originItems.splice(origin.index, 1);\n\t\t\tupdatedState[origin.columnId] = originItems;\n\n\t\t\tconst destinationItems = updatedState[destinationColumnId] ?? [];\n\t\t\tconst insertIndex =\n\t\t\t\torigin.columnId === destinationColumnId &&\n\t\t\t\torigin.index < destinationIndex\n\t\t\t\t\t? destinationIndex - 1\n\t\t\t\t\t: destinationIndex;\n\n\t\t\tconst updatedItem = {\n\t\t\t\t...movedItem,\n\t\t\t\tcolumnId: destinationColumnId,\n\t\t\t};\n\n\t\t\tdestinationItems.splice(insertIndex, 0, updatedItem);\n\t\t\tupdatedState[destinationColumnId] = destinationItems;\n\n\t\t\tsetItemsByColumn(updatedState);\n\n\t\t\tconst flattened = flattenState(latestColumnsRef.current, updatedState);\n\t\t\tonDataChange?.(flattened);\n\n\t\t\tif (onItemMove) {\n\t\t\t\tonItemMove({\n\t\t\t\t\titem: updatedItem,\n\t\t\t\t\tfromColumnId: origin.columnId,\n\t\t\t\t\ttoColumnId: destinationColumnId,\n\t\t\t\t\ttoIndex: insertIndex,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[findItem, itemsByColumn, onDataChange, onItemMove],\n\t);\n\n\tconst contextValue = useMemo<KanbanContextValue<T>>(\n\t\t() => ({\n\t\t\tcolumns,\n\t\t\tgetItems: (columnId: string) => itemsByColumn[columnId] ?? [],\n\t\t\tfindItem,\n\t\t\tactiveItem,\n\t\t}),\n\t\t[columns, itemsByColumn, findItem, activeItem],\n\t);\n\n\treturn (\n\t\t<KanbanContext.Provider\n\t\t\tvalue={contextValue as KanbanContextValue<KanbanItemBase>}\n\t\t>\n\t\t\t<DndContext\n\t\t\t\tcollisionDetection={closestCorners}\n\t\t\t\tonDragCancel={() => setActiveItem(null)}\n\t\t\t\tonDragEnd={handleDragEnd}\n\t\t\t\tonDragStart={handleDragStart}\n\t\t\t\tsensors={sensors}\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"flex w-full gap-4 overflow-x-auto px-6 py-4 md:px-8 lg:px-10\",\n\t\t\t\t\t\tclassName,\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{children}\n\t\t\t\t</div>\n\t\t\t\t<DragOverlay>\n\t\t\t\t\t{activeItem ? (\n\t\t\t\t\t\trenderDragOverlay ? (\n\t\t\t\t\t\t\trenderDragOverlay(activeItem.item)\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<Card className=\"border-border/70 bg-background/95 w-[280px] max-w-[320px] border p-3 shadow-lg\">\n\t\t\t\t\t\t\t\t<p className=\"text-sm font-medium\">\n\t\t\t\t\t\t\t\t\t{String(activeItem.item.id)}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t)\n\t\t\t\t\t) : null}\n\t\t\t\t</DragOverlay>\n\t\t\t</DndContext>\n\t\t</KanbanContext.Provider>\n\t);\n}\n\nfunction useKanbanContext<T extends KanbanItemBase>() {\n\tconst context = useContext(KanbanContext) as KanbanContextValue<T> | null;\n\n\tif (!context) {\n\t\tthrow new Error(\"useKanbanContext must be used within a KanbanProvider\");\n\t}\n\n\treturn context;\n}\n\nexport type KanbanBoardProps = {\n\tcolumn: KanbanColumn;\n\tchildren: ReactNode;\n\tclassName?: string;\n};\n\nexport function KanbanBoard({ column, children, className }: KanbanBoardProps) {\n\treturn (\n\t\t<KanbanColumnContext.Provider value={column}>\n\t\t\t<section\n\t\t\t\taria-label={`${column.name} column`}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t\"kanban-column border-border/60 from-background via-background/60 to-muted/40 flex h-full min-w-[320px] flex-1 flex-col rounded-2xl border bg-gradient-to-b shadow-sm ring-1 ring-black/5 backdrop-blur-sm transition hover:shadow-md\",\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t</section>\n\t\t</KanbanColumnContext.Provider>\n\t);\n}\n\nexport type KanbanHeaderProps = {\n\tchildren: ReactNode;\n\tclassName?: string;\n};\n\nexport function KanbanHeader({ children, className }: KanbanHeaderProps) {\n\treturn (\n\t\t<header\n\t\t\tclassName={cn(\n\t\t\t\t\"bg-background/90 sticky top-0 z-10 flex items-center justify-between gap-2 rounded-t-2xl px-4 py-3 backdrop-blur-sm\",\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t>\n\t\t\t{children}\n\t\t</header>\n\t);\n}\n\nexport type KanbanCardsProps<T extends KanbanItemBase> = {\n\tcolumnId: string;\n\tchildren: (item: T, index: number) => ReactNode;\n\temptyState?: ReactNode;\n\tclassName?: string;\n\theight?: string;\n};\n\nexport function KanbanCards<T extends KanbanItemBase>({\n\tcolumnId,\n\tchildren,\n\temptyState,\n\tclassName,\n\theight = \"28rem\",\n}: KanbanCardsProps<T>) {\n\tconst { getItems } = useKanbanContext<T>();\n\tconst items = getItems(columnId);\n\tconst { setNodeRef, isOver } = useDroppable({\n\t\tid: `${COLUMN_DROPPABLE_PREFIX}${columnId}`,\n\t});\n\n\treturn (\n\t\t<SortableContext\n\t\t\titems={items.map((item) => item.id)}\n\t\t\tstrategy={verticalListSortingStrategy}\n\t\t>\n\t\t\t<ScrollArea className=\"kanban-scroll flex-1\">\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"kanban-column-cards bg-muted/30 flex min-h-[120px] flex-col gap-3 rounded-2xl p-3 transition\",\n\t\t\t\t\t\tisOver && \"ring-primary/60 ring-2 ring-offset-2\",\n\t\t\t\t\t\tclassName,\n\t\t\t\t\t)}\n\t\t\t\t\tdata-drop-state={isOver ? \"active\" : \"inactive\"}\n\t\t\t\t\tref={setNodeRef}\n\t\t\t\t\tstyle={{ minHeight: height }}\n\t\t\t\t>\n\t\t\t\t\t{items.length === 0 && emptyState}\n\t\t\t\t\t{items.map((item, index) => children(item, index))}\n\t\t\t\t</div>\n\t\t\t</ScrollArea>\n\t\t</SortableContext>\n\t);\n}\n\nexport type KanbanCardProps = {\n\titemId: UniqueIdentifier;\n\tchildren: ReactNode;\n\tclassName?: string;\n};\n\nexport function KanbanCard({ itemId, children, className }: KanbanCardProps) {\n\tconst {\n\t\tattributes,\n\t\tlisteners,\n\t\tsetNodeRef,\n\t\ttransform,\n\t\ttransition,\n\t\tisDragging,\n\t} = useSortable({\n\t\tid: itemId,\n\t});\n\n\tconst style = {\n\t\ttransform: CSS.Transform.toString(transform),\n\t\ttransition,\n\t};\n\n\treturn (\n\t\t<Card\n\t\t\tclassName={cn(\n\t\t\t\t\"border-border/70 bg-background/95 focus-visible:ring-ring grid gap-3 rounded-xl border p-4 text-left shadow-sm ring-0 transition-all outline-none hover:-translate-y-0.5 hover:shadow-md focus-visible:ring-2\",\n\t\t\t\tisDragging && \"border-primary/60 scale-[1.01] opacity-80 shadow-lg\",\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\tdata-dragging={isDragging ? \"\" : undefined}\n\t\t\tref={setNodeRef}\n\t\t\tstyle={style}\n\t\t\t{...listeners}\n\t\t\t{...attributes}\n\t\t>\n\t\t\t{children}\n\t\t</Card>\n\t);\n}\n\nfunction useKanbanColumn() {\n\tconst context = useContext(KanbanColumnContext);\n\tif (!context) {\n\t\tthrow new Error(\"useKanbanColumn must be used within a KanbanBoard\");\n\t}\n\n\treturn context;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AAcA;AAMA;AAEA;AASA;AAAA;AAAA;AAAA;;;AAjCA;;;;;;AA2EA,MAAM,8BAAgB,IAAA,qVAAa,EAClC;AAGD,MAAM,oCAAsB,IAAA,qVAAa,EAAsB;AAE/D,MAAM,0BAA0B;AAEhC,SAAS,WACR,OAAuB,EACvB,IAAS,EACT,WAAgC;IAEhC,MAAM,eAAe,OAAO,WAAW,CACtC,QAAQ,GAAG,CAAC,CAAC,SAAW;YAAC,OAAO,EAAE;YAAE,EAAE;SAAQ;IAG/C,OAAO,KAAK,MAAM,CAAsB,CAAC,OAAO;QAC/C,MAAM,WAAW,YAAY;QAC7B,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;YACrB,KAAK,CAAC,SAAS,GAAG,EAAE;QACrB;QAEA,KAAK,CAAC,SAAS,GAAG;eAAI,KAAK,CAAC,SAAS;YAAE;SAAK;QAC5C,OAAO;IACR,GAAG;AACJ;AAEA,SAAS,aACR,OAAuB,EACvB,KAA0B;IAE1B,OAAO,QAAQ,OAAO,CAAC,CAAC,SAAW,KAAK,CAAC,OAAO,EAAE,CAAC,IAAI,EAAE;AAC1D;AAEA,SAAS,WACR,KAA0B;IAE1B,OAAO,OAAO,WAAW,CACxB,OAAO,OAAO,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,UAAU,MAAM,GAAK;YAAC;YAAU,MAAM,KAAK;SAAG;AAE5E;AAEO,SAAS,eAAyC,EACxD,OAAO,EACP,IAAI,EACJ,YAAY,EACZ,UAAU,EACV,WAAW,EACX,QAAQ,EACR,SAAS,EACT,oBAAoB,EACpB,iBAAiB,EACO;;IACxB,MAAM,iBAAiB,IAAA,mVAAW,EACjC,eAAe;sDAAC,CAAC,OAAY,KAAK,QAAQ;KAAA,iDAC1C,EAAE;IAEH,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,gVAAQ;mCAAsB,IACvE,WAAW,SAAS,MAAM;;IAE3B,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,gVAAQ,EAGlC;IACV,MAAM,mBAAmB,IAAA,8UAAM,EAAC;IAEhC,IAAA,iVAAS;oCAAC;YACT,iBAAiB,OAAO,GAAG;QAC5B;mCAAG;QAAC;KAAQ;IAEZ,IAAA,iVAAS;oCAAC;YACT,iBAAiB,WAAW,SAAS,MAAM;QAC5C;mCAAG;QAAC;QAAS;QAAM;KAAe;IAElC,MAAM,UAAU,IAAA,0TAAU,EACzB,IAAA,yTAAS,EAAC,6TAAa,EAAE;QACxB,sBAAsB;YACrB,UAAU;QACX;QACA,GAAG,oBAAoB;IACxB,IACA,IAAA,yTAAS,EAAC,8TAAc,EAAE;QACzB,kBAAkB,wZAA2B;IAC9C;IAGD,MAAM,WAAW,IAAA,mVAAW;gDAC3B,CAAC;YACA,KAAK,MAAM,UAAU,iBAAiB,OAAO,CAAE;gBAC9C,MAAM,QAAQ,aAAa,CAAC,OAAO,EAAE,CAAC,IAAI,EAAE;gBAC5C,MAAM,QAAQ,MAAM,SAAS;kEAAC,CAAC,OAAS,KAAK,EAAE,KAAK;;gBACpD,IAAI,UAAU,CAAC,GAAG;oBACjB,OAAO;wBAAE,UAAU,OAAO,EAAE;wBAAE,MAAM,KAAK,CAAC,MAAM;wBAAE;oBAAM;gBACzD;YACD;YAEA,OAAO;QACR;+CACA;QAAC;KAAc;IAGhB,MAAM,kBAAkB,IAAA,mVAAW;uDAClC,CAAC;YACA,MAAM,SAAS,SAAS,MAAM,MAAM,CAAC,EAAE;YACvC,IAAI,QAAQ;gBACX,cAAc;oBAAE,MAAM,OAAO,IAAI;oBAAE,UAAU,OAAO,QAAQ;gBAAC;YAC9D;QACD;sDACA;QAAC;KAAS;IAGX,MAAM,gBAAgB,IAAA,mVAAW;qDAChC,CAAC;YACA,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG;YACzB,cAAc;YAEd,IAAI,CAAC,MAAM;gBACV;YACD;YAEA,MAAM,SAAS,SAAS,OAAO,EAAE;YACjC,IAAI,CAAC,QAAQ;gBACZ;YACD;YAEA,IAAI,sBAAqC;YACzC,IAAI,mBAAkC;YAEtC,IACC,OAAO,KAAK,EAAE,KAAK,YACnB,KAAK,EAAE,CAAC,UAAU,CAAC,0BAClB;gBACD,sBAAsB,KAAK,EAAE,CAAC,OAAO,CAAC,yBAAyB;gBAC/D,mBAAmB,CAAC,aAAa,CAAC,oBAAoB,IAAI,EAAE,EAAE,MAAM;YACrE,OAAO;gBACN,MAAM,cAAc,SAAS,KAAK,EAAE;gBACpC,IAAI,aAAa;oBAChB,sBAAsB,YAAY,QAAQ;oBAC1C,MAAM,cAAc,aAAa,CAAC,YAAY,QAAQ,CAAC,IAAI,EAAE;oBAC7D,mBAAmB,YAAY,SAAS;qEACvC,CAAC,OAAS,KAAK,EAAE,KAAK,YAAY,IAAI,CAAC,EAAE;;gBAE3C;YACD;YAEA,IACC,wBAAwB,QACxB,qBAAqB,QACpB,wBAAwB,OAAO,QAAQ,IACvC,qBAAqB,OAAO,KAAK,EACjC;gBACD;YACD;YAEA,MAAM,eAAe,WAAW;YAChC,MAAM,cAAc,YAAY,CAAC,OAAO,QAAQ,CAAC,IAAI,EAAE;YACvD,MAAM,CAAC,UAAU,GAAG,YAAY,MAAM,CAAC,OAAO,KAAK,EAAE;YACrD,YAAY,CAAC,OAAO,QAAQ,CAAC,GAAG;YAEhC,MAAM,mBAAmB,YAAY,CAAC,oBAAoB,IAAI,EAAE;YAChE,MAAM,cACL,OAAO,QAAQ,KAAK,uBACpB,OAAO,KAAK,GAAG,mBACZ,mBAAmB,IACnB;YAEJ,MAAM,cAAc;gBACnB,GAAG,SAAS;gBACZ,UAAU;YACX;YAEA,iBAAiB,MAAM,CAAC,aAAa,GAAG;YACxC,YAAY,CAAC,oBAAoB,GAAG;YAEpC,iBAAiB;YAEjB,MAAM,YAAY,aAAa,iBAAiB,OAAO,EAAE;YACzD,eAAe;YAEf,IAAI,YAAY;gBACf,WAAW;oBACV,MAAM;oBACN,cAAc,OAAO,QAAQ;oBAC7B,YAAY;oBACZ,SAAS;gBACV;YACD;QACD;oDACA;QAAC;QAAU;QAAe;QAAc;KAAW;IAGpD,MAAM,eAAe,IAAA,+UAAO;gDAC3B,IAAM,CAAC;gBACN;gBACA,QAAQ;4DAAE,CAAC,WAAqB,aAAa,CAAC,SAAS,IAAI,EAAE;;gBAC7D;gBACA;YACD,CAAC;+CACD;QAAC;QAAS;QAAe;QAAU;KAAW;IAG/C,qBACC,oWAAC,cAAc,QAAQ;QACtB,OAAO;kBAEP,cAAA,oWAAC,0TAAU;YACV,oBAAoB,8TAAc;YAClC,cAAc,IAAM,cAAc;YAClC,WAAW;YACX,aAAa;YACb,SAAS;;8BAET,oWAAC;oBACA,WAAW,IAAA,uIAAE,EACZ,gEACA;8BAGA;;;;;;8BAEF,oWAAC,2TAAW;8BACV,aACA,oBACC,kBAAkB,WAAW,IAAI,kBAEjC,oWAAC,yIAAI;wBAAC,WAAU;kCACf,cAAA,oWAAC;4BAAE,WAAU;sCACX,OAAO,WAAW,IAAI,CAAC,EAAE;;;;;;;;;;+BAI1B;;;;;;;;;;;;;;;;;AAKT;GAlMgB;;QAgCC,0TAAU;;;KAhCX;AAoMhB,SAAS;;IACR,MAAM,UAAU,IAAA,kVAAU,EAAC;IAE3B,IAAI,CAAC,SAAS;QACb,MAAM,IAAI,MAAM;IACjB;IAEA,OAAO;AACR;IARS;AAgBF,SAAS,YAAY,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAoB;IAC5E,qBACC,oWAAC,oBAAoB,QAAQ;QAAC,OAAO;kBACpC,cAAA,oWAAC;YACA,cAAY,GAAG,OAAO,IAAI,CAAC,OAAO,CAAC;YACnC,WAAW,IAAA,uIAAE,EACZ,wOACA;sBAGA;;;;;;;;;;;AAIL;MAdgB;AAqBT,SAAS,aAAa,EAAE,QAAQ,EAAE,SAAS,EAAqB;IACtE,qBACC,oWAAC;QACA,WAAW,IAAA,uIAAE,EACZ,uHACA;kBAGA;;;;;;AAGJ;MAXgB;AAqBT,SAAS,YAAsC,EACrD,QAAQ,EACR,QAAQ,EACR,UAAU,EACV,SAAS,EACT,SAAS,OAAO,EACK;;IACrB,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,MAAM,QAAQ,SAAS;IACvB,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,IAAA,4TAAY,EAAC;QAC3C,IAAI,GAAG,0BAA0B,UAAU;IAC5C;IAEA,qBACC,oWAAC,4YAAe;QACf,OAAO,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK,EAAE;QAClC,UAAU,wZAA2B;kBAErC,cAAA,oWAAC,yJAAU;YAAC,WAAU;sBACrB,cAAA,oWAAC;gBACA,WAAW,IAAA,uIAAE,EACZ,gGACA,UAAU,wCACV;gBAED,mBAAiB,SAAS,WAAW;gBACrC,KAAK;gBACL,OAAO;oBAAE,WAAW;gBAAO;;oBAE1B,MAAM,MAAM,KAAK,KAAK;oBACtB,MAAM,GAAG,CAAC,CAAC,MAAM,QAAU,SAAS,MAAM;;;;;;;;;;;;;;;;;AAKhD;IAnCgB;;QAOM;QAEU,4TAAY;;;MAT5B;AA2CT,SAAS,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAmB;;IAC1E,MAAM,EACL,UAAU,EACV,SAAS,EACT,UAAU,EACV,SAAS,EACT,UAAU,EACV,UAAU,EACV,GAAG,IAAA,wYAAW,EAAC;QACf,IAAI;IACL;IAEA,MAAM,QAAQ;QACb,WAAW,2QAAG,CAAC,SAAS,CAAC,QAAQ,CAAC;QAClC;IACD;IAEA,qBACC,oWAAC,yIAAI;QACJ,WAAW,IAAA,uIAAE,EACZ,iNACA,cAAc,uDACd;QAED,iBAAe,aAAa,KAAK;QACjC,KAAK;QACL,OAAO;QACN,GAAG,SAAS;QACZ,GAAG,UAAU;kBAEb;;;;;;AAGJ;IAjCgB;;QAQX,wYAAW;;;MARA;AAmChB,SAAS;;IACR,MAAM,UAAU,IAAA,kVAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACb,MAAM,IAAI,MAAM;IACjB;IAEA,OAAO;AACR;IAPS"}},
    {"offset": {"line": 470, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/entity-kanban.tsx"],"sourcesContent":["/**\n * EntityKanban - Generic Kanban Component\n *\n * Reusable kanban board component that handles common kanban logic.\n * Replaces individual kanban components (JobsKanban, InvoicesKanban, etc.)\n *\n * Features:\n * - Column definitions with status mapping\n * - Drag and drop functionality\n * - Column metadata (counts, totals)\n * - Custom card rendering\n * - Optional status change handler\n */\n\n\"use client\";\n\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Badge } from \"@stratos/ui\";\nimport {\n\tKanbanBoard,\n\tKanbanCard,\n\tKanbanCards,\n\ttype KanbanColumn,\n\tKanbanHeader,\n\ttype KanbanItemBase,\n\ttype KanbanMoveEvent,\n\tKanbanProvider,\n} from \"./shadcn-io/kanban\";\n\nexport type ColumnMeta = {\n\tcount: number;\n\ttotal?: number;\n\tvalue?: number;\n};\n\nexport type EntityKanbanProps<TEntity, TStatus extends string> = {\n\t/** Entity data array */\n\tdata: TEntity[];\n\n\t/** Column definitions */\n\tcolumns: Array<{\n\t\tid: TStatus;\n\t\tname: string;\n\t\taccentColor: string;\n\t}>;\n\n\t/** Map entity to kanban item */\n\tmapToKanbanItem: (entity: TEntity) => KanbanItemBase & { entity: TEntity };\n\n\t/** Update entity status when moved */\n\tupdateEntityStatus?: (entity: TEntity, newStatus: TStatus) => TEntity;\n\n\t/** Render card component */\n\trenderCard: (item: KanbanItemBase & { entity: TEntity }) => React.ReactNode;\n\n\t/** Render drag overlay */\n\trenderDragOverlay?: (\n\t\titem: KanbanItemBase & { entity: TEntity },\n\t) => React.ReactNode;\n\n\t/** Calculate column metadata (count, totals) */\n\tcalculateColumnMeta?: (\n\t\tcolumnId: TStatus,\n\t\titems: (KanbanItemBase & { entity: TEntity })[],\n\t) => ColumnMeta;\n\n\t/** Handle item move event */\n\tonItemMove?: (\n\t\tevent: KanbanMoveEvent<KanbanItemBase & { entity: TEntity }>,\n\t) => void | Promise<void>;\n\n\t/** Entity name for empty states (e.g., \"jobs\", \"invoices\") */\n\tentityName?: string;\n\n\t/** Custom empty state message */\n\temptyStateMessage?: (columnName: string) => string;\n\n\t/** Show totals in column headers */\n\tshowTotals?: boolean;\n\n\t/** Format total value */\n\tformatTotal?: (total: number) => string;\n};\n\nexport function EntityKanban<TEntity, TStatus extends string>({\n\tdata,\n\tcolumns,\n\tmapToKanbanItem,\n\tupdateEntityStatus,\n\trenderCard,\n\trenderDragOverlay,\n\tcalculateColumnMeta,\n\tonItemMove,\n\tentityName = \"items\",\n\temptyStateMessage,\n\tshowTotals = false,\n\tformatTotal,\n}: EntityKanbanProps<TEntity, TStatus>) {\n\tconst [items, setItems] = useState<(KanbanItemBase & { entity: TEntity })[]>(\n\t\t() => data.map(mapToKanbanItem),\n\t);\n\n\t// DO NOT sync prop changes - causes infinite re-render loop with array/function props\n\t// Initial state is set from props, updates come from drag-and-drop handlers\n\n\tconst handleDataChange = (next: (KanbanItemBase & { entity: TEntity })[]) => {\n\t\tif (updateEntityStatus) {\n\t\t\tsetItems(\n\t\t\t\tnext.map((item) => ({\n\t\t\t\t\t...item,\n\t\t\t\t\tentity: updateEntityStatus(item.entity, item.columnId as TStatus),\n\t\t\t\t})),\n\t\t\t);\n\t\t} else {\n\t\t\tsetItems(next);\n\t\t}\n\t};\n\n\tconst defaultCalculateColumnMeta = (\n\t\tcolumnId: TStatus,\n\t\titems: (KanbanItemBase & { entity: TEntity })[],\n\t): ColumnMeta => {\n\t\tconst columnItems = items.filter((item) => item.columnId === columnId);\n\t\treturn { count: columnItems.length };\n\t};\n\n\tconst getColumnMeta = calculateColumnMeta || defaultCalculateColumnMeta;\n\n\tconst columnMetaMap = useMemo(() => {\n\t\tconst meta: Record<string, ColumnMeta> = {};\n\t\tcolumns.forEach((column) => {\n\t\t\tmeta[column.id] = getColumnMeta(column.id, items);\n\t\t});\n\t\treturn meta;\n\t}, [columns, items, getColumnMeta]);\n\n\tconst kanbanColumns: KanbanColumn[] = useMemo(\n\t\t() =>\n\t\t\tcolumns.map((col) => ({\n\t\t\t\tid: col.id,\n\t\t\t\tname: col.name,\n\t\t\t\taccentColor: col.accentColor,\n\t\t\t})),\n\t\t[columns],\n\t);\n\n\tconst defaultEmptyState = (columnName: string) =>\n\t\t`No ${entityName} in ${columnName}`;\n\n\tconst getEmptyStateMessage = emptyStateMessage || defaultEmptyState;\n\n\treturn (\n\t\t<KanbanProvider<KanbanItemBase & { entity: TEntity }>\n\t\t\tclassName=\"pb-4\"\n\t\t\tcolumns={kanbanColumns}\n\t\t\tdata={items}\n\t\t\tonDataChange={handleDataChange}\n\t\t\tonItemMove={onItemMove}\n\t\t\trenderDragOverlay={\n\t\t\t\trenderDragOverlay ||\n\t\t\t\t((item) => (\n\t\t\t\t\t<div className=\"border-border/70 bg-background/95 w-[280px] rounded-xl border p-4 shadow-lg\">\n\t\t\t\t\t\t{renderCard(item)}\n\t\t\t\t\t</div>\n\t\t\t\t))\n\t\t\t}\n\t\t>\n\t\t\t{columns.map((column) => {\n\t\t\t\tconst meta = columnMetaMap[column.id] ?? { count: 0 };\n\t\t\t\treturn (\n\t\t\t\t\t<KanbanBoard\n\t\t\t\t\t\tclassName=\"min-h-[300px] flex-1\"\n\t\t\t\t\t\tcolumn={kanbanColumns.find((c) => c.id === column.id)!}\n\t\t\t\t\t\tkey={column.id}\n\t\t\t\t\t>\n\t\t\t\t\t\t<KanbanHeader>\n\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\t\t\t\t\tclassName=\"h-2.5 w-2.5 rounded-full\"\n\t\t\t\t\t\t\t\t\tstyle={{ backgroundColor: column.accentColor }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<span className=\"text-foreground text-sm font-semibold\">\n\t\t\t\t\t\t\t\t\t{column.name}\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\tclassName=\"bg-muted text-muted-foreground rounded-full px-2 py-0 text-xs font-medium\"\n\t\t\t\t\t\t\t\t\tvariant=\"secondary\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{meta.count} {entityName}\n\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t{showTotals && meta.total !== undefined && formatTotal && (\n\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t{formatTotal(meta.total)}\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{showTotals && meta.value !== undefined && formatTotal && (\n\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t{formatTotal(meta.value)}\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</KanbanHeader>\n\t\t\t\t\t\t<KanbanCards<KanbanItemBase & { entity: TEntity }>\n\t\t\t\t\t\t\tclassName=\"min-h-[200px]\"\n\t\t\t\t\t\t\tcolumnId={column.id}\n\t\t\t\t\t\t\temptyState={\n\t\t\t\t\t\t\t\t<div className=\"border-border/60 bg-background/60 text-muted-foreground rounded-xl border border-dashed p-4 text-center text-xs\">\n\t\t\t\t\t\t\t\t\t{getEmptyStateMessage(column.name)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{(item) => (\n\t\t\t\t\t\t\t\t<KanbanCard itemId={item.id} key={item.id}>\n\t\t\t\t\t\t\t\t\t{renderCard(item)}\n\t\t\t\t\t\t\t\t</KanbanCard>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</KanbanCards>\n\t\t\t\t\t</KanbanBoard>\n\t\t\t\t);\n\t\t\t})}\n\t\t</KanbanProvider>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/appointments.ts"],"sourcesContent":["/**\n * Appointments Server Actions\n *\n * Handles appointment scheduling and management with comprehensive CRUD operations,\n * status transitions, reminders, and team assignment logic.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { ActionError, ERROR_CODES } from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nconst APPOINTMENT_NUMBER_REGEX = /APT-(\\d+)/;\nconst APPOINTMENT_NUMBER_LENGTH = 6;\nconst MILLISECONDS_PER_MINUTE = 60_000;\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst DEFAULT_SEARCH_OFFSET = 0;\n\nconst getSupabaseServerClient = async (): Promise<SupabaseServerClient> => {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\treturn supabase as SupabaseServerClient;\n};\n\n// Validation Schemas\nconst createAppointmentSchema = z.object({\n\tcustomerId: z.string().uuid(\"Invalid customer ID\"),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional(),\n\tjobId: z.string().uuid(\"Invalid job ID\").optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\ttitle: z.string().min(1, \"Appointment title is required\"),\n\tdescription: z.string().optional(),\n\tcategory: z\n\t\t.enum([\n\t\t\t\"job_appointment\",\n\t\t\t\"estimate_appointment\",\n\t\t\t\"event\",\n\t\t\t\"meeting\",\n\t\t\t\"follow_up\",\n\t\t\t\"recurring_service\",\n\t\t])\n\t\t.default(\"job_appointment\"),\n\ttype: z\n\t\t.enum([\n\t\t\t\"service_call\",\n\t\t\t\"installation\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"repair\",\n\t\t\t\"estimate\",\n\t\t\t\"follow_up\",\n\t\t\t\"winterization\",\n\t\t\t\"emergency\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]).default(\"normal\"),\n\tscheduledStart: z.string().min(1, \"Start time is required\"),\n\tscheduledEnd: z.string().min(1, \"End time is required\"),\n\tnotes: z.string().optional(),\n\ttravelTimeMinutes: z.number().int().min(0).optional(),\n});\n\nconst updateAppointmentSchema = z.object({\n\ttitle: z.string().min(1, \"Appointment title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"scheduled\",\n\t\t\t\"confirmed\",\n\t\t\t\"in_progress\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"no_show\",\n\t\t\t\"rescheduled\",\n\t\t])\n\t\t.optional(),\n\ttype: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"consultation\",\n\t\t\t\"estimate\",\n\t\t\t\"follow_up\",\n\t\t\t\"maintenance\",\n\t\t\t\"emergency\",\n\t\t\t\"inspection\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tactualStart: z.string().optional(),\n\tactualEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tnotes: z.string().optional(),\n\tcancellationReason: z.string().optional(),\n});\n\nconst rescheduleAppointmentSchema = z.object({\n\tscheduledStart: z.string().min(1, \"Start time is required\"),\n\tscheduledEnd: z.string().min(1, \"End time is required\"),\n\treason: z.string().optional(),\n});\n\n/**\n * Generate unique appointment number using database function\n */\nasync function generateAppointmentNumber(\n\tsupabase: SupabaseServerClient,\n\tcompanyId: string,\n): Promise<string> {\n\tconst { data, error } = await supabase.rpc(\"generate_appointment_number\", {\n\t\tp_company_id: companyId,\n\t});\n\n\tif (error || !data) {\n\t\t// Fallback to manual generation\n\t\tconst { data: latestAppointment } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"appointment_number\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tif (!latestAppointment) {\n\t\t\treturn \"APT-000001\";\n\t\t}\n\n\t\tconst match = latestAppointment.appointment_number.match(\n\t\t\tAPPOINTMENT_NUMBER_REGEX,\n\t\t);\n\t\tif (match) {\n\t\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\t\treturn `APT-${nextNumber.toString().padStart(APPOINTMENT_NUMBER_LENGTH, \"0\")}`;\n\t\t}\n\n\t\treturn `APT-${Date.now().toString().slice(-APPOINTMENT_NUMBER_LENGTH)}`;\n\t}\n\n\treturn data;\n}\n\n/**\n * Calculate duration in minutes between two dates\n */\nfunction calculateDuration(start: string, end: string): number {\n\tconst startDate = new Date(start);\n\tconst endDate = new Date(end);\n\treturn Math.round(\n\t\t(endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_MINUTE,\n\t);\n}\n\n/**\n * Validate appointment times\n */\nfunction validateAppointmentTimes(start: string, end: string): void {\n\tconst startDate = new Date(start);\n\tconst endDate = new Date(end);\n\n\tif (endDate <= startDate) {\n\t\tthrow new ActionError(\n\t\t\t\"End time must be after start time\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\n\tif (startDate < new Date()) {\n\t\tthrow new ActionError(\n\t\t\t\"Cannot schedule appointments in the past\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nconst extractFormValues = (\n\tformData: FormData,\n\tfields: string[],\n): Record<string, unknown> => {\n\tconst result: Record<string, unknown> = {};\n\tfor (const field of fields) {\n\t\tconst value = formData.get(field);\n\t\tif (value !== null && value !== undefined && value !== \"\") {\n\t\t\tresult[field] = value;\n\t\t}\n\t}\n\treturn result;\n};\n\nconst buildUpdatePayload = (\n\tdata: z.infer<typeof updateAppointmentSchema>,\n\tduration?: number,\n): Record<string, unknown> => {\n\tconst updateData: Record<string, unknown> = { ...data };\n\tif (duration) {\n\t\tupdateData.duration_minutes = duration;\n\t}\n\n\tif (data.actualStart && data.actualEnd) {\n\t\tupdateData.actual_duration_minutes = calculateDuration(\n\t\t\tdata.actualStart,\n\t\t\tdata.actualEnd,\n\t\t);\n\t}\n\n\treturn updateData;\n};\n\nconst toSnakeCaseRecord = (data: Record<string, unknown>) => {\n\tconst result: Record<string, unknown> = {};\n\tfor (const [key, value] of Object.entries(data)) {\n\t\tconst snakeKey = key.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n\t\tresult[snakeKey] = value;\n\t}\n\treturn result;\n};\n\n/**\n * Create a new appointment\n */\nexport async function createAppointment(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\tcustomerId: formData.get(\"customerId\") as string,\n\t\t\tpropertyId: (formData.get(\"propertyId\") as string) || undefined,\n\t\t\tjobId: (formData.get(\"jobId\") as string) || undefined,\n\t\t\tassignedTo: (formData.get(\"assignedTo\") as string) || undefined,\n\t\t\ttitle: formData.get(\"title\") as string,\n\t\t\tdescription: (formData.get(\"description\") as string) || undefined,\n\t\t\tcategory: (formData.get(\"category\") as string) || \"job_appointment\",\n\t\t\ttype: (formData.get(\"type\") as string) || undefined,\n\t\t\tpriority: (formData.get(\"priority\") as string) || \"normal\",\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") as string,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") as string,\n\t\t\tnotes: (formData.get(\"notes\") as string) || undefined,\n\t\t\ttravelTimeMinutes: formData.get(\"travelTimeMinutes\")\n\t\t\t\t? Number.parseInt(formData.get(\"travelTimeMinutes\") as string, 10)\n\t\t\t\t: undefined,\n\t\t};\n\n\t\tconst validatedData = createAppointmentSchema.parse(rawData);\n\n\t\t// Validate appointment times\n\t\tvalidateAppointmentTimes(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Calculate duration\n\t\tconst duration = calculateDuration(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Generate appointment number\n\t\tconst appointmentNumber = await generateAppointmentNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\n\t\t// Create appointment\n\t\tconst { data: appointment, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: validatedData.customerId,\n\t\t\t\tproperty_id: validatedData.propertyId,\n\t\t\t\tjob_id: validatedData.jobId,\n\t\t\t\tassigned_to: validatedData.assignedTo,\n\t\t\t\tappointment_number: appointmentNumber,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tdescription: validatedData.description,\n\t\t\t\tcategory: validatedData.category,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\tscheduled_start: validatedData.scheduledStart,\n\t\t\t\tscheduled_end: validatedData.scheduledEnd,\n\t\t\t\tduration_minutes: duration,\n\t\t\t\tnotes: validatedData.notes,\n\t\t\t\ttravel_time_minutes: validatedData.travelTimeMinutes,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tcreated_by: user.id,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to create appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\tif (validatedData.jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${validatedData.jobId}`);\n\t\t}\n\n\t\treturn appointment.id;\n\t});\n}\n\n/**\n * Update an existing appointment\n */\nasync function updateAppointment(\n\tappointmentId: string,\n\tformData: FormData,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Verify appointment exists and belongs to company\n\t\tconst { data: existingAppointment, error: fetchError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, company_id, status, scheduled_start, scheduled_end, job_id\")\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !existingAppointment) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Appointment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\t// Parse and validate form data\n\t\tconst rawData = extractFormValues(formData, [\n\t\t\t\"title\",\n\t\t\t\"description\",\n\t\t\t\"status\",\n\t\t\t\"type\",\n\t\t\t\"priority\",\n\t\t\t\"scheduledStart\",\n\t\t\t\"scheduledEnd\",\n\t\t\t\"actualStart\",\n\t\t\t\"actualEnd\",\n\t\t\t\"assignedTo\",\n\t\t\t\"notes\",\n\t\t\t\"cancellationReason\",\n\t\t]);\n\n\t\tconst validatedData = updateAppointmentSchema.parse(rawData);\n\n\t\t// Validate times if both are provided\n\t\tif (validatedData.scheduledStart && validatedData.scheduledEnd) {\n\t\t\tvalidateAppointmentTimes(\n\t\t\t\tvalidatedData.scheduledStart,\n\t\t\t\tvalidatedData.scheduledEnd,\n\t\t\t);\n\t\t}\n\n\t\t// Calculate new duration if times changed\n\t\tlet duration: number | undefined;\n\t\tif (validatedData.scheduledStart && validatedData.scheduledEnd) {\n\t\t\tduration = calculateDuration(\n\t\t\t\tvalidatedData.scheduledStart,\n\t\t\t\tvalidatedData.scheduledEnd,\n\t\t\t);\n\t\t}\n\n\t\t// Build update object\n\t\tconst updateData = buildUpdatePayload(validatedData, duration);\n\t\tconst dbUpdateData = toSnakeCaseRecord(updateData);\n\n\t\t// Update appointment\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(dbUpdateData)\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to update appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\tif (existingAppointment.job_id) {\n\t\t\trevalidatePath(`/dashboard/work/${existingAppointment.job_id}`);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Reschedule an appointment\n */\nasync function rescheduleAppointment(\n\tappointmentId: string,\n\tformData: FormData,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") as string,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") as string,\n\t\t\treason: (formData.get(\"reason\") as string) || undefined,\n\t\t};\n\n\t\tconst validatedData = rescheduleAppointmentSchema.parse(rawData);\n\n\t\t// Validate appointment times\n\t\tvalidateAppointmentTimes(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Calculate new duration\n\t\tconst duration = calculateDuration(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Update appointment with rescheduled status\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: validatedData.scheduledStart,\n\t\t\t\tscheduled_end: validatedData.scheduledEnd,\n\t\t\t\tduration_minutes: duration,\n\t\t\t\tstatus: \"rescheduled\",\n\t\t\t\tnotes: validatedData.reason\n\t\t\t\t\t? `Rescheduled: ${validatedData.reason}`\n\t\t\t\t\t: undefined,\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to reschedule appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Cancel an appointment\n */\nasync function cancelAppointment(\n\tappointmentId: string,\n\treason?: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Update appointment status to cancelled\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tcancellation_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to cancel appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Complete an appointment\n */\nasync function completeAppointment(\n\tappointmentId: string,\n\tactualEnd?: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Update appointment status to completed\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end: actualEnd || new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to complete appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Archive an appointment (soft delete)\n */\nexport async function archiveAppointment(\n\tappointmentId: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Archive appointment (soft delete)\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: now,\n\t\t\t\tdeleted_at: now,\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"cancelled\", // Mark as cancelled when archived\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to archive appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Delete an appointment (hard delete)\n */\nasync function deleteAppointment(\n\tappointmentId: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Delete appointment\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to delete appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Search appointments\n */\nasync function searchAppointments(\n\tsearchQuery: string,\n\toptions?: {\n\t\tlimit?: number;\n\t\toffset?: number;\n\t},\n): Promise<ActionResult<Record<string, unknown>[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Use the RPC function for ranked search\n\t\tconst { data, error } = await supabase.rpc(\"search_appointments_ranked\", {\n\t\t\tp_company_id: companyId,\n\t\t\tp_search_query: searchQuery,\n\t\t\tp_limit: options?.limit ?? DEFAULT_SEARCH_LIMIT,\n\t\t\tp_offset: options?.offset ?? DEFAULT_SEARCH_OFFSET,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Search failed: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn (data as Record<string, unknown>[]) || [];\n\t});\n}\n\n/**\n * Unlink appointment from job\n * Removes the job association (sets job_id to NULL)\n * Bidirectional operation - updates both appointment and job views\n */\nasync function unlinkScheduleFromJob(\n\tappointmentId: string,\n): Promise<ActionResult<void>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Get current appointment to verify exists and get job_id for revalidation\n\t\tconst { data: appointment, error: fetchError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !appointment) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Appointment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tconst previousJobId = appointment.job_id;\n\n\t\t// Unlink appointment from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (unlinkError) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to unlink appointment from job\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate both pages\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA+OsB,oBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/utils/customer-display.ts"],"sourcesContent":["/**\n * Customer Display Utilities\n *\n * Unified logic for displaying customer information consistently across the application.\n * This prevents inconsistent customer name display and provides fallback logic.\n */\n\nexport interface CustomerDisplayData {\n\tid?: string;\n\tdisplay_name?: string | null;\n\tfirst_name?: string | null;\n\tlast_name?: string | null;\n\tcompany_name?: string | null;\n\temail?: string | null;\n\tphone?: string | null;\n}\n\n/**\n * Get a customer's display name using consistent precedence logic:\n * 1. display_name (if set)\n * 2. first_name + last_name (combined)\n * 3. first_name OR last_name (whichever exists)\n * 4. company_name (for business customers)\n * 5. email (as last resort)\n * 6. \"Unknown Customer\" (ultimate fallback)\n *\n * @param customer - Customer object with potential name fields\n * @param fallbackEmail - Optional email to use if customer has no name\n * @returns Display-ready customer name\n *\n * @example\n * ```ts\n * getCustomerDisplayName({ first_name: \"John\", last_name: \"Doe\" })\n * // Returns: \"John Doe\"\n *\n * getCustomerDisplayName({ display_name: \"John's Plumbing\" })\n * // Returns: \"John's Plumbing\"\n *\n * getCustomerDisplayName({ email: \"john@example.com\" })\n * // Returns: \"john@example.com\"\n * ```\n */\nexport function getCustomerDisplayName(\n\tcustomer: CustomerDisplayData | null | undefined,\n\tfallbackEmail?: string | null\n): string {\n\tif (!customer) {\n\t\treturn fallbackEmail || \"Unknown Customer\";\n\t}\n\n\t// Priority 1: Explicit display name\n\tif (customer.display_name) {\n\t\treturn customer.display_name;\n\t}\n\n\t// Priority 2: Full name (first + last)\n\tconst firstName = customer.first_name?.trim();\n\tconst lastName = customer.last_name?.trim();\n\n\tif (firstName && lastName) {\n\t\treturn `${firstName} ${lastName}`;\n\t}\n\n\t// Priority 3: Either first or last name\n\tif (firstName) return firstName;\n\tif (lastName) return lastName;\n\n\t// Priority 4: Company name (for business customers)\n\tif (customer.company_name) {\n\t\treturn customer.company_name;\n\t}\n\n\t// Priority 5: Email from customer record\n\tif (customer.email) {\n\t\treturn customer.email;\n\t}\n\n\t// Priority 6: Fallback email provided\n\tif (fallbackEmail) {\n\t\treturn fallbackEmail;\n\t}\n\n\t// Ultimate fallback\n\treturn \"Unknown Customer\";\n}\n\n/**\n * Get customer initials for avatar displays\n * Takes first letter of each word (max 2 letters)\n *\n * @param customer - Customer object with potential name fields\n * @returns 1-2 character initials (uppercase)\n *\n * @example\n * ```ts\n * getCustomerInitials({ first_name: \"John\", last_name: \"Doe\" })\n * // Returns: \"JD\"\n *\n * getCustomerInitials({ display_name: \"ACME Corp\" })\n * // Returns: \"AC\"\n *\n * getCustomerInitials({ email: \"john@example.com\" })\n * // Returns: \"J\"\n * ```\n */\nexport function getCustomerInitials(\n\tcustomer: CustomerDisplayData | null | undefined\n): string {\n\tif (!customer) return \"?\";\n\n\tconst displayName = getCustomerDisplayName(customer);\n\n\t// Split by spaces and take first letter of each word\n\tconst words = displayName.split(/\\s+/).filter(Boolean);\n\n\tif (words.length >= 2) {\n\t\treturn (words[0][0] + words[1][0]).toUpperCase();\n\t}\n\n\tif (words.length === 1 && words[0].length >= 2) {\n\t\treturn words[0].slice(0, 2).toUpperCase();\n\t}\n\n\tif (words.length === 1) {\n\t\treturn words[0][0].toUpperCase();\n\t}\n\n\treturn \"?\";\n}\n\n/**\n * Get customer's full contact display (name + email/phone)\n * Useful for tooltips, hover cards, and detail views\n *\n * @param customer - Customer object\n * @returns Multi-line contact string\n *\n * @example\n * ```ts\n * getCustomerContactDisplay({\n *   first_name: \"John\",\n *   last_name: \"Doe\",\n *   email: \"john@example.com\",\n *   phone: \"555-1234\"\n * })\n * // Returns: \"John Doe\\njohn@example.com\\n555-1234\"\n * ```\n */\nexport function getCustomerContactDisplay(\n\tcustomer: CustomerDisplayData | null | undefined\n): string {\n\tif (!customer) return \"Unknown Customer\";\n\n\tconst lines: string[] = [getCustomerDisplayName(customer)];\n\n\tif (customer.email) {\n\t\tlines.push(customer.email);\n\t}\n\n\tif (customer.phone) {\n\t\tlines.push(customer.phone);\n\t}\n\n\treturn lines.join(\"\\n\");\n}\n\n/**\n * Check if customer has any name information (not just email)\n * Useful for validation and \"not linked\" indicators\n *\n * @param customer - Customer object\n * @returns true if customer has a real name, false if only email/unknown\n */\nexport function hasCustomerName(\n\tcustomer: CustomerDisplayData | null | undefined\n): boolean {\n\tif (!customer) return false;\n\n\treturn !!(\n\t\tcustomer.display_name ||\n\t\tcustomer.first_name ||\n\t\tcustomer.last_name ||\n\t\tcustomer.company_name\n\t);\n}\n\n/**\n * Format customer name for sorting/comparison\n * Always uses \"Last, First\" format for consistent alphabetization\n *\n * @param customer - Customer object\n * @returns Sortable name string\n *\n * @example\n * ```ts\n * getCustomerSortName({ first_name: \"John\", last_name: \"Doe\" })\n * // Returns: \"Doe, John\"\n *\n * getCustomerSortName({ company_name: \"ACME Corp\" })\n * // Returns: \"ACME Corp\"\n * ```\n */\nexport function getCustomerSortName(\n\tcustomer: CustomerDisplayData | null | undefined\n): string {\n\tif (!customer) return \"zzz_unknown\"; // Sort unknowns to end\n\n\t// If only last name, use it\n\tif (customer.last_name && !customer.first_name) {\n\t\treturn customer.last_name;\n\t}\n\n\t// If only first name, use it\n\tif (customer.first_name && !customer.last_name) {\n\t\treturn customer.first_name;\n\t}\n\n\t// If both names, use \"Last, First\" format\n\tif (customer.first_name && customer.last_name) {\n\t\treturn `${customer.last_name}, ${customer.first_name}`;\n\t}\n\n\t// Otherwise use display name logic\n\treturn getCustomerDisplayName(customer);\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;AAqCM,SAAS,uBACf,QAAgD,EAChD,aAA6B;IAE7B,IAAI,CAAC,UAAU;QACd,OAAO,iBAAiB;IACzB;IAEA,oCAAoC;IACpC,IAAI,SAAS,YAAY,EAAE;QAC1B,OAAO,SAAS,YAAY;IAC7B;IAEA,uCAAuC;IACvC,MAAM,YAAY,SAAS,UAAU,EAAE;IACvC,MAAM,WAAW,SAAS,SAAS,EAAE;IAErC,IAAI,aAAa,UAAU;QAC1B,OAAO,GAAG,UAAU,CAAC,EAAE,UAAU;IAClC;IAEA,wCAAwC;IACxC,IAAI,WAAW,OAAO;IACtB,IAAI,UAAU,OAAO;IAErB,oDAAoD;IACpD,IAAI,SAAS,YAAY,EAAE;QAC1B,OAAO,SAAS,YAAY;IAC7B;IAEA,yCAAyC;IACzC,IAAI,SAAS,KAAK,EAAE;QACnB,OAAO,SAAS,KAAK;IACtB;IAEA,sCAAsC;IACtC,IAAI,eAAe;QAClB,OAAO;IACR;IAEA,oBAAoB;IACpB,OAAO;AACR;AAqBO,SAAS,oBACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO;IAEtB,MAAM,cAAc,uBAAuB;IAE3C,qDAAqD;IACrD,MAAM,QAAQ,YAAY,KAAK,CAAC,OAAO,MAAM,CAAC;IAE9C,IAAI,MAAM,MAAM,IAAI,GAAG;QACtB,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,WAAW;IAC/C;IAEA,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,CAAC,MAAM,IAAI,GAAG;QAC/C,OAAO,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,GAAG,WAAW;IACxC;IAEA,IAAI,MAAM,MAAM,KAAK,GAAG;QACvB,OAAO,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,WAAW;IAC/B;IAEA,OAAO;AACR;AAoBO,SAAS,0BACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO;IAEtB,MAAM,QAAkB;QAAC,uBAAuB;KAAU;IAE1D,IAAI,SAAS,KAAK,EAAE;QACnB,MAAM,IAAI,CAAC,SAAS,KAAK;IAC1B;IAEA,IAAI,SAAS,KAAK,EAAE;QACnB,MAAM,IAAI,CAAC,SAAS,KAAK;IAC1B;IAEA,OAAO,MAAM,IAAI,CAAC;AACnB;AASO,SAAS,gBACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO;IAEtB,OAAO,CAAC,CAAC,CACR,SAAS,YAAY,IACrB,SAAS,UAAU,IACnB,SAAS,SAAS,IAClB,SAAS,YAAY,AACtB;AACD;AAkBO,SAAS,oBACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO,eAAe,uBAAuB;IAE5D,4BAA4B;IAC5B,IAAI,SAAS,SAAS,IAAI,CAAC,SAAS,UAAU,EAAE;QAC/C,OAAO,SAAS,SAAS;IAC1B;IAEA,6BAA6B;IAC7B,IAAI,SAAS,UAAU,IAAI,CAAC,SAAS,SAAS,EAAE;QAC/C,OAAO,SAAS,UAAU;IAC3B;IAEA,0CAA0C;IAC1C,IAAI,SAAS,UAAU,IAAI,SAAS,SAAS,EAAE;QAC9C,OAAO,GAAG,SAAS,SAAS,CAAC,EAAE,EAAE,SAAS,UAAU,EAAE;IACvD;IAEA,mCAAmC;IACnC,OAAO,uBAAuB;AAC/B"}},
    {"offset": {"line": 803, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/customers/customer-autocomplete.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * CustomerAutocomplete Component\n *\n * Reusable autocomplete for customer selection in forms.\n * Features:\n * - Instant search with debouncing\n * - Shows customer details (email, phone, company)\n * - Recent customers quick access\n * - Create new customer option\n * - react-hook-form compatible\n * - Keyboard navigation (arrows, enter, escape)\n */\n\nimport { searchCustomers } from \"@/actions/customers\";\nimport { Avatar, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tCommand,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList,\n\tCommandSeparator,\n} from \"@/components/ui/command\";\nimport {\n\tPopover,\n\tPopoverContent,\n\tPopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport {\n\tgetCustomerDisplayName,\n\tgetCustomerInitials,\n\ttype CustomerDisplayData,\n} from \"@/lib/utils/customer-display\";\nimport {\n\tBuilding2,\n\tCheck,\n\tChevronDown,\n\tChevronsUpDown,\n\tClock,\n\tLoader2,\n\tMail,\n\tPhone,\n\tPlus,\n\tSearch,\n\tUser,\n} from \"lucide-react\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nexport type CustomerOption = {\n\tid: string;\n\tdisplay_name?: string | null;\n\tfirst_name?: string | null;\n\tlast_name?: string | null;\n\tcompany_name?: string | null;\n\temail?: string | null;\n\tphone?: string | null;\n};\n\ninterface CustomerAutocompleteProps {\n\t/** Selected customer ID */\n\tvalue?: string | null;\n\t/** Callback when customer is selected */\n\tonChange: (customerId: string | null, customer: CustomerOption | null) => void;\n\t/** Optional placeholder text */\n\tplaceholder?: string;\n\t/** Optional className for styling */\n\tclassName?: string;\n\t/** Show recent customers section */\n\tshowRecent?: boolean;\n\t/** Optional recent customers list */\n\trecentCustomers?: CustomerOption[];\n\t/** Show \"Create New Customer\" option */\n\tshowCreateNew?: boolean;\n\t/** Callback when \"Create New Customer\" is clicked */\n\tonCreateNew?: () => void;\n\t/** Disabled state */\n\tdisabled?: boolean;\n\t/** Optional label */\n\tlabel?: string;\n\t/** Show error state */\n\terror?: boolean;\n\t/** Error message */\n\terrorMessage?: string;\n}\n\nexport function CustomerAutocomplete({\n\tvalue,\n\tonChange,\n\tplaceholder = \"Search for customer...\",\n\tclassName,\n\tshowRecent = true,\n\trecentCustomers = [],\n\tshowCreateNew = true,\n\tonCreateNew,\n\tdisabled = false,\n\tlabel,\n\terror = false,\n\terrorMessage,\n}: CustomerAutocompleteProps) {\n\tconst [open, setOpen] = useState(false);\n\tconst [search, setSearch] = useState(\"\");\n\tconst [customers, setCustomers] = useState<CustomerOption[]>([]);\n\tconst [loading, setLoading] = useState(false);\n\tconst [selectedCustomer, setSelectedCustomer] = useState<CustomerOption | null>(null);\n\n\t// Debounced search\n\tuseEffect(() => {\n\t\tif (search.trim().length < 2) {\n\t\t\tsetCustomers([]);\n\t\t\tsetLoading(false);\n\t\t\treturn;\n\t\t}\n\n\t\tsetLoading(true);\n\t\tconst timeoutId = setTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tconst result = await searchCustomers(search, { limit: 10 });\n\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\tconst customerArray = Array.isArray(result.data) ? result.data : [result.data];\n\t\t\t\t\tsetCustomers(customerArray as CustomerOption[]);\n\t\t\t\t} else {\n\t\t\t\t\tsetCustomers([]);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Customer search error:\", error);\n\t\t\t\tsetCustomers([]);\n\t\t\t} finally {\n\t\t\t\tsetLoading(false);\n\t\t\t}\n\t\t}, 300);\n\n\t\treturn () => clearTimeout(timeoutId);\n\t}, [search]);\n\n\t// Handle customer selection\n\tconst handleSelectCustomer = useCallback(\n\t\t(customer: CustomerOption) => {\n\t\t\tsetSelectedCustomer(customer);\n\t\t\tonChange(customer.id, customer);\n\t\t\tsetOpen(false);\n\t\t\tsetSearch(\"\");\n\t\t},\n\t\t[onChange]\n\t);\n\n\t// Clear selection\n\tconst handleClear = useCallback(() => {\n\t\tsetSelectedCustomer(null);\n\t\tonChange(null, null);\n\t\tsetSearch(\"\");\n\t}, [onChange]);\n\n\t// Get display name for selected customer\n\tconst displayName = selectedCustomer\n\t\t? getCustomerDisplayName(selectedCustomer)\n\t\t: placeholder;\n\n\t// Combine recent and search results (deduplicate by ID)\n\tconst allCustomers = useMemo(() => {\n\t\tconst customerMap = new Map<string, CustomerOption>();\n\n\t\t// Add search results first (higher priority)\n\t\tcustomers.forEach((c) => customerMap.set(c.id, c));\n\n\t\t// Add recent customers if no search\n\t\tif (search.trim().length < 2 && showRecent) {\n\t\t\trecentCustomers.forEach((c) => customerMap.set(c.id, c));\n\t\t}\n\n\t\treturn Array.from(customerMap.values());\n\t}, [customers, recentCustomers, search, showRecent]);\n\n\t// Customer list item component\n\tconst CustomerListItem = ({ customer }: { customer: CustomerOption }) => {\n\t\tconst name = getCustomerDisplayName(customer);\n\t\tconst initials = getCustomerInitials(customer);\n\t\tconst isSelected = value === customer.id;\n\n\t\treturn (\n\t\t\t<CommandItem\n\t\t\t\tkey={customer.id}\n\t\t\t\tvalue={customer.id}\n\t\t\t\tonSelect={() => handleSelectCustomer(customer)}\n\t\t\t\tclassName=\"flex items-center gap-3 px-3 py-2.5 cursor-pointer\"\n\t\t\t>\n\t\t\t\t<Avatar className=\"h-8 w-8 shrink-0\">\n\t\t\t\t\t<AvatarFallback className=\"text-xs font-semibold\">\n\t\t\t\t\t\t{initials}\n\t\t\t\t\t</AvatarFallback>\n\t\t\t\t</Avatar>\n\n\t\t\t\t<div className=\"flex-1 min-w-0\">\n\t\t\t\t\t<p className=\"font-medium text-sm truncate\">{name}</p>\n\t\t\t\t\t<div className=\"flex items-center gap-2 text-xs text-muted-foreground\">\n\t\t\t\t\t\t{customer.email && (\n\t\t\t\t\t\t\t<span className=\"flex items-center gap-1 truncate\">\n\t\t\t\t\t\t\t\t<Mail className=\"h-3 w-3 shrink-0\" />\n\t\t\t\t\t\t\t\t{customer.email}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{customer.phone && (\n\t\t\t\t\t\t\t<span className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t\t<Phone className=\"h-3 w-3 shrink-0\" />\n\t\t\t\t\t\t\t\t{customer.phone}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t\t{customer.company_name && (\n\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground flex items-center gap-1 mt-0.5\">\n\t\t\t\t\t\t\t<Building2 className=\"h-3 w-3 shrink-0\" />\n\t\t\t\t\t\t\t{customer.company_name}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\n\t\t\t\t{isSelected && (\n\t\t\t\t\t<Check className=\"h-4 w-4 text-primary shrink-0\" />\n\t\t\t\t)}\n\t\t\t</CommandItem>\n\t\t);\n\t};\n\n\treturn (\n\t\t<div className={cn(\"flex flex-col gap-1.5\", className)}>\n\t\t\t{label && (\n\t\t\t\t<label className=\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\">\n\t\t\t\t\t{label}\n\t\t\t\t</label>\n\t\t\t)}\n\n\t\t\t<Popover open={open} onOpenChange={setOpen}>\n\t\t\t\t<PopoverTrigger asChild>\n\t\t\t\t\t<Button\n\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\trole=\"combobox\"\n\t\t\t\t\t\taria-expanded={open}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\"w-full justify-between\",\n\t\t\t\t\t\t\t!selectedCustomer && \"text-muted-foreground\",\n\t\t\t\t\t\t\terror && \"border-destructive focus-visible:ring-destructive\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span className=\"flex items-center gap-2 truncate\">\n\t\t\t\t\t\t\t{selectedCustomer ? (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<User className=\"h-4 w-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t<span className=\"truncate\">{displayName}</span>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<Search className=\"h-4 w-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t<span>{placeholder}</span>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n\t\t\t\t\t</Button>\n\t\t\t\t</PopoverTrigger>\n\n\t\t\t\t<PopoverContent className=\"w-[400px] p-0\" align=\"start\">\n\t\t\t\t\t<Command shouldFilter={false}>\n\t\t\t\t\t\t<CommandInput\n\t\t\t\t\t\t\tplaceholder=\"Search customers...\"\n\t\t\t\t\t\t\tvalue={search}\n\t\t\t\t\t\t\tonValueChange={setSearch}\n\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t\t{loading ? (\n\t\t\t\t\t\t\t\t<div className=\"flex items-center justify-center py-6\">\n\t\t\t\t\t\t\t\t\t<Loader2 className=\"h-5 w-5 animate-spin text-muted-foreground\" />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t{/* Search Results / All Customers */}\n\t\t\t\t\t\t\t\t\t{allCustomers.length > 0 ? (\n\t\t\t\t\t\t\t\t\t\t<CommandGroup\n\t\t\t\t\t\t\t\t\t\t\theading={\n\t\t\t\t\t\t\t\t\t\t\t\tsearch.trim().length >= 2\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"Search Results\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: showRecent && recentCustomers.length > 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"Recent Customers\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"All Customers\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<ScrollArea className=\"max-h-[300px]\">\n\t\t\t\t\t\t\t\t\t\t\t\t{allCustomers.map((customer) => (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CustomerListItem key={customer.id} customer={customer} />\n\t\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t\t</ScrollArea>\n\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t) : search.trim().length >= 2 ? (\n\t\t\t\t\t\t\t\t\t\t<CommandEmpty>No customers found.</CommandEmpty>\n\t\t\t\t\t\t\t\t\t) : showRecent && recentCustomers.length === 0 ? (\n\t\t\t\t\t\t\t\t\t\t<CommandEmpty>Start typing to search for customers...</CommandEmpty>\n\t\t\t\t\t\t\t\t\t) : null}\n\n\t\t\t\t\t\t\t\t\t{/* Create New Customer */}\n\t\t\t\t\t\t\t\t\t{showCreateNew && onCreateNew && (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t<CommandSeparator />\n\t\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetOpen(false);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonCreateNew();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2.5 cursor-pointer text-primary\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Plus className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-medium\">Create New Customer</span>\n\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</CommandList>\n\n\t\t\t\t\t\t{/* Clear Selection */}\n\t\t\t\t\t\t{selectedCustomer && !disabled && (\n\t\t\t\t\t\t\t<div className=\"border-t p-2\">\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tonClick={handleClear}\n\t\t\t\t\t\t\t\t\tclassName=\"w-full text-muted-foreground hover:text-destructive\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tClear Selection\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Command>\n\t\t\t\t</PopoverContent>\n\t\t\t</Popover>\n\n\t\t\t{error && errorMessage && (\n\t\t\t\t<p className=\"text-sm text-destructive\">{errorMessage}</p>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1321, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/quick-appointment-dialog.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * QuickAppointmentDialog Component\n *\n * A streamlined dialog for quickly creating appointments from the dispatch map.\n * Triggered by clicking on the map canvas.\n *\n * Features:\n * - Pre-fills location from map click coordinates\n * - Customer autocomplete with nearby customer suggestions\n * - Technician assignment\n * - Date/time picker with smart defaults\n * - Job type/priority selection\n */\n\nimport { createAppointment } from \"@/actions/appointments\";\nimport { CustomerAutocomplete, type CustomerOption } from \"@/components/customers/customer-autocomplete\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n\tSelect,\n\tSelectContent,\n\tSelectItem,\n\tSelectTrigger,\n\tSelectValue,\n} from \"@/components/ui/select\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { cn } from \"@/lib/utils\";\nimport {\n\tAlertTriangle,\n\tCalendar,\n\tClock,\n\tLoader2,\n\tMapPin,\n\tUser,\n\tWrench,\n} from \"lucide-react\";\nimport { useCallback, useEffect, useState, useTransition } from \"react\";\nimport { format } from \"date-fns\";\n\n// Job types matching the backend schema\n// Valid types: service_call, installation, maintenance, inspection, repair, estimate, follow_up, winterization, emergency\nconst JOB_TYPES = [\n\t{ value: \"emergency\", label: \"Emergency / Urgent\", color: \"text-red-500\" },\n\t{ value: \"follow_up\", label: \"Callback / Follow Up\", color: \"text-orange-500\" },\n\t{ value: \"maintenance\", label: \"Maintenance / Recurring\", color: \"text-purple-500\" },\n\t{ value: \"installation\", label: \"Install / New Work\", color: \"text-green-500\" },\n\t{ value: \"service_call\", label: \"Service Call\", color: \"text-blue-500\" },\n\t{ value: \"inspection\", label: \"Inspection\", color: \"text-slate-500\" },\n\t{ value: \"estimate\", label: \"Estimate\", color: \"text-amber-500\" },\n\t{ value: \"repair\", label: \"Repair\", color: \"text-cyan-500\" },\n\t{ value: \"winterization\", label: \"Winterization\", color: \"text-indigo-500\" },\n] as const;\n\nconst PRIORITIES = [\n\t{ value: \"low\", label: \"Low\", color: \"text-slate-500\" },\n\t{ value: \"normal\", label: \"Normal\", color: \"text-blue-500\" },\n\t{ value: \"high\", label: \"High\", color: \"text-orange-500\" },\n\t{ value: \"urgent\", label: \"Urgent\", color: \"text-red-500\" },\n] as const;\n\nconst DURATIONS = [\n\t{ value: 30, label: \"30 min\" },\n\t{ value: 60, label: \"1 hour\" },\n\t{ value: 90, label: \"1.5 hours\" },\n\t{ value: 120, label: \"2 hours\" },\n\t{ value: 180, label: \"3 hours\" },\n\t{ value: 240, label: \"4 hours\" },\n\t{ value: 480, label: \"Full day\" },\n] as const;\n\nexport type MapClickLocation = {\n\tlat: number;\n\tlng: number;\n\taddress?: string;\n};\n\nexport type TechnicianOption = {\n\tid: string;\n\tname: string;\n\tavatar?: string;\n};\n\ninterface QuickAppointmentDialogProps {\n\topen: boolean;\n\tonOpenChange: (open: boolean) => void;\n\tlocation?: MapClickLocation | null;\n\ttechnicians?: TechnicianOption[];\n\tnearbyCustomers?: CustomerOption[];\n\tonSuccess?: (appointmentId: string) => void;\n\tonCreateCustomer?: () => void;\n\t/** Pre-select a technician (e.g., from timeline double-click) */\n\tdefaultTechnicianId?: string;\n\t/** Pre-fill date/time (e.g., from timeline double-click) */\n\tdefaultDateTime?: Date;\n\t/** Pre-fill duration in minutes (e.g., from timeline drag-to-create) */\n\tdefaultDuration?: number;\n}\n\nexport function QuickAppointmentDialog({\n\topen,\n\tonOpenChange,\n\tlocation,\n\ttechnicians = [],\n\tnearbyCustomers = [],\n\tonSuccess,\n\tonCreateCustomer,\n\tdefaultTechnicianId,\n\tdefaultDateTime,\n\tdefaultDuration,\n}: QuickAppointmentDialogProps) {\n\tconst [isPending, startTransition] = useTransition();\n\tconst [error, setError] = useState<string | null>(null);\n\n\t// Form state\n\tconst [selectedCustomer, setSelectedCustomer] = useState<CustomerOption | null>(null);\n\tconst [customerId, setCustomerId] = useState<string | null>(null);\n\tconst [title, setTitle] = useState(\"\");\n\tconst [jobType, setJobType] = useState<string>(\"service_call\");\n\tconst [priority, setPriority] = useState<string>(\"normal\");\n\tconst [technicianId, setTechnicianId] = useState<string>(\"\");\n\tconst [duration, setDuration] = useState<number>(60);\n\tconst [notes, setNotes] = useState(\"\");\n\n\t// Apply defaults when dialog opens\n\tuseEffect(() => {\n\t\tif (open) {\n\t\t\tif (defaultTechnicianId) {\n\t\t\t\tsetTechnicianId(defaultTechnicianId);\n\t\t\t}\n\t\t\tif (defaultDateTime) {\n\t\t\t\t// Ensure the time is not in the past (server rejects past appointments)\n\t\t\t\tconst now = new Date();\n\t\t\t\tlet adjustedTime = defaultDateTime;\n\t\t\t\tif (defaultDateTime < now) {\n\t\t\t\t\t// Move to the same time slot tomorrow, or next available hour if today\n\t\t\t\t\tadjustedTime = new Date();\n\t\t\t\t\tadjustedTime.setMinutes(0, 0, 0);\n\t\t\t\t\tadjustedTime.setHours(adjustedTime.getHours() + 1);\n\t\t\t\t}\n\t\t\t\tsetScheduledStart(format(adjustedTime, \"yyyy-MM-dd'T'HH:mm\"));\n\t\t\t}\n\t\t\tif (defaultDuration) {\n\t\t\t\t// Snap to nearest valid duration option\n\t\t\t\tconst validDurations = [30, 60, 90, 120, 180, 240, 480];\n\t\t\t\tconst closest = validDurations.reduce((prev, curr) =>\n\t\t\t\t\tMath.abs(curr - defaultDuration) < Math.abs(prev - defaultDuration) ? curr : prev\n\t\t\t\t);\n\t\t\t\tsetDuration(closest);\n\t\t\t}\n\t\t}\n\t}, [open, defaultTechnicianId, defaultDateTime, defaultDuration]);\n\n\t// Date/time - default to next available slot (next hour)\n\tconst getDefaultDateTime = () => {\n\t\tconst now = new Date();\n\t\tnow.setMinutes(0, 0, 0);\n\t\tnow.setHours(now.getHours() + 1);\n\t\treturn now.toISOString().slice(0, 16);\n\t};\n\tconst [scheduledStart, setScheduledStart] = useState(getDefaultDateTime());\n\n\t// Calculate end time based on duration\n\tconst getScheduledEnd = useCallback(() => {\n\t\tconst start = new Date(scheduledStart);\n\t\tstart.setMinutes(start.getMinutes() + duration);\n\t\treturn start.toISOString();\n\t}, [scheduledStart, duration]);\n\n\t// Handle customer selection\n\tconst handleCustomerChange = (id: string | null, customer: CustomerOption | null) => {\n\t\tsetCustomerId(id);\n\t\tsetSelectedCustomer(customer);\n\t\t// Auto-fill title if empty\n\t\tif (customer && !title) {\n\t\t\tconst customerName = customer.display_name ||\n\t\t\t\t`${customer.first_name || \"\"} ${customer.last_name || \"\"}`.trim() ||\n\t\t\t\tcustomer.company_name || \"Customer\";\n\t\t\tsetTitle(`Service call - ${customerName}`);\n\t\t}\n\t};\n\n\t// Reset form\n\tconst resetForm = useCallback(() => {\n\t\tsetSelectedCustomer(null);\n\t\tsetCustomerId(null);\n\t\tsetTitle(\"\");\n\t\tsetJobType(\"service_call\");\n\t\tsetPriority(\"normal\");\n\t\tsetTechnicianId(\"\");\n\t\tsetDuration(60);\n\t\tsetNotes(\"\");\n\t\tsetScheduledStart(getDefaultDateTime());\n\t\tsetError(null);\n\t}, []);\n\n\t// Handle close\n\tconst handleOpenChange = (newOpen: boolean) => {\n\t\tif (!newOpen) {\n\t\t\tresetForm();\n\t\t}\n\t\tonOpenChange(newOpen);\n\t};\n\n\t// Handle form submission\n\tconst handleSubmit = async (e: React.FormEvent) => {\n\t\te.preventDefault();\n\t\tsetError(null);\n\n\t\tif (!customerId) {\n\t\t\tsetError(\"Please select a customer\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!title.trim()) {\n\t\t\tsetError(\"Please enter a title\");\n\t\t\treturn;\n\t\t}\n\n\t\tstartTransition(async () => {\n\t\t\ttry {\n\t\t\t\tconst formData = new FormData();\n\t\t\t\tformData.set(\"customerId\", customerId);\n\t\t\t\tformData.set(\"title\", title.trim());\n\t\t\t\tformData.set(\"scheduledStart\", new Date(scheduledStart).toISOString());\n\t\t\t\tformData.set(\"scheduledEnd\", getScheduledEnd());\n\t\t\t\tformData.set(\"type\", jobType);\n\t\t\t\tformData.set(\"priority\", priority);\n\t\t\t\tformData.set(\"category\", \"job_appointment\");\n\n\t\t\t\tif (technicianId && technicianId !== \"unassigned\") {\n\t\t\t\t\tformData.set(\"assignedTo\", technicianId);\n\t\t\t\t}\n\n\t\t\t\tif (notes.trim()) {\n\t\t\t\t\tformData.set(\"notes\", notes.trim());\n\t\t\t\t}\n\n\t\t\t\t// Add location info to notes if available\n\t\t\t\tif (location?.address) {\n\t\t\t\t\tconst existingNotes = notes.trim();\n\t\t\t\t\tconst locationNote = `Location: ${location.address}`;\n\t\t\t\t\tformData.set(\"notes\", existingNotes ? `${existingNotes}\\n\\n${locationNote}` : locationNote);\n\t\t\t\t}\n\n\t\t\t\tconst result = await createAppointment(formData);\n\n\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\tonSuccess?.(result.data);\n\t\t\t\t\thandleOpenChange(false);\n\t\t\t\t} else {\n\t\t\t\t\tsetError(result.error || \"Failed to create appointment\");\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\"Failed to create appointment:\", err);\n\t\t\t\tsetError(\"An unexpected error occurred\");\n\t\t\t}\n\t\t});\n\t};\n\n\treturn (\n\t\t<Dialog open={open} onOpenChange={handleOpenChange}>\n\t\t\t<DialogContent className=\"sm:max-w-[500px]\">\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle className=\"flex items-center gap-2\">\n\t\t\t\t\t\t<Calendar className=\"h-5 w-5 text-primary\" />\n\t\t\t\t\t\tQuick Appointment\n\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t<DialogDescription>\n\t\t\t\t\t\t{location?.address ? (\n\t\t\t\t\t\t\t<span className=\"flex items-center gap-1 text-sm\">\n\t\t\t\t\t\t\t\t<MapPin className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\t{location.address}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\"Create a new appointment from the dispatch map\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</DialogHeader>\n\n\t\t\t\t<form onSubmit={handleSubmit} className=\"space-y-4\">\n\t\t\t\t\t{/* Customer Selection */}\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<Label htmlFor=\"customer\">Customer *</Label>\n\t\t\t\t\t\t<CustomerAutocomplete\n\t\t\t\t\t\t\tvalue={customerId}\n\t\t\t\t\t\t\tonChange={handleCustomerChange}\n\t\t\t\t\t\t\tplaceholder=\"Search or select customer...\"\n\t\t\t\t\t\t\tshowCreateNew\n\t\t\t\t\t\t\tonCreateNew={onCreateCustomer}\n\t\t\t\t\t\t\tshowRecent\n\t\t\t\t\t\t\trecentCustomers={nearbyCustomers}\n\t\t\t\t\t\t\terror={error?.includes(\"customer\")}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Title */}\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<Label htmlFor=\"title\">Title *</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tid=\"title\"\n\t\t\t\t\t\t\tvalue={title}\n\t\t\t\t\t\t\tonChange={(e) => setTitle(e.target.value)}\n\t\t\t\t\t\t\tplaceholder=\"e.g., AC Repair, Plumbing Inspection\"\n\t\t\t\t\t\t\tclassName={cn(error?.includes(\"title\") && \"border-destructive\")}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Job Type & Priority */}\n\t\t\t\t\t<div className=\"grid grid-cols-2 gap-4\">\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"jobType\">Job Type</Label>\n\t\t\t\t\t\t\t<Select value={jobType} onValueChange={setJobType}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"jobType\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t{JOB_TYPES.map((type) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={type.value} value={type.value}>\n\t\t\t\t\t\t\t\t\t\t\t<span className={cn(\"flex items-center gap-2\", type.color)}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Wrench className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\t\t\t\t\t{type.label}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"priority\">Priority</Label>\n\t\t\t\t\t\t\t<Select value={priority} onValueChange={setPriority}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"priority\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t{PRIORITIES.map((p) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={p.value} value={p.value}>\n\t\t\t\t\t\t\t\t\t\t\t<span className={cn(\"flex items-center gap-2\", p.color)}>\n\t\t\t\t\t\t\t\t\t\t\t\t{p.value === \"urgent\" && <AlertTriangle className=\"h-3.5 w-3.5\" />}\n\t\t\t\t\t\t\t\t\t\t\t\t{p.label}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Date/Time & Duration */}\n\t\t\t\t\t<div className=\"grid grid-cols-2 gap-4\">\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"scheduledStart\">Date & Time</Label>\n\t\t\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t\t\t<Clock className=\"absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tid=\"scheduledStart\"\n\t\t\t\t\t\t\t\t\ttype=\"datetime-local\"\n\t\t\t\t\t\t\t\t\tvalue={scheduledStart}\n\t\t\t\t\t\t\t\t\tonChange={(e) => setScheduledStart(e.target.value)}\n\t\t\t\t\t\t\t\t\tclassName=\"pl-9\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"duration\">Duration</Label>\n\t\t\t\t\t\t\t<Select value={duration.toString()} onValueChange={(v) => setDuration(Number(v))}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"duration\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t{DURATIONS.map((d) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={d.value} value={d.value.toString()}>\n\t\t\t\t\t\t\t\t\t\t\t{d.label}\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Technician Assignment */}\n\t\t\t\t\t{technicians.length > 0 && (\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"technician\">Assign Technician</Label>\n\t\t\t\t\t\t\t<Select value={technicianId} onValueChange={setTechnicianId}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"technician\">\n\t\t\t\t\t\t\t\t\t<SelectValue placeholder=\"Select technician (optional)\" />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t<SelectItem value=\"unassigned\">Unassigned</SelectItem>\n\t\t\t\t\t\t\t\t\t{technicians.map((tech) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={tech.id} value={tech.id}>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<User className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\t\t\t\t\t{tech.name}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Notes */}\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<Label htmlFor=\"notes\">Notes</Label>\n\t\t\t\t\t\t<Textarea\n\t\t\t\t\t\t\tid=\"notes\"\n\t\t\t\t\t\t\tvalue={notes}\n\t\t\t\t\t\t\tonChange={(e) => setNotes(e.target.value)}\n\t\t\t\t\t\t\tplaceholder=\"Additional notes or instructions...\"\n\t\t\t\t\t\t\trows={2}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Error Display */}\n\t\t\t\t\t{error && (\n\t\t\t\t\t\t<div className=\"rounded-md bg-destructive/10 p-3 text-sm text-destructive\">\n\t\t\t\t\t\t\t{error}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t<DialogFooter>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tonClick={() => handleOpenChange(false)}\n\t\t\t\t\t\t\tdisabled={isPending}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tCancel\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button type=\"submit\" disabled={isPending || !customerId}>\n\t\t\t\t\t\t\t{isPending ? (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t\t\t\tCreating...\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\"Create Appointment\"\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</DialogFooter>\n\t\t\t\t</form>\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2191, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA0NsB,qBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 2206, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAuJsB,0BAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 2221, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAihBsB,0BAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 2236, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\n/**\n * Move an existing appointment to a new technician and/or time slot\n * Batches both operations in a single database call for performance\n */\nexport async function moveAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for both assignment and times\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to move appointment\",\n\t\t};\n\t}\n}\n\n/**\n * Assign an unassigned job to a technician with a specific time slot\n * Used when dragging from unassigned panel to a technician lane\n */\nexport async function assignNewAppointment(\n\tscheduleId: string,\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\t// Single atomic update for assignment\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: technicianId,\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to assign appointment\",\n\t\t};\n\t}\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA6esB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 2251, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/context-menu.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 2262, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/schedule-job-context-menu.tsx"],"sourcesContent":["\"use client\";\n\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport {\n\tArchive,\n\tCalendar,\n\tCheckCircle2,\n\tChevronRight,\n\tClock,\n\tCopy,\n\tExternalLink,\n\tMapPin,\n\tMessageSquare,\n\tMoreHorizontal,\n\tNavigation,\n\tPhone,\n\tSend,\n\tTrash2,\n\tTruck,\n\tUserCheck,\n\tUserMinus,\n\tXCircle,\n} from \"lucide-react\";\nimport {\n\tarchiveAppointment,\n\tarriveAppointment,\n\tcancelAppointment,\n\tcancelJobAndAppointment,\n\tcloseAppointment,\n\tcompleteAppointment,\n\tdispatchAppointment,\n\tsendOnMyWayNotification,\n\tunassignAppointment,\n} from \"@/actions/schedule-assignments\";\nimport {\n\tContextMenu,\n\tContextMenuContent,\n\tContextMenuItem,\n\tContextMenuLabel,\n\tContextMenuSeparator,\n\tContextMenuShortcut,\n\tContextMenuSub,\n\tContextMenuSubContent,\n\tContextMenuSubTrigger,\n\tContextMenuTrigger,\n} from \"@/components/ui/context-menu\";\nimport { cn } from \"@/lib/utils\";\nimport type { Job } from \"./schedule-types\";\n\ntype ScheduleJobContextMenuProps = {\n\tjob: Job;\n\tchildren: React.ReactNode;\n\tonOpenChange?: (open: boolean) => void;\n};\n\n// Status workflow order for visual display\nconst STATUS_ORDER = [\"scheduled\", \"dispatched\", \"arrived\", \"in-progress\", \"closed\", \"completed\"];\n\n// Get current status step for progress indicator\nfunction getStatusStep(status: Job[\"status\"]) {\n\tconst idx = STATUS_ORDER.indexOf(status);\n\treturn idx === -1 ? 0 : idx;\n}\n\nexport function ScheduleJobContextMenu({\n\tjob,\n\tchildren,\n\tonOpenChange,\n}: ScheduleJobContextMenuProps) {\n\tconst router = useRouter();\n\tconst currentStep = getStatusStep(job.status);\n\tconst isCancelled = job.status === \"cancelled\";\n\tconst isClosed = job.status === \"closed\" || job.status === \"completed\";\n\n\tconst handleAction = async (\n\t\taction: string,\n\t\tactionFn: (id: string, ...args: unknown[]) => Promise<{ success: boolean; error?: string }>,\n\t\t...args: unknown[]\n\t) => {\n\t\tconst toastId = toast.loading(`${action}...`);\n\t\tconst result = await actionFn(job.id, ...args);\n\n\t\tif (result.success) {\n\t\t\ttoast.success(`${action} successful`, { id: toastId });\n\t\t} else {\n\t\t\ttoast.error(result.error || `Failed to ${action.toLowerCase()}`, {\n\t\t\t\tid: toastId,\n\t\t\t});\n\t\t}\n\t};\n\n\tconst handleSendOnMyWay = async () => {\n\t\tif (!job.customer?.phone) {\n\t\t\ttoast.error(\"Customer has no phone number\");\n\t\t\treturn;\n\t\t}\n\t\tconst techName = job.assignments[0]?.displayName || \"Your technician\";\n\t\tconst address = job.location?.address\n\t\t\t? `${job.location.address.street}, ${job.location.address.city}, ${job.location.address.state}`\n\t\t\t: undefined;\n\n\t\ttoast.loading(\"Sending On My Way notification...\");\n\t\tconst result = await sendOnMyWayNotification(\n\t\t\tjob.id,\n\t\t\ttechName,\n\t\t\tjob.customer.phone,\n\t\t\taddress,\n\t\t);\n\t\ttoast.dismiss();\n\n\t\tif (result.success) {\n\t\t\ttoast.success(\"On My Way notification sent!\");\n\t\t} else {\n\t\t\ttoast.error(result.error || \"Failed to send notification\");\n\t\t}\n\t};\n\n\treturn (\n\t\t<ContextMenu onOpenChange={onOpenChange}>\n\t\t\t<ContextMenuTrigger asChild>{children}</ContextMenuTrigger>\n\n\t\t\t<ContextMenuContent className=\"w-64\">\n\t\t\t\t{/* Header - Job Info */}\n\t\t\t\t<div className=\"px-2 py-2 border-b mb-1\">\n\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\"size-2 rounded-full shrink-0\",\n\t\t\t\t\t\t\t\tjob.status === \"scheduled\" && \"bg-blue-500\",\n\t\t\t\t\t\t\t\tjob.status === \"dispatched\" && \"bg-sky-500\",\n\t\t\t\t\t\t\t\tjob.status === \"arrived\" && \"bg-emerald-400\",\n\t\t\t\t\t\t\t\tjob.status === \"in-progress\" && \"bg-amber-500 animate-pulse\",\n\t\t\t\t\t\t\t\tjob.status === \"closed\" && \"bg-emerald-600\",\n\t\t\t\t\t\t\t\tjob.status === \"completed\" && \"bg-emerald-600\",\n\t\t\t\t\t\t\t\tjob.status === \"cancelled\" && \"bg-slate-400\",\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span className=\"text-sm font-semibold truncate flex-1\">\n\t\t\t\t\t\t\t{job.customer?.name || \"Unknown Customer\"}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<p className=\"text-xs text-muted-foreground mt-0.5 truncate pl-4\">\n\t\t\t\t\t\t{job.title}\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\n\t\t\t\t{/* View Actions */}\n\t\t\t\t<ContextMenuLabel className=\"text-xs text-muted-foreground font-normal\">\n\t\t\t\t\tView\n\t\t\t\t</ContextMenuLabel>\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={!job.jobId}\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\tif (job.jobId) {\n\t\t\t\t\t\t\trouter.push(`/dashboard/work/${job.jobId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<ExternalLink className=\"size-4\" />\n\t\t\t\t\t<span>View Job Details</span>\n\t\t\t\t\t<ContextMenuShortcut>O</ContextMenuShortcut>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t{job.location?.address && (\n\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tconst address = `${job.location?.address?.street}, ${job.location?.address?.city}, ${job.location?.address?.state}`;\n\t\t\t\t\t\t\twindow.open(\n\t\t\t\t\t\t\t\t`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(address)}`,\n\t\t\t\t\t\t\t\t\"_blank\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Navigation className=\"size-4\" />\n\t\t\t\t\t\t<span>Open in Maps</span>\n\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t)}\n\n\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t{/* Status Progression */}\n\t\t\t\t<ContextMenuLabel className=\"text-xs text-muted-foreground font-normal\">\n\t\t\t\t\tUpdate Status\n\t\t\t\t</ContextMenuLabel>\n\n\t\t\t\t{/* Progress indicator */}\n\t\t\t\t{!isCancelled && (\n\t\t\t\t\t<div className=\"px-2 py-1.5 mb-1\">\n\t\t\t\t\t\t<div className=\"flex items-center gap-0.5\">\n\t\t\t\t\t\t\t{STATUS_ORDER.slice(0, -1).map((status, idx) => (\n\t\t\t\t\t\t\t\t<div key={status} className=\"flex items-center flex-1\">\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\"h-1 flex-1 rounded-full transition-colors\",\n\t\t\t\t\t\t\t\t\t\t\tidx < currentStep\n\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-emerald-500\"\n\t\t\t\t\t\t\t\t\t\t\t\t: idx === currentStep\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-blue-500\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"bg-muted\",\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p className=\"text-[10px] text-muted-foreground mt-1 text-center capitalize\">\n\t\t\t\t\t\t\tCurrent: {job.status.replace(\"-\", \" \")}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={currentStep >= 1 || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Dispatching\", dispatchAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<Truck className=\"size-4\" />\n\t\t\t\t\t<span>Mark Dispatched</span>\n\t\t\t\t\t{currentStep >= 1 && !isCancelled && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t{job.customer?.phone && (\n\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\tdisabled={currentStep >= 2 || isCancelled}\n\t\t\t\t\t\tonClick={handleSendOnMyWay}\n\t\t\t\t\t\tclassName=\"text-sky-600 dark:text-sky-400\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Send className=\"size-4\" />\n\t\t\t\t\t\t<span>Send \"On My Way\" SMS</span>\n\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t)}\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={currentStep >= 2 || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Marking arrived\", arriveAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<MapPin className=\"size-4\" />\n\t\t\t\t\t<span>Mark Arrived</span>\n\t\t\t\t\t{currentStep >= 2 && !isCancelled && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={currentStep >= 4 || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Closing\", closeAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<UserCheck className=\"size-4\" />\n\t\t\t\t\t<span>Mark Closed</span>\n\t\t\t\t\t{currentStep >= 4 && !isCancelled && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={isClosed || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Completing\", completeAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<CheckCircle2 className=\"size-4\" />\n\t\t\t\t\t<span>Mark Complete</span>\n\t\t\t\t\t{(job.status === \"completed\") && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t{/* Communication */}\n\t\t\t\t{(job.customer?.phone || job.customer?.email) && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<ContextMenuSub>\n\t\t\t\t\t\t\t<ContextMenuSubTrigger>\n\t\t\t\t\t\t\t\t<MessageSquare className=\"size-4\" />\n\t\t\t\t\t\t\t\t<span>Contact Customer</span>\n\t\t\t\t\t\t\t</ContextMenuSubTrigger>\n\t\t\t\t\t\t\t<ContextMenuSubContent className=\"w-48\">\n\t\t\t\t\t\t\t\t{job.customer?.phone && (\n\t\t\t\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\twindow.location.href = `tel:${job.customer?.phone}`;\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Phone className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t<span>Call {job.customer.phone}</span>\n\t\t\t\t\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{job.customer?.phone && (\n\t\t\t\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\twindow.location.href = `sms:${job.customer?.phone}`;\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<MessageSquare className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t<span>Send SMS</span>\n\t\t\t\t\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</ContextMenuSubContent>\n\t\t\t\t\t\t</ContextMenuSub>\n\t\t\t\t\t\t<ContextMenuSeparator />\n\t\t\t\t\t</>\n\t\t\t\t)}\n\n\t\t\t\t{/* Scheduling Actions */}\n\t\t\t\t<ContextMenuLabel className=\"text-xs text-muted-foreground font-normal\">\n\t\t\t\t\tSchedule\n\t\t\t\t</ContextMenuLabel>\n\n\t\t\t\t<ContextMenuItem>\n\t\t\t\t\t<Calendar className=\"size-4\" />\n\t\t\t\t\t<span>Reschedule</span>\n\t\t\t\t\t<ContextMenuShortcut>R</ContextMenuShortcut>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem>\n\t\t\t\t\t<Copy className=\"size-4\" />\n\t\t\t\t\t<span>Duplicate</span>\n\t\t\t\t\t<ContextMenuShortcut>D</ContextMenuShortcut>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tonClick={() => handleAction(\"Moving to Unscheduled\", unassignAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<UserMinus className=\"size-4\" />\n\t\t\t\t\t<span>Move to Unscheduled</span>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t{/* Danger Zone */}\n\t\t\t\t<ContextMenuSub>\n\t\t\t\t\t<ContextMenuSubTrigger className=\"text-destructive focus:text-destructive\">\n\t\t\t\t\t\t<MoreHorizontal className=\"size-4\" />\n\t\t\t\t\t\t<span>More Actions</span>\n\t\t\t\t\t</ContextMenuSubTrigger>\n\t\t\t\t\t<ContextMenuSubContent className=\"w-56\">\n\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\tclassName=\"text-orange-600 focus:text-orange-600 dark:text-orange-400 dark:focus:text-orange-400\"\n\t\t\t\t\t\t\tdisabled={isCancelled}\n\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\thandleAction(\"Cancelling appointment\", cancelAppointment)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<XCircle className=\"size-4\" />\n\t\t\t\t\t\t\t<span>Cancel Appointment Only</span>\n\t\t\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\tdisabled={isCancelled || !job.jobId}\n\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\thandleAction(\"Cancelling job & appointment\", (scheduleId) =>\n\t\t\t\t\t\t\t\t\tcancelJobAndAppointment(scheduleId as string, job.jobId ?? \"\"),\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Trash2 className=\"size-4\" />\n\t\t\t\t\t\t\t<span>Cancel Job & Appointment</span>\n\t\t\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\tonClick={() => handleAction(\"Archiving\", archiveAppointment)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Archive className=\"size-4\" />\n\t\t\t\t\t\t\t<span>Archive</span>\n\t\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t\t</ContextMenuSubContent>\n\t\t\t\t</ContextMenuSub>\n\t\t\t</ContextMenuContent>\n\t\t</ContextMenu>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3029, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/schedule-utils.ts"],"sourcesContent":["import type {\n\tAddress,\n\tCustomer,\n\tJob,\n\tJobAssignment,\n\tLegacyJob,\n\tLocation,\n\tTechnician,\n\tTechnicianSchedule,\n} from \"@/components/schedule/schedule-types\";\n\n/**\n * Utilities for schedule management\n */\n\n// ============================================\n// CONFLICT DETECTION\n// ============================================\n\nfunction hasTimeConflict(\n\tjob1Start: Date | string,\n\tjob1End: Date | string,\n\tjob2Start: Date | string,\n\tjob2End: Date | string,\n): boolean {\n\tconst start1 = job1Start instanceof Date ? job1Start : new Date(job1Start);\n\tconst end1 = job1End instanceof Date ? job1End : new Date(job1End);\n\tconst start2 = job2Start instanceof Date ? job2Start : new Date(job2Start);\n\tconst end2 = job2End instanceof Date ? job2End : new Date(job2End);\n\n\treturn (\n\t\t(start1 >= start2 && start1 < end2) ||\n\t\t(end1 > start2 && end1 <= end2) ||\n\t\t(start1 <= start2 && end1 >= end2)\n\t);\n}\n\nfunction findConflictingJobs(\n\tjobs: Job[],\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n\texcludeJobId?: string,\n): Job[] {\n\treturn jobs.filter((job) => {\n\t\tif (excludeJobId && job.id === excludeJobId) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!jobHasTechnician(job, technicianId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasTimeConflict(startTime, endTime, job.startTime, job.endTime);\n\t});\n}\n\n// ============================================\n// MIGRATION UTILITIES\n// ============================================\n\nfunction legacyJobToJob(legacy: LegacyJob, technicianId: string): Job {\n\tconst today = new Date();\n\ttoday.setHours(0, 0, 0, 0);\n\n\t// Parse time strings\n\tconst [startHour, startMin] = legacy.startTime.split(\":\").map(Number);\n\tconst [endHour, endMin] = legacy.endTime.split(\":\").map(Number);\n\n\tconst startTime = new Date(today);\n\tstartTime.setHours(startHour, startMin, 0, 0);\n\n\tconst endTime = new Date(today);\n\tendTime.setHours(endHour, endMin, 0, 0);\n\n\t// Create address and location\n\tconst address: Address = {\n\t\tstreet: legacy.address,\n\t\tcity: \"\",\n\t\tstate: \"\",\n\t\tzip: \"\",\n\t\tcountry: \"USA\",\n\t};\n\n\tconst location: Location = {\n\t\taddress,\n\t\tcoordinates: {\n\t\t\tlat: legacy.lat,\n\t\t\tlng: legacy.lng,\n\t\t},\n\t};\n\n\t// Create customer\n\tconst customer: Customer = {\n\t\tid: `customer-${legacy.customer.toLowerCase().replace(/\\s+/g, \"-\")}`,\n\t\tname: legacy.customer,\n\t\tlocation,\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date(),\n\t};\n\n\t// Calculate estimated duration in minutes\n\tconst estimatedDuration = legacy.estimatedDuration\n\t\t? Number.parseFloat(legacy.estimatedDuration.replace(/[^\\d.]/g, \"\")) * 60\n\t\t: undefined;\n\n\tconst assignments: JobAssignment[] = technicianId\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\ttechnicianId,\n\t\t\t\t\tteamMemberId: undefined,\n\t\t\t\t\tdisplayName: \"Technician\",\n\t\t\t\t\tavatar: null,\n\t\t\t\t\trole: \"primary\",\n\t\t\t\t\tstatus: \"available\",\n\t\t\t\t\tisActive: true,\n\t\t\t\t},\n\t\t\t]\n\t\t: [];\n\n\treturn {\n\t\tid: legacy.id,\n\t\ttechnicianId,\n\t\tassignments,\n\t\tisUnassigned: assignments.length === 0,\n\t\ttitle: legacy.title,\n\t\tdescription: legacy.description,\n\t\tcustomer,\n\t\tlocation,\n\t\tstartTime,\n\t\tendTime,\n\t\tstatus: legacy.status,\n\t\tpriority: legacy.priority,\n\t\tmetadata: {\n\t\t\testimatedDuration,\n\t\t},\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date(),\n\t};\n}\n\n// ============================================\n// TIME CALCULATIONS\n// ============================================\n\nfunction calculateDuration(\n\tstartTime: Date | string,\n\tendTime: Date | string,\n): number {\n\tconst start = startTime instanceof Date ? startTime : new Date(startTime);\n\tconst end = endTime instanceof Date ? endTime : new Date(endTime);\n\treturn Math.round((end.getTime() - start.getTime()) / (1000 * 60)); // minutes\n}\n\nfunction formatDuration(minutes: number): string {\n\tif (minutes < 60) {\n\t\treturn `${minutes}m`;\n\t}\n\n\tconst hours = Math.floor(minutes / 60);\n\tconst mins = minutes % 60;\n\n\treturn mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;\n}\n\nfunction addMinutes(date: Date, minutes: number): Date {\n\treturn new Date(date.getTime() + minutes * 60 * 1000);\n}\n\n// ============================================\n// WORK HOURS CALCULATIONS\n// ============================================\n\nfunction calculateWorkload(\n\tjobs: Job[],\n\ttechnicianSchedule: TechnicianSchedule,\n\tdate: Date,\n): {\n\ttotalMinutes: number;\n\tavailableMinutes: number;\n\tutilizationRate: number;\n} {\n\tconst dayStart = new Date(date);\n\tdayStart.setHours(technicianSchedule.availableHours.start, 0, 0, 0);\n\n\tconst dayEnd = new Date(date);\n\tdayEnd.setHours(technicianSchedule.availableHours.end, 0, 0, 0);\n\n\tconst availableMinutes = calculateDuration(dayStart, dayEnd);\n\n\t// Calculate total job duration for this day\n\tconst totalMinutes = jobs.reduce((sum, job) => {\n\t\t// Check if job is on this date\n\t\tif (\n\t\t\tjob.startTime.toDateString() === date.toDateString() ||\n\t\t\tjob.endTime.toDateString() === date.toDateString()\n\t\t) {\n\t\t\treturn sum + calculateDuration(job.startTime, job.endTime);\n\t\t}\n\t\treturn sum;\n\t}, 0);\n\n\tconst utilizationRate =\n\t\tavailableMinutes > 0 ? (totalMinutes / availableMinutes) * 100 : 0;\n\n\treturn {\n\t\ttotalMinutes,\n\t\tavailableMinutes,\n\t\tutilizationRate: Math.min(utilizationRate, 100),\n\t};\n}\n\n// ============================================\n// DATE UTILITIES\n// ============================================\n\nfunction isSameDay(date1: Date, date2: Date): boolean {\n\treturn (\n\t\tdate1.getFullYear() === date2.getFullYear() &&\n\t\tdate1.getMonth() === date2.getMonth() &&\n\t\tdate1.getDate() === date2.getDate()\n\t);\n}\n\nfunction isToday(date: Date): boolean {\n\treturn isSameDay(date, new Date());\n}\n\nexport function startOfDay(date: Date): Date {\n\tconst result = new Date(date);\n\tresult.setHours(0, 0, 0, 0);\n\treturn result;\n}\n\nexport function endOfDay(date: Date): Date {\n\tconst result = new Date(date);\n\tresult.setHours(23, 59, 59, 999);\n\treturn result;\n}\n\n// ============================================\n// RECURRING JOBS\n// ============================================\n\nfunction generateRecurringJobInstances(\n\tbaseJob: Job,\n\tstartDate: Date,\n\tendDate: Date,\n): Job[] {\n\tif (!baseJob.recurrence) {\n\t\treturn [baseJob];\n\t}\n\n\tconst instances: Job[] = [];\n\tconst {\n\t\tfrequency,\n\t\tinterval,\n\t\tcount,\n\t\tendDate: recurrenceEndDate,\n\t} = baseJob.recurrence;\n\n\tconst currentDate = new Date(baseJob.startTime);\n\tlet instanceCount = 0;\n\n\twhile (currentDate <= endDate) {\n\t\tif (currentDate >= startDate) {\n\t\t\t// Calculate job duration\n\t\t\tconst duration = calculateDuration(baseJob.startTime, baseJob.endTime);\n\n\t\t\t// Create new instance\n\t\t\tconst instance: Job = {\n\t\t\t\t...baseJob,\n\t\t\t\tid: `${baseJob.id}-instance-${instanceCount}`,\n\t\t\t\tparentJobId: baseJob.id,\n\t\t\t\tstartTime: new Date(currentDate),\n\t\t\t\tendTime: addMinutes(new Date(currentDate), duration),\n\t\t\t};\n\n\t\t\tinstances.push(instance);\n\t\t}\n\n\t\t// Move to next occurrence\n\t\tinstanceCount++;\n\n\t\tif (count && instanceCount >= count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (recurrenceEndDate && currentDate >= recurrenceEndDate) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (frequency) {\n\t\t\tcase \"daily\":\n\t\t\t\tcurrentDate.setDate(currentDate.getDate() + interval);\n\t\t\t\tbreak;\n\t\t\tcase \"weekly\":\n\t\t\t\tcurrentDate.setDate(currentDate.getDate() + interval * 7);\n\t\t\t\tbreak;\n\t\t\tcase \"monthly\":\n\t\t\t\tcurrentDate.setMonth(currentDate.getMonth() + interval);\n\t\t\t\tbreak;\n\t\t\tcase \"yearly\":\n\t\t\t\tcurrentDate.setFullYear(currentDate.getFullYear() + interval);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn instances;\n}\n\n// ============================================\n// FILTERING\n// ============================================\n\nexport function filterJobs(\n\tjobs: Job[],\n\tfilters: {\n\t\ttechnicianIds?: string[];\n\t\tstatuses?: Job[\"status\"][];\n\t\tpriorities?: Job[\"priority\"][];\n\t\tsearchQuery?: string;\n\t},\n): Job[] {\n\treturn jobs.filter((job) => {\n\t\t// Filter by technician\n\t\tif (\n\t\t\tfilters.technicianIds &&\n\t\t\tfilters.technicianIds.length > 0 &&\n\t\t\t!filters.technicianIds.some((technicianId) =>\n\t\t\t\tjobHasTechnician(job, technicianId),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Filter by status\n\t\tif (\n\t\t\tfilters.statuses &&\n\t\t\tfilters.statuses.length > 0 &&\n\t\t\t!filters.statuses.includes(job.status)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Filter by priority\n\t\tif (\n\t\t\tfilters.priorities &&\n\t\t\tfilters.priorities.length > 0 &&\n\t\t\t!filters.priorities.includes(job.priority)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Filter by search query\n\t\tif (filters.searchQuery && filters.searchQuery.trim() !== \"\") {\n\t\t\tconst query = filters.searchQuery.toLowerCase();\n\t\t\tconst matchesTitle = job.title.toLowerCase().includes(query);\n\t\t\tconst matchesCustomer = job.customer.name.toLowerCase().includes(query);\n\t\t\tconst matchesDescription = job.description?.toLowerCase().includes(query);\n\n\t\t\tif (!(matchesTitle || matchesCustomer || matchesDescription)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n// ============================================\n// SORTING\n// ============================================\n\nexport function sortJobsByStartTime(jobs: Job[]): Job[] {\n\treturn [...jobs].sort((a, b) => {\n\t\t// Ensure dates are Date objects\n\t\tconst aTime =\n\t\t\ta.startTime instanceof Date ? a.startTime : new Date(a.startTime);\n\t\tconst bTime =\n\t\t\tb.startTime instanceof Date ? b.startTime : new Date(b.startTime);\n\t\treturn aTime.getTime() - bTime.getTime();\n\t});\n}\n\nfunction sortTechniciansByName(technicians: Technician[]): Technician[] {\n\treturn [...technicians].sort((a, b) => a.name.localeCompare(b.name));\n}\n\n// ============================================\n// VALIDATION\n// ============================================\n\nfunction validateJobTimes(\n\tstartTime: Date,\n\tendTime: Date,\n): {\n\tvalid: boolean;\n\terror?: string;\n} {\n\tif (startTime >= endTime) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: \"End time must be after start time\",\n\t\t};\n\t}\n\n\tconst duration = calculateDuration(startTime, endTime);\n\tif (duration < 15) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: \"Job must be at least 15 minutes long\",\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\nfunction validateJob(job: Partial<Job>): {\n\tvalid: boolean;\n\terrors: string[];\n} {\n\tconst errors: string[] = [];\n\n\tif (!job.title || job.title.trim() === \"\") {\n\t\terrors.push(\"Title is required\");\n\t}\n\n\tconst hasTechnician =\n\t\t!!job.technicianId ||\n\t\tjob.assignments?.some((assignment) => assignment.technicianId);\n\n\tif (!hasTechnician) {\n\t\terrors.push(\"Technician must be assigned\");\n\t}\n\n\tif (!job.startTime) {\n\t\terrors.push(\"Start time is required\");\n\t}\n\n\tif (!job.endTime) {\n\t\terrors.push(\"End time is required\");\n\t}\n\n\tif (job.startTime && job.endTime) {\n\t\tconst timeValidation = validateJobTimes(job.startTime, job.endTime);\n\t\tif (!timeValidation.valid) {\n\t\t\terrors.push(timeValidation.error!);\n\t\t}\n\t}\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t};\n}\n\nfunction jobHasTechnician(job: Job, technicianId: string): boolean {\n\tif (job.technicianId === technicianId) {\n\t\treturn true;\n\t}\n\n\treturn job.assignments.some(\n\t\t(assignment) => assignment.technicianId === technicianId,\n\t);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAWA;;CAEC,GAED,+CAA+C;AAC/C,qBAAqB;AACrB,+CAA+C;AAE/C,SAAS,gBACR,SAAwB,EACxB,OAAsB,EACtB,SAAwB,EACxB,OAAsB;IAEtB,MAAM,SAAS,qBAAqB,OAAO,YAAY,IAAI,KAAK;IAChE,MAAM,OAAO,mBAAmB,OAAO,UAAU,IAAI,KAAK;IAC1D,MAAM,SAAS,qBAAqB,OAAO,YAAY,IAAI,KAAK;IAChE,MAAM,OAAO,mBAAmB,OAAO,UAAU,IAAI,KAAK;IAE1D,OACC,AAAC,UAAU,UAAU,SAAS,QAC7B,OAAO,UAAU,QAAQ,QACzB,UAAU,UAAU,QAAQ;AAE/B;AAEA,SAAS,oBACR,IAAW,EACX,YAAoB,EACpB,SAAe,EACf,OAAa,EACb,YAAqB;IAErB,OAAO,KAAK,MAAM,CAAC,CAAC;QACnB,IAAI,gBAAgB,IAAI,EAAE,KAAK,cAAc;YAC5C,OAAO;QACR;QACA,IAAI,CAAC,iBAAiB,KAAK,eAAe;YACzC,OAAO;QACR;QAEA,OAAO,gBAAgB,WAAW,SAAS,IAAI,SAAS,EAAE,IAAI,OAAO;IACtE;AACD;AAEA,+CAA+C;AAC/C,sBAAsB;AACtB,+CAA+C;AAE/C,SAAS,eAAe,MAAiB,EAAE,YAAoB;IAC9D,MAAM,QAAQ,IAAI;IAClB,MAAM,QAAQ,CAAC,GAAG,GAAG,GAAG;IAExB,qBAAqB;IACrB,MAAM,CAAC,WAAW,SAAS,GAAG,OAAO,SAAS,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC;IAC9D,MAAM,CAAC,SAAS,OAAO,GAAG,OAAO,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC;IAExD,MAAM,YAAY,IAAI,KAAK;IAC3B,UAAU,QAAQ,CAAC,WAAW,UAAU,GAAG;IAE3C,MAAM,UAAU,IAAI,KAAK;IACzB,QAAQ,QAAQ,CAAC,SAAS,QAAQ,GAAG;IAErC,8BAA8B;IAC9B,MAAM,UAAmB;QACxB,QAAQ,OAAO,OAAO;QACtB,MAAM;QACN,OAAO;QACP,KAAK;QACL,SAAS;IACV;IAEA,MAAM,WAAqB;QAC1B;QACA,aAAa;YACZ,KAAK,OAAO,GAAG;YACf,KAAK,OAAO,GAAG;QAChB;IACD;IAEA,kBAAkB;IAClB,MAAM,WAAqB;QAC1B,IAAI,CAAC,SAAS,EAAE,OAAO,QAAQ,CAAC,WAAW,GAAG,OAAO,CAAC,QAAQ,MAAM;QACpE,MAAM,OAAO,QAAQ;QACrB;QACA,WAAW,IAAI;QACf,WAAW,IAAI;IAChB;IAEA,0CAA0C;IAC1C,MAAM,oBAAoB,OAAO,iBAAiB,GAC/C,OAAO,UAAU,CAAC,OAAO,iBAAiB,CAAC,OAAO,CAAC,WAAW,OAAO,KACrE;IAEH,MAAM,cAA+B,eAClC;QACA;YACC;YACA,cAAc;YACd,aAAa;YACb,QAAQ;YACR,MAAM;YACN,QAAQ;YACR,UAAU;QACX;KACA,GACA,EAAE;IAEL,OAAO;QACN,IAAI,OAAO,EAAE;QACb;QACA;QACA,cAAc,YAAY,MAAM,KAAK;QACrC,OAAO,OAAO,KAAK;QACnB,aAAa,OAAO,WAAW;QAC/B;QACA;QACA;QACA;QACA,QAAQ,OAAO,MAAM;QACrB,UAAU,OAAO,QAAQ;QACzB,UAAU;YACT;QACD;QACA,WAAW,IAAI;QACf,WAAW,IAAI;IAChB;AACD;AAEA,+CAA+C;AAC/C,oBAAoB;AACpB,+CAA+C;AAE/C,SAAS,kBACR,SAAwB,EACxB,OAAsB;IAEtB,MAAM,QAAQ,qBAAqB,OAAO,YAAY,IAAI,KAAK;IAC/D,MAAM,MAAM,mBAAmB,OAAO,UAAU,IAAI,KAAK;IACzD,OAAO,KAAK,KAAK,CAAC,CAAC,IAAI,OAAO,KAAK,MAAM,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,UAAU;AAC/E;AAEA,SAAS,eAAe,OAAe;IACtC,IAAI,UAAU,IAAI;QACjB,OAAO,GAAG,QAAQ,CAAC,CAAC;IACrB;IAEA,MAAM,QAAQ,KAAK,KAAK,CAAC,UAAU;IACnC,MAAM,OAAO,UAAU;IAEvB,OAAO,OAAO,IAAI,GAAG,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC;AACrD;AAEA,SAAS,WAAW,IAAU,EAAE,OAAe;IAC9C,OAAO,IAAI,KAAK,KAAK,OAAO,KAAK,UAAU,KAAK;AACjD;AAEA,+CAA+C;AAC/C,0BAA0B;AAC1B,+CAA+C;AAE/C,SAAS,kBACR,IAAW,EACX,kBAAsC,EACtC,IAAU;IAMV,MAAM,WAAW,IAAI,KAAK;IAC1B,SAAS,QAAQ,CAAC,mBAAmB,cAAc,CAAC,KAAK,EAAE,GAAG,GAAG;IAEjE,MAAM,SAAS,IAAI,KAAK;IACxB,OAAO,QAAQ,CAAC,mBAAmB,cAAc,CAAC,GAAG,EAAE,GAAG,GAAG;IAE7D,MAAM,mBAAmB,kBAAkB,UAAU;IAErD,4CAA4C;IAC5C,MAAM,eAAe,KAAK,MAAM,CAAC,CAAC,KAAK;QACtC,+BAA+B;QAC/B,IACC,IAAI,SAAS,CAAC,YAAY,OAAO,KAAK,YAAY,MAClD,IAAI,OAAO,CAAC,YAAY,OAAO,KAAK,YAAY,IAC/C;YACD,OAAO,MAAM,kBAAkB,IAAI,SAAS,EAAE,IAAI,OAAO;QAC1D;QACA,OAAO;IACR,GAAG;IAEH,MAAM,kBACL,mBAAmB,IAAI,AAAC,eAAe,mBAAoB,MAAM;IAElE,OAAO;QACN;QACA;QACA,iBAAiB,KAAK,GAAG,CAAC,iBAAiB;IAC5C;AACD;AAEA,+CAA+C;AAC/C,iBAAiB;AACjB,+CAA+C;AAE/C,SAAS,UAAU,KAAW,EAAE,KAAW;IAC1C,OACC,MAAM,WAAW,OAAO,MAAM,WAAW,MACzC,MAAM,QAAQ,OAAO,MAAM,QAAQ,MACnC,MAAM,OAAO,OAAO,MAAM,OAAO;AAEnC;AAEA,SAAS,QAAQ,IAAU;IAC1B,OAAO,UAAU,MAAM,IAAI;AAC5B;AAEO,SAAS,WAAW,IAAU;IACpC,MAAM,SAAS,IAAI,KAAK;IACxB,OAAO,QAAQ,CAAC,GAAG,GAAG,GAAG;IACzB,OAAO;AACR;AAEO,SAAS,SAAS,IAAU;IAClC,MAAM,SAAS,IAAI,KAAK;IACxB,OAAO,QAAQ,CAAC,IAAI,IAAI,IAAI;IAC5B,OAAO;AACR;AAEA,+CAA+C;AAC/C,iBAAiB;AACjB,+CAA+C;AAE/C,SAAS,8BACR,OAAY,EACZ,SAAe,EACf,OAAa;IAEb,IAAI,CAAC,QAAQ,UAAU,EAAE;QACxB,OAAO;YAAC;SAAQ;IACjB;IAEA,MAAM,YAAmB,EAAE;IAC3B,MAAM,EACL,SAAS,EACT,QAAQ,EACR,KAAK,EACL,SAAS,iBAAiB,EAC1B,GAAG,QAAQ,UAAU;IAEtB,MAAM,cAAc,IAAI,KAAK,QAAQ,SAAS;IAC9C,IAAI,gBAAgB;IAEpB,MAAO,eAAe,QAAS;QAC9B,IAAI,eAAe,WAAW;YAC7B,yBAAyB;YACzB,MAAM,WAAW,kBAAkB,QAAQ,SAAS,EAAE,QAAQ,OAAO;YAErE,sBAAsB;YACtB,MAAM,WAAgB;gBACrB,GAAG,OAAO;gBACV,IAAI,GAAG,QAAQ,EAAE,CAAC,UAAU,EAAE,eAAe;gBAC7C,aAAa,QAAQ,EAAE;gBACvB,WAAW,IAAI,KAAK;gBACpB,SAAS,WAAW,IAAI,KAAK,cAAc;YAC5C;YAEA,UAAU,IAAI,CAAC;QAChB;QAEA,0BAA0B;QAC1B;QAEA,IAAI,SAAS,iBAAiB,OAAO;YACpC;QACD;QACA,IAAI,qBAAqB,eAAe,mBAAmB;YAC1D;QACD;QAEA,OAAQ;YACP,KAAK;gBACJ,YAAY,OAAO,CAAC,YAAY,OAAO,KAAK;gBAC5C;YACD,KAAK;gBACJ,YAAY,OAAO,CAAC,YAAY,OAAO,KAAK,WAAW;gBACvD;YACD,KAAK;gBACJ,YAAY,QAAQ,CAAC,YAAY,QAAQ,KAAK;gBAC9C;YACD,KAAK;gBACJ,YAAY,WAAW,CAAC,YAAY,WAAW,KAAK;gBACpD;QACF;IACD;IAEA,OAAO;AACR;AAMO,SAAS,WACf,IAAW,EACX,OAKC;IAED,OAAO,KAAK,MAAM,CAAC,CAAC;QACnB,uBAAuB;QACvB,IACC,QAAQ,aAAa,IACrB,QAAQ,aAAa,CAAC,MAAM,GAAG,KAC/B,CAAC,QAAQ,aAAa,CAAC,IAAI,CAAC,CAAC,eAC5B,iBAAiB,KAAK,gBAEtB;YACD,OAAO;QACR;QAEA,mBAAmB;QACnB,IACC,QAAQ,QAAQ,IAChB,QAAQ,QAAQ,CAAC,MAAM,GAAG,KAC1B,CAAC,QAAQ,QAAQ,CAAC,QAAQ,CAAC,IAAI,MAAM,GACpC;YACD,OAAO;QACR;QAEA,qBAAqB;QACrB,IACC,QAAQ,UAAU,IAClB,QAAQ,UAAU,CAAC,MAAM,GAAG,KAC5B,CAAC,QAAQ,UAAU,CAAC,QAAQ,CAAC,IAAI,QAAQ,GACxC;YACD,OAAO;QACR;QAEA,yBAAyB;QACzB,IAAI,QAAQ,WAAW,IAAI,QAAQ,WAAW,CAAC,IAAI,OAAO,IAAI;YAC7D,MAAM,QAAQ,QAAQ,WAAW,CAAC,WAAW;YAC7C,MAAM,eAAe,IAAI,KAAK,CAAC,WAAW,GAAG,QAAQ,CAAC;YACtD,MAAM,kBAAkB,IAAI,QAAQ,CAAC,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC;YACjE,MAAM,qBAAqB,IAAI,WAAW,EAAE,cAAc,SAAS;YAEnE,IAAI,CAAC,CAAC,gBAAgB,mBAAmB,kBAAkB,GAAG;gBAC7D,OAAO;YACR;QACD;QAEA,OAAO;IACR;AACD;AAMO,SAAS,oBAAoB,IAAW;IAC9C,OAAO;WAAI;KAAK,CAAC,IAAI,CAAC,CAAC,GAAG;QACzB,gCAAgC;QAChC,MAAM,QACL,EAAE,SAAS,YAAY,OAAO,EAAE,SAAS,GAAG,IAAI,KAAK,EAAE,SAAS;QACjE,MAAM,QACL,EAAE,SAAS,YAAY,OAAO,EAAE,SAAS,GAAG,IAAI,KAAK,EAAE,SAAS;QACjE,OAAO,MAAM,OAAO,KAAK,MAAM,OAAO;IACvC;AACD;AAEA,SAAS,sBAAsB,WAAyB;IACvD,OAAO;WAAI;KAAY,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;AACnE;AAEA,+CAA+C;AAC/C,aAAa;AACb,+CAA+C;AAE/C,SAAS,iBACR,SAAe,EACf,OAAa;IAKb,IAAI,aAAa,SAAS;QACzB,OAAO;YACN,OAAO;YACP,OAAO;QACR;IACD;IAEA,MAAM,WAAW,kBAAkB,WAAW;IAC9C,IAAI,WAAW,IAAI;QAClB,OAAO;YACN,OAAO;YACP,OAAO;QACR;IACD;IAEA,OAAO;QAAE,OAAO;IAAK;AACtB;AAEA,SAAS,YAAY,GAAiB;IAIrC,MAAM,SAAmB,EAAE;IAE3B,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,IAAI,OAAO,IAAI;QAC1C,OAAO,IAAI,CAAC;IACb;IAEA,MAAM,gBACL,CAAC,CAAC,IAAI,YAAY,IAClB,IAAI,WAAW,EAAE,KAAK,CAAC,aAAe,WAAW,YAAY;IAE9D,IAAI,CAAC,eAAe;QACnB,OAAO,IAAI,CAAC;IACb;IAEA,IAAI,CAAC,IAAI,SAAS,EAAE;QACnB,OAAO,IAAI,CAAC;IACb;IAEA,IAAI,CAAC,IAAI,OAAO,EAAE;QACjB,OAAO,IAAI,CAAC;IACb;IAEA,IAAI,IAAI,SAAS,IAAI,IAAI,OAAO,EAAE;QACjC,MAAM,iBAAiB,iBAAiB,IAAI,SAAS,EAAE,IAAI,OAAO;QAClE,IAAI,CAAC,eAAe,KAAK,EAAE;YAC1B,OAAO,IAAI,CAAC,eAAe,KAAK;QACjC;IACD;IAEA,OAAO;QACN,OAAO,OAAO,MAAM,KAAK;QACzB;IACD;AACD;AAEA,SAAS,iBAAiB,GAAQ,EAAE,YAAoB;IACvD,IAAI,IAAI,YAAY,KAAK,cAAc;QACtC,OAAO;IACR;IAEA,OAAO,IAAI,WAAW,CAAC,IAAI,CAC1B,CAAC,aAAe,WAAW,YAAY,KAAK;AAE9C"}},
    {"offset": {"line": 3347, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-schedule.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport type { Job, Technician } from \"@/components/schedule/schedule-types\";\nimport { fetchScheduleData } from \"@/lib/schedule-data\";\nimport { filterJobs, sortJobsByStartTime } from \"@/lib/schedule-utils\";\nimport { useScheduleStore } from \"@/lib/stores/schedule-store\";\nimport { useViewStore } from \"@/lib/stores/view-store\";\nimport { createClient } from \"@/lib/supabase/client\";\n\nexport function useSchedule() {\n\t// Use granular selectors to avoid closure issues\n\tconst isLoading = useScheduleStore((state) => state.isLoading);\n\tconst error = useScheduleStore((state) => state.error);\n\tconst lastSync = useScheduleStore((state) => state.lastSync);\n\tconst jobs = useScheduleStore((state) => state.jobs);\n\tconst technicians = useScheduleStore((state) => state.technicians);\n\tconst selectedJobId = useScheduleStore((state) => state.selectedJobId);\n\tconst selectedTechnicianId = useScheduleStore(\n\t\t(state) => state.selectedTechnicianId,\n\t);\n\tconst lastFetchedRange = useScheduleStore((state) => state.lastFetchedRange);\n\tconst storeCompanyId = useScheduleStore((state) => state.companyId);\n\tconst unassignedHasMore = useScheduleStore(\n\t\t(state) => state.unassignedHasMore,\n\t);\n\tconst unassignedSearch = useScheduleStore((state) => state.unassignedSearch);\n\tconst isLoadingUnassigned = useScheduleStore(\n\t\t(state) => state.isLoadingUnassigned,\n\t);\n\tconst unassignedTotalCount = useScheduleStore(\n\t\t(state) => state.unassignedTotalCount,\n\t);\n\n\t// Get actions\n\tconst setLoading = useScheduleStore((state) => state.setLoading);\n\tconst setError = useScheduleStore((state) => state.setError);\n\tconst setJobs = useScheduleStore((state) => state.setJobs);\n\tconst setTechnicians = useScheduleStore((state) => state.setTechnicians);\n\tconst selectJob = useScheduleStore((state) => state.selectJob);\n\tconst selectTechnician = useScheduleStore((state) => state.selectTechnician);\n\tconst addJob = useScheduleStore((state) => state.addJob);\n\tconst updateJob = useScheduleStore((state) => state.updateJob);\n\tconst moveJob = useScheduleStore((state) => state.moveJob);\n\tconst deleteJob = useScheduleStore((state) => state.deleteJob);\n\tconst duplicateJob = useScheduleStore((state) => state.duplicateJob);\n\tconst getJobById = useScheduleStore((state) => state.getJobById);\n\tconst syncWithServer = useScheduleStore((state) => state.syncWithServer);\n\tconst setLastSync = useScheduleStore((state) => state.setLastSync);\n\tconst setCompanyId = useScheduleStore((state) => state.setCompanyId);\n\tconst setLastFetchedRange = useScheduleStore(\n\t\t(state) => state.setLastFetchedRange,\n\t);\n\tconst setUnassignedMeta = useScheduleStore(\n\t\t(state) => state.setUnassignedMeta,\n\t);\n\tconst getUnassignedJobsFromStore = useScheduleStore(\n\t\t(state) => state.getUnassignedJobs,\n\t);\n\tconst getJobsGroupedByTechnicianFromStore = useScheduleStore(\n\t\t(state) => state.getJobsGroupedByTechnician,\n\t);\n\tconst loadMoreUnassignedJobs = useScheduleStore(\n\t\t(state) => state.loadMoreUnassignedJobs,\n\t);\n\n\t// Get view store values with selectors to avoid re-renders\n\tconst filters = useViewStore((state) => state.filters);\n\tconst showCompletedJobs = useViewStore((state) => state.showCompletedJobs);\n\tconst _currentDate = useViewStore((state) => state.currentDate);\n\tconst _zoom = useViewStore((state) => state.zoom);\n\n\t// Calculate visible time range once\n\tconst visibleTimeRange = useMemo(\n\t\t() => useViewStore.getState().getVisibleTimeRange(),\n\t\t[],\n\t);\n\n\tconst rangeStart = visibleTimeRange.start.getTime();\n\tconst rangeEnd = visibleTimeRange.end.getTime();\n\tconst companyIdRef = useRef<string | null>(\n\t\tuseScheduleStore.getState().companyId,\n\t);\n\n\tuseEffect(() => {\n\t\tcompanyIdRef.current = storeCompanyId;\n\t}, [storeCompanyId]);\n\n\tconst jobCount = jobs.size;\n\n\tconst hasCoverage = useMemo(() => {\n\t\tif (!lastFetchedRange || jobCount === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst fetchedStart = lastFetchedRange.start.getTime();\n\t\tconst fetchedEnd = lastFetchedRange.end.getTime();\n\n\t\treturn fetchedStart <= rangeStart && fetchedEnd >= rangeEnd;\n\t}, [jobCount, lastFetchedRange, rangeEnd, rangeStart]);\n\n\tuseEffect(() => {\n\t\tlet isMounted = true;\n\n\t\tif (hasCoverage && companyIdRef.current) {\n\t\t\treturn () => {\n\t\t\t\tisMounted = false;\n\t\t\t};\n\t\t}\n\n\t\tconst loadData = async () => {\n\t\t\tsetLoading(true);\n\t\t\tsetError(null);\n\n\t\t\ttry {\n\t\t\t\tconst supabase = createClient();\n\n\t\t\t\tif (!supabase) {\n\t\t\t\t\tthrow new Error(\"Database connection not available\");\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tdata: { user },\n\t\t\t\t\terror: authError,\n\t\t\t\t} = await supabase.auth.getUser();\n\n\t\t\t\tif (authError) {\n\t\t\t\t\tthrow authError;\n\t\t\t\t}\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tthrow new Error(\"User session not found\");\n\t\t\t\t}\n\n\t\t\t\tlet companyId = companyIdRef.current;\n\n\t\t\t\tif (!companyId) {\n\t\t\t\t\tconst { data: membership, error: membershipError } = await supabase\n\t\t\t\t\t\t.from(\"company_memberships\")\n\t\t\t\t\t\t.select(\"company_id\")\n\t\t\t\t\t\t.eq(\"user_id\", user.id)\n\t\t\t\t\t\t.eq(\"status\", \"active\")\n\t\t\t\t\t\t.order(\"joined_at\", { ascending: false, nullsFirst: false })\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.maybeSingle();\n\n\t\t\t\t\tif (membershipError) {\n\t\t\t\t\t\tthrow membershipError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!membership?.company_id) {\n\t\t\t\t\t\tthrow new Error(\"No active company membership found\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcompanyId = membership.company_id;\n\t\t\t\t\tcompanyIdRef.current = companyId;\n\t\t\t\t\tsetCompanyId(companyId);\n\t\t\t\t}\n\n\t\t\t\tif (!companyId) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unable to resolve company context for schedule data\",\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tjobs: convertedJobs,\n\t\t\t\t\ttechnicians: convertedTechnicians,\n\t\t\t\t\tunassignedMeta,\n\t\t\t\t} = await fetchScheduleData({\n\t\t\t\t\tsupabase,\n\t\t\t\t\tcompanyId,\n\t\t\t\t\trange: {\n\t\t\t\t\t\tstart: new Date(rangeStart),\n\t\t\t\t\t\tend: new Date(rangeEnd),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tif (!isMounted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsetTechnicians(convertedTechnicians);\n\t\t\t\tsetJobs(convertedJobs);\n\t\t\t\tconst fetchedRange = {\n\t\t\t\t\tstart: new Date(rangeStart),\n\t\t\t\t\tend: new Date(rangeEnd),\n\t\t\t\t};\n\n\t\t\t\tsetTechnicians(convertedTechnicians);\n\t\t\t\tsetJobs(convertedJobs);\n\t\t\t\tconst unassignedCount = convertedJobs.filter(\n\t\t\t\t\t(job) => job.isUnassigned,\n\t\t\t\t).length;\n\t\t\t\tsetUnassignedMeta(unassignedMeta, unassignedCount);\n\t\t\t\tsetLastSync(new Date());\n\t\t\t\tsetLastFetchedRange(fetchedRange);\n\t\t\t} catch (error) {\n\t\t\t\tif (!isMounted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst errorMessage =\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t: typeof error === \"object\" && error !== null && \"message\" in error\n\t\t\t\t\t\t\t? String((error as { message: string }).message)\n\t\t\t\t\t\t\t: \"Unknown error\";\n\t\t\t\tsetError(errorMessage);\n\t\t\t} finally {\n\t\t\t\tif (isMounted) {\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tloadData();\n\n\t\treturn () => {\n\t\t\tisMounted = false;\n\t\t};\n\t}, [\n\t\thasCoverage,\n\t\trangeEnd,\n\t\trangeStart,\n\t\tsetCompanyId,\n\t\tsetLastFetchedRange,\n\t\tsetError,\n\t\tsetJobs,\n\t\tsetLastSync,\n\t\tsetLoading,\n\t\tsetTechnicians,\n\t]);\n\n\t// Get filtered and sorted jobs - MEMOIZED\n\tconst filteredJobs = useMemo((): Job[] => {\n\t\tconst allJobs = Array.from(jobs.values());\n\n\t\t// Apply view filters\n\t\tconst filtered = filterJobs(allJobs, {\n\t\t\ttechnicianIds: filters.technicianIds,\n\t\t\tstatuses: filters.statuses,\n\t\t\tpriorities: filters.priorities,\n\t\t\tsearchQuery: filters.searchQuery,\n\t\t});\n\n\t\t// Filter by completed jobs visibility\n\t\tconst visible = showCompletedJobs\n\t\t\t? filtered\n\t\t\t: filtered.filter((job) => job.status !== \"completed\");\n\n\t\t// Sort by start time\n\t\treturn sortJobsByStartTime(visible);\n\t}, [jobs, filters, showCompletedJobs]);\n\n\t// Get filtered technicians - MEMOIZED\n\tconst filteredTechnicians = useMemo((): Technician[] => {\n\t\tconst allTechnicians = Array.from(technicians.values());\n\n\t\t// If technician filter is active, only show filtered technicians\n\t\tif (filters.technicianIds.length > 0) {\n\t\t\treturn allTechnicians.filter((tech) =>\n\t\t\t\tfilters.technicianIds.includes(tech.id),\n\t\t\t);\n\t\t}\n\n\t\treturn allTechnicians;\n\t}, [technicians, filters.technicianIds]);\n\n\t// Pre-index jobs by technician ID for O(1) lookups instead of O(n) filter\n\tconst jobsByTechnicianId = useMemo(() => {\n\t\tconst map = new Map<string, Job[]>();\n\t\tfor (const job of filteredJobs) {\n\t\t\tconst techId = job.technicianId;\n\t\t\tif (techId) {\n\t\t\t\tconst existing = map.get(techId);\n\t\t\t\tif (existing) {\n\t\t\t\t\texisting.push(job);\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(techId, [job]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}, [filteredJobs]);\n\n\t// Get jobs for a specific technician - now O(1) lookup\n\tconst getJobsForTechnician = useCallback(\n\t\t(technicianId: string): Job[] =>\n\t\t\tjobsByTechnicianId.get(technicianId) ?? [],\n\t\t[jobsByTechnicianId],\n\t);\n\n\t// Get jobs within visible time range - MEMOIZED\n\tconst visibleJobs = useMemo((): Job[] => {\n\t\tconst { start, end } = visibleTimeRange;\n\n\t\treturn filteredJobs.filter((job) => {\n\t\t\t// Job overlaps with visible range\n\t\t\treturn job.startTime <= end && job.endTime >= start;\n\t\t});\n\t}, [filteredJobs, visibleTimeRange]);\n\n\t// Get all jobs (unfiltered)\n\tconst getAllJobs = useCallback(\n\t\t(): Job[] => Array.from(jobs.values()),\n\t\t[jobs],\n\t);\n\n\treturn {\n\t\t// State\n\t\tisLoading,\n\t\terror,\n\t\tlastSync,\n\n\t\t// Data\n\t\ttechnicians: filteredTechnicians,\n\t\tjobs: filteredJobs,\n\t\tvisibleJobs,\n\n\t\t// Selection\n\t\tselectedJobId,\n\t\tselectedTechnicianId,\n\t\tselectedJob: selectedJobId ? getJobById(selectedJobId) : null,\n\n\t\t// Actions\n\t\tgetJobsForTechnician,\n\t\tgetAllJobs,\n\t\tselectJob,\n\t\tselectTechnician,\n\t\tgetUnassignedJobs: getUnassignedJobsFromStore,\n\t\tgetJobsGroupedByTechnician: getJobsGroupedByTechnicianFromStore,\n\t\tunassignedHasMore,\n\t\tunassignedSearch,\n\t\tisLoadingUnassigned,\n\t\tunassignedTotalCount,\n\t\tloadMoreUnassignedJobs,\n\n\t\t// Mutations\n\t\taddJob,\n\t\tupdateJob,\n\t\tmoveJob,\n\t\tdeleteJob,\n\t\tduplicateJob,\n\n\t\t// Sync\n\t\trefresh: syncWithServer,\n\t};\n}\n\n/**\n * Hook for real-time schedule updates via Supabase\n * Subscribes to appointments table for INSERT, UPDATE, DELETE events\n */\nexport function useScheduleRealtime() {\n\tconst companyId = useScheduleStore((state) => state.companyId);\n\tconst updateJob = useScheduleStore((state) => state.updateJob);\n\tconst deleteJob = useScheduleStore((state) => state.deleteJob);\n\tconst addJob = useScheduleStore((state) => state.addJob);\n\tconst getJobById = useScheduleStore((state) => state.getJobById);\n\tconst syncWithServer = useScheduleStore((state) => state.syncWithServer);\n\tconst lastSync = useScheduleStore((state) => state.lastSync);\n\tconst [isConnected, setIsConnected] = useState(false);\n\tconst [connectionError, setConnectionError] = useState<string | null>(null);\n\n\tuseEffect(() => {\n\t\tif (!companyId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst supabase = createClient();\n\t\tif (!supabase) {\n\t\t\tsetConnectionError(\"Database connection not available\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst channelName = `schedule-realtime-${companyId}`;\n\n\t\tconst channel = supabase\n\t\t\t.channel(channelName)\n\t\t\t.on(\n\t\t\t\t\"postgres_changes\",\n\t\t\t\t{\n\t\t\t\t\tevent: \"*\",\n\t\t\t\t\tschema: \"public\",\n\t\t\t\t\ttable: \"appointments\",\n\t\t\t\t\tfilter: `company_id=eq.${companyId}`,\n\t\t\t\t},\n\t\t\t\tasync (payload) => {\n\t\t\t\t\tconst { eventType, new: newRecord, old: oldRecord } = payload;\n\n\t\t\t\t\tswitch (eventType) {\n\t\t\t\t\t\tcase \"DELETE\": {\n\t\t\t\t\t\t\t// Remove job from store\n\t\t\t\t\t\t\tconst jobId = (oldRecord as { id?: string })?.id;\n\t\t\t\t\t\t\tif (jobId) {\n\t\t\t\t\t\t\t\tdeleteJob(jobId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"UPDATE\": {\n\t\t\t\t\t\t\t// For updates, try to merge changes into existing job\n\t\t\t\t\t\t\tconst record = newRecord as Record<string, unknown>;\n\t\t\t\t\t\t\tconst jobId = record.id as string;\n\n\t\t\t\t\t\t\tif (!jobId) break;\n\n\t\t\t\t\t\t\tconst existingJob = getJobById(jobId);\n\n\t\t\t\t\t\t\tif (existingJob) {\n\t\t\t\t\t\t\t\t// Merge updates into existing job\n\t\t\t\t\t\t\t\tconst updates: Partial<Job> = {};\n\n\t\t\t\t\t\t\t\tif (record.title !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.title = record.title as string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.description !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.description = record.description as string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.status !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.status = mapStatus(record.status as string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.start_time !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.startTime = new Date(record.start_time as string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.end_time !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.endTime = new Date(record.end_time as string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.assigned_to !== undefined) {\n\t\t\t\t\t\t\t\t\t// Assignment changed - need to handle technician change\n\t\t\t\t\t\t\t\t\tif (record.assigned_to === null) {\n\t\t\t\t\t\t\t\t\t\tupdates.isUnassigned = true;\n\t\t\t\t\t\t\t\t\t\tupdates.technicianId = \"\";\n\t\t\t\t\t\t\t\t\t\tupdates.assignments = [];\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tupdates.isUnassigned = false;\n\t\t\t\t\t\t\t\t\t\tupdates.technicianId = record.assigned_to as string;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (Object.keys(updates).length > 0) {\n\t\t\t\t\t\t\t\t\tupdateJob(jobId, updates);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Job not in store - fetch fresh data\n\t\t\t\t\t\t\t\tawait syncWithServer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"INSERT\": {\n\t\t\t\t\t\t\t// For new jobs, we need full data with joins\n\t\t\t\t\t\t\t// Trigger a sync to get complete job with customer/property data\n\t\t\t\t\t\t\tawait syncWithServer();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t)\n\t\t\t.subscribe((status) => {\n\t\t\t\tif (status === \"SUBSCRIBED\") {\n\t\t\t\t\tsetIsConnected(true);\n\t\t\t\t\tsetConnectionError(null);\n\t\t\t\t} else if (status === \"CHANNEL_ERROR\") {\n\t\t\t\t\tsetIsConnected(false);\n\t\t\t\t\tsetConnectionError(\"Failed to connect to real-time updates\");\n\t\t\t\t} else if (status === \"CLOSED\") {\n\t\t\t\t\tsetIsConnected(false);\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn () => {\n\t\t\tsupabase.removeChannel(channel);\n\t\t\tsetIsConnected(false);\n\t\t};\n\t}, [\n\t\tcompanyId,\n\t\tupdateJob,\n\t\tdeleteJob,\n\t\taddJob,\n\t\tgetJobById,\n\t\tsyncWithServer,\n\t]);\n\n\treturn {\n\t\tisConnected,\n\t\tconnectionError,\n\t\tlastUpdate: lastSync,\n\t};\n}\n\n// Helper to map database status to Job status\nfunction mapStatus(status: string): Job[\"status\"] {\n\tconst normalized = status?.toLowerCase() ?? \"scheduled\";\n\tswitch (normalized) {\n\t\tcase \"scheduled\":\n\t\tcase \"dispatched\":\n\t\tcase \"arrived\":\n\t\tcase \"closed\":\n\t\tcase \"cancelled\":\n\t\t\treturn normalized as Job[\"status\"];\n\t\tcase \"in-progress\":\n\t\tcase \"in_progress\":\n\t\tcase \"inprogress\":\n\t\t\treturn \"in-progress\";\n\t\tcase \"completed\":\n\t\tcase \"complete\":\n\t\tcase \"done\":\n\t\t\treturn \"completed\";\n\t\tdefault:\n\t\t\treturn \"scheduled\";\n\t}\n}\n\n/**\n * Hook for schedule statistics\n */\nfunction useScheduleStats() {\n\tconst { technicians, jobs, visibleJobs } = useSchedule();\n\n\tconst stats = {\n\t\ttotalTechnicians: technicians.length,\n\t\ttotalJobs: jobs.length,\n\t\tvisibleJobs: visibleJobs.length,\n\t\tscheduledJobs: jobs.filter((j) => j.status === \"scheduled\").length,\n\t\tinProgressJobs: jobs.filter((j) => j.status === \"in-progress\").length,\n\t\tcompletedJobs: jobs.filter((j) => j.status === \"completed\").length,\n\t\tcancelledJobs: jobs.filter((j) => j.status === \"cancelled\").length,\n\t\turgentJobs: jobs.filter((j) => j.priority === \"urgent\").length,\n\t};\n\n\treturn stats;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3982, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/team-avatar-manager.tsx"],"sourcesContent":["\"use client\";\n\nimport { X } from \"lucide-react\";\nimport { useState } from \"react\";\nimport { Avatar, AvatarFallback } from \"@/components/ui/avatar\";\nimport { cn } from \"@/lib/utils\";\nimport type { JobAssignment } from \"./schedule-types\";\n\nfunction TeamAvatar({\n\tassignment,\n\tonRemove,\n\tsize = \"sm\",\n}: {\n\tassignment: JobAssignment;\n\tonRemove?: () => void;\n\tsize?: \"sm\" | \"md\";\n}) {\n\tconst [isHovered, setIsHovered] = useState(false);\n\n\tconst sizeClasses = size === \"md\" ? \"size-8\" : \"size-6\";\n\tconst textSize = size === \"md\" ? \"text-[10px]\" : \"text-[8px]\";\n\n\treturn (\n\t\t<div\n\t\t\tclassName=\"relative\"\n\t\t\tonMouseEnter={() => setIsHovered(true)}\n\t\t\tonMouseLeave={() => setIsHovered(false)}\n\t\t>\n\t\t\t<Avatar\n\t\t\t\tclassName={cn(\n\t\t\t\t\tsizeClasses,\n\t\t\t\t\t\"border-card border-2 transition-all\",\n\t\t\t\t\tisHovered && \"ring-primary ring-2\",\n\t\t\t\t)}\n\t\t\t\ttitle={assignment.displayName}\n\t\t\t>\n\t\t\t\t{assignment.avatar && (\n\t\t\t\t\t<img\n\t\t\t\t\t\talt={assignment.displayName}\n\t\t\t\t\t\tclassName=\"size-full object-cover\"\n\t\t\t\t\t\tsrc={assignment.avatar}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t<AvatarFallback\n\t\t\t\t\tclassName={cn(\"bg-muted text-foreground font-bold\", textSize)}\n\t\t\t\t>\n\t\t\t\t\t{assignment.displayName\n\t\t\t\t\t\t.split(\" \")\n\t\t\t\t\t\t.map((n) => n[0])\n\t\t\t\t\t\t.join(\"\")\n\t\t\t\t\t\t.toUpperCase()}\n\t\t\t\t</AvatarFallback>\n\t\t\t</Avatar>\n\n\t\t\t{/* Remove button on hover */}\n\t\t\t{isHovered && onRemove && (\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"bg-destructive text-destructive-foreground absolute -top-1 -right-1 flex size-4 items-center justify-center rounded-full shadow-md transition-transform hover:scale-110\"\n\t\t\t\t\tonClick={(e) => {\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\tonRemove();\n\t\t\t\t\t}}\n\t\t\t\t\ttitle=\"Remove from job\"\n\t\t\t\t>\n\t\t\t\t\t<X className=\"size-3\" />\n\t\t\t\t</button>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n\nexport function TeamAvatarGroup({\n\tassignments,\n\tmaxVisible = 3,\n\tonRemove,\n\tonAddMember,\n\tsize = \"sm\",\n\tjobId,\n}: {\n\tassignments: JobAssignment[];\n\tmaxVisible?: number;\n\tonRemove?: (technicianId: string) => void;\n\tonAddMember?: () => void;\n\tsize?: \"sm\" | \"md\";\n\tjobId?: string;\n}) {\n\tconst [showAll, setShowAll] = useState(false);\n\tconst visibleAssignments = showAll\n\t\t? assignments\n\t\t: assignments.slice(0, maxVisible);\n\tconst remainingCount = assignments.length - maxVisible;\n\n\treturn (\n\t\t<div className=\"flex shrink-0 items-center gap-1\" data-job-id={jobId}>\n\t\t\t<div className=\"flex -space-x-1.5\">\n\t\t\t\t{visibleAssignments.map((assignment, idx) => (\n\t\t\t\t\t<TeamAvatar\n\t\t\t\t\t\tassignment={assignment}\n\t\t\t\t\t\tkey={idx}\n\t\t\t\t\t\tonRemove={\n\t\t\t\t\t\t\tonRemove\n\t\t\t\t\t\t\t\t? () => onRemove(assignment.technicianId || \"\")\n\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsize={size}\n\t\t\t\t\t/>\n\t\t\t\t))}\n\n\t\t\t\t{!showAll && remainingCount > 0 && (\n\t\t\t\t\t<button\n\t\t\t\t\t\tclassName=\"border-card bg-muted text-muted-foreground hover:bg-muted/80 hover:ring-primary flex size-6 items-center justify-center rounded-full border-2 text-[8px] font-bold transition-all hover:ring-2\"\n\t\t\t\t\t\tonClick={(e) => {\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\tsetShowAll(true);\n\t\t\t\t\t\t}}\n\t\t\t\t\t\ttitle={`Show ${remainingCount} more`}\n\t\t\t\t\t>\n\t\t\t\t\t\t+{remainingCount}\n\t\t\t\t\t</button>\n\t\t\t\t)}\n\t\t\t</div>\n\n\t\t\t{/* Add member button */}\n\t\t\t{onAddMember && (\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"border-muted-foreground/30 bg-muted/50 text-muted-foreground hover:border-primary hover:bg-primary/10 hover:text-primary flex size-6 items-center justify-center rounded-full border-2 border-dashed transition-all\"\n\t\t\t\t\tonClick={(e) => {\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\tonAddMember();\n\t\t\t\t\t}}\n\t\t\t\t\ttitle=\"Add team member\"\n\t\t\t\t>\n\t\t\t\t\t<span\n\t\t\t\t\t\tclassName=\"relative flex items-center justify-center text-base leading-none font-bold\"\n\t\t\t\t\t\tstyle={{ top: \"-1px\" }}\n\t\t\t\t\t>\n\t\t\t\t\t\t+\n\t\t\t\t\t</span>\n\t\t\t\t</button>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAAA;AACA;;;AALA;;;;;AAQA,SAAS,WAAW,EACnB,UAAU,EACV,QAAQ,EACR,OAAO,IAAI,EAKX;;IACA,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,gVAAQ,EAAC;IAE3C,MAAM,cAAc,SAAS,OAAO,WAAW;IAC/C,MAAM,WAAW,SAAS,OAAO,gBAAgB;IAEjD,qBACC,oWAAC;QACA,WAAU;QACV,cAAc,IAAM,aAAa;QACjC,cAAc,IAAM,aAAa;;0BAEjC,oWAAC,6IAAM;gBACN,WAAW,IAAA,2IAAE,EACZ,aACA,uCACA,aAAa;gBAEd,OAAO,WAAW,WAAW;;oBAE5B,WAAW,MAAM,kBACjB,oWAAC;wBACA,KAAK,WAAW,WAAW;wBAC3B,WAAU;wBACV,KAAK,WAAW,MAAM;;;;;;kCAGxB,oWAAC,qJAAc;wBACd,WAAW,IAAA,2IAAE,EAAC,sCAAsC;kCAEnD,WAAW,WAAW,CACrB,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,IAAM,CAAC,CAAC,EAAE,EACf,IAAI,CAAC,IACL,WAAW;;;;;;;;;;;;YAKd,aAAa,0BACb,oWAAC;gBACA,WAAU;gBACV,SAAS,CAAC;oBACT,EAAE,eAAe;oBACjB;gBACD;gBACA,OAAM;0BAEN,cAAA,oWAAC,wRAAC;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAKlB;GA7DS;KAAA;AA+DF,SAAS,gBAAgB,EAC/B,WAAW,EACX,aAAa,CAAC,EACd,QAAQ,EACR,WAAW,EACX,OAAO,IAAI,EACX,KAAK,EAQL;;IACA,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,gVAAQ,EAAC;IACvC,MAAM,qBAAqB,UACxB,cACA,YAAY,KAAK,CAAC,GAAG;IACxB,MAAM,iBAAiB,YAAY,MAAM,GAAG;IAE5C,qBACC,oWAAC;QAAI,WAAU;QAAmC,eAAa;;0BAC9D,oWAAC;gBAAI,WAAU;;oBACb,mBAAmB,GAAG,CAAC,CAAC,YAAY,oBACpC,oWAAC;4BACA,YAAY;4BAEZ,UACC,WACG,IAAM,SAAS,WAAW,YAAY,IAAI,MAC1C;4BAEJ,MAAM;2BAND;;;;;oBAUN,CAAC,WAAW,iBAAiB,mBAC7B,oWAAC;wBACA,WAAU;wBACV,SAAS,CAAC;4BACT,EAAE,eAAe;4BACjB,WAAW;wBACZ;wBACA,OAAO,CAAC,KAAK,EAAE,eAAe,KAAK,CAAC;;4BACpC;4BACE;;;;;;;;;;;;;YAMJ,6BACA,oWAAC;gBACA,WAAU;gBACV,SAAS,CAAC;oBACT,EAAE,eAAe;oBACjB;gBACD;gBACA,OAAM;0BAEN,cAAA,oWAAC;oBACA,WAAU;oBACV,OAAO;wBAAE,KAAK;oBAAO;8BACrB;;;;;;;;;;;;;;;;;AAON;IAvEgB;MAAA"}},
    {"offset": {"line": 4149, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/kanban-view.tsx"],"sourcesContent":["\"use client\";\n\nimport { format } from \"date-fns\";\nimport {\n\tBriefcase,\n\tCalendar,\n\tCar,\n\tCheck,\n\tClipboardCheck,\n\tClock,\n\tExternalLink,\n\tHardHat,\n\tMapPin,\n\tPhone,\n\tPlay,\n\tPlus,\n\tSearch,\n\tSend,\n\tSettings,\n\tStar,\n\tUsers,\n\tWrench,\n\tZap,\n} from \"lucide-react\";\nimport Link from \"next/link\";\nimport { useCallback, useState, useTransition } from \"react\";\nimport { toast } from \"sonner\";\nimport {\n\tarriveAppointment,\n\tcancelAppointment,\n\tcloseAppointment,\n\tcompleteAppointment,\n\tdispatchAppointment,\n} from \"@/actions/schedule-assignments\";\nimport { Button } from \"@/components/ui/button\";\nimport { EntityKanban } from \"@/components/ui/entity-kanban\";\nimport { QuickAppointmentDialog } from \"./quick-appointment-dialog\";\nimport { ScheduleJobContextMenu } from \"./schedule-job-context-menu\";\nimport type {\n\tKanbanItemBase,\n\tKanbanMoveEvent,\n} from \"@/components/ui/shadcn-io/kanban\";\nimport {\n\tTooltip,\n\tTooltipContent,\n\tTooltipProvider,\n\tTooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { useSchedule } from \"@/hooks/use-schedule\";\nimport { cn } from \"@/lib/utils\";\nimport type { AppointmentCategory, Job, JobType } from \"./schedule-types\";\nimport { TeamAvatarGroup } from \"./team-avatar-manager\";\n\ntype ScheduleStatus =\n\t| \"scheduled\"\n\t| \"dispatched\"\n\t| \"arrived\"\n\t| \"in-progress\"\n\t| \"closed\"\n\t| \"completed\"\n\t| \"cancelled\";\n\ntype ScheduleKanbanItem = KanbanItemBase & {\n\tentity: Job;\n};\n\nconst SCHEDULE_STATUS_COLUMNS: Array<{\n\tid: ScheduleStatus | \"unassigned\";\n\tname: string;\n\taccentColor: string;\n}> = [\n\t{ id: \"unassigned\", name: \"Unscheduled\", accentColor: \"#EF4444\" }, // Red\n\t{ id: \"scheduled\", name: \"Scheduled\", accentColor: \"#3B82F6\" }, // Blue\n\t{ id: \"dispatched\", name: \"Dispatched\", accentColor: \"#0EA5E9\" }, // Sky\n\t{ id: \"arrived\", name: \"Arrived\", accentColor: \"#34D399\" }, // Emerald\n\t{ id: \"in-progress\", name: \"In Progress\", accentColor: \"#F59E0B\" }, // Amber\n\t{ id: \"closed\", name: \"Closed\", accentColor: \"#10B981\" }, // Green\n\t{ id: \"completed\", name: \"Completed\", accentColor: \"#059669\" }, // Emerald-600\n\t{ id: \"cancelled\", name: \"Cancelled\", accentColor: \"#94A3B8\" }, // Slate\n];\n\nconst COLUMN_LABEL = new Map(\n\tSCHEDULE_STATUS_COLUMNS.map((column) => [column.id, column.name]),\n);\n\nconst DEFAULT_STATUS: ScheduleStatus = \"scheduled\";\n\nfunction resolveStatus(\n\tstatus: string | null | undefined,\n\ttechnicianId: string | null | undefined,\n): ScheduleStatus | \"unassigned\" {\n\t// If no technician assigned, it's unscheduled\n\tif (!technicianId) {\n\t\treturn \"unassigned\";\n\t}\n\n\tif (!status) {\n\t\treturn DEFAULT_STATUS;\n\t}\n\n\tconst normalized = status as ScheduleStatus;\n\treturn COLUMN_LABEL.has(normalized) ? normalized : DEFAULT_STATUS;\n}\n\n// Job type visual configuration - consistent with timeline view\ntype JobTypeConfig = {\n\tborderColor: string;\n\tbgColor: string;\n\ticon: React.ComponentType<{ className?: string }>;\n\tlabel: string;\n};\n\nconst JOB_TYPE_CONFIG: Record<JobType | \"default\", JobTypeConfig> = {\n\temergency: {\n\t\tborderColor: \"border-l-red-500\",\n\t\tbgColor: \"bg-red-500/10\",\n\t\ticon: Zap,\n\t\tlabel: \"Emergency\",\n\t},\n\trepair: {\n\t\tborderColor: \"border-l-orange-500\",\n\t\tbgColor: \"bg-orange-500/10\",\n\t\ticon: Wrench,\n\t\tlabel: \"Repair\",\n\t},\n\tinstallation: {\n\t\tborderColor: \"border-l-green-500\",\n\t\tbgColor: \"bg-green-500/10\",\n\t\ticon: HardHat,\n\t\tlabel: \"Installation\",\n\t},\n\tmaintenance: {\n\t\tborderColor: \"border-l-blue-500\",\n\t\tbgColor: \"bg-blue-500/10\",\n\t\ticon: Settings,\n\t\tlabel: \"Maintenance\",\n\t},\n\tpremium_maintenance: {\n\t\tborderColor: \"border-l-violet-500\",\n\t\tbgColor: \"bg-violet-500/10\",\n\t\ticon: Star,\n\t\tlabel: \"Premium\",\n\t},\n\tinspection: {\n\t\tborderColor: \"border-l-cyan-500\",\n\t\tbgColor: \"bg-cyan-500/10\",\n\t\ticon: Search,\n\t\tlabel: \"Inspection\",\n\t},\n\tservice: {\n\t\tborderColor: \"border-l-sky-500\",\n\t\tbgColor: \"bg-sky-500/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Service\",\n\t},\n\tservice_call: {\n\t\tborderColor: \"border-l-teal-500\",\n\t\tbgColor: \"bg-teal-500/10\",\n\t\ticon: Phone,\n\t\tlabel: \"Service Call\",\n\t},\n\testimate: {\n\t\tborderColor: \"border-l-amber-500\",\n\t\tbgColor: \"bg-amber-500/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Estimate\",\n\t},\n\tcallback: {\n\t\tborderColor: \"border-l-pink-500\",\n\t\tbgColor: \"bg-pink-500/10\",\n\t\ticon: Phone,\n\t\tlabel: \"Callback\",\n\t},\n\tother: {\n\t\tborderColor: \"border-l-slate-400\",\n\t\tbgColor: \"bg-slate-400/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Other\",\n\t},\n\tdefault: {\n\t\tborderColor: \"border-l-slate-400\",\n\t\tbgColor: \"bg-slate-400/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Job\",\n\t},\n};\n\nconst getJobTypeConfig = (job: Job): JobTypeConfig => {\n\tconst config = job.jobType ? JOB_TYPE_CONFIG[job.jobType] : JOB_TYPE_CONFIG.default;\n\treturn config || JOB_TYPE_CONFIG.default;\n};\n\nconst getJobTypeColor = (job: Job) => {\n\tconst config = getJobTypeConfig(job);\n\treturn `border-l-4 ${config.borderColor}`;\n};\n\n// Appointment category visual configuration - differentiates jobs, meetings, and events\ntype AppointmentCategoryConfig = {\n\ticon: React.ComponentType<{ className?: string }>;\n\tlabel: string;\n\tbgColor: string;\n\ttextColor: string;\n\tborderStyle: string;\n};\n\nconst APPOINTMENT_CATEGORY_CONFIG: Record<AppointmentCategory, AppointmentCategoryConfig> = {\n\tjob: {\n\t\ticon: Briefcase,\n\t\tlabel: \"Job\",\n\t\tbgColor: \"bg-blue-500/10\",\n\t\ttextColor: \"text-blue-600 dark:text-blue-400\",\n\t\tborderStyle: \"border-solid\",\n\t},\n\tmeeting: {\n\t\ticon: Users,\n\t\tlabel: \"Meeting\",\n\t\tbgColor: \"bg-purple-500/10\",\n\t\ttextColor: \"text-purple-600 dark:text-purple-400\",\n\t\tborderStyle: \"border-dashed\",\n\t},\n\tevent: {\n\t\ticon: Calendar,\n\t\tlabel: \"Event\",\n\t\tbgColor: \"bg-emerald-500/10\",\n\t\ttextColor: \"text-emerald-600 dark:text-emerald-400\",\n\t\tborderStyle: \"border-dotted\",\n\t},\n};\n\nconst getAppointmentCategoryConfig = (job: Job): AppointmentCategoryConfig => {\n\tconst category = job.appointmentCategory || \"job\";\n\treturn APPOINTMENT_CATEGORY_CONFIG[category];\n};\n\n// Job status color mapping (same as timeline view)\nconst getStatusColor = (status: Job[\"status\"]) => {\n\tswitch (status) {\n\t\tcase \"scheduled\":\n\t\t\treturn \"bg-blue-500\";\n\t\tcase \"dispatched\":\n\t\t\treturn \"bg-sky-500\";\n\t\tcase \"arrived\":\n\t\t\treturn \"bg-emerald-400\";\n\t\tcase \"in-progress\":\n\t\t\treturn \"bg-amber-500 animate-pulse\";\n\t\tcase \"closed\":\n\t\t\treturn \"bg-emerald-600\";\n\t\tcase \"completed\":\n\t\t\treturn \"bg-emerald-600\";\n\t\tcase \"cancelled\":\n\t\t\treturn \"bg-slate-400\";\n\t\tdefault:\n\t\t\treturn \"bg-slate-500\";\n\t}\n};\n\nfunction JobCard({ item }: { item: ScheduleKanbanItem }) {\n\tconst { entity: job } = item;\n\tconst [isPending, startTransition] = useTransition();\n\tconst startTime =\n\t\tjob.startTime instanceof Date ? job.startTime : new Date(job.startTime);\n\tconst endTime =\n\t\tjob.endTime instanceof Date ? job.endTime : new Date(job.endTime);\n\n\t// Quick action handlers\n\tconst handleDispatch = useCallback(\n\t\t(e: React.MouseEvent) => {\n\t\t\te.stopPropagation();\n\t\t\tif (!job.jobId) return;\n\t\t\tstartTransition(async () => {\n\t\t\t\tconst result = await dispatchAppointment(job.jobId!);\n\t\t\t\tif (result.success) {\n\t\t\t\t\ttoast.success(\"Job dispatched\");\n\t\t\t\t} else {\n\t\t\t\t\ttoast.error(result.error || \"Failed to dispatch\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[job.jobId],\n\t);\n\n\tconst handleArrive = useCallback(\n\t\t(e: React.MouseEvent) => {\n\t\t\te.stopPropagation();\n\t\t\tif (!job.jobId) return;\n\t\t\tstartTransition(async () => {\n\t\t\t\tconst result = await arriveAppointment(job.jobId!);\n\t\t\t\tif (result.success) {\n\t\t\t\t\ttoast.success(\"Marked as arrived\");\n\t\t\t\t} else {\n\t\t\t\t\ttoast.error(result.error || \"Failed to update\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[job.jobId],\n\t);\n\n\tconst handleComplete = useCallback(\n\t\t(e: React.MouseEvent) => {\n\t\t\te.stopPropagation();\n\t\t\tif (!job.jobId) return;\n\t\t\tstartTransition(async () => {\n\t\t\t\tconst result = await completeAppointment(job.jobId!);\n\t\t\t\tif (result.success) {\n\t\t\t\t\ttoast.success(\"Job completed\");\n\t\t\t\t} else {\n\t\t\t\t\ttoast.error(result.error || \"Failed to complete\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[job.jobId],\n\t);\n\n\t// Determine which quick action to show based on status\n\tconst getQuickAction = () => {\n\t\tif (!job.jobId) return null;\n\n\t\tswitch (job.status) {\n\t\t\tcase \"scheduled\":\n\t\t\t\treturn {\n\t\t\t\t\ticon: Send,\n\t\t\t\t\tlabel: \"Dispatch\",\n\t\t\t\t\tonClick: handleDispatch,\n\t\t\t\t\tclassName: \"bg-blue-500 hover:bg-blue-600 text-white\",\n\t\t\t\t};\n\t\t\tcase \"dispatched\":\n\t\t\t\treturn {\n\t\t\t\t\ticon: Car,\n\t\t\t\t\tlabel: \"Arrive\",\n\t\t\t\t\tonClick: handleArrive,\n\t\t\t\t\tclassName: \"bg-sky-500 hover:bg-sky-600 text-white\",\n\t\t\t\t};\n\t\t\tcase \"arrived\":\n\t\t\t\treturn {\n\t\t\t\t\ticon: Play,\n\t\t\t\t\tlabel: \"Start\",\n\t\t\t\t\tonClick: handleComplete,\n\t\t\t\t\tclassName: \"bg-emerald-500 hover:bg-emerald-600 text-white\",\n\t\t\t\t};\n\t\t\tcase \"in-progress\":\n\t\t\t\treturn {\n\t\t\t\t\ticon: Check,\n\t\t\t\t\tlabel: \"Done\",\n\t\t\t\t\tonClick: handleComplete,\n\t\t\t\t\tclassName: \"bg-amber-500 hover:bg-amber-600 text-white\",\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t};\n\n\tconst quickAction = getQuickAction();\n\n\tconst categoryConfig = getAppointmentCategoryConfig(job);\n\n\treturn (\n\t\t<TooltipProvider>\n\t\t\t<ScheduleJobContextMenu job={job}>\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"group relative -m-4 flex flex-col gap-2 rounded-xl border-l-4 p-4\",\n\t\t\t\t\t\tgetJobTypeColor(job),\n\t\t\t\t\t\tcategoryConfig.borderStyle,\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{/* Status Dot + Quick Actions */}\n\t\t\t\t\t<div className=\"absolute top-3 right-3 flex items-center gap-1.5\">\n\t\t\t\t\t\t{/* Quick Action Button - appears on hover */}\n\t\t\t\t\t\t{quickAction && (\n\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t\tonClick={quickAction.onClick}\n\t\t\t\t\t\t\t\t\t\tdisabled={isPending}\n\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\"flex size-6 items-center justify-center rounded-md opacity-0 transition-all group-hover:opacity-100\",\n\t\t\t\t\t\t\t\t\t\t\t\"focus:outline-none focus:ring-2 focus:ring-offset-1\",\n\t\t\t\t\t\t\t\t\t\t\tquickAction.className,\n\t\t\t\t\t\t\t\t\t\t\tisPending && \"cursor-wait opacity-50\",\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{isPending ? (\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"size-3 animate-spin rounded-full border-2 border-white border-t-transparent\" />\n\t\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t\t<quickAction.icon className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t<TooltipContent side=\"top\" className=\"text-xs\">\n\t\t\t\t\t\t\t\t\t{quickAction.label}\n\t\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* View Details Link - appears on hover */}\n\t\t\t\t\t\t{job.jobId && (\n\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\t\t\thref={`/dashboard/work/${job.jobId}`}\n\t\t\t\t\t\t\t\t\t\tonClick={(e) => e.stopPropagation()}\n\t\t\t\t\t\t\t\t\t\tclassName=\"flex size-6 items-center justify-center rounded-md bg-slate-100 opacity-0 transition-all hover:bg-slate-200 group-hover:opacity-100 dark:bg-slate-800 dark:hover:bg-slate-700\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<ExternalLink className=\"size-3 text-slate-600 dark:text-slate-400\" />\n\t\t\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t<TooltipContent side=\"top\" className=\"text-xs\">\n\t\t\t\t\t\t\t\t\tView Details\n\t\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* Status Dot */}\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName={cn(\"size-2 rounded-full\", getStatusColor(job.status))}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Appointment Category + Job Type Badge + Customer Name */}\n\t\t\t\t\t<div className=\"flex items-start gap-2 pr-16\">\n\t\t\t\t\t\t{/* Appointment Category Icon */}\n\t\t\t\t\t\t{(() => {\n\t\t\t\t\t\t\tconst CategoryIcon = categoryConfig.icon;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t<div className={cn(\"mt-0.5 flex size-4 shrink-0 items-center justify-center rounded-sm\", categoryConfig.bgColor)}>\n\t\t\t\t\t\t\t\t\t\t\t<CategoryIcon className={cn(\"size-2.5\", categoryConfig.textColor)} />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t<TooltipContent side=\"top\" className=\"text-xs\">\n\t\t\t\t\t\t\t\t\t\t{categoryConfig.label}\n\t\t\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})()}\n\t\t\t\t\t\t{/* Job Type Icon */}\n\t\t\t\t\t\t{(() => {\n\t\t\t\t\t\t\tconst typeConfig = getJobTypeConfig(job);\n\t\t\t\t\t\t\tconst TypeIcon = typeConfig.icon;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t<div className={cn(\"mt-0.5 flex size-5 shrink-0 items-center justify-center rounded\", typeConfig.bgColor)}>\n\t\t\t\t\t\t\t\t\t\t\t<TypeIcon className={cn(\"size-3\", typeConfig.borderColor.replace(\"border-l-\", \"text-\"))} />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t<TooltipContent side=\"top\" className=\"text-xs\">\n\t\t\t\t\t\t\t\t\t\t{typeConfig.label}\n\t\t\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})()}\n\t\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t\t<h3 className=\"text-foreground truncate text-sm leading-tight font-semibold\">\n\t\t\t\t\t\t\t\t{job.customer?.name || \"Unknown Customer\"}\n\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t<p className=\"text-muted-foreground truncate text-xs\">{job.title}</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Time & Date */}\n\t\t\t\t\t<div className=\"flex flex-col gap-1\">\n\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1.5 text-xs\">\n\t\t\t\t\t\t\t<Clock className=\"size-3 shrink-0\" />\n\t\t\t\t\t\t\t<span className=\"truncate\">\n\t\t\t\t\t\t\t\t{format(startTime, \"h:mm a\")} - {format(endTime, \"h:mm a\")}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1.5 text-xs\">\n\t\t\t\t\t\t\t<Calendar className=\"size-3 shrink-0\" />\n\t\t\t\t\t\t\t<span className=\"truncate\">{format(startTime, \"MMM d, yyyy\")}</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Location */}\n\t\t\t\t\t{job.location?.address?.street && (\n\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1.5 text-xs\">\n\t\t\t\t\t\t\t<MapPin className=\"size-3 shrink-0\" />\n\t\t\t\t\t\t\t<span className=\"truncate\">{job.location.address.street}</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Team Avatars */}\n\t\t\t\t\t{job.assignments.length > 0 && (\n\t\t\t\t\t\t<div className=\"border-t pt-2\">\n\t\t\t\t\t\t\t<TeamAvatarGroup\n\t\t\t\t\t\t\t\tassignments={job.assignments}\n\t\t\t\t\t\t\t\tjobId={job.id}\n\t\t\t\t\t\t\t\tmaxVisible={3}\n\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</ScheduleJobContextMenu>\n\t\t</TooltipProvider>\n\t);\n}\n\nexport function KanbanView() {\n\tconst { getAllJobs, isLoading } = useSchedule();\n\tconst [_isPending, startTransition] = useTransition();\n\tconst [showQuickAppointment, setShowQuickAppointment] = useState(false);\n\n\tconst jobs = getAllJobs();\n\n\tconst handleItemMove = async ({\n\t\titem,\n\t\tfromColumnId,\n\t\ttoColumnId,\n\t}: KanbanMoveEvent<ScheduleKanbanItem>) => {\n\t\tif (fromColumnId === toColumnId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst jobItem = item;\n\n\t\tstartTransition(() => {\n\t\t\tvoid (async () => {\n\t\t\t\tlet result: { success: boolean; error?: string } = {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"Unknown status\",\n\t\t\t\t};\n\n\t\t\t\t// Handle moving to/from unassigned\n\t\t\t\tif (toColumnId === \"unassigned\") {\n\t\t\t\t\t// Moving to unassigned - unassign the job\n\t\t\t\t\tconst { unassignAppointment } = await import(\n\t\t\t\t\t\t\"@/actions/schedule-assignments\"\n\t\t\t\t\t);\n\t\t\t\t\tresult = await unassignAppointment(jobItem.entity.id);\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\ttoast.success(\"Appointment unscheduled\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst newStatus = toColumnId as ScheduleStatus;\n\n\t\t\t\t// Call appropriate action based on new status\n\t\t\t\tswitch (newStatus) {\n\t\t\t\t\tcase \"dispatched\":\n\t\t\t\t\t\tresult = await dispatchAppointment(jobItem.entity.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"arrived\":\n\t\t\t\t\t\tresult = await arriveAppointment(jobItem.entity.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"closed\":\n\t\t\t\t\t\tresult = await closeAppointment(jobItem.entity.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"completed\":\n\t\t\t\t\t\tresult = await completeAppointment(jobItem.entity.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"cancelled\":\n\t\t\t\t\t\tresult = await cancelAppointment(jobItem.entity.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// For \"scheduled\" and \"in-progress\", we'd need new actions\n\t\t\t\t\t\tresult = { success: false, error: \"Status change not supported\" };\n\t\t\t\t}\n\n\t\t\t\tif (!result.success) {\n\t\t\t\t\ttoast.error(\"Unable to move appointment\", {\n\t\t\t\t\t\tdescription: result.error,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttoast.success(`Appointment moved to ${COLUMN_LABEL.get(newStatus)}`);\n\t\t\t})();\n\t\t});\n\t};\n\n\tif (isLoading) {\n\t\treturn (\n\t\t\t<div className=\"flex h-full w-full items-center justify-center\">\n\t\t\t\t<div className=\"text-muted-foreground\">Loading schedule...</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div className=\"relative h-full overflow-auto\">\n\t\t\t<EntityKanban<Job, ScheduleStatus | \"unassigned\">\n\t\t\t\tcalculateColumnMeta={(columnId, items) => {\n\t\t\t\t\tconst columnItems = items.filter(\n\t\t\t\t\t\t(item) => item.columnId === columnId,\n\t\t\t\t\t);\n\t\t\t\t\treturn { count: columnItems.length };\n\t\t\t\t}}\n\t\t\t\tcolumns={SCHEDULE_STATUS_COLUMNS}\n\t\t\t\tdata={jobs}\n\t\t\t\tentityName=\"appointments\"\n\t\t\t\tmapToKanbanItem={(job) => ({\n\t\t\t\t\tid: job.id,\n\t\t\t\t\tcolumnId: resolveStatus(job.status, job.technicianId),\n\t\t\t\t\tentity: job,\n\t\t\t\t})}\n\t\t\t\tonItemMove={handleItemMove}\n\t\t\t\trenderCard={(item) => <JobCard item={item} />}\n\t\t\t\tupdateEntityStatus={(job, newStatus) =>\n\t\t\t\t\tnewStatus === \"unassigned\"\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...job,\n\t\t\t\t\t\t\t\tisUnassigned: true,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t...job,\n\t\t\t\t\t\t\t\tstatus: newStatus,\n\t\t\t\t\t\t\t\tisUnassigned: false,\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t/>\n\n\t\t\t{/* Floating Add Button */}\n\t\t\t<TooltipProvider>\n\t\t\t\t<Tooltip>\n\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tclassName=\"fixed bottom-6 right-6 z-50 size-12 rounded-full shadow-lg\"\n\t\t\t\t\t\t\tonClick={() => setShowQuickAppointment(true)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Plus className=\"size-5\" />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t<TooltipContent side=\"left\">\n\t\t\t\t\t\tCreate Appointment\n\t\t\t\t\t</TooltipContent>\n\t\t\t\t</Tooltip>\n\t\t\t</TooltipProvider>\n\n\t\t\t{/* Quick Appointment Dialog */}\n\t\t\t<QuickAppointmentDialog\n\t\t\t\topen={showQuickAppointment}\n\t\t\t\tonOpenChange={setShowQuickAppointment}\n\t\t\t\tonSuccess={() => {\n\t\t\t\t\tsetShowQuickAppointment(false);\n\t\t\t\t\ttoast.success(\"Appointment created\");\n\t\t\t\t}}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n"],"names":[],"mappings":"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"}}]
}