{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;CAaC"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA6PsB,YAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAolBsB,YAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA87BsB,kBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA+vCsB,WAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAi1CsB,cAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAknDsB,aAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA04DsB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/jobs.ts"],"sourcesContent":["/**\n * Jobs Server Actions - REFACTORED FOR DOMAIN TABLE STRUCTURE\n *\n * Handles job/work order management with comprehensive CRUD operations,\n * status transitions, scheduling, and assignment logic.\n *\n * MIGRATION NOTES:\n * - Core jobs table now has ~20 columns\n * - Domain-specific data moved to 11 domain tables\n * - Financial data -> job_financial\n * - Time tracking -> job_time_tracking\n * - Archive/deletion -> job_multi_entity\n * - All domain tables have CASCADE delete on job_id\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { notifyJobCreated } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype JobStatus,\n\ttype JobStatusTransitionContext,\n\tvalidateStatusTransition,\n} from \"@/lib/validations/job-status-transitions\";\n\n// Regex constants\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst createJobSchema = z.object({\n\tpropertyId: z.string().uuid(\"Invalid property ID\"),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional(),\n\ttitle: z.string().min(1, \"Job title is required\"),\n\tdescription: z.string().optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).default(\"medium\"),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\tnotes: z.string().optional(),\n\t// Enhanced scheduling fields\n\tisRecurring: z.boolean().optional(),\n\tschedulingMode: z.enum([\"specific\", \"window\"]).optional(),\n\ttimeWindow: z.string().optional(),\n\trecurrenceType: z\n\t\t.enum([\"daily\", \"weekly\", \"biweekly\", \"monthly\", \"quarterly\", \"yearly\"])\n\t\t.optional(),\n\trecurrenceEndDate: z.string().optional(),\n\trecurrenceCount: z.number().int().min(1).max(365).optional(),\n});\n\nconst updateJobSchema = z.object({\n\ttitle: z.string().min(1, \"Job title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"medium\", \"high\", \"urgent\"]).optional(),\n\tjobType: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"installation\",\n\t\t\t\"repair\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"consultation\",\n\t\t])\n\t\t.optional(),\n\tnotes: z.string().optional(),\n\t// Financial fields (now in job_financial domain table)\n\ttotalAmount: z.number().min(0).optional(),\n\tpaidAmount: z.number().min(0).optional(),\n\tdepositAmount: z.number().min(0).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tcustomerId: z.string().uuid(\"Invalid customer ID\").optional().nullable(),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional().nullable(),\n});\n\n// Type for updateJobData - makes it easier to use programmatically\nexport type UpdateJobData = z.infer<typeof updateJobSchema>;\n\nconst scheduleJobSchema = z.object({\n\tscheduledStart: z.string(),\n\tscheduledEnd: z.string(),\n});\n\n/**\n * Generate unique job number\n */\nasync function generateJobNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\t// Get the latest job number for this company\n\tconst { data: latestJob } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"job_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestJob) {\n\t\treturn `JOB-${new Date().getFullYear()}-001`;\n\t}\n\n\t// Extract number from format: JOB-YYYY-NNN\n\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\t// Fallback\n\treturn `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate next recurrence date\n */\nfunction calculateNextRecurrence(\n\tcurrentDate: Date,\n\trecurrenceType: string,\n): Date {\n\tconst nextDate = new Date(currentDate);\n\n\tswitch (recurrenceType) {\n\t\tcase \"daily\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 1);\n\t\t\tbreak;\n\t\tcase \"weekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 7);\n\t\t\tbreak;\n\t\tcase \"biweekly\":\n\t\t\tnextDate.setDate(nextDate.getDate() + 14);\n\t\t\tbreak;\n\t\tcase \"monthly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t\tcase \"quarterly\":\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 3);\n\t\t\tbreak;\n\t\tcase \"yearly\":\n\t\t\tnextDate.setFullYear(nextDate.getFullYear() + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Default to monthly if unknown type\n\t\t\tnextDate.setMonth(nextDate.getMonth() + 1);\n\t\t\tbreak;\n\t}\n\n\treturn nextDate;\n}\n\n/**\n * Create recurring jobs\n */\nasync function createRecurringJobs(\n\tsupabase: any,\n\tcompanyId: string,\n\tbaseJob: any,\n\trecurrenceType: string,\n\trecurrenceEndDate?: string,\n\trecurrenceCount?: number,\n): Promise<void> {\n\tif (!baseJob.scheduled_start) {\n\t\treturn; // Can't create recurring jobs without a start date\n\t}\n\n\tconst startDate = new Date(baseJob.scheduled_start);\n\tconst endDate = new Date(baseJob.scheduled_end || baseJob.scheduled_start);\n\tconst duration = endDate.getTime() - startDate.getTime();\n\n\t// Determine how many occurrences to create\n\tconst maxOccurrences = recurrenceCount || 52; // Default to 1 year of weekly jobs\n\tconst endDateLimit = recurrenceEndDate ? new Date(recurrenceEndDate) : null;\n\n\tconst recurringJobs: (typeof baseJob)[] = [];\n\tlet currentDate = new Date(startDate);\n\n\tfor (let i = 0; i < maxOccurrences - 1; i++) {\n\t\t// -1 because we already created the first job\n\t\tcurrentDate = calculateNextRecurrence(currentDate, recurrenceType);\n\n\t\t// Stop if we've reached the end date\n\t\tif (endDateLimit && currentDate > endDateLimit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst currentEndDate = new Date(currentDate.getTime() + duration);\n\n\t\t// Generate a unique job number for this occurrence\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\trecurringJobs.push({\n\t\t\t...baseJob,\n\t\t\tjob_number: jobNumber,\n\t\t\tscheduled_start: currentDate.toISOString(),\n\t\t\tscheduled_end: currentEndDate.toISOString(),\n\t\t\ttitle: `${baseJob.title} (${i + 2}/${maxOccurrences})`, // Add occurrence number\n\t\t});\n\n\t\t// Create jobs in batches of 10 to avoid memory issues\n\t\tif (recurringJobs.length >= 10) {\n\t\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t\t\trecurringJobs.length = 0; // Clear array\n\t\t}\n\t}\n\n\t// Insert any remaining jobs\n\tif (recurringJobs.length > 0) {\n\t\tawait supabase.from(\"jobs\").insert(recurringJobs);\n\t}\n}\n\n/**\n * Create a new job\n * ‚úÖ ALREADY MIGRATED - Creates core job + all 10 domain records in parallel\n */\nexport async function createJob(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = createJobSchema.parse({\n\t\t\tpropertyId: formData.get(\"propertyId\"),\n\t\t\tcustomerId: formData.get(\"customerId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || \"medium\",\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Enhanced scheduling fields\n\t\t\tisRecurring: formData.get(\"isRecurring\") === \"true\",\n\t\t\tschedulingMode: (formData.get(\"schedulingMode\") as any) || undefined,\n\t\t\ttimeWindow: formData.get(\"timeWindow\") || undefined,\n\t\t\trecurrenceType: (formData.get(\"recurrenceType\") as any) || undefined,\n\t\t\trecurrenceEndDate: formData.get(\"recurrenceEndDate\") || undefined,\n\t\t\trecurrenceCount: formData.get(\"recurrenceCount\")\n\t\t\t\t? Number.parseInt(formData.get(\"recurrenceCount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t});\n\n\t\t// Verify property belongs to company\n\t\tconst { data: property } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"company_id, customer_id, address\")\n\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t.single();\n\n\t\tassertExists(property, \"Property\");\n\n\t\tif (property.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"property\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use customer from property if not provided\n\t\tconst customerId = data.customerId || property.customer_id;\n\n\t\t// Generate unique job number\n\t\tconst jobNumber = await generateJobNumber(supabase, companyId);\n\n\t\t// Add time window info to notes if applicable\n\t\tlet jobNotes = data.notes || \"\";\n\t\tif (data.schedulingMode === \"window\" && data.timeWindow) {\n\t\t\tconst windowInfo = `\\n\\n[Scheduling] Customer preferred time window: ${data.timeWindow.charAt(0).toUpperCase() + data.timeWindow.slice(1)}`;\n\t\t\tjobNotes = jobNotes ? `${jobNotes}${windowInfo}` : windowInfo.trim();\n\t\t}\n\n\t\t// Create core job record\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tservice_type: data.jobType, // Default service_type to job_type\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: jobNotes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create domain records (parallel inserts for performance)\n\t\tconst domainInserts = await Promise.all([\n\t\t\t// Financial domain - always create with defaults\n\t\t\tsupabase\n\t\t\t\t.from(\"job_financial\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_amount: 0,\n\t\t\t\t\tpaid_amount: 0,\n\t\t\t\t\tdeposit_amount: 0,\n\t\t\t\t}),\n\n\t\t\t// Workflow domain - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_workflow\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tworkflow_completed_stages: [],\n\t\t\t\t}),\n\n\t\t\t// Time tracking - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\ttotal_labor_hours: 0,\n\t\t\t\t\tbreak_time_minutes: 0,\n\t\t\t\t}),\n\n\t\t\t// Customer approval - always create with pending\n\t\t\tsupabase\n\t\t\t\t.from(\"job_customer_approval\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tcustomer_approval_status: \"pending\",\n\t\t\t\t}),\n\n\t\t\t// Equipment service - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_equipment_service\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tequipment_service_history: [],\n\t\t\t\t\tequipment_serviced: [],\n\t\t\t\t}),\n\n\t\t\t// Dispatch - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_dispatch\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Quality - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_quality\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\tinspection_required: false,\n\t\t\t\t}),\n\n\t\t\t// Safety - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_safety\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_permit: false,\n\t\t\t\t}),\n\n\t\t\t// AI enrichment - create empty for future processing\n\t\t\tsupabase\n\t\t\t\t.from(\"job_ai_enrichment\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t}),\n\n\t\t\t// Multi-entity - always create\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.insert({\n\t\t\t\t\tjob_id: newJob.id,\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t\trequires_multiple_properties: false,\n\t\t\t\t\trequires_multiple_customers: false,\n\t\t\t\t}),\n\t\t]);\n\n\t\t// Check for any domain insert errors\n\t\tconst domainErrors = domainInserts.filter((result) => result.error);\n\t\tif (domainErrors.length > 0) {\n\t\t\t// Rollback - delete the job (CASCADE will delete domain records)\n\t\t\tawait supabase.from(\"jobs\").delete().eq(\"id\", newJob.id);\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job domains\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create recurring jobs if requested\n\t\tif (data.isRecurring && data.recurrenceType && data.scheduledStart) {\n\t\t\tconst baseJob = {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tproperty_id: data.propertyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tassigned_to: data.assignedTo,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"quoted\",\n\t\t\t\tpriority: data.priority,\n\t\t\t\tjob_type: data.jobType,\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tnotes: data.notes,\n\t\t\t};\n\n\t\t\tawait createRecurringJobs(\n\t\t\t\tsupabase,\n\t\t\t\tcompanyId,\n\t\t\t\tbaseJob,\n\t\t\t\tdata.recurrenceType,\n\t\t\t\tdata.recurrenceEndDate,\n\t\t\t\tdata.recurrenceCount,\n\t\t\t);\n\t\t}\n\n\t\t// Send notification to assigned user if job is assigned\n\t\tif (data.assignedTo && data.assignedTo !== user.id) {\n\t\t\tawait notifyJobCreated({\n\t\t\t\tuserId: data.assignedTo,\n\t\t\t\tcompanyId: companyId,\n\t\t\t\tjobId: newJob.id,\n\t\t\t\tjobTitle: data.title,\n\t\t\t\taddress: property.address || \"Unknown address\",\n\t\t\t\tpriority:\n\t\t\t\t\tdata.priority === \"urgent\"\n\t\t\t\t\t\t? \"urgent\"\n\t\t\t\t\t\t: data.priority === \"high\"\n\t\t\t\t\t\t\t? \"high\"\n\t\t\t\t\t\t\t: \"medium\",\n\t\t\t\tactionUrl: \"/dashboard/work\",\n\t\t\t});\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Get a single job by ID\n * ‚úÖ ALREADY MIGRATED - Fetches job with all domain data\n */\nasync function getJob(jobId: string): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get job with basic relationships\n\t\t// Simplified query - many domain tables don't exist yet\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\t*,\n\t\t\t\tproperty:properties(*),\n\t\t\t\tcustomer:customers!customer_id(id, first_name, last_name, email, phone, display_name)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.notFound(\"Job\"),\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify job belongs to company\n\t\tif (job.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\treturn job;\n\t});\n}\n\n/**\n * Update job details\n * üîß REFACTORED - Now updates both core jobs table and domain tables\n */\nexport async function updateJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get user's role to check if they're admin/owner\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        role_id,\n        custom_roles!role_id(name, is_system)\n      `,\n\t\t\t)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tconst role = Array.isArray(teamMember?.custom_roles)\n\t\t\t? teamMember.custom_roles[0]\n\t\t\t: teamMember?.custom_roles;\n\n\t\tconst isAdminOrOwner =\n\t\t\trole?.name === \"Admin\" ||\n\t\t\trole?.name === \"Owner\" ||\n\t\t\trole?.is_system === true;\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent editing completed or cancelled jobs (unless admin/owner)\n\t\tif (\n\t\t\t!isAdminOrOwner &&\n\t\t\t(existingJob.status === \"completed\" || existingJob.status === \"cancelled\")\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot edit ${existingJob.status} jobs`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst customerIdValue = formData.get(\"customerId\");\n\t\tconst propertyIdValue = formData.get(\"propertyId\");\n\n\t\t// Handle customerId: empty string or \"null\" string means remove (set to null)\n\t\t// undefined means don't change it\n\t\tlet parsedCustomerId: string | null | undefined;\n\t\tif (customerIdValue === null || customerIdValue === undefined) {\n\t\t\tparsedCustomerId = undefined; // Don't change\n\t\t} else if (customerIdValue === \"\" || customerIdValue === \"null\") {\n\t\t\tparsedCustomerId = null; // Remove customer\n\t\t} else {\n\t\t\tparsedCustomerId = customerIdValue as string; // Set to this customer\n\t\t}\n\n\t\t// Handle propertyId: empty string means remove (set to null), undefined means don't change\n\t\tlet parsedPropertyId: string | null | undefined;\n\t\tif (propertyIdValue === null || propertyIdValue === undefined) {\n\t\t\tparsedPropertyId = undefined; // Don't change\n\t\t} else if (propertyIdValue === \"\" || propertyIdValue === \"null\") {\n\t\t\tparsedPropertyId = null; // Remove property\n\t\t} else {\n\t\t\tparsedPropertyId = propertyIdValue as string; // Set to this property\n\t\t}\n\n\t\tconst data = updateJobSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tstatus: formData.get(\"status\") || undefined,\n\t\t\tpriority: formData.get(\"priority\") || undefined,\n\t\t\tjobType: formData.get(\"jobType\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\t// Financial fields (now in job_financial domain table)\n\t\t\ttotalAmount: formData.get(\"totalAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"totalAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tpaidAmount: formData.get(\"paidAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"paidAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tdepositAmount: formData.get(\"depositAmount\")\n\t\t\t\t? Number.parseInt(formData.get(\"depositAmount\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") || undefined,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") || undefined,\n\t\t\tassignedTo: formData.get(\"assignedTo\") || null,\n\t\t\tcustomerId: parsedCustomerId,\n\t\t\tpropertyId: parsedPropertyId,\n\t\t});\n\n\t\t// If status is being changed, validate the transition\n\t\tif (data.status !== undefined && data.status !== existingJob.status) {\n\t\t\t// Fetch additional context for status validation\n\t\t\tconst { data: jobWithContext } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n\t\t\t\t\tid,\n\t\t\t\t\tstatus,\n\t\t\t\t\tscheduled_start,\n\t\t\t\t\tscheduled_end,\n\t\t\t\t\tassigned_to,\n\t\t\t\t\tcustomer_id,\n\t\t\t\t\tproperty_id,\n\t\t\t\t\ttotal_amount,\n\t\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\t\testimates:estimates(status),\n\t\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t\t`,\n\t\t\t\t)\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.single();\n\n\t\t\tif (jobWithContext) {\n\t\t\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\t\t\tcurrentStatus: jobWithContext.status as JobStatus,\n\t\t\t\t\tnewStatus: data.status as JobStatus,\n\t\t\t\t\tjob: {\n\t\t\t\t\t\tid: jobWithContext.id,\n\t\t\t\t\t\tscheduled_start:\n\t\t\t\t\t\t\tdata.scheduledStart || jobWithContext.scheduled_start,\n\t\t\t\t\t\tscheduled_end: data.scheduledEnd || jobWithContext.scheduled_end,\n\t\t\t\t\t\tassigned_to:\n\t\t\t\t\t\t\tdata.assignedTo !== undefined\n\t\t\t\t\t\t\t\t? data.assignedTo\n\t\t\t\t\t\t\t\t: jobWithContext.assigned_to,\n\t\t\t\t\t\tcustomer_id:\n\t\t\t\t\t\t\tdata.customerId !== undefined\n\t\t\t\t\t\t\t\t? data.customerId\n\t\t\t\t\t\t\t\t: jobWithContext.customer_id,\n\t\t\t\t\t\tproperty_id:\n\t\t\t\t\t\t\tdata.propertyId !== undefined\n\t\t\t\t\t\t\t\t? data.propertyId\n\t\t\t\t\t\t\t\t: jobWithContext.property_id,\n\t\t\t\t\t\ttotal_amount:\n\t\t\t\t\t\t\tdata.totalAmount !== undefined\n\t\t\t\t\t\t\t\t? data.totalAmount\n\t\t\t\t\t\t\t\t: jobWithContext.total_amount,\n\t\t\t\t\t\tinvoices: jobWithContext.invoices || [],\n\t\t\t\t\t\testimates: jobWithContext.estimates || [],\n\t\t\t\t\t\tteamAssignments: jobWithContext.team_assignments || [],\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\t\t\tif (!validationResult.allowed) {\n\t\t\t\t\tlet errorMessage =\n\t\t\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t\t\t) {\n\t\t\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if present (non-blocking)\n\t\t\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tcurrentStatus: jobWithContext.status,\n\t\t\t\t\t\tnewStatus: data.status,\n\t\t\t\t\t\twarnings: validationResult.warnings,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build core job update object with only defined values\n\t\tconst coreUpdateData: any = {};\n\t\tif (data.title !== undefined) {\n\t\t\tcoreUpdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tcoreUpdateData.description = data.description;\n\t\t}\n\t\tif (data.status !== undefined) {\n\t\t\tcoreUpdateData.status = data.status;\n\t\t}\n\t\tif (data.priority !== undefined) {\n\t\t\tcoreUpdateData.priority = data.priority;\n\t\t}\n\t\tif (data.jobType !== undefined) {\n\t\t\tcoreUpdateData.job_type = data.jobType;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tcoreUpdateData.notes = data.notes;\n\t\t}\n\t\tif (data.scheduledStart !== undefined) {\n\t\t\tcoreUpdateData.scheduled_start = data.scheduledStart;\n\t\t}\n\t\tif (data.scheduledEnd !== undefined) {\n\t\t\tcoreUpdateData.scheduled_end = data.scheduledEnd;\n\t\t}\n\t\tif (data.assignedTo !== undefined) {\n\t\t\tcoreUpdateData.assigned_to = data.assignedTo;\n\t\t}\n\t\tif (data.customerId !== undefined) {\n\t\t\tcoreUpdateData.customer_id = data.customerId;\n\t\t}\n\t\tif (data.propertyId !== undefined) {\n\t\t\tcoreUpdateData.property_id = data.propertyId;\n\t\t\t// If property is being set (not null), verify it belongs to the customer (if customer is set)\n\t\t\tif (\n\t\t\t\tdata.propertyId !== null &&\n\t\t\t\tdata.customerId !== undefined &&\n\t\t\t\tdata.customerId !== null\n\t\t\t) {\n\t\t\t\tconst { data: property } = await supabase\n\t\t\t\t\t.from(\"properties\")\n\t\t\t\t\t.select(\"customer_id\")\n\t\t\t\t\t.eq(\"id\", data.propertyId)\n\t\t\t\t\t.single();\n\n\t\t\t\tif (property && property.customer_id !== data.customerId) {\n\t\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\t\"Property does not belong to the selected customer\",\n\t\t\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build financial domain update object (if any financial fields provided)\n\t\tconst financialUpdateData: any = {};\n\t\tif (data.totalAmount !== undefined) {\n\t\t\tfinancialUpdateData.total_amount = data.totalAmount;\n\t\t}\n\t\tif (data.paidAmount !== undefined) {\n\t\t\tfinancialUpdateData.paid_amount = data.paidAmount;\n\t\t}\n\t\tif (data.depositAmount !== undefined) {\n\t\t\tfinancialUpdateData.deposit_amount = data.depositAmount;\n\t\t}\n\n\t\t// Execute updates in parallel for performance\n\t\tconst updates: Promise<any>[] = [];\n\n\t\t// Update core job table if there are changes\n\t\tif (Object.keys(coreUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () => await supabase.from(\"jobs\").update(coreUpdateData).eq(\"id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Update financial domain table if there are changes\n\t\tif (Object.keys(financialUpdateData).length > 0) {\n\t\t\tupdates.push(\n\t\t\t\t(async () =>\n\t\t\t\t\tawait supabase\n\t\t\t\t\t\t.from(\"job_financial\")\n\t\t\t\t\t\t.update(financialUpdateData)\n\t\t\t\t\t\t.eq(\"job_id\", jobId))(),\n\t\t\t);\n\t\t}\n\n\t\t// Execute all updates in parallel\n\t\tif (updates.length > 0) {\n\t\t\tconst results = await Promise.all(updates);\n\n\t\t\t// Check for errors in any update\n\t\t\tconst errors = results.filter((result) => result.error);\n\t\t\tif (errors.length > 0) {\n\t\t\t\tconst errorMessages = errors.map((e) => e.error.message).join(\", \");\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t`${ERROR_MESSAGES.operationFailed(\"update job\")}: ${errorMessages}`,\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Update job with data object (easier for programmatic use)\n * Used by job editor for in-place updates\n */\nasync function updateJobData(\n\tjobId: string,\n\tdata: Partial<UpdateJobData>,\n): Promise<ActionResult<void>> {\n\t// Convert data object to FormData for compatibility with existing updateJob\n\tconst formData = new FormData();\n\n\t// Add all defined fields to FormData\n\tif (data.title !== undefined) formData.append(\"title\", data.title);\n\tif (data.description !== undefined)\n\t\tformData.append(\"description\", data.description);\n\tif (data.status !== undefined) formData.append(\"status\", data.status);\n\tif (data.priority !== undefined) formData.append(\"priority\", data.priority);\n\tif (data.jobType !== undefined) formData.append(\"jobType\", data.jobType);\n\tif (data.notes !== undefined) formData.append(\"notes\", data.notes);\n\tif (data.totalAmount !== undefined)\n\t\tformData.append(\"totalAmount\", data.totalAmount.toString());\n\tif (data.paidAmount !== undefined)\n\t\tformData.append(\"paidAmount\", data.paidAmount.toString());\n\tif (data.depositAmount !== undefined)\n\t\tformData.append(\"depositAmount\", data.depositAmount.toString());\n\tif (data.scheduledStart !== undefined)\n\t\tformData.append(\"scheduledStart\", data.scheduledStart);\n\tif (data.scheduledEnd !== undefined)\n\t\tformData.append(\"scheduledEnd\", data.scheduledEnd);\n\tif (data.assignedTo !== undefined)\n\t\tformData.append(\"assignedTo\", data.assignedTo || \"\");\n\tif (data.customerId !== undefined)\n\t\tformData.append(\"customerId\", data.customerId || \"\");\n\tif (data.propertyId !== undefined)\n\t\tformData.append(\"propertyId\", data.propertyId || \"\");\n\n\t// Reuse existing updateJob logic (which already handles errors)\n\treturn updateJob(jobId, formData);\n}\n\n/**\n * Update job status with validation\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status\n */\nexport async function updateJobStatus(\n\tjobId: string,\n\tnewStatus: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Validate status value\n\t\tconst validStatuses: JobStatus[] = [\n\t\t\t\"quoted\",\n\t\t\t\"scheduled\",\n\t\t\t\"in_progress\",\n\t\t\t\"on_hold\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"invoiced\",\n\t\t\t\"paid\",\n\t\t];\n\t\tif (!validStatuses.includes(newStatus as JobStatus)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invalid job status\",\n\t\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch job with all context needed for transition validation\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tcompany_id,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tassigned_to,\n\t\t\t\tcustomer_id,\n\t\t\t\tproperty_id,\n\t\t\t\ttotal_amount,\n\t\t\t\tinvoices:invoices(status, total_amount),\n\t\t\t\testimates:estimates(status),\n\t\t\t\tteam_assignments:job_team_assignments(team_member_id)\n\t\t\t`,\n\t\t\t)\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Build context for transition validation\n\t\tconst transitionContext: JobStatusTransitionContext = {\n\t\t\tcurrentStatus: existingJob.status as JobStatus,\n\t\t\tnewStatus: newStatus as JobStatus,\n\t\t\tjob: {\n\t\t\t\tid: existingJob.id,\n\t\t\t\tscheduled_start: existingJob.scheduled_start,\n\t\t\t\tscheduled_end: existingJob.scheduled_end,\n\t\t\t\tassigned_to: existingJob.assigned_to,\n\t\t\t\tcustomer_id: existingJob.customer_id,\n\t\t\t\tproperty_id: existingJob.property_id,\n\t\t\t\ttotal_amount: existingJob.total_amount,\n\t\t\t\tinvoices: existingJob.invoices || [],\n\t\t\t\testimates: existingJob.estimates || [],\n\t\t\t\tteamAssignments: existingJob.team_assignments || [],\n\t\t\t},\n\t\t};\n\n\t\t// Validate transition with comprehensive business rules\n\t\tconst validationResult = validateStatusTransition(transitionContext);\n\n\t\tif (!validationResult.allowed) {\n\t\t\tlet errorMessage =\n\t\t\t\tvalidationResult.reason || \"Status transition not allowed\";\n\n\t\t\tif (\n\t\t\t\tvalidationResult.requiredFields &&\n\t\t\t\tvalidationResult.requiredFields.length > 0\n\t\t\t) {\n\t\t\t\terrorMessage += `. Missing: ${validationResult.requiredFields.join(\", \")}`;\n\t\t\t}\n\n\t\t\tthrow new ActionError(errorMessage, ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Log warnings if present (non-blocking)\n\t\tif (validationResult.warnings && validationResult.warnings.length > 0) {\n\t\t\tconsole.warn(\"‚ö†Ô∏è Status transition warnings:\", {\n\t\t\t\tjobId,\n\t\t\t\tcurrentStatus: existingJob.status,\n\t\t\t\tnewStatus,\n\t\t\t\twarnings: validationResult.warnings,\n\t\t\t});\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ status: newStatus })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update job status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(\"‚úÖ Job status updated:\", {\n\t\t\tjobId,\n\t\t\toldStatus: existingJob.status,\n\t\t\tnewStatus,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Assign job to a technician\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.assigned_to\n */\nasync function assignJob(\n\tjobId: string,\n\ttechnicianId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify technician belongs to company\n\t\tconst { data: technician } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"user_id\", technicianId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!technician) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Technician not found in your company\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t404,\n\t\t\t);\n\t\t}\n\n\t\t// Assign job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Schedule a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs table scheduling fields\n */\nasync function scheduleJob(\n\tjobId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = scheduleJobSchema.parse({\n\t\t\tscheduledStart: formData.get(\"scheduledStart\"),\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\"),\n\t\t});\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update schedule and status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: data.scheduledStart,\n\t\t\t\tscheduled_end: data.scheduledEnd,\n\t\t\t\tstatus:\n\t\t\t\t\texistingJob.status === \"quoted\" ? \"scheduled\" : existingJob.status,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"schedule job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Start a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_start instead of jobs.actual_start\n */\nexport async function startJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only start scheduled jobs\n\t\tif (existingJob.status !== \"scheduled\" && existingJob.status !== \"quoted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be scheduled before starting\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_start) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"in_progress\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update({ actual_start: now })\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"start job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Complete a job\n * üîß REFACTORED - Now updates job_time_tracking.actual_end and calculates total_labor_hours\n */\nexport async function completeJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and get time tracking data\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, timeTracking:job_time_tracking(*)\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only complete in-progress jobs\n\t\tif (existingJob.status !== \"in_progress\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job must be in progress to complete\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Calculate total labor hours if we have actual_start\n\t\tconst timeTracking = Array.isArray(existingJob.timeTracking)\n\t\t\t? existingJob.timeTracking[0]\n\t\t\t: existingJob.timeTracking;\n\n\t\tconst timeTrackingUpdate: any = { actual_end: now };\n\n\t\tif (timeTracking?.actual_start) {\n\t\t\tconst startTime = new Date(timeTracking.actual_start).getTime();\n\t\t\tconst endTime = new Date(now).getTime();\n\t\t\tconst hoursWorked = (endTime - startTime) / (1000 * 60 * 60); // Convert ms to hours\n\t\t\ttimeTrackingUpdate.total_labor_hours = hoursWorked;\n\t\t}\n\n\t\t// Update both jobs table (status) and job_time_tracking table (actual_end, total_labor_hours) in parallel\n\t\tconst updates = await Promise.all([\n\t\t\tsupabase.from(\"jobs\").update({ status: \"completed\" }).eq(\"id\", jobId),\n\t\t\tsupabase\n\t\t\t\t.from(\"job_time_tracking\")\n\t\t\t\t.update(timeTrackingUpdate)\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"complete job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Cancel a job\n * ‚úÖ NO CHANGES NEEDED - Only updates jobs.status and jobs.notes\n */\nasync function cancelJob(\n\tjobId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: existingJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status, notes\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(existingJob, \"Job\");\n\n\t\tif (existingJob.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel completed jobs\n\t\tif (existingJob.status === \"completed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel completed jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${existingJob.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: existingJob.notes;\n\n\t\t// Cancel job\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t});\n}\n\n/**\n * Search jobs with full-text search and ranking\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchJobs(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\tconst { searchJobsFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst jobs = await searchJobsFullText(supabase, teamMember.company_id, searchTerm, {\n\t\t\tlimit: options?.limit || 50,\n\t\t\toffset: options?.offset || 0,\n\t\t});\n\n\t\treturn jobs;\n\t});\n}\n\n/**\n * Universal search across all entities\n * ‚úÖ NO CHANGES NEEDED - Only searches jobs table\n */\nasync function searchAll(\n\tsearchTerm: string,\n): Promise<ActionResult<any>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Use universal search RPC function\n\t\tconst { data, error } = await supabase.rpc(\"search_all_entities\", {\n\t\t\tcompany_id_param: teamMember.company_id,\n\t\t\tsearch_query: searchTerm,\n\t\t\tper_entity_limit: 5,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"search\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// JOB ARCHIVE & RESTORE\n// ============================================================================\n\n/**\n * Archive job (soft delete)\n * üîß REFACTORED - Now updates job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nexport async function archiveJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive completed/paid jobs (business rule)\n\t\tif (job.status === \"completed\" || job.status === \"invoiced\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive completed or invoiced jobs. These must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive job (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString();\n\n\t\t// Update both jobs table and job_multi_entity table in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Update core jobs table with archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: now,\n\t\t\t\t\tarchived_at: now,\n\t\t\t\t\tstatus: \"archived\",\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Update job_multi_entity table with deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: user.id,\n\t\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived job\n * üîß REFACTORED - Now clears job_multi_entity.deleted_by and permanent_delete_scheduled_at\n */\nasync function restoreJob(jobId: string): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job belongs to company and is archived\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\tif (job.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"job\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!job.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Job is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore job - update both tables in parallel\n\t\tconst updates = await Promise.all([\n\t\t\t// Clear core jobs table archive metadata\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_at: null,\n\t\t\t\t\tarchived_at: null,\n\t\t\t\t\tstatus: job.status === \"archived\" ? \"scheduled\" : job.status,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId),\n\n\t\t\t// Clear job_multi_entity table deletion tracking\n\t\t\tsupabase\n\t\t\t\t.from(\"job_multi_entity\")\n\t\t\t\t.update({\n\t\t\t\t\tdeleted_by: null,\n\t\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\t})\n\t\t\t\t.eq(\"job_id\", jobId),\n\t\t]);\n\n\t\t// Check for errors in either update\n\t\tconst errors = updates.filter((result) => result.error);\n\t\tif (errors.length > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Remove team assignment from job\n * ‚úÖ NO CHANGES NEEDED - Only deletes from job_team_assignments junction table\n */\nasync function removeTeamAssignment(\n\tassignmentId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's active company using helper (handles multi-company users)\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get the junction record to find job_id for revalidation\n\t\tconst { data: record, error: fetchError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.select(\"id, job_id, company_id\")\n\t\t\t.eq(\"id\", assignmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !record) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Team assignment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tif (record.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"team assignment\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst jobId = record.job_id;\n\n\t\t// Delete junction table row\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"job_team_assignments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", assignmentId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove team assignment from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate job page and schedule\n\t\tif (jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t});\n}\n\n/**\n * Assign Customer and Property to Job\n *\n * Updates the job's customer_id and property_id.\n * Only one customer and property can be assigned per job.\n *\n * @param jobId - Job ID\n * @param customerId - Customer ID to assign\n * @param propertyId - Property ID to assign (optional)\n */\nexport async function assignCustomerToJob(\n\tjobId: string,\n\tcustomerId: string,\n\tpropertyId: string | null,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job, error: jobError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (jobError) {\n\t\t\tconsole.error(\"Job query error:\", jobError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find job: ${jobError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer, error: customerError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (customerError) {\n\t\t\tconsole.error(\"Customer query error:\", customerError);\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${customerError.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t500,\n\t\t\t);\n\t\t}\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\t// If property is provided, verify it exists and belongs to customer\n\t\tif (propertyId) {\n\t\t\tconst { data: property } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id, customer_id\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.single();\n\n\t\t\tif (!property) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"Property not found or does not belong to this customer\",\n\t\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t\t\t404,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Update job with customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"assign customer to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"assigned\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: `Assigned customer${propertyId ? \" and property\" : \"\"}`,\n\t\t\tmetadata: {\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tproperty_id: propertyId,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n\n/**\n * Remove Customer and Property from Job\n *\n * Removes the customer_id and property_id from the job.\n * Related data (appointments, invoices, etc.) remain but are no longer linked.\n *\n * @param jobId - Job ID\n */\nexport async function removeCustomerFromJob(\n\tjobId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"company access\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify job exists and belongs to company\n\t\tconst { data: job } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, company_id, customer_id, property_id\")\n\t\t\t.eq(\"id\", jobId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(job, \"Job\");\n\n\t\t// Update job to remove customer and property\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tcustomer_id: null,\n\t\t\t\tproperty_id: null,\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"remove customer from job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Log activity\n\t\tawait supabase.from(\"job_activity_log\").insert({\n\t\t\tjob_id: jobId,\n\t\t\tcompany_id: companyId,\n\t\t\tuser_id: user.id,\n\t\t\tactivity_type: \"removed\",\n\t\t\tentity_type: \"customer\",\n\t\t\tdescription: \"Removed customer and property\",\n\t\t\tmetadata: {\n\t\t\t\tprevious_customer_id: job.customer_id,\n\t\t\t\tprevious_property_id: job.property_id,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/welcome\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA4gEsB,wBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}}]
}