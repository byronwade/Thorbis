{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAsDsB,yBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA0NsB,qBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA+VsB,oBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA6GsB,oBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAuJsB,0BAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAsWsB,mBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAyPsB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA2VsB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IAiZsB,0BAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/schedule-assignments.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport async function assignJobToTechnician(\n\t_jobId: string,\n\tscheduleId: string,\n\ttechnicianId: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// First check if the schedule exists and get current assignment\n\t\tconst { data: existingSchedule, error: checkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, assigned_to\")\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.single();\n\n\t\tif (checkError) {\n\t\t\tthrow new Error(`Schedule check failed: ${checkError.message}`);\n\t\t}\n\n\t\tif (!existingSchedule) {\n\t\t\tthrow new Error(\"Schedule not found\");\n\t\t}\n\n\t\t// Update the schedule's assigned_to field\n\t\tconst { data: updatedSchedule, error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ assigned_to: technicianId })\n\t\t\t.eq(\"id\", scheduleId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (scheduleError) {\n\t\t\tthrow new Error(`Schedule update failed: ${scheduleError.message}`);\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true, data: updatedSchedule };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to assign job\",\n\t\t};\n\t}\n}\n\nexport async function updateAppointmentTimes(\n\tscheduleId: string,\n\tstartTime: Date,\n\tendTime: Date,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst duration = Math.round(\n\t\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t\t);\n\n\t\t// Format as local datetime string WITHOUT timezone conversion\n\t\t// Get year, month, day, hour, minute from the Date object directly\n\t\tconst formatLocalDateTime = (date: Date) => {\n\t\t\tconst year = date.getFullYear();\n\t\t\tconst month = String(date.getMonth() + 1).padStart(2, \"0\");\n\t\t\tconst day = String(date.getDate()).padStart(2, \"0\");\n\t\t\tconst hour = String(date.getHours()).padStart(2, \"0\");\n\t\t\tconst minute = String(date.getMinutes()).padStart(2, \"0\");\n\t\t\tconst second = String(date.getSeconds()).padStart(2, \"0\");\n\t\t\treturn `${year}-${month}-${day} ${hour}:${minute}:${second}`;\n\t\t};\n\n\t\tconst startStr = formatLocalDateTime(startTime);\n\t\tconst endStr = formatLocalDateTime(endTime);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstart_time: startStr,\n\t\t\t\tend_time: endStr,\n\t\t\t\tduration,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Don't revalidate immediately - let the optimistic update show\n\t\t// revalidatePath(\"/dashboard/schedule\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to update times\",\n\t\t};\n\t}\n}\n\nexport async function cancelAppointment(scheduleId: string, reason?: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Cancel appointment - unschedule it (remove assigned_to)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null, // Unassign technician\n\t\t\t\tcancelled_at: new Date().toISOString(),\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to cancel appointment\",\n\t\t};\n\t}\n}\n\nexport async function cancelJobAndAppointment(\n\tscheduleId: string,\n\tjobId: string,\n\treason?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\t// Cancel the appointment\n\t\tconst { error: scheduleError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tassigned_to: null,\n\t\t\t\tcancelled_at: now,\n\t\t\t\tcancelled_by: user.id,\n\t\t\t\tcancellation_reason: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (scheduleError) {\n\t\t\tthrow scheduleError;\n\t\t}\n\n\t\t// Also cancel the job if it exists\n\t\tif (jobId) {\n\t\t\tconst { error: jobError } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"cancelled\",\n\t\t\t\t\tcancelled_at: now,\n\t\t\t\t\tcancelled_by: user.id,\n\t\t\t\t\tcancellation_reason: reason || null,\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", jobId);\n\n\t\t\tif (jobError) {\n\t\t\t\tthrow jobError;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to cancel job and appointment\",\n\t\t};\n\t}\n}\n\nexport async function archiveAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to archive appointment\",\n\t\t};\n\t}\n}\n\nexport async function completeAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end_time: now,\n\t\t\t\tcompleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to complete appointment\",\n\t\t};\n\t}\n}\n\ntype DispatchStatus = \"dispatched\" | \"arrived\" | \"closed\";\n\nasync function updateScheduleStatus(\n\tscheduleId: string,\n\tstatus: DispatchStatus,\n\textraUpdates: Record<string, unknown> = {},\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst now = new Date().toISOString();\n\t\tconst updates: Record<string, unknown> = {\n\t\t\tstatus,\n\t\t\tupdated_at: now,\n\t\t\t...extraUpdates,\n\t\t};\n\n\t\tif (status === \"closed\") {\n\t\t\tupdates.completed_by = user.id;\n\t\t\tupdates.actual_end_time = updates.actual_end_time ?? now;\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(updates)\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to update appointment status to ${status}`,\n\t\t};\n\t}\n}\n\nexport async function dispatchAppointment(scheduleId: string) {\n\treturn updateScheduleStatus(scheduleId, \"dispatched\");\n}\n\nexport async function arriveAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"arrived\", {\n\t\tactual_start_time: now,\n\t});\n}\n\nexport async function closeAppointment(scheduleId: string) {\n\tconst now = new Date().toISOString();\n\treturn updateScheduleStatus(scheduleId, \"closed\", {\n\t\tactual_end_time: now,\n\t});\n}\n\nexport async function unassignAppointment(scheduleId: string) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tassigned_to: null,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to move appointment to Unscheduled\",\n\t\t};\n\t}\n}\n\n/**\n * Send \"On My Way\" SMS notification to customer\n * Includes technician name and estimated arrival time\n */\nexport async function sendOnMyWayNotification(\n\tscheduleId: string,\n\ttechnicianName: string,\n\tcustomerPhone: string,\n\tdestinationAddress?: string,\n) {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, error: \"Database not available\" };\n\t}\n\n\ttry {\n\t\t// Get user and company info\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get company's Telnyx settings for the from number\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership?.company_id) {\n\t\t\treturn { success: false, error: \"No active company membership\" };\n\t\t}\n\n\t\tconst { data: telnyxSettings } = await supabase\n\t\t\t.from(\"company_telnyx_settings\")\n\t\t\t.select(\"phone_number, status\")\n\t\t\t.eq(\"company_id\", membership.company_id)\n\t\t\t.eq(\"status\", \"ready\")\n\t\t\t.single();\n\n\t\tif (!telnyxSettings?.phone_number) {\n\t\t\treturn { success: false, error: \"No phone number configured for SMS\" };\n\t\t}\n\n\t\t// Get company name for the message\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", membership.company_id)\n\t\t\t.single();\n\n\t\t// Build the \"On My Way\" message\n\t\tlet message = `Hi! ${technicianName} from ${company?.name || \"your service provider\"} is on the way to your appointment.`;\n\n\t\t// Try to get travel time estimate if we have a destination\n\t\tif (destinationAddress) {\n\t\t\ttry {\n\t\t\t\tconst baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\";\n\t\t\t\tconst travelResponse = await fetch(\n\t\t\t\t\t`${baseUrl}/api/travel-time?destination=${encodeURIComponent(destinationAddress)}`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tCookie: `sb-access-token=${user.id}`, // Pass auth context\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (travelResponse.ok) {\n\t\t\t\t\tconst travelData = await travelResponse.json();\n\t\t\t\t\tif (travelData.durationText) {\n\t\t\t\t\t\tmessage += ` Estimated arrival: ${travelData.durationText}.`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Travel time fetch failed - continue without it\n\t\t\t}\n\t\t}\n\n\t\tmessage += \" We'll see you soon!\";\n\n\t\t// Send the SMS via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tto: customerPhone,\n\t\t\tfrom: telnyxSettings.phone_number,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: \"Failed to send SMS\" };\n\t\t}\n\n\t\t// Update appointment status to dispatched\n\t\tawait supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"dispatched\",\n\t\t\t\tdispatched_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", scheduleId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"On My Way notification sent successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to send On My Way notification\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;IA6WsB,sBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/ui/context-menu.tsx"],"sourcesContent":["// Re-export from @stratos/ui package\nexport * from \"@stratos/ui\";\n"],"names":[],"mappings":"AAAA,qCAAqC;;AACrC"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/schedule-job-context-menu.tsx"],"sourcesContent":["\"use client\";\n\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport {\n\tArchive,\n\tCalendar,\n\tCheckCircle2,\n\tChevronRight,\n\tClock,\n\tCopy,\n\tExternalLink,\n\tMapPin,\n\tMessageSquare,\n\tMoreHorizontal,\n\tNavigation,\n\tPhone,\n\tSend,\n\tTrash2,\n\tTruck,\n\tUserCheck,\n\tUserMinus,\n\tXCircle,\n} from \"lucide-react\";\nimport {\n\tarchiveAppointment,\n\tarriveAppointment,\n\tcancelAppointment,\n\tcancelJobAndAppointment,\n\tcloseAppointment,\n\tcompleteAppointment,\n\tdispatchAppointment,\n\tsendOnMyWayNotification,\n\tunassignAppointment,\n} from \"@/actions/schedule-assignments\";\nimport {\n\tContextMenu,\n\tContextMenuContent,\n\tContextMenuItem,\n\tContextMenuLabel,\n\tContextMenuSeparator,\n\tContextMenuShortcut,\n\tContextMenuSub,\n\tContextMenuSubContent,\n\tContextMenuSubTrigger,\n\tContextMenuTrigger,\n} from \"@/components/ui/context-menu\";\nimport { cn } from \"@/lib/utils\";\nimport type { Job } from \"./schedule-types\";\n\ntype ScheduleJobContextMenuProps = {\n\tjob: Job;\n\tchildren: React.ReactNode;\n\tonOpenChange?: (open: boolean) => void;\n};\n\n// Status workflow order for visual display\nconst STATUS_ORDER = [\"scheduled\", \"dispatched\", \"arrived\", \"in-progress\", \"closed\", \"completed\"];\n\n// Get current status step for progress indicator\nfunction getStatusStep(status: Job[\"status\"]) {\n\tconst idx = STATUS_ORDER.indexOf(status);\n\treturn idx === -1 ? 0 : idx;\n}\n\nexport function ScheduleJobContextMenu({\n\tjob,\n\tchildren,\n\tonOpenChange,\n}: ScheduleJobContextMenuProps) {\n\tconst router = useRouter();\n\tconst currentStep = getStatusStep(job.status);\n\tconst isCancelled = job.status === \"cancelled\";\n\tconst isClosed = job.status === \"closed\" || job.status === \"completed\";\n\n\tconst handleAction = async (\n\t\taction: string,\n\t\tactionFn: (id: string, ...args: unknown[]) => Promise<{ success: boolean; error?: string }>,\n\t\t...args: unknown[]\n\t) => {\n\t\tconst toastId = toast.loading(`${action}...`);\n\t\tconst result = await actionFn(job.id, ...args);\n\n\t\tif (result.success) {\n\t\t\ttoast.success(`${action} successful`, { id: toastId });\n\t\t} else {\n\t\t\ttoast.error(result.error || `Failed to ${action.toLowerCase()}`, {\n\t\t\t\tid: toastId,\n\t\t\t});\n\t\t}\n\t};\n\n\tconst handleSendOnMyWay = async () => {\n\t\tif (!job.customer?.phone) {\n\t\t\ttoast.error(\"Customer has no phone number\");\n\t\t\treturn;\n\t\t}\n\t\tconst techName = job.assignments[0]?.displayName || \"Your technician\";\n\t\tconst address = job.location?.address\n\t\t\t? `${job.location.address.street}, ${job.location.address.city}, ${job.location.address.state}`\n\t\t\t: undefined;\n\n\t\ttoast.loading(\"Sending On My Way notification...\");\n\t\tconst result = await sendOnMyWayNotification(\n\t\t\tjob.id,\n\t\t\ttechName,\n\t\t\tjob.customer.phone,\n\t\t\taddress,\n\t\t);\n\t\ttoast.dismiss();\n\n\t\tif (result.success) {\n\t\t\ttoast.success(\"On My Way notification sent!\");\n\t\t} else {\n\t\t\ttoast.error(result.error || \"Failed to send notification\");\n\t\t}\n\t};\n\n\treturn (\n\t\t<ContextMenu onOpenChange={onOpenChange}>\n\t\t\t<ContextMenuTrigger asChild>{children}</ContextMenuTrigger>\n\n\t\t\t<ContextMenuContent className=\"w-64\">\n\t\t\t\t{/* Header - Job Info */}\n\t\t\t\t<div className=\"px-2 py-2 border-b mb-1\">\n\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\"size-2 rounded-full shrink-0\",\n\t\t\t\t\t\t\t\tjob.status === \"scheduled\" && \"bg-blue-500\",\n\t\t\t\t\t\t\t\tjob.status === \"dispatched\" && \"bg-sky-500\",\n\t\t\t\t\t\t\t\tjob.status === \"arrived\" && \"bg-emerald-400\",\n\t\t\t\t\t\t\t\tjob.status === \"in-progress\" && \"bg-amber-500 animate-pulse\",\n\t\t\t\t\t\t\t\tjob.status === \"closed\" && \"bg-emerald-600\",\n\t\t\t\t\t\t\t\tjob.status === \"completed\" && \"bg-emerald-600\",\n\t\t\t\t\t\t\t\tjob.status === \"cancelled\" && \"bg-slate-400\",\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span className=\"text-sm font-semibold truncate flex-1\">\n\t\t\t\t\t\t\t{job.customer?.name || \"Unknown Customer\"}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<p className=\"text-xs text-muted-foreground mt-0.5 truncate pl-4\">\n\t\t\t\t\t\t{job.title}\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\n\t\t\t\t{/* View Actions */}\n\t\t\t\t<ContextMenuLabel className=\"text-xs text-muted-foreground font-normal\">\n\t\t\t\t\tView\n\t\t\t\t</ContextMenuLabel>\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={!job.jobId}\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\tif (job.jobId) {\n\t\t\t\t\t\t\trouter.push(`/dashboard/work/${job.jobId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<ExternalLink className=\"size-4\" />\n\t\t\t\t\t<span>View Job Details</span>\n\t\t\t\t\t<ContextMenuShortcut>O</ContextMenuShortcut>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t{job.location?.address && (\n\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tconst address = `${job.location?.address?.street}, ${job.location?.address?.city}, ${job.location?.address?.state}`;\n\t\t\t\t\t\t\twindow.open(\n\t\t\t\t\t\t\t\t`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(address)}`,\n\t\t\t\t\t\t\t\t\"_blank\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Navigation className=\"size-4\" />\n\t\t\t\t\t\t<span>Open in Maps</span>\n\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t)}\n\n\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t{/* Status Progression */}\n\t\t\t\t<ContextMenuLabel className=\"text-xs text-muted-foreground font-normal\">\n\t\t\t\t\tUpdate Status\n\t\t\t\t</ContextMenuLabel>\n\n\t\t\t\t{/* Progress indicator */}\n\t\t\t\t{!isCancelled && (\n\t\t\t\t\t<div className=\"px-2 py-1.5 mb-1\">\n\t\t\t\t\t\t<div className=\"flex items-center gap-0.5\">\n\t\t\t\t\t\t\t{STATUS_ORDER.slice(0, -1).map((status, idx) => (\n\t\t\t\t\t\t\t\t<div key={status} className=\"flex items-center flex-1\">\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\"h-1 flex-1 rounded-full transition-colors\",\n\t\t\t\t\t\t\t\t\t\t\tidx < currentStep\n\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-emerald-500\"\n\t\t\t\t\t\t\t\t\t\t\t\t: idx === currentStep\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"bg-blue-500\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"bg-muted\",\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p className=\"text-[10px] text-muted-foreground mt-1 text-center capitalize\">\n\t\t\t\t\t\t\tCurrent: {job.status.replace(\"-\", \" \")}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={currentStep >= 1 || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Dispatching\", dispatchAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<Truck className=\"size-4\" />\n\t\t\t\t\t<span>Mark Dispatched</span>\n\t\t\t\t\t{currentStep >= 1 && !isCancelled && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t{job.customer?.phone && (\n\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\tdisabled={currentStep >= 2 || isCancelled}\n\t\t\t\t\t\tonClick={handleSendOnMyWay}\n\t\t\t\t\t\tclassName=\"text-sky-600 dark:text-sky-400\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Send className=\"size-4\" />\n\t\t\t\t\t\t<span>Send \"On My Way\" SMS</span>\n\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t)}\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={currentStep >= 2 || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Marking arrived\", arriveAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<MapPin className=\"size-4\" />\n\t\t\t\t\t<span>Mark Arrived</span>\n\t\t\t\t\t{currentStep >= 2 && !isCancelled && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={currentStep >= 4 || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Closing\", closeAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<UserCheck className=\"size-4\" />\n\t\t\t\t\t<span>Mark Closed</span>\n\t\t\t\t\t{currentStep >= 4 && !isCancelled && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tdisabled={isClosed || isCancelled}\n\t\t\t\t\tonClick={() => handleAction(\"Completing\", completeAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<CheckCircle2 className=\"size-4\" />\n\t\t\t\t\t<span>Mark Complete</span>\n\t\t\t\t\t{(job.status === \"completed\") && (\n\t\t\t\t\t\t<CheckCircle2 className=\"size-3.5 text-emerald-500 ml-auto\" />\n\t\t\t\t\t)}\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t{/* Communication */}\n\t\t\t\t{(job.customer?.phone || job.customer?.email) && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<ContextMenuSub>\n\t\t\t\t\t\t\t<ContextMenuSubTrigger>\n\t\t\t\t\t\t\t\t<MessageSquare className=\"size-4\" />\n\t\t\t\t\t\t\t\t<span>Contact Customer</span>\n\t\t\t\t\t\t\t</ContextMenuSubTrigger>\n\t\t\t\t\t\t\t<ContextMenuSubContent className=\"w-48\">\n\t\t\t\t\t\t\t\t{job.customer?.phone && (\n\t\t\t\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\twindow.location.href = `tel:${job.customer?.phone}`;\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Phone className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t<span>Call {job.customer.phone}</span>\n\t\t\t\t\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{job.customer?.phone && (\n\t\t\t\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\twindow.location.href = `sms:${job.customer?.phone}`;\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<MessageSquare className=\"size-4\" />\n\t\t\t\t\t\t\t\t\t\t<span>Send SMS</span>\n\t\t\t\t\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</ContextMenuSubContent>\n\t\t\t\t\t\t</ContextMenuSub>\n\t\t\t\t\t\t<ContextMenuSeparator />\n\t\t\t\t\t</>\n\t\t\t\t)}\n\n\t\t\t\t{/* Scheduling Actions */}\n\t\t\t\t<ContextMenuLabel className=\"text-xs text-muted-foreground font-normal\">\n\t\t\t\t\tSchedule\n\t\t\t\t</ContextMenuLabel>\n\n\t\t\t\t<ContextMenuItem>\n\t\t\t\t\t<Calendar className=\"size-4\" />\n\t\t\t\t\t<span>Reschedule</span>\n\t\t\t\t\t<ContextMenuShortcut>R</ContextMenuShortcut>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem>\n\t\t\t\t\t<Copy className=\"size-4\" />\n\t\t\t\t\t<span>Duplicate</span>\n\t\t\t\t\t<ContextMenuShortcut>D</ContextMenuShortcut>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuItem\n\t\t\t\t\tonClick={() => handleAction(\"Moving to Unscheduled\", unassignAppointment)}\n\t\t\t\t>\n\t\t\t\t\t<UserMinus className=\"size-4\" />\n\t\t\t\t\t<span>Move to Unscheduled</span>\n\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t{/* Danger Zone */}\n\t\t\t\t<ContextMenuSub>\n\t\t\t\t\t<ContextMenuSubTrigger className=\"text-destructive focus:text-destructive\">\n\t\t\t\t\t\t<MoreHorizontal className=\"size-4\" />\n\t\t\t\t\t\t<span>More Actions</span>\n\t\t\t\t\t</ContextMenuSubTrigger>\n\t\t\t\t\t<ContextMenuSubContent className=\"w-56\">\n\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\tclassName=\"text-orange-600 focus:text-orange-600 dark:text-orange-400 dark:focus:text-orange-400\"\n\t\t\t\t\t\t\tdisabled={isCancelled}\n\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\thandleAction(\"Cancelling appointment\", cancelAppointment)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<XCircle className=\"size-4\" />\n\t\t\t\t\t\t\t<span>Cancel Appointment Only</span>\n\t\t\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\tdisabled={isCancelled || !job.jobId}\n\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\thandleAction(\"Cancelling job & appointment\", (scheduleId) =>\n\t\t\t\t\t\t\t\t\tcancelJobAndAppointment(scheduleId as string, job.jobId ?? \"\"),\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Trash2 className=\"size-4\" />\n\t\t\t\t\t\t\t<span>Cancel Job & Appointment</span>\n\t\t\t\t\t\t</ContextMenuItem>\n\n\t\t\t\t\t\t<ContextMenuSeparator />\n\n\t\t\t\t\t\t<ContextMenuItem\n\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\tonClick={() => handleAction(\"Archiving\", archiveAppointment)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Archive className=\"size-4\" />\n\t\t\t\t\t\t\t<span>Archive</span>\n\t\t\t\t\t\t</ContextMenuItem>\n\t\t\t\t\t</ContextMenuSubContent>\n\t\t\t\t</ContextMenuSub>\n\t\t\t</ContextMenuContent>\n\t\t</ContextMenu>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/schedule-utils.ts"],"sourcesContent":["import type {\n\tAddress,\n\tCustomer,\n\tJob,\n\tJobAssignment,\n\tLegacyJob,\n\tLocation,\n\tTechnician,\n\tTechnicianSchedule,\n} from \"@/components/schedule/schedule-types\";\n\n/**\n * Utilities for schedule management\n */\n\n// ============================================\n// CONFLICT DETECTION\n// ============================================\n\nfunction hasTimeConflict(\n\tjob1Start: Date | string,\n\tjob1End: Date | string,\n\tjob2Start: Date | string,\n\tjob2End: Date | string,\n): boolean {\n\tconst start1 = job1Start instanceof Date ? job1Start : new Date(job1Start);\n\tconst end1 = job1End instanceof Date ? job1End : new Date(job1End);\n\tconst start2 = job2Start instanceof Date ? job2Start : new Date(job2Start);\n\tconst end2 = job2End instanceof Date ? job2End : new Date(job2End);\n\n\treturn (\n\t\t(start1 >= start2 && start1 < end2) ||\n\t\t(end1 > start2 && end1 <= end2) ||\n\t\t(start1 <= start2 && end1 >= end2)\n\t);\n}\n\nfunction findConflictingJobs(\n\tjobs: Job[],\n\ttechnicianId: string,\n\tstartTime: Date,\n\tendTime: Date,\n\texcludeJobId?: string,\n): Job[] {\n\treturn jobs.filter((job) => {\n\t\tif (excludeJobId && job.id === excludeJobId) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!jobHasTechnician(job, technicianId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasTimeConflict(startTime, endTime, job.startTime, job.endTime);\n\t});\n}\n\n// ============================================\n// MIGRATION UTILITIES\n// ============================================\n\nfunction legacyJobToJob(legacy: LegacyJob, technicianId: string): Job {\n\tconst today = new Date();\n\ttoday.setHours(0, 0, 0, 0);\n\n\t// Parse time strings\n\tconst [startHour, startMin] = legacy.startTime.split(\":\").map(Number);\n\tconst [endHour, endMin] = legacy.endTime.split(\":\").map(Number);\n\n\tconst startTime = new Date(today);\n\tstartTime.setHours(startHour, startMin, 0, 0);\n\n\tconst endTime = new Date(today);\n\tendTime.setHours(endHour, endMin, 0, 0);\n\n\t// Create address and location\n\tconst address: Address = {\n\t\tstreet: legacy.address,\n\t\tcity: \"\",\n\t\tstate: \"\",\n\t\tzip: \"\",\n\t\tcountry: \"USA\",\n\t};\n\n\tconst location: Location = {\n\t\taddress,\n\t\tcoordinates: {\n\t\t\tlat: legacy.lat,\n\t\t\tlng: legacy.lng,\n\t\t},\n\t};\n\n\t// Create customer\n\tconst customer: Customer = {\n\t\tid: `customer-${legacy.customer.toLowerCase().replace(/\\s+/g, \"-\")}`,\n\t\tname: legacy.customer,\n\t\tlocation,\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date(),\n\t};\n\n\t// Calculate estimated duration in minutes\n\tconst estimatedDuration = legacy.estimatedDuration\n\t\t? Number.parseFloat(legacy.estimatedDuration.replace(/[^\\d.]/g, \"\")) * 60\n\t\t: undefined;\n\n\tconst assignments: JobAssignment[] = technicianId\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\ttechnicianId,\n\t\t\t\t\tteamMemberId: undefined,\n\t\t\t\t\tdisplayName: \"Technician\",\n\t\t\t\t\tavatar: null,\n\t\t\t\t\trole: \"primary\",\n\t\t\t\t\tstatus: \"available\",\n\t\t\t\t\tisActive: true,\n\t\t\t\t},\n\t\t\t]\n\t\t: [];\n\n\treturn {\n\t\tid: legacy.id,\n\t\ttechnicianId,\n\t\tassignments,\n\t\tisUnassigned: assignments.length === 0,\n\t\ttitle: legacy.title,\n\t\tdescription: legacy.description,\n\t\tcustomer,\n\t\tlocation,\n\t\tstartTime,\n\t\tendTime,\n\t\tstatus: legacy.status,\n\t\tpriority: legacy.priority,\n\t\tmetadata: {\n\t\t\testimatedDuration,\n\t\t},\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date(),\n\t};\n}\n\n// ============================================\n// TIME CALCULATIONS\n// ============================================\n\nfunction calculateDuration(\n\tstartTime: Date | string,\n\tendTime: Date | string,\n): number {\n\tconst start = startTime instanceof Date ? startTime : new Date(startTime);\n\tconst end = endTime instanceof Date ? endTime : new Date(endTime);\n\treturn Math.round((end.getTime() - start.getTime()) / (1000 * 60)); // minutes\n}\n\nfunction formatDuration(minutes: number): string {\n\tif (minutes < 60) {\n\t\treturn `${minutes}m`;\n\t}\n\n\tconst hours = Math.floor(minutes / 60);\n\tconst mins = minutes % 60;\n\n\treturn mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;\n}\n\nfunction addMinutes(date: Date, minutes: number): Date {\n\treturn new Date(date.getTime() + minutes * 60 * 1000);\n}\n\n// ============================================\n// WORK HOURS CALCULATIONS\n// ============================================\n\nfunction calculateWorkload(\n\tjobs: Job[],\n\ttechnicianSchedule: TechnicianSchedule,\n\tdate: Date,\n): {\n\ttotalMinutes: number;\n\tavailableMinutes: number;\n\tutilizationRate: number;\n} {\n\tconst dayStart = new Date(date);\n\tdayStart.setHours(technicianSchedule.availableHours.start, 0, 0, 0);\n\n\tconst dayEnd = new Date(date);\n\tdayEnd.setHours(technicianSchedule.availableHours.end, 0, 0, 0);\n\n\tconst availableMinutes = calculateDuration(dayStart, dayEnd);\n\n\t// Calculate total job duration for this day\n\tconst totalMinutes = jobs.reduce((sum, job) => {\n\t\t// Check if job is on this date\n\t\tif (\n\t\t\tjob.startTime.toDateString() === date.toDateString() ||\n\t\t\tjob.endTime.toDateString() === date.toDateString()\n\t\t) {\n\t\t\treturn sum + calculateDuration(job.startTime, job.endTime);\n\t\t}\n\t\treturn sum;\n\t}, 0);\n\n\tconst utilizationRate =\n\t\tavailableMinutes > 0 ? (totalMinutes / availableMinutes) * 100 : 0;\n\n\treturn {\n\t\ttotalMinutes,\n\t\tavailableMinutes,\n\t\tutilizationRate: Math.min(utilizationRate, 100),\n\t};\n}\n\n// ============================================\n// DATE UTILITIES\n// ============================================\n\nfunction isSameDay(date1: Date, date2: Date): boolean {\n\treturn (\n\t\tdate1.getFullYear() === date2.getFullYear() &&\n\t\tdate1.getMonth() === date2.getMonth() &&\n\t\tdate1.getDate() === date2.getDate()\n\t);\n}\n\nfunction isToday(date: Date): boolean {\n\treturn isSameDay(date, new Date());\n}\n\nexport function startOfDay(date: Date): Date {\n\tconst result = new Date(date);\n\tresult.setHours(0, 0, 0, 0);\n\treturn result;\n}\n\nexport function endOfDay(date: Date): Date {\n\tconst result = new Date(date);\n\tresult.setHours(23, 59, 59, 999);\n\treturn result;\n}\n\n// ============================================\n// RECURRING JOBS\n// ============================================\n\nfunction generateRecurringJobInstances(\n\tbaseJob: Job,\n\tstartDate: Date,\n\tendDate: Date,\n): Job[] {\n\tif (!baseJob.recurrence) {\n\t\treturn [baseJob];\n\t}\n\n\tconst instances: Job[] = [];\n\tconst {\n\t\tfrequency,\n\t\tinterval,\n\t\tcount,\n\t\tendDate: recurrenceEndDate,\n\t} = baseJob.recurrence;\n\n\tconst currentDate = new Date(baseJob.startTime);\n\tlet instanceCount = 0;\n\n\twhile (currentDate <= endDate) {\n\t\tif (currentDate >= startDate) {\n\t\t\t// Calculate job duration\n\t\t\tconst duration = calculateDuration(baseJob.startTime, baseJob.endTime);\n\n\t\t\t// Create new instance\n\t\t\tconst instance: Job = {\n\t\t\t\t...baseJob,\n\t\t\t\tid: `${baseJob.id}-instance-${instanceCount}`,\n\t\t\t\tparentJobId: baseJob.id,\n\t\t\t\tstartTime: new Date(currentDate),\n\t\t\t\tendTime: addMinutes(new Date(currentDate), duration),\n\t\t\t};\n\n\t\t\tinstances.push(instance);\n\t\t}\n\n\t\t// Move to next occurrence\n\t\tinstanceCount++;\n\n\t\tif (count && instanceCount >= count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (recurrenceEndDate && currentDate >= recurrenceEndDate) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (frequency) {\n\t\t\tcase \"daily\":\n\t\t\t\tcurrentDate.setDate(currentDate.getDate() + interval);\n\t\t\t\tbreak;\n\t\t\tcase \"weekly\":\n\t\t\t\tcurrentDate.setDate(currentDate.getDate() + interval * 7);\n\t\t\t\tbreak;\n\t\t\tcase \"monthly\":\n\t\t\t\tcurrentDate.setMonth(currentDate.getMonth() + interval);\n\t\t\t\tbreak;\n\t\t\tcase \"yearly\":\n\t\t\t\tcurrentDate.setFullYear(currentDate.getFullYear() + interval);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn instances;\n}\n\n// ============================================\n// FILTERING\n// ============================================\n\nexport function filterJobs(\n\tjobs: Job[],\n\tfilters: {\n\t\ttechnicianIds?: string[];\n\t\tstatuses?: Job[\"status\"][];\n\t\tpriorities?: Job[\"priority\"][];\n\t\tsearchQuery?: string;\n\t},\n): Job[] {\n\treturn jobs.filter((job) => {\n\t\t// Filter by technician\n\t\tif (\n\t\t\tfilters.technicianIds &&\n\t\t\tfilters.technicianIds.length > 0 &&\n\t\t\t!filters.technicianIds.some((technicianId) =>\n\t\t\t\tjobHasTechnician(job, technicianId),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Filter by status\n\t\tif (\n\t\t\tfilters.statuses &&\n\t\t\tfilters.statuses.length > 0 &&\n\t\t\t!filters.statuses.includes(job.status)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Filter by priority\n\t\tif (\n\t\t\tfilters.priorities &&\n\t\t\tfilters.priorities.length > 0 &&\n\t\t\t!filters.priorities.includes(job.priority)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Filter by search query\n\t\tif (filters.searchQuery && filters.searchQuery.trim() !== \"\") {\n\t\t\tconst query = filters.searchQuery.toLowerCase();\n\t\t\tconst matchesTitle = job.title.toLowerCase().includes(query);\n\t\t\tconst matchesCustomer = job.customer.name.toLowerCase().includes(query);\n\t\t\tconst matchesDescription = job.description?.toLowerCase().includes(query);\n\n\t\t\tif (!(matchesTitle || matchesCustomer || matchesDescription)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n// ============================================\n// SORTING\n// ============================================\n\nexport function sortJobsByStartTime(jobs: Job[]): Job[] {\n\treturn [...jobs].sort((a, b) => {\n\t\t// Ensure dates are Date objects\n\t\tconst aTime =\n\t\t\ta.startTime instanceof Date ? a.startTime : new Date(a.startTime);\n\t\tconst bTime =\n\t\t\tb.startTime instanceof Date ? b.startTime : new Date(b.startTime);\n\t\treturn aTime.getTime() - bTime.getTime();\n\t});\n}\n\nfunction sortTechniciansByName(technicians: Technician[]): Technician[] {\n\treturn [...technicians].sort((a, b) => a.name.localeCompare(b.name));\n}\n\n// ============================================\n// VALIDATION\n// ============================================\n\nfunction validateJobTimes(\n\tstartTime: Date,\n\tendTime: Date,\n): {\n\tvalid: boolean;\n\terror?: string;\n} {\n\tif (startTime >= endTime) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: \"End time must be after start time\",\n\t\t};\n\t}\n\n\tconst duration = calculateDuration(startTime, endTime);\n\tif (duration < 15) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: \"Job must be at least 15 minutes long\",\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\nfunction validateJob(job: Partial<Job>): {\n\tvalid: boolean;\n\terrors: string[];\n} {\n\tconst errors: string[] = [];\n\n\tif (!job.title || job.title.trim() === \"\") {\n\t\terrors.push(\"Title is required\");\n\t}\n\n\tconst hasTechnician =\n\t\t!!job.technicianId ||\n\t\tjob.assignments?.some((assignment) => assignment.technicianId);\n\n\tif (!hasTechnician) {\n\t\terrors.push(\"Technician must be assigned\");\n\t}\n\n\tif (!job.startTime) {\n\t\terrors.push(\"Start time is required\");\n\t}\n\n\tif (!job.endTime) {\n\t\terrors.push(\"End time is required\");\n\t}\n\n\tif (job.startTime && job.endTime) {\n\t\tconst timeValidation = validateJobTimes(job.startTime, job.endTime);\n\t\tif (!timeValidation.valid) {\n\t\t\terrors.push(timeValidation.error!);\n\t\t}\n\t}\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t};\n}\n\nfunction jobHasTechnician(job: Job, technicianId: string): boolean {\n\tif (job.technicianId === technicianId) {\n\t\treturn true;\n\t}\n\n\treturn job.assignments.some(\n\t\t(assignment) => assignment.technicianId === technicianId,\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1250, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/hooks/use-schedule.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport type { Job, Technician } from \"@/components/schedule/schedule-types\";\nimport { fetchScheduleData } from \"@/lib/schedule-data\";\nimport { filterJobs, sortJobsByStartTime } from \"@/lib/schedule-utils\";\nimport { useScheduleStore } from \"@/lib/stores/schedule-store\";\nimport { useViewStore } from \"@/lib/stores/view-store\";\nimport { createClient } from \"@/lib/supabase/client\";\n\nexport function useSchedule() {\n\t// Use granular selectors to avoid closure issues\n\tconst isLoading = useScheduleStore((state) => state.isLoading);\n\tconst error = useScheduleStore((state) => state.error);\n\tconst lastSync = useScheduleStore((state) => state.lastSync);\n\tconst jobs = useScheduleStore((state) => state.jobs);\n\tconst technicians = useScheduleStore((state) => state.technicians);\n\tconst selectedJobId = useScheduleStore((state) => state.selectedJobId);\n\tconst selectedTechnicianId = useScheduleStore(\n\t\t(state) => state.selectedTechnicianId,\n\t);\n\tconst lastFetchedRange = useScheduleStore((state) => state.lastFetchedRange);\n\tconst storeCompanyId = useScheduleStore((state) => state.companyId);\n\tconst unassignedHasMore = useScheduleStore(\n\t\t(state) => state.unassignedHasMore,\n\t);\n\tconst unassignedSearch = useScheduleStore((state) => state.unassignedSearch);\n\tconst isLoadingUnassigned = useScheduleStore(\n\t\t(state) => state.isLoadingUnassigned,\n\t);\n\tconst unassignedTotalCount = useScheduleStore(\n\t\t(state) => state.unassignedTotalCount,\n\t);\n\n\t// Get actions\n\tconst setLoading = useScheduleStore((state) => state.setLoading);\n\tconst setError = useScheduleStore((state) => state.setError);\n\tconst setJobs = useScheduleStore((state) => state.setJobs);\n\tconst setTechnicians = useScheduleStore((state) => state.setTechnicians);\n\tconst selectJob = useScheduleStore((state) => state.selectJob);\n\tconst selectTechnician = useScheduleStore((state) => state.selectTechnician);\n\tconst addJob = useScheduleStore((state) => state.addJob);\n\tconst updateJob = useScheduleStore((state) => state.updateJob);\n\tconst moveJob = useScheduleStore((state) => state.moveJob);\n\tconst deleteJob = useScheduleStore((state) => state.deleteJob);\n\tconst duplicateJob = useScheduleStore((state) => state.duplicateJob);\n\tconst getJobById = useScheduleStore((state) => state.getJobById);\n\tconst syncWithServer = useScheduleStore((state) => state.syncWithServer);\n\tconst setLastSync = useScheduleStore((state) => state.setLastSync);\n\tconst setCompanyId = useScheduleStore((state) => state.setCompanyId);\n\tconst setLastFetchedRange = useScheduleStore(\n\t\t(state) => state.setLastFetchedRange,\n\t);\n\tconst setUnassignedMeta = useScheduleStore(\n\t\t(state) => state.setUnassignedMeta,\n\t);\n\tconst getUnassignedJobsFromStore = useScheduleStore(\n\t\t(state) => state.getUnassignedJobs,\n\t);\n\tconst getJobsGroupedByTechnicianFromStore = useScheduleStore(\n\t\t(state) => state.getJobsGroupedByTechnician,\n\t);\n\tconst loadMoreUnassignedJobs = useScheduleStore(\n\t\t(state) => state.loadMoreUnassignedJobs,\n\t);\n\n\t// Get view store values with selectors to avoid re-renders\n\tconst filters = useViewStore((state) => state.filters);\n\tconst showCompletedJobs = useViewStore((state) => state.showCompletedJobs);\n\tconst _currentDate = useViewStore((state) => state.currentDate);\n\tconst _zoom = useViewStore((state) => state.zoom);\n\n\t// Calculate visible time range once\n\tconst visibleTimeRange = useMemo(\n\t\t() => useViewStore.getState().getVisibleTimeRange(),\n\t\t[],\n\t);\n\n\tconst rangeStart = visibleTimeRange.start.getTime();\n\tconst rangeEnd = visibleTimeRange.end.getTime();\n\tconst companyIdRef = useRef<string | null>(\n\t\tuseScheduleStore.getState().companyId,\n\t);\n\n\tuseEffect(() => {\n\t\tcompanyIdRef.current = storeCompanyId;\n\t}, [storeCompanyId]);\n\n\tconst jobCount = jobs.size;\n\n\tconst hasCoverage = useMemo(() => {\n\t\tif (!lastFetchedRange || jobCount === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst fetchedStart = lastFetchedRange.start.getTime();\n\t\tconst fetchedEnd = lastFetchedRange.end.getTime();\n\n\t\treturn fetchedStart <= rangeStart && fetchedEnd >= rangeEnd;\n\t}, [jobCount, lastFetchedRange, rangeEnd, rangeStart]);\n\n\tuseEffect(() => {\n\t\tlet isMounted = true;\n\n\t\tif (hasCoverage && companyIdRef.current) {\n\t\t\treturn () => {\n\t\t\t\tisMounted = false;\n\t\t\t};\n\t\t}\n\n\t\tconst loadData = async () => {\n\t\t\tsetLoading(true);\n\t\t\tsetError(null);\n\n\t\t\ttry {\n\t\t\t\tconst supabase = createClient();\n\n\t\t\t\tif (!supabase) {\n\t\t\t\t\tthrow new Error(\"Database connection not available\");\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tdata: { user },\n\t\t\t\t\terror: authError,\n\t\t\t\t} = await supabase.auth.getUser();\n\n\t\t\t\tif (authError) {\n\t\t\t\t\tthrow authError;\n\t\t\t\t}\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tthrow new Error(\"User session not found\");\n\t\t\t\t}\n\n\t\t\t\tlet companyId = companyIdRef.current;\n\n\t\t\t\tif (!companyId) {\n\t\t\t\t\tconst { data: membership, error: membershipError } = await supabase\n\t\t\t\t\t\t.from(\"company_memberships\")\n\t\t\t\t\t\t.select(\"company_id\")\n\t\t\t\t\t\t.eq(\"user_id\", user.id)\n\t\t\t\t\t\t.eq(\"status\", \"active\")\n\t\t\t\t\t\t.order(\"joined_at\", { ascending: false, nullsFirst: false })\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.maybeSingle();\n\n\t\t\t\t\tif (membershipError) {\n\t\t\t\t\t\tthrow membershipError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!membership?.company_id) {\n\t\t\t\t\t\tthrow new Error(\"No active company membership found\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcompanyId = membership.company_id;\n\t\t\t\t\tcompanyIdRef.current = companyId;\n\t\t\t\t\tsetCompanyId(companyId);\n\t\t\t\t}\n\n\t\t\t\tif (!companyId) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unable to resolve company context for schedule data\",\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tjobs: convertedJobs,\n\t\t\t\t\ttechnicians: convertedTechnicians,\n\t\t\t\t\tunassignedMeta,\n\t\t\t\t} = await fetchScheduleData({\n\t\t\t\t\tsupabase,\n\t\t\t\t\tcompanyId,\n\t\t\t\t\trange: {\n\t\t\t\t\t\tstart: new Date(rangeStart),\n\t\t\t\t\t\tend: new Date(rangeEnd),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tif (!isMounted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsetTechnicians(convertedTechnicians);\n\t\t\t\tsetJobs(convertedJobs);\n\t\t\t\tconst fetchedRange = {\n\t\t\t\t\tstart: new Date(rangeStart),\n\t\t\t\t\tend: new Date(rangeEnd),\n\t\t\t\t};\n\n\t\t\t\tsetTechnicians(convertedTechnicians);\n\t\t\t\tsetJobs(convertedJobs);\n\t\t\t\tconst unassignedCount = convertedJobs.filter(\n\t\t\t\t\t(job) => job.isUnassigned,\n\t\t\t\t).length;\n\t\t\t\tsetUnassignedMeta(unassignedMeta, unassignedCount);\n\t\t\t\tsetLastSync(new Date());\n\t\t\t\tsetLastFetchedRange(fetchedRange);\n\t\t\t} catch (error) {\n\t\t\t\tif (!isMounted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst errorMessage =\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t: typeof error === \"object\" && error !== null && \"message\" in error\n\t\t\t\t\t\t\t? String((error as { message: string }).message)\n\t\t\t\t\t\t\t: \"Unknown error\";\n\t\t\t\tsetError(errorMessage);\n\t\t\t} finally {\n\t\t\t\tif (isMounted) {\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tloadData();\n\n\t\treturn () => {\n\t\t\tisMounted = false;\n\t\t};\n\t}, [\n\t\thasCoverage,\n\t\trangeEnd,\n\t\trangeStart,\n\t\tsetCompanyId,\n\t\tsetLastFetchedRange,\n\t\tsetError,\n\t\tsetJobs,\n\t\tsetLastSync,\n\t\tsetLoading,\n\t\tsetTechnicians,\n\t]);\n\n\t// Get filtered and sorted jobs - MEMOIZED\n\tconst filteredJobs = useMemo((): Job[] => {\n\t\tconst allJobs = Array.from(jobs.values());\n\n\t\t// Apply view filters\n\t\tconst filtered = filterJobs(allJobs, {\n\t\t\ttechnicianIds: filters.technicianIds,\n\t\t\tstatuses: filters.statuses,\n\t\t\tpriorities: filters.priorities,\n\t\t\tsearchQuery: filters.searchQuery,\n\t\t});\n\n\t\t// Filter by completed jobs visibility\n\t\tconst visible = showCompletedJobs\n\t\t\t? filtered\n\t\t\t: filtered.filter((job) => job.status !== \"completed\");\n\n\t\t// Sort by start time\n\t\treturn sortJobsByStartTime(visible);\n\t}, [jobs, filters, showCompletedJobs]);\n\n\t// Get filtered technicians - MEMOIZED\n\tconst filteredTechnicians = useMemo((): Technician[] => {\n\t\tconst allTechnicians = Array.from(technicians.values());\n\n\t\t// If technician filter is active, only show filtered technicians\n\t\tif (filters.technicianIds.length > 0) {\n\t\t\treturn allTechnicians.filter((tech) =>\n\t\t\t\tfilters.technicianIds.includes(tech.id),\n\t\t\t);\n\t\t}\n\n\t\treturn allTechnicians;\n\t}, [technicians, filters.technicianIds]);\n\n\t// Pre-index jobs by technician ID for O(1) lookups instead of O(n) filter\n\tconst jobsByTechnicianId = useMemo(() => {\n\t\tconst map = new Map<string, Job[]>();\n\t\tfor (const job of filteredJobs) {\n\t\t\tconst techId = job.technicianId;\n\t\t\tif (techId) {\n\t\t\t\tconst existing = map.get(techId);\n\t\t\t\tif (existing) {\n\t\t\t\t\texisting.push(job);\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(techId, [job]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}, [filteredJobs]);\n\n\t// Get jobs for a specific technician - now O(1) lookup\n\tconst getJobsForTechnician = useCallback(\n\t\t(technicianId: string): Job[] =>\n\t\t\tjobsByTechnicianId.get(technicianId) ?? [],\n\t\t[jobsByTechnicianId],\n\t);\n\n\t// Get jobs within visible time range - MEMOIZED\n\tconst visibleJobs = useMemo((): Job[] => {\n\t\tconst { start, end } = visibleTimeRange;\n\n\t\treturn filteredJobs.filter((job) => {\n\t\t\t// Job overlaps with visible range\n\t\t\treturn job.startTime <= end && job.endTime >= start;\n\t\t});\n\t}, [filteredJobs, visibleTimeRange]);\n\n\t// Get all jobs (unfiltered)\n\tconst getAllJobs = useCallback(\n\t\t(): Job[] => Array.from(jobs.values()),\n\t\t[jobs],\n\t);\n\n\treturn {\n\t\t// State\n\t\tisLoading,\n\t\terror,\n\t\tlastSync,\n\n\t\t// Data\n\t\ttechnicians: filteredTechnicians,\n\t\tjobs: filteredJobs,\n\t\tvisibleJobs,\n\n\t\t// Selection\n\t\tselectedJobId,\n\t\tselectedTechnicianId,\n\t\tselectedJob: selectedJobId ? getJobById(selectedJobId) : null,\n\n\t\t// Actions\n\t\tgetJobsForTechnician,\n\t\tgetAllJobs,\n\t\tselectJob,\n\t\tselectTechnician,\n\t\tgetUnassignedJobs: getUnassignedJobsFromStore,\n\t\tgetJobsGroupedByTechnician: getJobsGroupedByTechnicianFromStore,\n\t\tunassignedHasMore,\n\t\tunassignedSearch,\n\t\tisLoadingUnassigned,\n\t\tunassignedTotalCount,\n\t\tloadMoreUnassignedJobs,\n\n\t\t// Mutations\n\t\taddJob,\n\t\tupdateJob,\n\t\tmoveJob,\n\t\tdeleteJob,\n\t\tduplicateJob,\n\n\t\t// Sync\n\t\trefresh: syncWithServer,\n\t};\n}\n\n/**\n * Hook for real-time schedule updates via Supabase\n * Subscribes to appointments table for INSERT, UPDATE, DELETE events\n */\nexport function useScheduleRealtime() {\n\tconst companyId = useScheduleStore((state) => state.companyId);\n\tconst updateJob = useScheduleStore((state) => state.updateJob);\n\tconst deleteJob = useScheduleStore((state) => state.deleteJob);\n\tconst addJob = useScheduleStore((state) => state.addJob);\n\tconst getJobById = useScheduleStore((state) => state.getJobById);\n\tconst syncWithServer = useScheduleStore((state) => state.syncWithServer);\n\tconst lastSync = useScheduleStore((state) => state.lastSync);\n\tconst [isConnected, setIsConnected] = useState(false);\n\tconst [connectionError, setConnectionError] = useState<string | null>(null);\n\n\tuseEffect(() => {\n\t\tif (!companyId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst supabase = createClient();\n\t\tif (!supabase) {\n\t\t\tsetConnectionError(\"Database connection not available\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst channelName = `schedule-realtime-${companyId}`;\n\n\t\tconst channel = supabase\n\t\t\t.channel(channelName)\n\t\t\t.on(\n\t\t\t\t\"postgres_changes\",\n\t\t\t\t{\n\t\t\t\t\tevent: \"*\",\n\t\t\t\t\tschema: \"public\",\n\t\t\t\t\ttable: \"appointments\",\n\t\t\t\t\tfilter: `company_id=eq.${companyId}`,\n\t\t\t\t},\n\t\t\t\tasync (payload) => {\n\t\t\t\t\tconst { eventType, new: newRecord, old: oldRecord } = payload;\n\n\t\t\t\t\tswitch (eventType) {\n\t\t\t\t\t\tcase \"DELETE\": {\n\t\t\t\t\t\t\t// Remove job from store\n\t\t\t\t\t\t\tconst jobId = (oldRecord as { id?: string })?.id;\n\t\t\t\t\t\t\tif (jobId) {\n\t\t\t\t\t\t\t\tdeleteJob(jobId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"UPDATE\": {\n\t\t\t\t\t\t\t// For updates, try to merge changes into existing job\n\t\t\t\t\t\t\tconst record = newRecord as Record<string, unknown>;\n\t\t\t\t\t\t\tconst jobId = record.id as string;\n\n\t\t\t\t\t\t\tif (!jobId) break;\n\n\t\t\t\t\t\t\tconst existingJob = getJobById(jobId);\n\n\t\t\t\t\t\t\tif (existingJob) {\n\t\t\t\t\t\t\t\t// Merge updates into existing job\n\t\t\t\t\t\t\t\tconst updates: Partial<Job> = {};\n\n\t\t\t\t\t\t\t\tif (record.title !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.title = record.title as string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.description !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.description = record.description as string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.status !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.status = mapStatus(record.status as string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.start_time !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.startTime = new Date(record.start_time as string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.end_time !== undefined) {\n\t\t\t\t\t\t\t\t\tupdates.endTime = new Date(record.end_time as string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (record.assigned_to !== undefined) {\n\t\t\t\t\t\t\t\t\t// Assignment changed - need to handle technician change\n\t\t\t\t\t\t\t\t\tif (record.assigned_to === null) {\n\t\t\t\t\t\t\t\t\t\tupdates.isUnassigned = true;\n\t\t\t\t\t\t\t\t\t\tupdates.technicianId = \"\";\n\t\t\t\t\t\t\t\t\t\tupdates.assignments = [];\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tupdates.isUnassigned = false;\n\t\t\t\t\t\t\t\t\t\tupdates.technicianId = record.assigned_to as string;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (Object.keys(updates).length > 0) {\n\t\t\t\t\t\t\t\t\tupdateJob(jobId, updates);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Job not in store - fetch fresh data\n\t\t\t\t\t\t\t\tawait syncWithServer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"INSERT\": {\n\t\t\t\t\t\t\t// For new jobs, we need full data with joins\n\t\t\t\t\t\t\t// Trigger a sync to get complete job with customer/property data\n\t\t\t\t\t\t\tawait syncWithServer();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t)\n\t\t\t.subscribe((status) => {\n\t\t\t\tif (status === \"SUBSCRIBED\") {\n\t\t\t\t\tsetIsConnected(true);\n\t\t\t\t\tsetConnectionError(null);\n\t\t\t\t} else if (status === \"CHANNEL_ERROR\") {\n\t\t\t\t\tsetIsConnected(false);\n\t\t\t\t\tsetConnectionError(\"Failed to connect to real-time updates\");\n\t\t\t\t} else if (status === \"CLOSED\") {\n\t\t\t\t\tsetIsConnected(false);\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn () => {\n\t\t\tsupabase.removeChannel(channel);\n\t\t\tsetIsConnected(false);\n\t\t};\n\t}, [\n\t\tcompanyId,\n\t\tupdateJob,\n\t\tdeleteJob,\n\t\taddJob,\n\t\tgetJobById,\n\t\tsyncWithServer,\n\t]);\n\n\treturn {\n\t\tisConnected,\n\t\tconnectionError,\n\t\tlastUpdate: lastSync,\n\t};\n}\n\n// Helper to map database status to Job status\nfunction mapStatus(status: string): Job[\"status\"] {\n\tconst normalized = status?.toLowerCase() ?? \"scheduled\";\n\tswitch (normalized) {\n\t\tcase \"scheduled\":\n\t\tcase \"dispatched\":\n\t\tcase \"arrived\":\n\t\tcase \"closed\":\n\t\tcase \"cancelled\":\n\t\t\treturn normalized as Job[\"status\"];\n\t\tcase \"in-progress\":\n\t\tcase \"in_progress\":\n\t\tcase \"inprogress\":\n\t\t\treturn \"in-progress\";\n\t\tcase \"completed\":\n\t\tcase \"complete\":\n\t\tcase \"done\":\n\t\t\treturn \"completed\";\n\t\tdefault:\n\t\t\treturn \"scheduled\";\n\t}\n}\n\n/**\n * Hook for schedule statistics\n */\nfunction useScheduleStats() {\n\tconst { technicians, jobs, visibleJobs } = useSchedule();\n\n\tconst stats = {\n\t\ttotalTechnicians: technicians.length,\n\t\ttotalJobs: jobs.length,\n\t\tvisibleJobs: visibleJobs.length,\n\t\tscheduledJobs: jobs.filter((j) => j.status === \"scheduled\").length,\n\t\tinProgressJobs: jobs.filter((j) => j.status === \"in-progress\").length,\n\t\tcompletedJobs: jobs.filter((j) => j.status === \"completed\").length,\n\t\tcancelledJobs: jobs.filter((j) => j.status === \"cancelled\").length,\n\t\turgentJobs: jobs.filter((j) => j.priority === \"urgent\").length,\n\t};\n\n\treturn stats;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1885, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/schedule-command-menu.tsx"],"sourcesContent":["\"use client\";\n\nimport { format } from \"date-fns\";\nimport {\n\tArrowRight,\n\tBriefcase,\n\tCalendar,\n\tClock,\n\tMapPin,\n\tPlus,\n\tSearch,\n\tSparkles,\n\tUser,\n} from \"lucide-react\";\nimport { useRouter } from \"next/navigation\";\nimport { useCallback, useState } from \"react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport {\n\tCommandDialog,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList,\n\tCommandSeparator,\n} from \"@/components/ui/command\";\nimport { cn } from \"@/lib/utils\";\nimport type { Job } from \"./schedule-types\";\n\ntype ScheduleCommandMenuProps = {\n\tisOpen: boolean;\n\tonClose: () => void;\n\tselectedDate: Date | null;\n\tselectedTechnicianId?: string | null;\n\tselectedTechnicianName?: string;\n\tunassignedJobs?: Job[];\n};\n\nexport function ScheduleCommandMenu({\n\tisOpen,\n\tonClose,\n\tselectedDate,\n\tselectedTechnicianId,\n\tselectedTechnicianName,\n\tunassignedJobs = [],\n}: ScheduleCommandMenuProps) {\n\tconst router = useRouter();\n\tconst [searchQuery, setSearchQuery] = useState(\"\");\n\n\tconst handleCreateNew = useCallback(() => {\n\t\tconst params = new URLSearchParams();\n\n\t\tif (selectedDate) {\n\t\t\tparams.set(\"date\", format(selectedDate, \"yyyy-MM-dd\"));\n\t\t\tparams.set(\"startTime\", format(selectedDate, \"HH:mm\"));\n\t\t}\n\n\t\tif (selectedTechnicianId) {\n\t\t\tparams.set(\"assignTo\", selectedTechnicianId);\n\t\t}\n\n\t\tconst queryString = params.toString();\n\t\trouter.push(`/dashboard/work/new${queryString ? `?${queryString}` : \"\"}`);\n\t\tonClose();\n\t}, [selectedDate, selectedTechnicianId, router, onClose]);\n\n\tconst handleSelectUnassigned = useCallback(\n\t\t(job: Job) => {\n\t\t\t// Navigate to job details to schedule it\n\t\t\tif (job.jobId) {\n\t\t\t\trouter.push(`/dashboard/work/${job.jobId}`);\n\t\t\t}\n\t\t\tonClose();\n\t\t},\n\t\t[router, onClose],\n\t);\n\n\t// Filter unassigned jobs by search query\n\tconst filteredJobs = unassignedJobs.filter((job) => {\n\t\tif (!searchQuery) {\n\t\t\treturn true;\n\t\t}\n\t\tconst query = searchQuery.toLowerCase();\n\t\treturn (\n\t\t\tjob.title?.toLowerCase().includes(query) ||\n\t\t\tjob.customer?.name?.toLowerCase().includes(query) ||\n\t\t\tjob.location?.address?.street?.toLowerCase().includes(query)\n\t\t);\n\t});\n\n\t// Get priority indicator for jobs\n\tconst getJobPriority = (job: Job) => {\n\t\tconst title = job.title.toLowerCase();\n\t\tif (title.includes(\"emergency\") || title.includes(\"urgent\")) {\n\t\t\treturn { label: \"Urgent\", color: \"bg-red-500\" };\n\t\t}\n\t\tif (title.includes(\"callback\") || title.includes(\"follow\")) {\n\t\t\treturn { label: \"Callback\", color: \"bg-orange-500\" };\n\t\t}\n\t\treturn null;\n\t};\n\n\treturn (\n\t\t<CommandDialog onOpenChange={onClose} open={isOpen}>\n\t\t\t<div className=\"flex items-center border-b px-3\">\n\t\t\t\t<Search className=\"text-muted-foreground mr-2 size-4 shrink-0\" />\n\t\t\t\t<CommandInput\n\t\t\t\t\tonValueChange={setSearchQuery}\n\t\t\t\t\tplaceholder=\"Search jobs, customers, or addresses...\"\n\t\t\t\t\tvalue={searchQuery}\n\t\t\t\t\tclassName=\"border-0 focus:ring-0\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<CommandList className=\"max-h-[400px]\">\n\t\t\t\t<CommandEmpty>\n\t\t\t\t\t<div className=\"flex flex-col items-center justify-center py-8 text-center\">\n\t\t\t\t\t\t<div className=\"bg-muted mb-3 flex size-12 items-center justify-center rounded-full\">\n\t\t\t\t\t\t\t<Search className=\"text-muted-foreground size-5\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p className=\"mb-1 text-sm font-medium\">No matching jobs</p>\n\t\t\t\t\t\t<p className=\"text-muted-foreground mb-4 max-w-[200px] text-xs\">\n\t\t\t\t\t\t\tTry a different search term or create a new job\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={handleCreateNew}\n\t\t\t\t\t\t\tclassName=\"text-primary hover:text-primary/80 flex items-center gap-1 text-sm font-medium transition-colors\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Plus className=\"size-4\" />\n\t\t\t\t\t\t\tCreate New Job\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</CommandEmpty>\n\n\t\t\t\t{/* Create New */}\n\t\t\t\t<CommandGroup heading=\"Quick Actions\">\n\t\t\t\t\t<CommandItem className=\"group py-3\" onSelect={handleCreateNew}>\n\t\t\t\t\t\t<div className=\"bg-primary/10 group-aria-selected:bg-primary/20 mr-3 flex size-10 items-center justify-center rounded-lg transition-colors\">\n\t\t\t\t\t\t\t<Plus className=\"text-primary size-5\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"flex flex-1 flex-col gap-1\">\n\t\t\t\t\t\t\t<div className=\"flex flex-wrap items-center gap-2\">\n\t\t\t\t\t\t\t\t<span className=\"text-sm font-semibold\">Create New Job</span>\n\t\t\t\t\t\t\t\t{selectedDate && (\n\t\t\t\t\t\t\t\t\t<Badge className=\"gap-1 font-medium\" variant=\"secondary\">\n\t\t\t\t\t\t\t\t\t\t<Calendar className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t{format(selectedDate, \"MMM d\")} at{\" \"}\n\t\t\t\t\t\t\t\t\t\t{format(selectedDate, \"h:mm a\")}\n\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{selectedTechnicianName && (\n\t\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\t\tclassName=\"gap-1 font-medium\"\n\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<User className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t{selectedTechnicianName}\n\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t{selectedTechnicianName\n\t\t\t\t\t\t\t\t\t? `Schedule a new appointment for ${selectedTechnicianName}`\n\t\t\t\t\t\t\t\t\t: \"Create a new job or service appointment\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<kbd className=\"bg-muted text-muted-foreground ml-2 hidden rounded px-1.5 py-0.5 font-mono text-[10px] group-aria-selected:inline\">\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t</kbd>\n\t\t\t\t\t</CommandItem>\n\t\t\t\t</CommandGroup>\n\n\t\t\t\t{/* Unassigned Jobs */}\n\t\t\t\t{filteredJobs.length > 0 && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<CommandSeparator />\n\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t<div className=\"flex items-center justify-between px-2 py-1.5\">\n\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs font-medium\">\n\t\t\t\t\t\t\t\t\tUnscheduled Jobs\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<Badge variant=\"secondary\" className=\"h-5 px-1.5 text-[10px]\">\n\t\t\t\t\t\t\t\t\t{filteredJobs.length}\n\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{filteredJobs.slice(0, 10).map((job) => {\n\t\t\t\t\t\t\t\tconst startTime =\n\t\t\t\t\t\t\t\t\tjob.startTime instanceof Date\n\t\t\t\t\t\t\t\t\t\t? job.startTime\n\t\t\t\t\t\t\t\t\t\t: new Date(job.startTime);\n\t\t\t\t\t\t\t\tconst priority = getJobPriority(job);\n\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\tclassName=\"group py-2.5\"\n\t\t\t\t\t\t\t\t\t\tkey={job.id}\n\t\t\t\t\t\t\t\t\t\tonSelect={() => handleSelectUnassigned(job)}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<div className=\"mr-3 flex size-10 items-center justify-center rounded-lg bg-orange-500/10 group-aria-selected:bg-orange-500/20 transition-colors\">\n\t\t\t\t\t\t\t\t\t\t\t<Briefcase className=\"size-5 text-orange-600 dark:text-orange-500\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex flex-1 flex-col gap-1\">\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-sm font-semibold\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{job.title}\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t{priority && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rounded px-1.5 py-0.5 text-[10px] font-medium text-white\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority.color\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{priority.label}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t{job.customer?.name && (\n\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{job.customer.name}\n\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex flex-wrap items-center gap-x-3 gap-y-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t{job.startTime && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Clock className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span>{format(startTime, \"MMM d, h:mm a\")}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t{job.assignments.length > 0 && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<User className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{job.assignments.length} assigned\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t{job.location?.address?.street && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<MapPin className=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"max-w-[180px] truncate\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{job.location.address.street}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<ArrowRight className=\"text-muted-foreground ml-2 size-4 shrink-0 opacity-0 transition-opacity group-aria-selected:opacity-100\" />\n\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t{filteredJobs.length > 10 && (\n\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2 px-2 py-2\">\n\t\t\t\t\t\t\t\t\t<Sparkles className=\"text-muted-foreground/50 size-4\" />\n\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t+{filteredJobs.length - 10} more jobs available\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t</CommandList>\n\n\t\t\t{/* Keyboard shortcuts footer */}\n\t\t\t<div className=\"border-t px-3 py-2\">\n\t\t\t\t<div className=\"flex items-center justify-between\">\n\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-4 text-xs\">\n\t\t\t\t\t\t<span className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t<kbd className=\"bg-muted rounded px-1 font-mono text-[10px]\"></kbd>\n\t\t\t\t\t\t\tnavigate\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t<kbd className=\"bg-muted rounded px-1 font-mono text-[10px]\"></kbd>\n\t\t\t\t\t\t\tselect\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t<kbd className=\"bg-muted rounded px-1 font-mono text-[10px]\">esc</kbd>\n\t\t\t\t\t\t\tclose\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t{filteredJobs.length > 0 && (\n\t\t\t\t\t\t<span className=\"text-muted-foreground text-[10px]\">\n\t\t\t\t\t\t\t{filteredJobs.length} result{filteredJobs.length !== 1 ? \"s\" : \"\"}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</CommandDialog>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2535, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/appointments.ts"],"sourcesContent":["/**\n * Appointments Server Actions\n *\n * Handles appointment scheduling and management with comprehensive CRUD operations,\n * status transitions, reminders, and team assignment logic.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { ActionError, ERROR_CODES } from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nconst APPOINTMENT_NUMBER_REGEX = /APT-(\\d+)/;\nconst APPOINTMENT_NUMBER_LENGTH = 6;\nconst MILLISECONDS_PER_MINUTE = 60_000;\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst DEFAULT_SEARCH_OFFSET = 0;\n\nconst getSupabaseServerClient = async (): Promise<SupabaseServerClient> => {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\treturn supabase as SupabaseServerClient;\n};\n\n// Validation Schemas\nconst createAppointmentSchema = z.object({\n\tcustomerId: z.string().uuid(\"Invalid customer ID\"),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional(),\n\tjobId: z.string().uuid(\"Invalid job ID\").optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\ttitle: z.string().min(1, \"Appointment title is required\"),\n\tdescription: z.string().optional(),\n\tcategory: z\n\t\t.enum([\n\t\t\t\"job_appointment\",\n\t\t\t\"estimate_appointment\",\n\t\t\t\"event\",\n\t\t\t\"meeting\",\n\t\t\t\"follow_up\",\n\t\t\t\"recurring_service\",\n\t\t])\n\t\t.default(\"job_appointment\"),\n\ttype: z\n\t\t.enum([\n\t\t\t\"service_call\",\n\t\t\t\"installation\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"repair\",\n\t\t\t\"estimate\",\n\t\t\t\"follow_up\",\n\t\t\t\"winterization\",\n\t\t\t\"emergency\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]).default(\"normal\"),\n\tscheduledStart: z.string().min(1, \"Start time is required\"),\n\tscheduledEnd: z.string().min(1, \"End time is required\"),\n\tnotes: z.string().optional(),\n\ttravelTimeMinutes: z.number().int().min(0).optional(),\n});\n\nconst updateAppointmentSchema = z.object({\n\ttitle: z.string().min(1, \"Appointment title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"scheduled\",\n\t\t\t\"confirmed\",\n\t\t\t\"in_progress\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"no_show\",\n\t\t\t\"rescheduled\",\n\t\t])\n\t\t.optional(),\n\ttype: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"consultation\",\n\t\t\t\"estimate\",\n\t\t\t\"follow_up\",\n\t\t\t\"maintenance\",\n\t\t\t\"emergency\",\n\t\t\t\"inspection\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tactualStart: z.string().optional(),\n\tactualEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tnotes: z.string().optional(),\n\tcancellationReason: z.string().optional(),\n});\n\nconst rescheduleAppointmentSchema = z.object({\n\tscheduledStart: z.string().min(1, \"Start time is required\"),\n\tscheduledEnd: z.string().min(1, \"End time is required\"),\n\treason: z.string().optional(),\n});\n\n/**\n * Generate unique appointment number using database function\n */\nasync function generateAppointmentNumber(\n\tsupabase: SupabaseServerClient,\n\tcompanyId: string,\n): Promise<string> {\n\tconst { data, error } = await supabase.rpc(\"generate_appointment_number\", {\n\t\tp_company_id: companyId,\n\t});\n\n\tif (error || !data) {\n\t\t// Fallback to manual generation\n\t\tconst { data: latestAppointment } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"appointment_number\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tif (!latestAppointment) {\n\t\t\treturn \"APT-000001\";\n\t\t}\n\n\t\tconst match = latestAppointment.appointment_number.match(\n\t\t\tAPPOINTMENT_NUMBER_REGEX,\n\t\t);\n\t\tif (match) {\n\t\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\t\treturn `APT-${nextNumber.toString().padStart(APPOINTMENT_NUMBER_LENGTH, \"0\")}`;\n\t\t}\n\n\t\treturn `APT-${Date.now().toString().slice(-APPOINTMENT_NUMBER_LENGTH)}`;\n\t}\n\n\treturn data;\n}\n\n/**\n * Calculate duration in minutes between two dates\n */\nfunction calculateDuration(start: string, end: string): number {\n\tconst startDate = new Date(start);\n\tconst endDate = new Date(end);\n\treturn Math.round(\n\t\t(endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_MINUTE,\n\t);\n}\n\n/**\n * Validate appointment times\n */\nfunction validateAppointmentTimes(start: string, end: string): void {\n\tconst startDate = new Date(start);\n\tconst endDate = new Date(end);\n\n\tif (endDate <= startDate) {\n\t\tthrow new ActionError(\n\t\t\t\"End time must be after start time\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\n\tif (startDate < new Date()) {\n\t\tthrow new ActionError(\n\t\t\t\"Cannot schedule appointments in the past\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nconst extractFormValues = (\n\tformData: FormData,\n\tfields: string[],\n): Record<string, unknown> => {\n\tconst result: Record<string, unknown> = {};\n\tfor (const field of fields) {\n\t\tconst value = formData.get(field);\n\t\tif (value !== null && value !== undefined && value !== \"\") {\n\t\t\tresult[field] = value;\n\t\t}\n\t}\n\treturn result;\n};\n\nconst buildUpdatePayload = (\n\tdata: z.infer<typeof updateAppointmentSchema>,\n\tduration?: number,\n): Record<string, unknown> => {\n\tconst updateData: Record<string, unknown> = { ...data };\n\tif (duration) {\n\t\tupdateData.duration_minutes = duration;\n\t}\n\n\tif (data.actualStart && data.actualEnd) {\n\t\tupdateData.actual_duration_minutes = calculateDuration(\n\t\t\tdata.actualStart,\n\t\t\tdata.actualEnd,\n\t\t);\n\t}\n\n\treturn updateData;\n};\n\nconst toSnakeCaseRecord = (data: Record<string, unknown>) => {\n\tconst result: Record<string, unknown> = {};\n\tfor (const [key, value] of Object.entries(data)) {\n\t\tconst snakeKey = key.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n\t\tresult[snakeKey] = value;\n\t}\n\treturn result;\n};\n\n/**\n * Create a new appointment\n */\nexport async function createAppointment(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\tcustomerId: formData.get(\"customerId\") as string,\n\t\t\tpropertyId: (formData.get(\"propertyId\") as string) || undefined,\n\t\t\tjobId: (formData.get(\"jobId\") as string) || undefined,\n\t\t\tassignedTo: (formData.get(\"assignedTo\") as string) || undefined,\n\t\t\ttitle: formData.get(\"title\") as string,\n\t\t\tdescription: (formData.get(\"description\") as string) || undefined,\n\t\t\tcategory: (formData.get(\"category\") as string) || \"job_appointment\",\n\t\t\ttype: (formData.get(\"type\") as string) || undefined,\n\t\t\tpriority: (formData.get(\"priority\") as string) || \"normal\",\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") as string,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") as string,\n\t\t\tnotes: (formData.get(\"notes\") as string) || undefined,\n\t\t\ttravelTimeMinutes: formData.get(\"travelTimeMinutes\")\n\t\t\t\t? Number.parseInt(formData.get(\"travelTimeMinutes\") as string, 10)\n\t\t\t\t: undefined,\n\t\t};\n\n\t\tconst validatedData = createAppointmentSchema.parse(rawData);\n\n\t\t// Validate appointment times\n\t\tvalidateAppointmentTimes(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Calculate duration\n\t\tconst duration = calculateDuration(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Generate appointment number\n\t\tconst appointmentNumber = await generateAppointmentNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\n\t\t// Create appointment\n\t\tconst { data: appointment, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: validatedData.customerId,\n\t\t\t\tproperty_id: validatedData.propertyId,\n\t\t\t\tjob_id: validatedData.jobId,\n\t\t\t\tassigned_to: validatedData.assignedTo,\n\t\t\t\tappointment_number: appointmentNumber,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tdescription: validatedData.description,\n\t\t\t\tcategory: validatedData.category,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\tscheduled_start: validatedData.scheduledStart,\n\t\t\t\tscheduled_end: validatedData.scheduledEnd,\n\t\t\t\tduration_minutes: duration,\n\t\t\t\tnotes: validatedData.notes,\n\t\t\t\ttravel_time_minutes: validatedData.travelTimeMinutes,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tcreated_by: user.id,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to create appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\tif (validatedData.jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${validatedData.jobId}`);\n\t\t}\n\n\t\treturn appointment.id;\n\t});\n}\n\n/**\n * Update an existing appointment\n */\nasync function updateAppointment(\n\tappointmentId: string,\n\tformData: FormData,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Verify appointment exists and belongs to company\n\t\tconst { data: existingAppointment, error: fetchError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, company_id, status, scheduled_start, scheduled_end, job_id\")\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !existingAppointment) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Appointment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\t// Parse and validate form data\n\t\tconst rawData = extractFormValues(formData, [\n\t\t\t\"title\",\n\t\t\t\"description\",\n\t\t\t\"status\",\n\t\t\t\"type\",\n\t\t\t\"priority\",\n\t\t\t\"scheduledStart\",\n\t\t\t\"scheduledEnd\",\n\t\t\t\"actualStart\",\n\t\t\t\"actualEnd\",\n\t\t\t\"assignedTo\",\n\t\t\t\"notes\",\n\t\t\t\"cancellationReason\",\n\t\t]);\n\n\t\tconst validatedData = updateAppointmentSchema.parse(rawData);\n\n\t\t// Validate times if both are provided\n\t\tif (validatedData.scheduledStart && validatedData.scheduledEnd) {\n\t\t\tvalidateAppointmentTimes(\n\t\t\t\tvalidatedData.scheduledStart,\n\t\t\t\tvalidatedData.scheduledEnd,\n\t\t\t);\n\t\t}\n\n\t\t// Calculate new duration if times changed\n\t\tlet duration: number | undefined;\n\t\tif (validatedData.scheduledStart && validatedData.scheduledEnd) {\n\t\t\tduration = calculateDuration(\n\t\t\t\tvalidatedData.scheduledStart,\n\t\t\t\tvalidatedData.scheduledEnd,\n\t\t\t);\n\t\t}\n\n\t\t// Build update object\n\t\tconst updateData = buildUpdatePayload(validatedData, duration);\n\t\tconst dbUpdateData = toSnakeCaseRecord(updateData);\n\n\t\t// Update appointment\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(dbUpdateData)\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to update appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\tif (existingAppointment.job_id) {\n\t\t\trevalidatePath(`/dashboard/work/${existingAppointment.job_id}`);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Reschedule an appointment\n */\nasync function rescheduleAppointment(\n\tappointmentId: string,\n\tformData: FormData,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") as string,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") as string,\n\t\t\treason: (formData.get(\"reason\") as string) || undefined,\n\t\t};\n\n\t\tconst validatedData = rescheduleAppointmentSchema.parse(rawData);\n\n\t\t// Validate appointment times\n\t\tvalidateAppointmentTimes(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Calculate new duration\n\t\tconst duration = calculateDuration(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Update appointment with rescheduled status\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: validatedData.scheduledStart,\n\t\t\t\tscheduled_end: validatedData.scheduledEnd,\n\t\t\t\tduration_minutes: duration,\n\t\t\t\tstatus: \"rescheduled\",\n\t\t\t\tnotes: validatedData.reason\n\t\t\t\t\t? `Rescheduled: ${validatedData.reason}`\n\t\t\t\t\t: undefined,\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to reschedule appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Cancel an appointment\n */\nasync function cancelAppointment(\n\tappointmentId: string,\n\treason?: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Update appointment status to cancelled\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tcancellation_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to cancel appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Complete an appointment\n */\nasync function completeAppointment(\n\tappointmentId: string,\n\tactualEnd?: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Update appointment status to completed\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end: actualEnd || new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to complete appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Archive an appointment (soft delete)\n */\nexport async function archiveAppointment(\n\tappointmentId: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Archive appointment (soft delete)\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: now,\n\t\t\t\tdeleted_at: now,\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"cancelled\", // Mark as cancelled when archived\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to archive appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Delete an appointment (hard delete)\n */\nasync function deleteAppointment(\n\tappointmentId: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Delete appointment\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to delete appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Search appointments\n */\nasync function searchAppointments(\n\tsearchQuery: string,\n\toptions?: {\n\t\tlimit?: number;\n\t\toffset?: number;\n\t},\n): Promise<ActionResult<Record<string, unknown>[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Use the RPC function for ranked search\n\t\tconst { data, error } = await supabase.rpc(\"search_appointments_ranked\", {\n\t\t\tp_company_id: companyId,\n\t\t\tp_search_query: searchQuery,\n\t\t\tp_limit: options?.limit ?? DEFAULT_SEARCH_LIMIT,\n\t\t\tp_offset: options?.offset ?? DEFAULT_SEARCH_OFFSET,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Search failed: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn (data as Record<string, unknown>[]) || [];\n\t});\n}\n\n/**\n * Unlink appointment from job\n * Removes the job association (sets job_id to NULL)\n * Bidirectional operation - updates both appointment and job views\n */\nasync function unlinkScheduleFromJob(\n\tappointmentId: string,\n): Promise<ActionResult<void>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Get current appointment to verify exists and get job_id for revalidation\n\t\tconst { data: appointment, error: fetchError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !appointment) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Appointment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tconst previousJobId = appointment.job_id;\n\n\t\t// Unlink appointment from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (unlinkError) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to unlink appointment from job\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate both pages\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IA+OsB,oBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 2550, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/lib/utils/customer-display.ts"],"sourcesContent":["/**\n * Customer Display Utilities\n *\n * Unified logic for displaying customer information consistently across the application.\n * This prevents inconsistent customer name display and provides fallback logic.\n */\n\nexport interface CustomerDisplayData {\n\tid?: string;\n\tdisplay_name?: string | null;\n\tfirst_name?: string | null;\n\tlast_name?: string | null;\n\tcompany_name?: string | null;\n\temail?: string | null;\n\tphone?: string | null;\n}\n\n/**\n * Get a customer's display name using consistent precedence logic:\n * 1. display_name (if set)\n * 2. first_name + last_name (combined)\n * 3. first_name OR last_name (whichever exists)\n * 4. company_name (for business customers)\n * 5. email (as last resort)\n * 6. \"Unknown Customer\" (ultimate fallback)\n *\n * @param customer - Customer object with potential name fields\n * @param fallbackEmail - Optional email to use if customer has no name\n * @returns Display-ready customer name\n *\n * @example\n * ```ts\n * getCustomerDisplayName({ first_name: \"John\", last_name: \"Doe\" })\n * // Returns: \"John Doe\"\n *\n * getCustomerDisplayName({ display_name: \"John's Plumbing\" })\n * // Returns: \"John's Plumbing\"\n *\n * getCustomerDisplayName({ email: \"john@example.com\" })\n * // Returns: \"john@example.com\"\n * ```\n */\nexport function getCustomerDisplayName(\n\tcustomer: CustomerDisplayData | null | undefined,\n\tfallbackEmail?: string | null\n): string {\n\tif (!customer) {\n\t\treturn fallbackEmail || \"Unknown Customer\";\n\t}\n\n\t// Priority 1: Explicit display name\n\tif (customer.display_name) {\n\t\treturn customer.display_name;\n\t}\n\n\t// Priority 2: Full name (first + last)\n\tconst firstName = customer.first_name?.trim();\n\tconst lastName = customer.last_name?.trim();\n\n\tif (firstName && lastName) {\n\t\treturn `${firstName} ${lastName}`;\n\t}\n\n\t// Priority 3: Either first or last name\n\tif (firstName) return firstName;\n\tif (lastName) return lastName;\n\n\t// Priority 4: Company name (for business customers)\n\tif (customer.company_name) {\n\t\treturn customer.company_name;\n\t}\n\n\t// Priority 5: Email from customer record\n\tif (customer.email) {\n\t\treturn customer.email;\n\t}\n\n\t// Priority 6: Fallback email provided\n\tif (fallbackEmail) {\n\t\treturn fallbackEmail;\n\t}\n\n\t// Ultimate fallback\n\treturn \"Unknown Customer\";\n}\n\n/**\n * Get customer initials for avatar displays\n * Takes first letter of each word (max 2 letters)\n *\n * @param customer - Customer object with potential name fields\n * @returns 1-2 character initials (uppercase)\n *\n * @example\n * ```ts\n * getCustomerInitials({ first_name: \"John\", last_name: \"Doe\" })\n * // Returns: \"JD\"\n *\n * getCustomerInitials({ display_name: \"ACME Corp\" })\n * // Returns: \"AC\"\n *\n * getCustomerInitials({ email: \"john@example.com\" })\n * // Returns: \"J\"\n * ```\n */\nexport function getCustomerInitials(\n\tcustomer: CustomerDisplayData | null | undefined\n): string {\n\tif (!customer) return \"?\";\n\n\tconst displayName = getCustomerDisplayName(customer);\n\n\t// Split by spaces and take first letter of each word\n\tconst words = displayName.split(/\\s+/).filter(Boolean);\n\n\tif (words.length >= 2) {\n\t\treturn (words[0][0] + words[1][0]).toUpperCase();\n\t}\n\n\tif (words.length === 1 && words[0].length >= 2) {\n\t\treturn words[0].slice(0, 2).toUpperCase();\n\t}\n\n\tif (words.length === 1) {\n\t\treturn words[0][0].toUpperCase();\n\t}\n\n\treturn \"?\";\n}\n\n/**\n * Get customer's full contact display (name + email/phone)\n * Useful for tooltips, hover cards, and detail views\n *\n * @param customer - Customer object\n * @returns Multi-line contact string\n *\n * @example\n * ```ts\n * getCustomerContactDisplay({\n *   first_name: \"John\",\n *   last_name: \"Doe\",\n *   email: \"john@example.com\",\n *   phone: \"555-1234\"\n * })\n * // Returns: \"John Doe\\njohn@example.com\\n555-1234\"\n * ```\n */\nexport function getCustomerContactDisplay(\n\tcustomer: CustomerDisplayData | null | undefined\n): string {\n\tif (!customer) return \"Unknown Customer\";\n\n\tconst lines: string[] = [getCustomerDisplayName(customer)];\n\n\tif (customer.email) {\n\t\tlines.push(customer.email);\n\t}\n\n\tif (customer.phone) {\n\t\tlines.push(customer.phone);\n\t}\n\n\treturn lines.join(\"\\n\");\n}\n\n/**\n * Check if customer has any name information (not just email)\n * Useful for validation and \"not linked\" indicators\n *\n * @param customer - Customer object\n * @returns true if customer has a real name, false if only email/unknown\n */\nexport function hasCustomerName(\n\tcustomer: CustomerDisplayData | null | undefined\n): boolean {\n\tif (!customer) return false;\n\n\treturn !!(\n\t\tcustomer.display_name ||\n\t\tcustomer.first_name ||\n\t\tcustomer.last_name ||\n\t\tcustomer.company_name\n\t);\n}\n\n/**\n * Format customer name for sorting/comparison\n * Always uses \"Last, First\" format for consistent alphabetization\n *\n * @param customer - Customer object\n * @returns Sortable name string\n *\n * @example\n * ```ts\n * getCustomerSortName({ first_name: \"John\", last_name: \"Doe\" })\n * // Returns: \"Doe, John\"\n *\n * getCustomerSortName({ company_name: \"ACME Corp\" })\n * // Returns: \"ACME Corp\"\n * ```\n */\nexport function getCustomerSortName(\n\tcustomer: CustomerDisplayData | null | undefined\n): string {\n\tif (!customer) return \"zzz_unknown\"; // Sort unknowns to end\n\n\t// If only last name, use it\n\tif (customer.last_name && !customer.first_name) {\n\t\treturn customer.last_name;\n\t}\n\n\t// If only first name, use it\n\tif (customer.first_name && !customer.last_name) {\n\t\treturn customer.first_name;\n\t}\n\n\t// If both names, use \"Last, First\" format\n\tif (customer.first_name && customer.last_name) {\n\t\treturn `${customer.last_name}, ${customer.first_name}`;\n\t}\n\n\t// Otherwise use display name logic\n\treturn getCustomerDisplayName(customer);\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;AAqCM,SAAS,uBACf,QAAgD,EAChD,aAA6B;IAE7B,IAAI,CAAC,UAAU;QACd,OAAO,iBAAiB;IACzB;IAEA,oCAAoC;IACpC,IAAI,SAAS,YAAY,EAAE;QAC1B,OAAO,SAAS,YAAY;IAC7B;IAEA,uCAAuC;IACvC,MAAM,YAAY,SAAS,UAAU,EAAE;IACvC,MAAM,WAAW,SAAS,SAAS,EAAE;IAErC,IAAI,aAAa,UAAU;QAC1B,OAAO,GAAG,UAAU,CAAC,EAAE,UAAU;IAClC;IAEA,wCAAwC;IACxC,IAAI,WAAW,OAAO;IACtB,IAAI,UAAU,OAAO;IAErB,oDAAoD;IACpD,IAAI,SAAS,YAAY,EAAE;QAC1B,OAAO,SAAS,YAAY;IAC7B;IAEA,yCAAyC;IACzC,IAAI,SAAS,KAAK,EAAE;QACnB,OAAO,SAAS,KAAK;IACtB;IAEA,sCAAsC;IACtC,IAAI,eAAe;QAClB,OAAO;IACR;IAEA,oBAAoB;IACpB,OAAO;AACR;AAqBO,SAAS,oBACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO;IAEtB,MAAM,cAAc,uBAAuB;IAE3C,qDAAqD;IACrD,MAAM,QAAQ,YAAY,KAAK,CAAC,OAAO,MAAM,CAAC;IAE9C,IAAI,MAAM,MAAM,IAAI,GAAG;QACtB,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,WAAW;IAC/C;IAEA,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,CAAC,MAAM,IAAI,GAAG;QAC/C,OAAO,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,GAAG,WAAW;IACxC;IAEA,IAAI,MAAM,MAAM,KAAK,GAAG;QACvB,OAAO,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,WAAW;IAC/B;IAEA,OAAO;AACR;AAoBO,SAAS,0BACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO;IAEtB,MAAM,QAAkB;QAAC,uBAAuB;KAAU;IAE1D,IAAI,SAAS,KAAK,EAAE;QACnB,MAAM,IAAI,CAAC,SAAS,KAAK;IAC1B;IAEA,IAAI,SAAS,KAAK,EAAE;QACnB,MAAM,IAAI,CAAC,SAAS,KAAK;IAC1B;IAEA,OAAO,MAAM,IAAI,CAAC;AACnB;AASO,SAAS,gBACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO;IAEtB,OAAO,CAAC,CAAC,CACR,SAAS,YAAY,IACrB,SAAS,UAAU,IACnB,SAAS,SAAS,IAClB,SAAS,YAAY,AACtB;AACD;AAkBO,SAAS,oBACf,QAAgD;IAEhD,IAAI,CAAC,UAAU,OAAO,eAAe,uBAAuB;IAE5D,4BAA4B;IAC5B,IAAI,SAAS,SAAS,IAAI,CAAC,SAAS,UAAU,EAAE;QAC/C,OAAO,SAAS,SAAS;IAC1B;IAEA,6BAA6B;IAC7B,IAAI,SAAS,UAAU,IAAI,CAAC,SAAS,SAAS,EAAE;QAC/C,OAAO,SAAS,UAAU;IAC3B;IAEA,0CAA0C;IAC1C,IAAI,SAAS,UAAU,IAAI,SAAS,SAAS,EAAE;QAC9C,OAAO,GAAG,SAAS,SAAS,CAAC,EAAE,EAAE,SAAS,UAAU,EAAE;IACvD;IAEA,mCAAmC;IACnC,OAAO,uBAAuB;AAC/B"}},
    {"offset": {"line": 2656, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/customers/customer-autocomplete.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * CustomerAutocomplete Component\n *\n * Reusable autocomplete for customer selection in forms.\n * Features:\n * - Instant search with debouncing\n * - Shows customer details (email, phone, company)\n * - Recent customers quick access\n * - Create new customer option\n * - react-hook-form compatible\n * - Keyboard navigation (arrows, enter, escape)\n */\n\nimport { searchCustomers } from \"@/actions/customers\";\nimport { Avatar, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tCommand,\n\tCommandEmpty,\n\tCommandGroup,\n\tCommandInput,\n\tCommandItem,\n\tCommandList,\n\tCommandSeparator,\n} from \"@/components/ui/command\";\nimport {\n\tPopover,\n\tPopoverContent,\n\tPopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport {\n\tgetCustomerDisplayName,\n\tgetCustomerInitials,\n\ttype CustomerDisplayData,\n} from \"@/lib/utils/customer-display\";\nimport {\n\tBuilding2,\n\tCheck,\n\tChevronDown,\n\tChevronsUpDown,\n\tClock,\n\tLoader2,\n\tMail,\n\tPhone,\n\tPlus,\n\tSearch,\n\tUser,\n} from \"lucide-react\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nexport type CustomerOption = {\n\tid: string;\n\tdisplay_name?: string | null;\n\tfirst_name?: string | null;\n\tlast_name?: string | null;\n\tcompany_name?: string | null;\n\temail?: string | null;\n\tphone?: string | null;\n};\n\ninterface CustomerAutocompleteProps {\n\t/** Selected customer ID */\n\tvalue?: string | null;\n\t/** Callback when customer is selected */\n\tonChange: (customerId: string | null, customer: CustomerOption | null) => void;\n\t/** Optional placeholder text */\n\tplaceholder?: string;\n\t/** Optional className for styling */\n\tclassName?: string;\n\t/** Show recent customers section */\n\tshowRecent?: boolean;\n\t/** Optional recent customers list */\n\trecentCustomers?: CustomerOption[];\n\t/** Show \"Create New Customer\" option */\n\tshowCreateNew?: boolean;\n\t/** Callback when \"Create New Customer\" is clicked */\n\tonCreateNew?: () => void;\n\t/** Disabled state */\n\tdisabled?: boolean;\n\t/** Optional label */\n\tlabel?: string;\n\t/** Show error state */\n\terror?: boolean;\n\t/** Error message */\n\terrorMessage?: string;\n}\n\nexport function CustomerAutocomplete({\n\tvalue,\n\tonChange,\n\tplaceholder = \"Search for customer...\",\n\tclassName,\n\tshowRecent = true,\n\trecentCustomers = [],\n\tshowCreateNew = true,\n\tonCreateNew,\n\tdisabled = false,\n\tlabel,\n\terror = false,\n\terrorMessage,\n}: CustomerAutocompleteProps) {\n\tconst [open, setOpen] = useState(false);\n\tconst [search, setSearch] = useState(\"\");\n\tconst [customers, setCustomers] = useState<CustomerOption[]>([]);\n\tconst [loading, setLoading] = useState(false);\n\tconst [selectedCustomer, setSelectedCustomer] = useState<CustomerOption | null>(null);\n\n\t// Debounced search\n\tuseEffect(() => {\n\t\tif (search.trim().length < 2) {\n\t\t\tsetCustomers([]);\n\t\t\tsetLoading(false);\n\t\t\treturn;\n\t\t}\n\n\t\tsetLoading(true);\n\t\tconst timeoutId = setTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tconst result = await searchCustomers(search, { limit: 10 });\n\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\tconst customerArray = Array.isArray(result.data) ? result.data : [result.data];\n\t\t\t\t\tsetCustomers(customerArray as CustomerOption[]);\n\t\t\t\t} else {\n\t\t\t\t\tsetCustomers([]);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Customer search error:\", error);\n\t\t\t\tsetCustomers([]);\n\t\t\t} finally {\n\t\t\t\tsetLoading(false);\n\t\t\t}\n\t\t}, 300);\n\n\t\treturn () => clearTimeout(timeoutId);\n\t}, [search]);\n\n\t// Handle customer selection\n\tconst handleSelectCustomer = useCallback(\n\t\t(customer: CustomerOption) => {\n\t\t\tsetSelectedCustomer(customer);\n\t\t\tonChange(customer.id, customer);\n\t\t\tsetOpen(false);\n\t\t\tsetSearch(\"\");\n\t\t},\n\t\t[onChange]\n\t);\n\n\t// Clear selection\n\tconst handleClear = useCallback(() => {\n\t\tsetSelectedCustomer(null);\n\t\tonChange(null, null);\n\t\tsetSearch(\"\");\n\t}, [onChange]);\n\n\t// Get display name for selected customer\n\tconst displayName = selectedCustomer\n\t\t? getCustomerDisplayName(selectedCustomer)\n\t\t: placeholder;\n\n\t// Combine recent and search results (deduplicate by ID)\n\tconst allCustomers = useMemo(() => {\n\t\tconst customerMap = new Map<string, CustomerOption>();\n\n\t\t// Add search results first (higher priority)\n\t\tcustomers.forEach((c) => customerMap.set(c.id, c));\n\n\t\t// Add recent customers if no search\n\t\tif (search.trim().length < 2 && showRecent) {\n\t\t\trecentCustomers.forEach((c) => customerMap.set(c.id, c));\n\t\t}\n\n\t\treturn Array.from(customerMap.values());\n\t}, [customers, recentCustomers, search, showRecent]);\n\n\t// Customer list item component\n\tconst CustomerListItem = ({ customer }: { customer: CustomerOption }) => {\n\t\tconst name = getCustomerDisplayName(customer);\n\t\tconst initials = getCustomerInitials(customer);\n\t\tconst isSelected = value === customer.id;\n\n\t\treturn (\n\t\t\t<CommandItem\n\t\t\t\tkey={customer.id}\n\t\t\t\tvalue={customer.id}\n\t\t\t\tonSelect={() => handleSelectCustomer(customer)}\n\t\t\t\tclassName=\"flex items-center gap-3 px-3 py-2.5 cursor-pointer\"\n\t\t\t>\n\t\t\t\t<Avatar className=\"h-8 w-8 shrink-0\">\n\t\t\t\t\t<AvatarFallback className=\"text-xs font-semibold\">\n\t\t\t\t\t\t{initials}\n\t\t\t\t\t</AvatarFallback>\n\t\t\t\t</Avatar>\n\n\t\t\t\t<div className=\"flex-1 min-w-0\">\n\t\t\t\t\t<p className=\"font-medium text-sm truncate\">{name}</p>\n\t\t\t\t\t<div className=\"flex items-center gap-2 text-xs text-muted-foreground\">\n\t\t\t\t\t\t{customer.email && (\n\t\t\t\t\t\t\t<span className=\"flex items-center gap-1 truncate\">\n\t\t\t\t\t\t\t\t<Mail className=\"h-3 w-3 shrink-0\" />\n\t\t\t\t\t\t\t\t{customer.email}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{customer.phone && (\n\t\t\t\t\t\t\t<span className=\"flex items-center gap-1\">\n\t\t\t\t\t\t\t\t<Phone className=\"h-3 w-3 shrink-0\" />\n\t\t\t\t\t\t\t\t{customer.phone}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t\t{customer.company_name && (\n\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground flex items-center gap-1 mt-0.5\">\n\t\t\t\t\t\t\t<Building2 className=\"h-3 w-3 shrink-0\" />\n\t\t\t\t\t\t\t{customer.company_name}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\n\t\t\t\t{isSelected && (\n\t\t\t\t\t<Check className=\"h-4 w-4 text-primary shrink-0\" />\n\t\t\t\t)}\n\t\t\t</CommandItem>\n\t\t);\n\t};\n\n\treturn (\n\t\t<div className={cn(\"flex flex-col gap-1.5\", className)}>\n\t\t\t{label && (\n\t\t\t\t<label className=\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\">\n\t\t\t\t\t{label}\n\t\t\t\t</label>\n\t\t\t)}\n\n\t\t\t<Popover open={open} onOpenChange={setOpen}>\n\t\t\t\t<PopoverTrigger asChild>\n\t\t\t\t\t<Button\n\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\trole=\"combobox\"\n\t\t\t\t\t\taria-expanded={open}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\"w-full justify-between\",\n\t\t\t\t\t\t\t!selectedCustomer && \"text-muted-foreground\",\n\t\t\t\t\t\t\terror && \"border-destructive focus-visible:ring-destructive\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span className=\"flex items-center gap-2 truncate\">\n\t\t\t\t\t\t\t{selectedCustomer ? (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<User className=\"h-4 w-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t<span className=\"truncate\">{displayName}</span>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<Search className=\"h-4 w-4 shrink-0\" />\n\t\t\t\t\t\t\t\t\t<span>{placeholder}</span>\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n\t\t\t\t\t</Button>\n\t\t\t\t</PopoverTrigger>\n\n\t\t\t\t<PopoverContent className=\"w-[400px] p-0\" align=\"start\">\n\t\t\t\t\t<Command shouldFilter={false}>\n\t\t\t\t\t\t<CommandInput\n\t\t\t\t\t\t\tplaceholder=\"Search customers...\"\n\t\t\t\t\t\t\tvalue={search}\n\t\t\t\t\t\t\tonValueChange={setSearch}\n\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t\t{loading ? (\n\t\t\t\t\t\t\t\t<div className=\"flex items-center justify-center py-6\">\n\t\t\t\t\t\t\t\t\t<Loader2 className=\"h-5 w-5 animate-spin text-muted-foreground\" />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t{/* Search Results / All Customers */}\n\t\t\t\t\t\t\t\t\t{allCustomers.length > 0 ? (\n\t\t\t\t\t\t\t\t\t\t<CommandGroup\n\t\t\t\t\t\t\t\t\t\t\theading={\n\t\t\t\t\t\t\t\t\t\t\t\tsearch.trim().length >= 2\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"Search Results\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: showRecent && recentCustomers.length > 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"Recent Customers\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"All Customers\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<ScrollArea className=\"max-h-[300px]\">\n\t\t\t\t\t\t\t\t\t\t\t\t{allCustomers.map((customer) => (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CustomerListItem key={customer.id} customer={customer} />\n\t\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t\t</ScrollArea>\n\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t) : search.trim().length >= 2 ? (\n\t\t\t\t\t\t\t\t\t\t<CommandEmpty>No customers found.</CommandEmpty>\n\t\t\t\t\t\t\t\t\t) : showRecent && recentCustomers.length === 0 ? (\n\t\t\t\t\t\t\t\t\t\t<CommandEmpty>Start typing to search for customers...</CommandEmpty>\n\t\t\t\t\t\t\t\t\t) : null}\n\n\t\t\t\t\t\t\t\t\t{/* Create New Customer */}\n\t\t\t\t\t\t\t\t\t{showCreateNew && onCreateNew && (\n\t\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t\t<CommandSeparator />\n\t\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetOpen(false);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonCreateNew();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2.5 cursor-pointer text-primary\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Plus className=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-medium\">Create New Customer</span>\n\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</CommandList>\n\n\t\t\t\t\t\t{/* Clear Selection */}\n\t\t\t\t\t\t{selectedCustomer && !disabled && (\n\t\t\t\t\t\t\t<div className=\"border-t p-2\">\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tonClick={handleClear}\n\t\t\t\t\t\t\t\t\tclassName=\"w-full text-muted-foreground hover:text-destructive\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tClear Selection\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Command>\n\t\t\t\t</PopoverContent>\n\t\t\t</Popover>\n\n\t\t\t{error && errorMessage && (\n\t\t\t\t<p className=\"text-sm text-destructive\">{errorMessage}</p>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3174, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/quick-appointment-dialog.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * QuickAppointmentDialog Component\n *\n * A streamlined dialog for quickly creating appointments from the dispatch map.\n * Triggered by clicking on the map canvas.\n *\n * Features:\n * - Pre-fills location from map click coordinates\n * - Customer autocomplete with nearby customer suggestions\n * - Technician assignment\n * - Date/time picker with smart defaults\n * - Job type/priority selection\n */\n\nimport { createAppointment } from \"@/actions/appointments\";\nimport { CustomerAutocomplete, type CustomerOption } from \"@/components/customers/customer-autocomplete\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n\tSelect,\n\tSelectContent,\n\tSelectItem,\n\tSelectTrigger,\n\tSelectValue,\n} from \"@/components/ui/select\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { cn } from \"@/lib/utils\";\nimport {\n\tAlertTriangle,\n\tCalendar,\n\tClock,\n\tLoader2,\n\tMapPin,\n\tUser,\n\tWrench,\n} from \"lucide-react\";\nimport { useCallback, useEffect, useState, useTransition } from \"react\";\nimport { format } from \"date-fns\";\n\n// Job types matching the backend schema\n// Valid types: service_call, installation, maintenance, inspection, repair, estimate, follow_up, winterization, emergency\nconst JOB_TYPES = [\n\t{ value: \"emergency\", label: \"Emergency / Urgent\", color: \"text-red-500\" },\n\t{ value: \"follow_up\", label: \"Callback / Follow Up\", color: \"text-orange-500\" },\n\t{ value: \"maintenance\", label: \"Maintenance / Recurring\", color: \"text-purple-500\" },\n\t{ value: \"installation\", label: \"Install / New Work\", color: \"text-green-500\" },\n\t{ value: \"service_call\", label: \"Service Call\", color: \"text-blue-500\" },\n\t{ value: \"inspection\", label: \"Inspection\", color: \"text-slate-500\" },\n\t{ value: \"estimate\", label: \"Estimate\", color: \"text-amber-500\" },\n\t{ value: \"repair\", label: \"Repair\", color: \"text-cyan-500\" },\n\t{ value: \"winterization\", label: \"Winterization\", color: \"text-indigo-500\" },\n] as const;\n\nconst PRIORITIES = [\n\t{ value: \"low\", label: \"Low\", color: \"text-slate-500\" },\n\t{ value: \"normal\", label: \"Normal\", color: \"text-blue-500\" },\n\t{ value: \"high\", label: \"High\", color: \"text-orange-500\" },\n\t{ value: \"urgent\", label: \"Urgent\", color: \"text-red-500\" },\n] as const;\n\nconst DURATIONS = [\n\t{ value: 30, label: \"30 min\" },\n\t{ value: 60, label: \"1 hour\" },\n\t{ value: 90, label: \"1.5 hours\" },\n\t{ value: 120, label: \"2 hours\" },\n\t{ value: 180, label: \"3 hours\" },\n\t{ value: 240, label: \"4 hours\" },\n\t{ value: 480, label: \"Full day\" },\n] as const;\n\nexport type MapClickLocation = {\n\tlat: number;\n\tlng: number;\n\taddress?: string;\n};\n\nexport type TechnicianOption = {\n\tid: string;\n\tname: string;\n\tavatar?: string;\n};\n\ninterface QuickAppointmentDialogProps {\n\topen: boolean;\n\tonOpenChange: (open: boolean) => void;\n\tlocation?: MapClickLocation | null;\n\ttechnicians?: TechnicianOption[];\n\tnearbyCustomers?: CustomerOption[];\n\tonSuccess?: (appointmentId: string) => void;\n\tonCreateCustomer?: () => void;\n\t/** Pre-select a technician (e.g., from timeline double-click) */\n\tdefaultTechnicianId?: string;\n\t/** Pre-fill date/time (e.g., from timeline double-click) */\n\tdefaultDateTime?: Date;\n\t/** Pre-fill duration in minutes (e.g., from timeline drag-to-create) */\n\tdefaultDuration?: number;\n}\n\nexport function QuickAppointmentDialog({\n\topen,\n\tonOpenChange,\n\tlocation,\n\ttechnicians = [],\n\tnearbyCustomers = [],\n\tonSuccess,\n\tonCreateCustomer,\n\tdefaultTechnicianId,\n\tdefaultDateTime,\n\tdefaultDuration,\n}: QuickAppointmentDialogProps) {\n\tconst [isPending, startTransition] = useTransition();\n\tconst [error, setError] = useState<string | null>(null);\n\n\t// Form state\n\tconst [selectedCustomer, setSelectedCustomer] = useState<CustomerOption | null>(null);\n\tconst [customerId, setCustomerId] = useState<string | null>(null);\n\tconst [title, setTitle] = useState(\"\");\n\tconst [jobType, setJobType] = useState<string>(\"service_call\");\n\tconst [priority, setPriority] = useState<string>(\"normal\");\n\tconst [technicianId, setTechnicianId] = useState<string>(\"\");\n\tconst [duration, setDuration] = useState<number>(60);\n\tconst [notes, setNotes] = useState(\"\");\n\n\t// Apply defaults when dialog opens\n\tuseEffect(() => {\n\t\tif (open) {\n\t\t\tif (defaultTechnicianId) {\n\t\t\t\tsetTechnicianId(defaultTechnicianId);\n\t\t\t}\n\t\t\tif (defaultDateTime) {\n\t\t\t\t// Ensure the time is not in the past (server rejects past appointments)\n\t\t\t\tconst now = new Date();\n\t\t\t\tlet adjustedTime = defaultDateTime;\n\t\t\t\tif (defaultDateTime < now) {\n\t\t\t\t\t// Move to the same time slot tomorrow, or next available hour if today\n\t\t\t\t\tadjustedTime = new Date();\n\t\t\t\t\tadjustedTime.setMinutes(0, 0, 0);\n\t\t\t\t\tadjustedTime.setHours(adjustedTime.getHours() + 1);\n\t\t\t\t}\n\t\t\t\tsetScheduledStart(format(adjustedTime, \"yyyy-MM-dd'T'HH:mm\"));\n\t\t\t}\n\t\t\tif (defaultDuration) {\n\t\t\t\t// Snap to nearest valid duration option\n\t\t\t\tconst validDurations = [30, 60, 90, 120, 180, 240, 480];\n\t\t\t\tconst closest = validDurations.reduce((prev, curr) =>\n\t\t\t\t\tMath.abs(curr - defaultDuration) < Math.abs(prev - defaultDuration) ? curr : prev\n\t\t\t\t);\n\t\t\t\tsetDuration(closest);\n\t\t\t}\n\t\t}\n\t}, [open, defaultTechnicianId, defaultDateTime, defaultDuration]);\n\n\t// Date/time - default to next available slot (next hour)\n\tconst getDefaultDateTime = () => {\n\t\tconst now = new Date();\n\t\tnow.setMinutes(0, 0, 0);\n\t\tnow.setHours(now.getHours() + 1);\n\t\treturn now.toISOString().slice(0, 16);\n\t};\n\tconst [scheduledStart, setScheduledStart] = useState(getDefaultDateTime());\n\n\t// Calculate end time based on duration\n\tconst getScheduledEnd = useCallback(() => {\n\t\tconst start = new Date(scheduledStart);\n\t\tstart.setMinutes(start.getMinutes() + duration);\n\t\treturn start.toISOString();\n\t}, [scheduledStart, duration]);\n\n\t// Handle customer selection\n\tconst handleCustomerChange = (id: string | null, customer: CustomerOption | null) => {\n\t\tsetCustomerId(id);\n\t\tsetSelectedCustomer(customer);\n\t\t// Auto-fill title if empty\n\t\tif (customer && !title) {\n\t\t\tconst customerName = customer.display_name ||\n\t\t\t\t`${customer.first_name || \"\"} ${customer.last_name || \"\"}`.trim() ||\n\t\t\t\tcustomer.company_name || \"Customer\";\n\t\t\tsetTitle(`Service call - ${customerName}`);\n\t\t}\n\t};\n\n\t// Reset form\n\tconst resetForm = useCallback(() => {\n\t\tsetSelectedCustomer(null);\n\t\tsetCustomerId(null);\n\t\tsetTitle(\"\");\n\t\tsetJobType(\"service_call\");\n\t\tsetPriority(\"normal\");\n\t\tsetTechnicianId(\"\");\n\t\tsetDuration(60);\n\t\tsetNotes(\"\");\n\t\tsetScheduledStart(getDefaultDateTime());\n\t\tsetError(null);\n\t}, []);\n\n\t// Handle close\n\tconst handleOpenChange = (newOpen: boolean) => {\n\t\tif (!newOpen) {\n\t\t\tresetForm();\n\t\t}\n\t\tonOpenChange(newOpen);\n\t};\n\n\t// Handle form submission\n\tconst handleSubmit = async (e: React.FormEvent) => {\n\t\te.preventDefault();\n\t\tsetError(null);\n\n\t\tif (!customerId) {\n\t\t\tsetError(\"Please select a customer\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!title.trim()) {\n\t\t\tsetError(\"Please enter a title\");\n\t\t\treturn;\n\t\t}\n\n\t\tstartTransition(async () => {\n\t\t\ttry {\n\t\t\t\tconst formData = new FormData();\n\t\t\t\tformData.set(\"customerId\", customerId);\n\t\t\t\tformData.set(\"title\", title.trim());\n\t\t\t\tformData.set(\"scheduledStart\", new Date(scheduledStart).toISOString());\n\t\t\t\tformData.set(\"scheduledEnd\", getScheduledEnd());\n\t\t\t\tformData.set(\"type\", jobType);\n\t\t\t\tformData.set(\"priority\", priority);\n\t\t\t\tformData.set(\"category\", \"job_appointment\");\n\n\t\t\t\tif (technicianId && technicianId !== \"unassigned\") {\n\t\t\t\t\tformData.set(\"assignedTo\", technicianId);\n\t\t\t\t}\n\n\t\t\t\tif (notes.trim()) {\n\t\t\t\t\tformData.set(\"notes\", notes.trim());\n\t\t\t\t}\n\n\t\t\t\t// Add location info to notes if available\n\t\t\t\tif (location?.address) {\n\t\t\t\t\tconst existingNotes = notes.trim();\n\t\t\t\t\tconst locationNote = `Location: ${location.address}`;\n\t\t\t\t\tformData.set(\"notes\", existingNotes ? `${existingNotes}\\n\\n${locationNote}` : locationNote);\n\t\t\t\t}\n\n\t\t\t\tconst result = await createAppointment(formData);\n\n\t\t\t\tif (result.success && result.data) {\n\t\t\t\t\tonSuccess?.(result.data);\n\t\t\t\t\thandleOpenChange(false);\n\t\t\t\t} else {\n\t\t\t\t\tsetError(result.error || \"Failed to create appointment\");\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\"Failed to create appointment:\", err);\n\t\t\t\tsetError(\"An unexpected error occurred\");\n\t\t\t}\n\t\t});\n\t};\n\n\treturn (\n\t\t<Dialog open={open} onOpenChange={handleOpenChange}>\n\t\t\t<DialogContent className=\"sm:max-w-[500px]\">\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle className=\"flex items-center gap-2\">\n\t\t\t\t\t\t<Calendar className=\"h-5 w-5 text-primary\" />\n\t\t\t\t\t\tQuick Appointment\n\t\t\t\t\t</DialogTitle>\n\t\t\t\t\t<DialogDescription>\n\t\t\t\t\t\t{location?.address ? (\n\t\t\t\t\t\t\t<span className=\"flex items-center gap-1 text-sm\">\n\t\t\t\t\t\t\t\t<MapPin className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\t{location.address}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\"Create a new appointment from the dispatch map\"\n\t\t\t\t\t\t)}\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</DialogHeader>\n\n\t\t\t\t<form onSubmit={handleSubmit} className=\"space-y-4\">\n\t\t\t\t\t{/* Customer Selection */}\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<Label htmlFor=\"customer\">Customer *</Label>\n\t\t\t\t\t\t<CustomerAutocomplete\n\t\t\t\t\t\t\tvalue={customerId}\n\t\t\t\t\t\t\tonChange={handleCustomerChange}\n\t\t\t\t\t\t\tplaceholder=\"Search or select customer...\"\n\t\t\t\t\t\t\tshowCreateNew\n\t\t\t\t\t\t\tonCreateNew={onCreateCustomer}\n\t\t\t\t\t\t\tshowRecent\n\t\t\t\t\t\t\trecentCustomers={nearbyCustomers}\n\t\t\t\t\t\t\terror={error?.includes(\"customer\")}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Title */}\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<Label htmlFor=\"title\">Title *</Label>\n\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\tid=\"title\"\n\t\t\t\t\t\t\tvalue={title}\n\t\t\t\t\t\t\tonChange={(e) => setTitle(e.target.value)}\n\t\t\t\t\t\t\tplaceholder=\"e.g., AC Repair, Plumbing Inspection\"\n\t\t\t\t\t\t\tclassName={cn(error?.includes(\"title\") && \"border-destructive\")}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Job Type & Priority */}\n\t\t\t\t\t<div className=\"grid grid-cols-2 gap-4\">\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"jobType\">Job Type</Label>\n\t\t\t\t\t\t\t<Select value={jobType} onValueChange={setJobType}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"jobType\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t{JOB_TYPES.map((type) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={type.value} value={type.value}>\n\t\t\t\t\t\t\t\t\t\t\t<span className={cn(\"flex items-center gap-2\", type.color)}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Wrench className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\t\t\t\t\t{type.label}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"priority\">Priority</Label>\n\t\t\t\t\t\t\t<Select value={priority} onValueChange={setPriority}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"priority\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t{PRIORITIES.map((p) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={p.value} value={p.value}>\n\t\t\t\t\t\t\t\t\t\t\t<span className={cn(\"flex items-center gap-2\", p.color)}>\n\t\t\t\t\t\t\t\t\t\t\t\t{p.value === \"urgent\" && <AlertTriangle className=\"h-3.5 w-3.5\" />}\n\t\t\t\t\t\t\t\t\t\t\t\t{p.label}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Date/Time & Duration */}\n\t\t\t\t\t<div className=\"grid grid-cols-2 gap-4\">\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"scheduledStart\">Date & Time</Label>\n\t\t\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t\t\t<Clock className=\"absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tid=\"scheduledStart\"\n\t\t\t\t\t\t\t\t\ttype=\"datetime-local\"\n\t\t\t\t\t\t\t\t\tvalue={scheduledStart}\n\t\t\t\t\t\t\t\t\tonChange={(e) => setScheduledStart(e.target.value)}\n\t\t\t\t\t\t\t\t\tclassName=\"pl-9\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"duration\">Duration</Label>\n\t\t\t\t\t\t\t<Select value={duration.toString()} onValueChange={(v) => setDuration(Number(v))}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"duration\">\n\t\t\t\t\t\t\t\t\t<SelectValue />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t{DURATIONS.map((d) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={d.value} value={d.value.toString()}>\n\t\t\t\t\t\t\t\t\t\t\t{d.label}\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Technician Assignment */}\n\t\t\t\t\t{technicians.length > 0 && (\n\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t<Label htmlFor=\"technician\">Assign Technician</Label>\n\t\t\t\t\t\t\t<Select value={technicianId} onValueChange={setTechnicianId}>\n\t\t\t\t\t\t\t\t<SelectTrigger id=\"technician\">\n\t\t\t\t\t\t\t\t\t<SelectValue placeholder=\"Select technician (optional)\" />\n\t\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t\t<SelectItem value=\"unassigned\">Unassigned</SelectItem>\n\t\t\t\t\t\t\t\t\t{technicians.map((tech) => (\n\t\t\t\t\t\t\t\t\t\t<SelectItem key={tech.id} value={tech.id}>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t\t<User className=\"h-3.5 w-3.5\" />\n\t\t\t\t\t\t\t\t\t\t\t\t{tech.name}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Notes */}\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<Label htmlFor=\"notes\">Notes</Label>\n\t\t\t\t\t\t<Textarea\n\t\t\t\t\t\t\tid=\"notes\"\n\t\t\t\t\t\t\tvalue={notes}\n\t\t\t\t\t\t\tonChange={(e) => setNotes(e.target.value)}\n\t\t\t\t\t\t\tplaceholder=\"Additional notes or instructions...\"\n\t\t\t\t\t\t\trows={2}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Error Display */}\n\t\t\t\t\t{error && (\n\t\t\t\t\t\t<div className=\"rounded-md bg-destructive/10 p-3 text-sm text-destructive\">\n\t\t\t\t\t\t\t{error}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t<DialogFooter>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tonClick={() => handleOpenChange(false)}\n\t\t\t\t\t\t\tdisabled={isPending}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tCancel\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button type=\"submit\" disabled={isPending || !customerId}>\n\t\t\t\t\t\t\t{isPending ? (\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\t\t\t\tCreating...\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\"Create Appointment\"\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</DialogFooter>\n\t\t\t\t</form>\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4044, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/unassigned-panel.tsx"],"sourcesContent":["\"use client\";\n\nimport { DragOverlay, useDroppable } from \"@dnd-kit/core\";\nimport {\n\tSortableContext,\n\tuseSortable,\n\tverticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { format } from \"date-fns\";\nimport {\n\tAlertCircle,\n\tBriefcase,\n\tCalendar,\n\tChevronLeft,\n\tChevronRight,\n\tClipboardCheck,\n\tClock,\n\tHardHat,\n\tMapPin,\n\tPhone,\n\tSearch,\n\tSettings,\n\tStar,\n\tUsers,\n\tWrench,\n\tZap,\n} from \"lucide-react\";\nimport { memo, useEffect, useMemo, useRef, useState } from \"react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { Collapsible, CollapsibleTrigger } from \"@/components/ui/collapsible\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport type { AppointmentCategory, Job, JobType } from \"./schedule-types\";\nimport {\n\tTooltip,\n\tTooltipContent,\n\tTooltipProvider,\n\tTooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\n// Job type visual configuration - consistent with timeline and kanban views\ntype JobTypeConfig = {\n\tborderColor: string;\n\tbgColor: string;\n\ticon: React.ComponentType<{ className?: string }>;\n\tlabel: string;\n};\n\nconst JOB_TYPE_CONFIG: Record<JobType | \"default\", JobTypeConfig> = {\n\temergency: {\n\t\tborderColor: \"border-l-red-500\",\n\t\tbgColor: \"bg-red-500/10\",\n\t\ticon: Zap,\n\t\tlabel: \"Emergency\",\n\t},\n\trepair: {\n\t\tborderColor: \"border-l-orange-500\",\n\t\tbgColor: \"bg-orange-500/10\",\n\t\ticon: Wrench,\n\t\tlabel: \"Repair\",\n\t},\n\tinstallation: {\n\t\tborderColor: \"border-l-green-500\",\n\t\tbgColor: \"bg-green-500/10\",\n\t\ticon: HardHat,\n\t\tlabel: \"Installation\",\n\t},\n\tmaintenance: {\n\t\tborderColor: \"border-l-blue-500\",\n\t\tbgColor: \"bg-blue-500/10\",\n\t\ticon: Settings,\n\t\tlabel: \"Maintenance\",\n\t},\n\tpremium_maintenance: {\n\t\tborderColor: \"border-l-violet-500\",\n\t\tbgColor: \"bg-violet-500/10\",\n\t\ticon: Star,\n\t\tlabel: \"Premium\",\n\t},\n\tinspection: {\n\t\tborderColor: \"border-l-cyan-500\",\n\t\tbgColor: \"bg-cyan-500/10\",\n\t\ticon: Search,\n\t\tlabel: \"Inspection\",\n\t},\n\tservice: {\n\t\tborderColor: \"border-l-sky-500\",\n\t\tbgColor: \"bg-sky-500/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Service\",\n\t},\n\tservice_call: {\n\t\tborderColor: \"border-l-teal-500\",\n\t\tbgColor: \"bg-teal-500/10\",\n\t\ticon: Phone,\n\t\tlabel: \"Service Call\",\n\t},\n\testimate: {\n\t\tborderColor: \"border-l-amber-500\",\n\t\tbgColor: \"bg-amber-500/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Estimate\",\n\t},\n\tcallback: {\n\t\tborderColor: \"border-l-pink-500\",\n\t\tbgColor: \"bg-pink-500/10\",\n\t\ticon: Phone,\n\t\tlabel: \"Callback\",\n\t},\n\tother: {\n\t\tborderColor: \"border-l-slate-400\",\n\t\tbgColor: \"bg-slate-400/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Other\",\n\t},\n\tdefault: {\n\t\tborderColor: \"border-l-slate-400\",\n\t\tbgColor: \"bg-slate-400/10\",\n\t\ticon: ClipboardCheck,\n\t\tlabel: \"Job\",\n\t},\n};\n\nconst getJobTypeConfig = (job: Job): JobTypeConfig => {\n\tconst config = job.jobType ? JOB_TYPE_CONFIG[job.jobType] : JOB_TYPE_CONFIG.default;\n\treturn config || JOB_TYPE_CONFIG.default;\n};\n\n// Appointment category visual configuration\ntype AppointmentCategoryConfig = {\n\ticon: React.ComponentType<{ className?: string }>;\n\tlabel: string;\n\tbgColor: string;\n\ttextColor: string;\n\tborderStyle: string;\n};\n\nconst APPOINTMENT_CATEGORY_CONFIG: Record<AppointmentCategory, AppointmentCategoryConfig> = {\n\tjob: {\n\t\ticon: Briefcase,\n\t\tlabel: \"Job\",\n\t\tbgColor: \"bg-blue-500/10\",\n\t\ttextColor: \"text-blue-600 dark:text-blue-400\",\n\t\tborderStyle: \"border-solid\",\n\t},\n\tmeeting: {\n\t\ticon: Users,\n\t\tlabel: \"Meeting\",\n\t\tbgColor: \"bg-purple-500/10\",\n\t\ttextColor: \"text-purple-600 dark:text-purple-400\",\n\t\tborderStyle: \"border-dashed\",\n\t},\n\tevent: {\n\t\ticon: Calendar,\n\t\tlabel: \"Event\",\n\t\tbgColor: \"bg-emerald-500/10\",\n\t\ttextColor: \"text-emerald-600 dark:text-emerald-400\",\n\t\tborderStyle: \"border-dotted\",\n\t},\n};\n\nconst getAppointmentCategoryConfig = (job: Job): AppointmentCategoryConfig => {\n\tconst category = job.appointmentCategory || \"job\";\n\treturn APPOINTMENT_CATEGORY_CONFIG[category];\n};\n\nconst UnassignedJobCard = memo(function UnassignedJobCard({\n\tjob,\n\tisDragOverlay = false,\n}: {\n\tjob: Job;\n\tisDragOverlay?: boolean;\n}) {\n\tconst sortable = useSortable({\n\t\tid: job.id,\n\t\tdata: { job },\n\t});\n\n\tconst {\n\t\tattributes,\n\t\tlisteners,\n\t\tsetNodeRef,\n\t\ttransform,\n\t\ttransition,\n\t\tisDragging,\n\t} = sortable;\n\n\tconst style = isDragOverlay\n\t\t? undefined\n\t\t: {\n\t\t\t\ttransform: CSS.Transform.toString(transform),\n\t\t\t\ttransition,\n\t\t\t};\n\n\tconst startTime =\n\t\tjob.startTime instanceof Date ? job.startTime : new Date(job.startTime);\n\tconst endTime =\n\t\tjob.endTime instanceof Date ? job.endTime : new Date(job.endTime);\n\tconst duration = Math.round(\n\t\t(endTime.getTime() - startTime.getTime()) / (1000 * 60),\n\t);\n\n\treturn (\n\t\t<div\n\t\t\tref={isDragOverlay ? undefined : setNodeRef}\n\t\t\tstyle={style}\n\t\t\t{...(isDragOverlay ? {} : attributes)}\n\t\t\t{...(isDragOverlay ? {} : listeners)}\n\t\t\tclassName={cn(\n\t\t\t\t\"group bg-card relative cursor-grab rounded-lg border-2 border-dashed border-red-200 p-3 shadow-sm transition-all hover:border-red-300 hover:shadow-md active:cursor-grabbing dark:border-red-900/50\",\n\t\t\t\tisDragging && !isDragOverlay && \"opacity-30\",\n\t\t\t\tisDragOverlay &&\n\t\t\t\t\t\"scale-105 cursor-grabbing shadow-2xl ring-2 ring-red-500\",\n\t\t\t)}\n\t\t>\n\t\t\t{/* Drag indicator */}\n\t\t\t<div className=\"absolute top-2 right-2 opacity-0 transition-opacity group-hover:opacity-100\">\n\t\t\t\t<div className=\"flex size-5 items-center justify-center rounded bg-red-500 text-white\">\n\t\t\t\t\t<ChevronRight className=\"size-3\" />\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div className=\"space-y-2\">\n\t\t\t\t{/* Appointment Category + Job Type + Title */}\n\t\t\t\t<div className=\"flex items-start gap-2 pr-6\">\n\t\t\t\t\t<TooltipProvider>\n\t\t\t\t\t\t{/* Appointment Category Icon */}\n\t\t\t\t\t\t{(() => {\n\t\t\t\t\t\t\tconst catConfig = getAppointmentCategoryConfig(job);\n\t\t\t\t\t\t\tconst CatIcon = catConfig.icon;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t<div className={cn(\"mt-0.5 flex size-4 shrink-0 items-center justify-center rounded-sm\", catConfig.bgColor)}>\n\t\t\t\t\t\t\t\t\t\t\t<CatIcon className={cn(\"size-2.5\", catConfig.textColor)} />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t<TooltipContent side=\"top\" className=\"text-xs\">\n\t\t\t\t\t\t\t\t\t\t{catConfig.label}\n\t\t\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})()}\n\t\t\t\t\t\t{/* Job Type Icon */}\n\t\t\t\t\t\t{(() => {\n\t\t\t\t\t\t\tconst typeConfig = getJobTypeConfig(job);\n\t\t\t\t\t\t\tconst TypeIcon = typeConfig.icon;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t\t\t\t<div className={cn(\"mt-0.5 flex size-5 shrink-0 items-center justify-center rounded\", typeConfig.bgColor)}>\n\t\t\t\t\t\t\t\t\t\t\t<TypeIcon className={cn(\"size-3\", typeConfig.borderColor.replace(\"border-l-\", \"text-\"))} />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t\t\t\t<TooltipContent side=\"top\" className=\"text-xs\">\n\t\t\t\t\t\t\t\t\t\t{typeConfig.label}\n\t\t\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})()}\n\t\t\t\t\t</TooltipProvider>\n\t\t\t\t\t<div className=\"min-w-0 flex-1\">\n\t\t\t\t\t\t<p className=\"text-foreground text-sm font-semibold\">{job.title}</p>\n\t\t\t\t\t\t{job.customer?.name && (\n\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">{job.customer.name}</p>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Time */}\n\t\t\t\t<div className=\"flex items-center gap-4 text-xs\">\n\t\t\t\t\t<div className=\"text-muted-foreground flex items-center gap-1.5\">\n\t\t\t\t\t\t<Clock className=\"size-3.5\" />\n\t\t\t\t\t\t<span className=\"font-mono font-medium\">\n\t\t\t\t\t\t\t{format(startTime, \"h:mm a\")}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Badge className=\"text-[10px]\" variant=\"secondary\">\n\t\t\t\t\t\t{duration} min\n\t\t\t\t\t</Badge>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Location */}\n\t\t\t\t{job.location?.address?.street && (\n\t\t\t\t\t<div className=\"text-muted-foreground flex items-start gap-1.5 text-xs\">\n\t\t\t\t\t\t<MapPin className=\"mt-0.5 size-3.5 shrink-0\" />\n\t\t\t\t\t\t<span className=\"line-clamp-1\">{job.location.address.street}</span>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t{/* Priority indicator */}\n\t\t\t\t{job.priority === \"urgent\" && (\n\t\t\t\t\t<Badge className=\"text-[9px]\" variant=\"destructive\">\n\t\t\t\t\t\tURGENT\n\t\t\t\t\t</Badge>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t);\n}, (prev, next) => {\n\t// Only re-render if job ID changes, isDragOverlay changes, or key job fields change\n\treturn prev.job.id === next.job.id &&\n\t\tprev.isDragOverlay === next.isDragOverlay &&\n\t\tprev.job.status === next.job.status &&\n\t\tprev.job.title === next.job.title;\n});\n\nexport function UnassignedPanel({\n\tunassignedJobs = [],\n\tisOpen,\n\tonToggle,\n\tdropId = \"unassigned-dropzone\",\n\tactiveJobId,\n\tsearchQuery = \"\",\n\tonSearchChange,\n\tonLoadMore,\n\thasMore = false,\n\tisLoadingMore = false,\n\ttotalCount,\n}: {\n\tunassignedJobs: Job[];\n\tisOpen: boolean;\n\tonToggle: () => void;\n\tdropId?: string;\n\tactiveJobId: string | null;\n\tsearchQuery?: string;\n\tonSearchChange?: (value: string) => void;\n\tonLoadMore?: () => void;\n\thasMore?: boolean;\n\tisLoadingMore?: boolean;\n\ttotalCount?: number;\n}) {\n\tconst { setNodeRef, isOver } = useDroppable({\n\t\tid: dropId,\n\t});\n\n\tconst rawJobs = Array.isArray(unassignedJobs) ? unassignedJobs : [];\n\tconst activeJob = rawJobs.find((job) => job.id === activeJobId);\n\tconst [searchValue, setSearchValue] = useState(searchQuery ?? \"\");\n\tconst lastSentSearch = useRef(searchQuery ?? \"\");\n\tconst trimmedSearch = searchValue.trim();\n\n\tuseEffect(() => {\n\t\tlastSentSearch.current = searchQuery ?? \"\";\n\t\tsetSearchValue(searchQuery ?? \"\");\n\t}, [searchQuery]);\n\n\tuseEffect(() => {\n\t\tif (!onSearchChange) {\n\t\t\treturn;\n\t\t}\n\t\tconst handler = setTimeout(() => {\n\t\t\tif (trimmedSearch === (lastSentSearch.current ?? \"\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSentSearch.current = trimmedSearch;\n\t\t\tonSearchChange(trimmedSearch);\n\t\t}, 400);\n\t\treturn () => clearTimeout(handler);\n\t}, [trimmedSearch, onSearchChange]);\n\n\t// Sort jobs by time (urgent first, then by start time)\n\tconst jobs = useMemo(() => {\n\t\treturn [...rawJobs].sort((a, b) => {\n\t\t\t// Urgent jobs first\n\t\t\tif (a.priority === \"urgent\" && b.priority !== \"urgent\") return -1;\n\t\t\tif (b.priority === \"urgent\" && a.priority !== \"urgent\") return 1;\n\t\t\t// Then by start time\n\t\t\treturn new Date(a.startTime).getTime() - new Date(b.startTime).getTime();\n\t\t});\n\t}, [rawJobs]);\n\n\treturn (\n\t\t<>\n\t\t\t<Collapsible className=\"h-full\" onOpenChange={onToggle} open={isOpen}>\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"bg-card flex h-full flex-col border-r transition-colors duration-200\",\n\t\t\t\t\t\tisOver &&\n\t\t\t\t\t\t\t\"bg-red-50/80 ring-2 ring-red-500 ring-inset dark:bg-red-950/50\",\n\t\t\t\t\t)}\n\t\t\t\t\tref={setNodeRef}\n\t\t\t\t>\n\t\t\t\t\t{isOpen ? (\n\t\t\t\t\t\t// Expanded: Full panel with flex layout\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<CollapsibleTrigger asChild>\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tclassName=\"hover:bg-muted h-auto w-full shrink-0 justify-between px-4 py-3\"\n\t\t\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t<AlertCircle className=\"size-4 text-red-500\" />\n\t\t\t\t\t\t\t\t\t\t<span className=\"text-sm font-semibold\">Unscheduled</span>\n\t\t\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"bg-red-100 px-2 py-0.5 text-xs font-semibold text-red-700 dark:bg-red-950/50 dark:text-red-400\"\n\t\t\t\t\t\t\t\t\t\t\tvariant=\"secondary\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{totalCount ?? jobs.length}\n\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<ChevronLeft className=\"size-4 transition-transform\" />\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</CollapsibleTrigger>\n\n\t\t\t\t\t\t\t<div className=\"border-b px-3 py-2\">\n\t\t\t\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t\t\t\t<Search className=\"text-muted-foreground absolute top-1/2 left-2 size-4 -translate-y-1/2\" />\n\t\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\t\tclassName=\"pl-8 text-sm\"\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"Search...\"\n\t\t\t\t\t\t\t\t\t\tvalue={searchValue}\n\t\t\t\t\t\t\t\t\t\tonChange={(event) => setSearchValue(event.target.value)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName=\"flex-1 overflow-x-hidden overflow-y-auto\"\n\t\t\t\t\t\t\t\tstyle={{ minHeight: 0 }}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div className=\"space-y-2 p-3\">\n\t\t\t\t\t\t\t\t\t{jobs.length === 0 ? (\n\t\t\t\t\t\t\t\t\t\t<div className=\"rounded-lg border border-dashed p-6 text-center\">\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t{trimmedSearch\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"No jobs match this search\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"All jobs scheduled\"}\n\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t<SortableContext\n\t\t\t\t\t\t\t\t\t\t\titems={jobs.map((job) => job.id)}\n\t\t\t\t\t\t\t\t\t\t\tstrategy={verticalListSortingStrategy}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{jobs.map((job) => (\n\t\t\t\t\t\t\t\t\t\t\t\t<UnassignedJobCard job={job} key={job.id} />\n\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t</SortableContext>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t{(hasMore || isLoadingMore) && (\n\t\t\t\t\t\t\t\t<div className=\"border-t px-3 py-2\">\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\tclassName=\"w-full\"\n\t\t\t\t\t\t\t\t\t\tdisabled={isLoadingMore || !onLoadMore}\n\t\t\t\t\t\t\t\t\t\tonClick={onLoadMore}\n\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{isLoadingMore ? \"Loading...\" : \"Load more\"}\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t// Collapsed: Vertical text in sliver\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName=\"flex h-full w-12 items-center justify-center bg-red-50 transition-colors hover:bg-red-100 dark:bg-red-950/30 dark:hover:bg-red-950/50\"\n\t\t\t\t\t\t\tonClick={onToggle}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div className=\"flex rotate-180 items-center gap-3 [writing-mode:vertical-rl]\">\n\t\t\t\t\t\t\t\t<span className=\"text-sm font-bold tracking-wider text-red-700 dark:text-red-400\">\n\t\t\t\t\t\t\t\t\tUNSCHEDULED\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\tclassName=\"bg-red-600 px-2.5 py-0.5 text-xs font-semibold text-white dark:bg-red-700\"\n\t\t\t\t\t\t\t\t\tvariant=\"secondary\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{totalCount ?? jobs.length}\n\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</Collapsible>\n\n\t\t\t{/* Drag Overlay - Ghost preview */}\n\t\t\t<DragOverlay dropAnimation={null}>\n\t\t\t\t{activeJob ? <UnassignedJobCard isDragOverlay job={activeJob} /> : null}\n\t\t\t</DragOverlay>\n\t\t</>\n\t);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4778, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/components/schedule/monthly-view.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n\tDndContext,\n\ttype DragEndEvent,\n\tDragOverlay,\n\ttype DragStartEvent,\n\tMouseSensor,\n\tTouchSensor,\n\tuseDraggable,\n\tuseDroppable,\n\tuseSensor,\n\tuseSensors,\n} from \"@dnd-kit/core\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport {\n\taddDays,\n\tendOfMonth,\n\tendOfWeek,\n\tformat,\n\tisSameDay,\n\tisSameMonth,\n\tisToday,\n\tstartOfMonth,\n\tstartOfWeek,\n} from \"date-fns\";\nimport {\n\tArchive,\n\tCalendar,\n\tCheckCircle,\n\tCheckCircle2,\n\tCopy,\n\tExternalLink,\n\tMapPin,\n\tNavigation,\n\tTruck,\n\tUserCheck,\n\tXCircle,\n} from \"lucide-react\";\nimport { useRouter } from \"next/navigation\";\nimport { memo, useCallback, useMemo, useState } from \"react\";\nimport { toast } from \"sonner\";\nimport { updateAppointmentTimes } from \"@/actions/schedule-assignments\";\nimport { Avatar, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScheduleJobContextMenu } from \"./schedule-job-context-menu\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n\tPopoverContent,\n\tPopover as PopoverRoot,\n\tPopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { StandardFormField } from \"@/components/ui/standard-form-field\";\nimport {\n\tTooltip,\n\tTooltipContent,\n\tTooltipProvider,\n\tTooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { useSchedule } from \"@/hooks/use-schedule\";\nimport { useScheduleViewStore } from \"@/lib/stores/schedule-view-store\";\nimport { cn } from \"@/lib/utils\";\nimport { ScheduleCommandMenu } from \"./schedule-command-menu\";\nimport {\n\tQuickAppointmentDialog,\n\ttype TechnicianOption,\n} from \"./quick-appointment-dialog\";\nimport type { Job } from \"./schedule-types\";\nimport { UnassignedPanel } from \"./unassigned-panel\";\n\nconst WEEKDAYS = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\n// Job status color mapping\nconst getStatusColor = (status: Job[\"status\"]) => {\n\tswitch (status) {\n\t\tcase \"scheduled\":\n\t\t\treturn \"bg-blue-500\";\n\t\tcase \"dispatched\":\n\t\t\treturn \"bg-sky-500\";\n\t\tcase \"arrived\":\n\t\t\treturn \"bg-emerald-400\";\n\t\tcase \"in-progress\":\n\t\t\treturn \"bg-amber-500 animate-pulse\";\n\t\tcase \"closed\":\n\t\t\treturn \"bg-emerald-600\";\n\t\tcase \"completed\":\n\t\t\treturn \"bg-emerald-600\";\n\t\tcase \"cancelled\":\n\t\t\treturn \"bg-slate-400\";\n\t\tdefault:\n\t\t\treturn \"bg-slate-500\";\n\t}\n};\n\n// Job type color mapping\nconst getJobTypeColor = (job: Job) => {\n\tconst title = job.title.toLowerCase();\n\n\tif (title.includes(\"emergency\") || title.includes(\"urgent\")) {\n\t\treturn \"border-red-400 dark:border-red-700\";\n\t}\n\n\tif (\n\t\ttitle.includes(\"callback\") ||\n\t\ttitle.includes(\"follow-up\") ||\n\t\ttitle.includes(\"followup\")\n\t) {\n\t\treturn \"border-orange-400 dark:border-orange-700\";\n\t}\n\n\tif (\n\t\ttitle.includes(\"meeting\") ||\n\t\ttitle.includes(\"event\") ||\n\t\ttitle.includes(\"training\")\n\t) {\n\t\treturn \"border-purple-400 dark:border-purple-700\";\n\t}\n\n\tif (\n\t\ttitle.includes(\"install\") ||\n\t\ttitle.includes(\"setup\") ||\n\t\ttitle.includes(\"new\")\n\t) {\n\t\treturn \"border-green-400 dark:border-green-700\";\n\t}\n\n\tif (title.includes(\"service\") || title.includes(\"maintenance\")) {\n\t\treturn \"border-blue-400 dark:border-blue-700\";\n\t}\n\n\treturn \"border-slate-300 dark:border-slate-700\";\n};\n\n// Compact job pill with tooltip details\nconst MonthlyJobPill = memo(function MonthlyJobPill({\n\tjob,\n\tisDragOverlay = false,\n\tisSelected = false,\n\tonSelect,\n}: {\n\tjob: Job;\n\tisDragOverlay?: boolean;\n\tisSelected?: boolean;\n\tonSelect?: (jobId: string, shiftKey: boolean) => void;\n}) {\n\tconst router = useRouter();\n\tconst [, setIsContextMenuOpen] = useState(false);\n\tconst [isEditOpen, setIsEditOpen] = useState(false);\n\tconst [editStartTime, setEditStartTime] = useState(\"\");\n\tconst [editEndTime, setEditEndTime] = useState(\"\");\n\tconst { attributes, listeners, setNodeRef, transform, isDragging } =\n\t\tuseDraggable({\n\t\t\tid: job.id,\n\t\t\tdata: { job },\n\t\t});\n\n\tconst style = {\n\t\ttransform: CSS.Translate.toString(transform),\n\t};\n\n\tconst startTime =\n\t\tjob.startTime instanceof Date ? job.startTime : new Date(job.startTime);\n\tconst endTime =\n\t\tjob.endTime instanceof Date ? job.endTime : new Date(job.endTime);\n\n\tconst handleOpenEdit = () => {\n\t\tsetEditStartTime(format(startTime, \"HH:mm\"));\n\t\tsetEditEndTime(format(endTime, \"HH:mm\"));\n\t\tsetIsEditOpen(true);\n\t};\n\n\tconst handleSaveEdit = async () => {\n\t\tconst [startHours, startMinutes] = editStartTime.split(\":\").map(Number);\n\t\tconst [endHours, endMinutes] = editEndTime.split(\":\").map(Number);\n\n\t\tconst newStartTime = new Date(startTime);\n\t\tnewStartTime.setHours(startHours, startMinutes, 0, 0);\n\n\t\tconst newEndTime = new Date(endTime);\n\t\tnewEndTime.setHours(endHours, endMinutes, 0, 0);\n\n\t\tconst toastId = toast.loading(\"Updating appointment times...\");\n\t\tconst result = await updateAppointmentTimes(\n\t\t\tjob.id,\n\t\t\tnewStartTime,\n\t\t\tnewEndTime,\n\t\t);\n\n\t\tif (result.success) {\n\t\t\ttoast.success(\"Times updated\", { id: toastId });\n\t\t\tsetIsEditOpen(false);\n\t\t} else {\n\t\t\ttoast.error(result.error || \"Failed to update times\", { id: toastId });\n\t\t}\n\t};\n\n\tconst handleAction = async (\n\t\taction: string,\n\t\tactionFn: (id: string) => Promise<{ success: boolean; error?: string }>,\n\t) => {\n\t\tconst toastId = toast.loading(`${action}...`);\n\t\tconst result = await actionFn(job.id);\n\n\t\tif (result.success) {\n\t\t\ttoast.success(`${action} successful`, { id: toastId });\n\t\t} else {\n\t\t\ttoast.error(result.error || `Failed to ${action.toLowerCase()}`, {\n\t\t\t\tid: toastId,\n\t\t\t});\n\t\t}\n\t};\n\n\t// Get status icon\n\tconst getStatusIcon = () => {\n\t\tswitch (job.status) {\n\t\t\tcase \"dispatched\":\n\t\t\t\treturn <Truck className=\"size-3\" />;\n\t\t\tcase \"arrived\":\n\t\t\t\treturn <Navigation className=\"size-3\" />;\n\t\t\tcase \"closed\":\n\t\t\t\treturn <CheckCircle className=\"size-3\" />;\n\t\t\tcase \"completed\":\n\t\t\t\treturn <CheckCircle2 className=\"size-3\" />;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t};\n\n\tconst pillContent = (\n\t\t<button\n\t\t\tref={setNodeRef}\n\t\t\tstyle={style}\n\t\t\t{...attributes}\n\t\t\t{...listeners}\n\t\t\tclassName={cn(\n\t\t\t\t\"group bg-background relative flex w-full cursor-grab items-center gap-1.5 rounded-full border-2 px-2.5 py-1.5 text-left text-xs font-medium shadow-sm transition-all hover:shadow-md active:cursor-grabbing\",\n\t\t\t\tgetJobTypeColor(job),\n\t\t\t\tisDragging && !isDragOverlay && \"opacity-30\",\n\t\t\t\tisDragOverlay && \"ring-primary cursor-grabbing shadow-xl ring-2\",\n\t\t\t\tisSelected && \"ring-primary ring-2 ring-offset-1\",\n\t\t\t)}\n\t\t\tonClick={(event) => {\n\t\t\t\tif (event.shiftKey && onSelect) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tonSelect(job.id, true);\n\t\t\t\t} else if (!event.shiftKey) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\thandleOpenEdit();\n\t\t\t\t}\n\t\t\t}}\n\t\t\ttype=\"button\"\n\t\t>\n\t\t\t{/* Status Icon or Dot */}\n\t\t\t{getStatusIcon() ? (\n\t\t\t\t<div className={cn(\"shrink-0\", getStatusColor(job.status))}>\n\t\t\t\t\t{getStatusIcon()}\n\t\t\t\t</div>\n\t\t\t) : (\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"size-1.5 shrink-0 rounded-full\",\n\t\t\t\t\t\tgetStatusColor(job.status),\n\t\t\t\t\t)}\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t{/* Time */}\n\t\t\t<span className=\"shrink-0 text-[10px] font-medium\">\n\t\t\t\t{format(startTime, \"h:mm a\")}\n\t\t\t</span>\n\n\t\t\t{/* Customer Name */}\n\t\t\t<span className=\"truncate text-[11px] font-semibold\">\n\t\t\t\t{job.customer?.name || \"Unknown\"}\n\t\t\t</span>\n\n\t\t\t{/* Mini Technician Avatars */}\n\t\t\t{job.assignments.length > 0 && (\n\t\t\t\t<div className=\"ml-auto flex shrink-0 -space-x-1\">\n\t\t\t\t\t{job.assignments.slice(0, 2).map((tech, idx) => (\n\t\t\t\t\t\t<Avatar\n\t\t\t\t\t\t\tclassName=\"border-background size-4 border\"\n\t\t\t\t\t\t\tkey={tech.technicianId || idx}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<AvatarFallback className=\"text-[8px]\">\n\t\t\t\t\t\t\t\t{tech.displayName?.slice(0, 2).toUpperCase() || \"?\"}\n\t\t\t\t\t\t\t</AvatarFallback>\n\t\t\t\t\t\t</Avatar>\n\t\t\t\t\t))}\n\t\t\t\t\t{job.assignments.length > 2 && (\n\t\t\t\t\t\t<div className=\"border-background bg-muted flex size-4 items-center justify-center rounded-full border text-[7px] font-medium\">\n\t\t\t\t\t\t\t+{job.assignments.length - 2}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</button>\n\t);\n\n\tconst tooltipContent = (\n\t\t<div className=\"space-y-2\">\n\t\t\t<div>\n\t\t\t\t<p className=\"text-sm font-semibold\">\n\t\t\t\t\t{job.customer?.name || \"Unknown Customer\"}\n\t\t\t\t</p>\n\t\t\t\t<p className=\"text-muted-foreground text-xs\">{job.title}</p>\n\t\t\t</div>\n\t\t\t<div className=\"space-y-1 text-xs\">\n\t\t\t\t<p>\n\t\t\t\t\t<span className=\"font-medium\">Time:</span>{\" \"}\n\t\t\t\t\t{format(startTime, \"h:mm a\")} - {format(endTime, \"h:mm a\")}\n\t\t\t\t</p>\n\t\t\t\t{job.location?.address?.street && (\n\t\t\t\t\t<p>\n\t\t\t\t\t\t<span className=\"font-medium\">Location:</span>{\" \"}\n\t\t\t\t\t\t{job.location.address.street}\n\t\t\t\t\t</p>\n\t\t\t\t)}\n\t\t\t\t{job.assignments.length > 0 && (\n\t\t\t\t\t<p>\n\t\t\t\t\t\t<span className=\"font-medium\">Team:</span>{\" \"}\n\t\t\t\t\t\t{job.assignments.map((a) => a.displayName).join(\", \")}\n\t\t\t\t\t</p>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t);\n\n\tif (isDragOverlay) {\n\t\treturn pillContent;\n\t}\n\n\tconst startInputId = `monthly-start-${job.id}`;\n\tconst endInputId = `monthly-end-${job.id}`;\n\n\treturn (\n\t\t<PopoverRoot onOpenChange={setIsEditOpen} open={isEditOpen}>\n\t\t\t<TooltipProvider>\n\t\t\t\t<Tooltip delayDuration={200}>\n\t\t\t\t\t<ScheduleJobContextMenu job={job} onOpenChange={setIsContextMenuOpen}>\n\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t<PopoverTrigger asChild>\n\t\t\t\t\t\t\t\t{pillContent}\n\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t</ScheduleJobContextMenu>\n\t\t\t\t\t<TooltipContent className=\"max-w-xs\" side=\"top\">\n\t\t\t\t\t\t{tooltipContent}\n\t\t\t\t\t</TooltipContent>\n\t\t\t\t</Tooltip>\n\t\t\t</TooltipProvider>\n\n\t\t\t<PopoverContent align=\"start\" className=\"w-80\">\n\t\t\t\t<div className=\"space-y-4\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 className=\"text-sm font-semibold\">Quick Edit Times</h4>\n\t\t\t\t\t\t<p className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t{job.customer?.name || \"Unknown Customer\"}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div className=\"grid gap-3\">\n\t\t\t\t\t\t<StandardFormField label=\"Start Time\" htmlFor={startInputId}>\n\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\tid={startInputId}\n\t\t\t\t\t\t\t\tonChange={(e) => setEditStartTime(e.target.value)}\n\t\t\t\t\t\t\t\ttype=\"time\"\n\t\t\t\t\t\t\t\tvalue={editStartTime}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</StandardFormField>\n\n\t\t\t\t\t\t<StandardFormField label=\"End Time\" htmlFor={endInputId}>\n\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\tid={endInputId}\n\t\t\t\t\t\t\t\tonChange={(e) => setEditEndTime(e.target.value)}\n\t\t\t\t\t\t\t\ttype=\"time\"\n\t\t\t\t\t\t\t\tvalue={editEndTime}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</StandardFormField>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div className=\"flex gap-2\">\n\t\t\t\t\t\t<Button className=\"flex-1\" onClick={handleSaveEdit} size=\"sm\">\n\t\t\t\t\t\t\tSave\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tclassName=\"flex-1\"\n\t\t\t\t\t\t\tonClick={() => setIsEditOpen(false)}\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tCancel\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</PopoverContent>\n\t\t</PopoverRoot>\n\t);\n});\n\nconst DayCell = memo(function DayCell({\n\tdate,\n\tjobs,\n\tisCurrentMonth,\n\tisSelectedDate,\n\tselectedJobIds,\n\tonJobSelect,\n\tonOpenCommandMenu,\n\tonDoubleClick,\n}: {\n\tdate: Date;\n\tjobs: Job[];\n\tisCurrentMonth: boolean;\n\tisSelectedDate: boolean;\n\tselectedJobIds?: Set<string>;\n\tonJobSelect?: (jobId: string, shiftKey: boolean) => void;\n\tonOpenCommandMenu?: (date: Date) => void;\n\tonDoubleClick?: (date: Date) => void;\n}) {\n\tconst { setNodeRef, isOver } = useDroppable({\n\t\tid: `day-${date.toISOString()}`,\n\t\tdata: { date },\n\t});\n\n\tconst isCurrentDay = isToday(date);\n\tconst hasJobs = jobs.length > 0;\n\n\tconst handleContextMenu = (e: React.MouseEvent) => {\n\t\te.preventDefault();\n\t\tonOpenCommandMenu?.(date);\n\t};\n\n\tconst handleDoubleClick = (e: React.MouseEvent) => {\n\t\t// Don't trigger if double-clicking on a job pill\n\t\tif ((e.target as HTMLElement).closest(\"[data-job-pill]\")) return;\n\t\tonDoubleClick?.(date);\n\t};\n\n\t// Calculate day metrics\n\tconst totalHours = useMemo(\n\t\t() =>\n\t\t\tjobs.reduce((sum, job) => {\n\t\t\t\tconst start =\n\t\t\t\t\tjob.startTime instanceof Date\n\t\t\t\t\t\t? job.startTime\n\t\t\t\t\t\t: new Date(job.startTime);\n\t\t\t\tconst end =\n\t\t\t\t\tjob.endTime instanceof Date ? job.endTime : new Date(job.endTime);\n\t\t\t\treturn sum + (end.getTime() - start.getTime()) / (1000 * 60 * 60);\n\t\t\t}, 0),\n\t\t[jobs],\n\t);\n\n\tconst isWeekend = date.getDay() === 0 || date.getDay() === 6;\n\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t\"border-border/50 relative flex h-[140px] cursor-context-menu flex-col border p-3 transition-all duration-200\",\n\t\t\t\t!isCurrentMonth && \"bg-muted/50 opacity-60\",\n\t\t\t\tisOver && \"bg-primary/10 ring-primary ring-2 ring-inset\",\n\t\t\t\tisCurrentDay &&\n\t\t\t\t\t\"bg-blue-50 ring-2 ring-blue-500/30 dark:bg-blue-950/30\",\n\t\t\t\tisSelectedDate &&\n\t\t\t\t\t!isCurrentDay &&\n\t\t\t\t\t\"bg-emerald-50 ring-2 ring-emerald-500/50 dark:bg-emerald-950/30\",\n\t\t\t\tisWeekend && !isCurrentDay && \"bg-slate-100/80 dark:bg-slate-800/30\",\n\t\t\t)}\n\t\t\tonContextMenu={handleContextMenu}\n\t\t\tonDoubleClick={handleDoubleClick}\n\t\t\tref={setNodeRef}\n\t\t>\n\t\t\t{/* Date Number & Metrics */}\n\t\t\t<div className=\"group/header mb-2 flex shrink-0 items-center justify-between gap-2\">\n\t\t\t\t<TooltipProvider>\n\t\t\t\t\t<Tooltip delayDuration={300}>\n\t\t\t\t\t\t<TooltipTrigger asChild>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\"flex size-7 items-center justify-center rounded-full text-base font-bold transition-all\",\n\t\t\t\t\t\t\t\t\tisCurrentDay && \"bg-blue-500 text-white shadow-md\",\n\t\t\t\t\t\t\t\t\tisSelectedDate &&\n\t\t\t\t\t\t\t\t\t\t!isCurrentDay &&\n\t\t\t\t\t\t\t\t\t\t\"bg-emerald-500 text-white shadow-md\",\n\t\t\t\t\t\t\t\t\t!(isCurrentDay || isSelectedDate || isCurrentMonth) &&\n\t\t\t\t\t\t\t\t\t\t\"text-muted-foreground/60\",\n\t\t\t\t\t\t\t\t\t!(isCurrentDay || isSelectedDate) &&\n\t\t\t\t\t\t\t\t\t\tisCurrentMonth &&\n\t\t\t\t\t\t\t\t\t\t\"text-foreground\",\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{format(date, \"d\")}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t\t{hasJobs && (\n\t\t\t\t\t\t\t<TooltipContent className=\"w-64\" side=\"top\">\n\t\t\t\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t\t\t\t<div className=\"flex items-center justify-between border-b pb-2\">\n\t\t\t\t\t\t\t\t\t\t<p className=\"text-sm font-semibold\">\n\t\t\t\t\t\t\t\t\t\t\t{format(date, \"EEEE, MMM d\")}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t<Badge variant=\"secondary\">{jobs.length} jobs</Badge>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div className=\"space-y-1 text-xs\">\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex justify-between\">\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t\tTotal Hours:\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t{totalHours.toFixed(1)}h\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex justify-between\">\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground\">\n\t\t\t\t\t\t\t\t\t\t\t\tAvg Duration:\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-medium\">\n\t\t\t\t\t\t\t\t\t\t\t\t{(totalHours / jobs.length).toFixed(1)}h\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div className=\"mt-2 space-y-1 border-t pt-2\">\n\t\t\t\t\t\t\t\t\t\t\t<p className=\"text-xs font-medium\">Status Breakdown:</p>\n\t\t\t\t\t\t\t\t\t\t\t{Object.entries(\n\t\t\t\t\t\t\t\t\t\t\t\tjobs.reduce(\n\t\t\t\t\t\t\t\t\t\t\t\t\t(acc, job) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tacc[job.status || \"scheduled\"] =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(acc[job.status || \"scheduled\"] || 0) + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{} as Record<string, number>,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t).map(([status, count]) => (\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"flex justify-between\" key={status}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"text-muted-foreground capitalize\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{status}:\n\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span className=\"font-medium\">{count}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</TooltipContent>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</TooltipProvider>\n\n\t\t\t\t{/* Day Metrics Badge */}\n\t\t\t\t{hasJobs && (\n\t\t\t\t\t<Badge\n\t\t\t\t\t\tclassName=\"h-5 px-2 text-[10px] font-semibold\"\n\t\t\t\t\t\tvariant=\"secondary\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{jobs.length} jobs  {totalHours.toFixed(1)}h\n\t\t\t\t\t</Badge>\n\t\t\t\t)}\n\t\t\t</div>\n\n\t\t\t{/* Drop Zone Indicator */}\n\t\t\t{isOver && (\n\t\t\t\t<div className=\"pointer-events-none absolute inset-0 z-10 flex items-center justify-center\">\n\t\t\t\t\t<div className=\"fade-in zoom-in-95 animate-in bg-primary text-primary-foreground rounded-lg px-3 py-1.5 text-xs font-semibold shadow-lg duration-200\">\n\t\t\t\t\t\tDrop to schedule\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{/* Jobs - Scrollable Pills */}\n\t\t\t<div className=\"flex-1 space-y-0.5 overflow-x-hidden overflow-y-auto\">\n\t\t\t\t{jobs.map((job) => (\n\t\t\t\t\t<MonthlyJobPill\n\t\t\t\t\t\tisSelected={selectedJobIds?.has(job.id)}\n\t\t\t\t\t\tjob={job}\n\t\t\t\t\t\tkey={job.id}\n\t\t\t\t\t\tonSelect={onJobSelect}\n\t\t\t\t\t/>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t</div>\n\t);\n});\n\nexport function MonthlyView() {\n\tconst [activeJobId, setActiveJobId] = useState<string | null>(null);\n\tconst [unassignedPanelOpen, setUnassignedPanelOpen] = useState(false);\n\tconst [selectedJobIds, setSelectedJobIds] = useState<Set<string>>(new Set());\n\tconst [commandMenuOpen, setCommandMenuOpen] = useState(false);\n\tconst [commandMenuDate, setCommandMenuDate] = useState<Date | null>(null);\n\tconst [showQuickAppointment, setShowQuickAppointment] = useState(false);\n\tconst [quickAppointmentDate, setQuickAppointmentDate] = useState<Date | null>(null);\n\tconst { currentDate } = useScheduleViewStore();\n\n\t// Multi-select handler\n\tconst handleJobSelect = useCallback((jobId: string, shiftKey: boolean) => {\n\t\tsetSelectedJobIds((prev) => {\n\t\t\tconst newSet = new Set(prev);\n\t\t\tif (shiftKey) {\n\t\t\t\t// Toggle selection\n\t\t\t\tif (newSet.has(jobId)) {\n\t\t\t\t\tnewSet.delete(jobId);\n\t\t\t\t} else {\n\t\t\t\t\tnewSet.add(jobId);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Single select (clear others)\n\t\t\t\tnewSet.clear();\n\t\t\t\tnewSet.add(jobId);\n\t\t\t}\n\t\t\treturn newSet;\n\t\t});\n\t}, []);\n\n\t// Command menu handler\n\tconst handleOpenCommandMenu = useCallback((date: Date) => {\n\t\tsetCommandMenuDate(date);\n\t\tsetCommandMenuOpen(true);\n\t}, []);\n\n\t// Quick appointment handler (double-click on day)\n\tconst handleDayDoubleClick = useCallback((date: Date) => {\n\t\t// Set default time to 9 AM on the clicked date\n\t\tconst appointmentDate = new Date(date);\n\t\tappointmentDate.setHours(9, 0, 0, 0);\n\t\tsetQuickAppointmentDate(appointmentDate);\n\t\tsetShowQuickAppointment(true);\n\t}, []);\n\n\tconst {\n\t\tgetAllJobs,\n\t\tmoveJob,\n\t\tisLoading,\n\t\tloadMoreUnassignedJobs,\n\t\tunassignedHasMore,\n\t\tunassignedSearch,\n\t\tisLoadingUnassigned,\n\t\tunassignedTotalCount,\n\t} = useSchedule();\n\n\tconst sensors = useSensors(\n\t\tuseSensor(MouseSensor, {\n\t\t\tactivationConstraint: { distance: 8 },\n\t\t}),\n\t\tuseSensor(TouchSensor, {\n\t\t\tactivationConstraint: { delay: 200, tolerance: 6 },\n\t\t}),\n\t);\n\n\tconst dateObj = useMemo(\n\t\t() => (currentDate instanceof Date ? currentDate : new Date(currentDate)),\n\t\t[currentDate],\n\t);\n\n\t// Generate calendar grid\n\tconst calendarDays = useMemo(() => {\n\t\tconst monthStart = startOfMonth(dateObj);\n\t\tconst monthEnd = endOfMonth(dateObj);\n\t\tconst calendarStart = startOfWeek(monthStart);\n\t\tconst calendarEnd = endOfWeek(monthEnd);\n\n\t\tconst days: Date[] = [];\n\t\tlet currentDay = calendarStart;\n\n\t\twhile (currentDay <= calendarEnd) {\n\t\t\tdays.push(currentDay);\n\t\t\tcurrentDay = addDays(currentDay, 1);\n\t\t}\n\n\t\treturn days;\n\t}, [dateObj]);\n\n\t// Group jobs by date and separate unassigned\n\tconst { jobsByDate, unassignedJobs } = useMemo(() => {\n\t\tconst allJobs = getAllJobs();\n\t\tconst grouped = new Map<string, Job[]>();\n\t\tconst unassigned: Job[] = [];\n\n\t\tfor (const job of allJobs) {\n\t\t\t// If no technician assigned, it's unscheduled\n\t\t\tif (!job.technicianId) {\n\t\t\t\tunassigned.push(job);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startTime =\n\t\t\t\tjob.startTime instanceof Date ? job.startTime : new Date(job.startTime);\n\t\t\tconst dateKey = format(startTime, \"yyyy-MM-dd\");\n\n\t\t\tif (!grouped.has(dateKey)) {\n\t\t\t\tgrouped.set(dateKey, []);\n\t\t\t}\n\t\t\tgrouped.get(dateKey)?.push(job);\n\t\t}\n\n\t\treturn { jobsByDate: grouped, unassignedJobs: unassigned };\n\t}, [getAllJobs]);\n\tconst showUnassignedPanel =\n\t\tunassignedJobs.length > 0 ||\n\t\tunassignedHasMore ||\n\t\tunassignedSearch.length > 0;\n\n\tconst handleDragStart = useCallback((event: DragStartEvent) => {\n\t\tsetActiveJobId(event.active.id as string);\n\t}, []);\n\n\tconst handleDragEnd = useCallback(\n\t\tasync (event: DragEndEvent) => {\n\t\t\tconst { active, over } = event;\n\n\t\t\tsetActiveJobId(null);\n\n\t\t\tif (!over) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst jobId = active.id as string;\n\t\t\tconst dropData = over.data.current as { date: Date } | undefined;\n\n\t\t\tif (!dropData?.date) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst allJobs = getAllJobs();\n\t\t\tconst job = allJobs.find((j) => j.id === jobId);\n\n\t\t\tif (!job) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst oldStart =\n\t\t\t\tjob.startTime instanceof Date ? job.startTime : new Date(job.startTime);\n\t\t\tconst oldEnd =\n\t\t\t\tjob.endTime instanceof Date ? job.endTime : new Date(job.endTime);\n\t\t\tconst duration = oldEnd.getTime() - oldStart.getTime();\n\n\t\t\t// Create new start time on the dropped date, keeping the same time of day\n\t\t\tconst newStart = new Date(dropData.date);\n\t\t\tnewStart.setHours(oldStart.getHours(), oldStart.getMinutes(), 0, 0);\n\t\t\tconst newEnd = new Date(newStart.getTime() + duration);\n\n\t\t\t// Optimistic update\n\t\t\tmoveJob(jobId, job.technicianId, newStart, newEnd);\n\n\t\t\tconst toastId = toast.loading(\n\t\t\t\t`Moving to ${format(dropData.date, \"MMM d\")}...`,\n\t\t\t);\n\n\t\t\tconst result = await updateAppointmentTimes(jobId, newStart, newEnd);\n\n\t\t\tif (result.success) {\n\t\t\t\ttoast.success(`Moved to ${format(dropData.date, \"MMM d\")}`, {\n\t\t\t\t\tid: toastId,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttoast.error(result.error || \"Failed to move appointment\", {\n\t\t\t\t\tid: toastId,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[getAllJobs, moveJob],\n\t);\n\n\tconst activeJob = useMemo(() => {\n\t\tif (!activeJobId) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getAllJobs().find((j) => j.id === activeJobId);\n\t}, [activeJobId, getAllJobs]);\n\n\tconst handleUnassignedSearch = useCallback(\n\t\t(value: string) => {\n\t\t\tloadMoreUnassignedJobs({ reset: true, search: value });\n\t\t},\n\t\t[loadMoreUnassignedJobs],\n\t);\n\n\tconst handleLoadMoreUnassigned = useCallback(() => {\n\t\tloadMoreUnassignedJobs({ search: unassignedSearch });\n\t}, [loadMoreUnassignedJobs, unassignedSearch]);\n\n\tif (isLoading) {\n\t\treturn (\n\t\t\t<div className=\"flex h-full w-full items-center justify-center\">\n\t\t\t\t<div className=\"text-muted-foreground\">Loading schedule...</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<DndContext\n\t\t\tonDragEnd={handleDragEnd}\n\t\t\tonDragStart={handleDragStart}\n\t\t\tsensors={sensors}\n\t\t>\n\t\t\t<div className=\"flex h-full overflow-hidden\">\n\t\t\t\t{/* Unscheduled Panel */}\n\t\t\t\t{showUnassignedPanel && (\n\t\t\t\t\t<UnassignedPanel\n\t\t\t\t\t\tactiveJobId={activeJobId}\n\t\t\t\t\t\thasMore={unassignedHasMore}\n\t\t\t\t\t\tisLoadingMore={isLoadingUnassigned}\n\t\t\t\t\t\tisOpen={unassignedPanelOpen}\n\t\t\t\t\t\tonLoadMore={handleLoadMoreUnassigned}\n\t\t\t\t\t\tonSearchChange={handleUnassignedSearch}\n\t\t\t\t\t\tonToggle={() => setUnassignedPanelOpen(!unassignedPanelOpen)}\n\t\t\t\t\t\tsearchQuery={unassignedSearch}\n\t\t\t\t\t\ttotalCount={unassignedTotalCount}\n\t\t\t\t\t\tunassignedJobs={unassignedJobs}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\n\t\t\t\t{/* Calendar Grid */}\n\t\t\t\t<div className=\"flex flex-1 flex-col overflow-hidden\">\n\t\t\t\t\t<div className=\"flex-1 overflow-auto\">\n\t\t\t\t\t\t<div className=\"grid min-h-full grid-cols-7\">\n\t\t\t\t\t\t\t{/* Weekday Headers */}\n\t\t\t\t\t\t\t{WEEKDAYS.map((day, idx) => (\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t\"bg-muted/50 sticky top-0 z-30 border-r border-b-2 px-4 py-3 text-center text-sm font-bold tracking-wide uppercase shadow-sm backdrop-blur-sm\",\n\t\t\t\t\t\t\t\t\t\t(idx === 0 || idx === 6) &&\n\t\t\t\t\t\t\t\t\t\t\t\"bg-slate-200/80 dark:bg-slate-700/50\",\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\tkey={day}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{day}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t))}\n\n\t\t\t\t\t\t\t{/* Day Cells - Fixed Height Rows */}\n\t\t\t\t\t\t\t{calendarDays.map((date, idx) => {\n\t\t\t\t\t\t\t\tconst dateKey = format(date, \"yyyy-MM-dd\");\n\t\t\t\t\t\t\t\tconst jobs = jobsByDate.get(dateKey) || [];\n\t\t\t\t\t\t\t\tconst isCurrentMonth = isSameMonth(date, dateObj);\n\t\t\t\t\t\t\t\tconst isSelectedDate = isSameDay(date, dateObj);\n\t\t\t\t\t\t\t\tconst _rowIndex = Math.floor(idx / 7);\n\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<DayCell\n\t\t\t\t\t\t\t\t\t\tdate={date}\n\t\t\t\t\t\t\t\t\t\tisCurrentMonth={isCurrentMonth}\n\t\t\t\t\t\t\t\t\t\tisSelectedDate={isSelectedDate}\n\t\t\t\t\t\t\t\t\t\tjobs={jobs}\n\t\t\t\t\t\t\t\t\t\tkey={date.toISOString()}\n\t\t\t\t\t\t\t\t\t\tonDoubleClick={handleDayDoubleClick}\n\t\t\t\t\t\t\t\t\t\tonJobSelect={handleJobSelect}\n\t\t\t\t\t\t\t\t\t\tonOpenCommandMenu={handleOpenCommandMenu}\n\t\t\t\t\t\t\t\t\t\tselectedJobIds={selectedJobIds}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t{/* Command Menu */}\n\t\t\t<ScheduleCommandMenu\n\t\t\t\tisOpen={commandMenuOpen}\n\t\t\t\tonClose={() => setCommandMenuOpen(false)}\n\t\t\t\tselectedDate={commandMenuDate}\n\t\t\t\tunassignedJobs={unassignedJobs}\n\t\t\t/>\n\n\t\t\t{/* Quick Appointment Dialog */}\n\t\t\t<QuickAppointmentDialog\n\t\t\t\topen={showQuickAppointment}\n\t\t\t\tonOpenChange={setShowQuickAppointment}\n\t\t\t\tdefaultDateTime={quickAppointmentDate || undefined}\n\t\t\t\tonSuccess={() => {\n\t\t\t\t\tsetShowQuickAppointment(false);\n\t\t\t\t\ttoast.success(\"Appointment created\");\n\t\t\t\t}}\n\t\t\t/>\n\n\t\t\t{/* Drag Overlay with Enhanced Visual */}\n\t\t\t<DragOverlay\n\t\t\t\tdropAnimation={{\n\t\t\t\t\tduration: 200,\n\t\t\t\t\teasing: \"cubic-bezier(0.18, 0.67, 0.6, 1.22)\",\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{activeJob ? (\n\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t{/* Drag Ghost */}\n\t\t\t\t\t\t<MonthlyJobPill isDragOverlay job={activeJob} />\n\t\t\t\t\t\t{/* Snap Guide Indicator */}\n\t\t\t\t\t\t<div className=\"pointer-events-none absolute -bottom-2 left-1/2 -translate-x-1/2\">\n\t\t\t\t\t\t\t<div className=\"bg-primary text-primary-foreground flex items-center gap-1 rounded-full px-2 py-0.5 text-[10px] shadow-lg\">\n\t\t\t\t\t\t\t\t<span>Drop to reschedule</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t</DragOverlay>\n\t\t</DndContext>\n\t);\n}\n"],"names":[],"mappings":"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"}}]
}