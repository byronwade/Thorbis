{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/customers.ts"],"sourcesContent":["/**\n * Customer Management Server Actions\n *\n * Comprehensive customer relationship management with:\n * - Customer CRUD operations\n * - Customer portal invitation and access\n * - Customer metrics tracking (revenue, jobs, invoices)\n * - Communication preferences\n * - Soft delete/archive support\n * - Customer search and filtering\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { geocodeAddressSilent } from \"@/lib/services/geocoding\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport PortalInvitationEmail from \"../../emails/templates/customer/portal-invitation\";\n\n// ============================================================================\n// VALIDATION SCHEMAS\n// ============================================================================\n\nconst CUSTOMER_NAME_MAX_LENGTH = 100;\nconst CUSTOMER_COMPANY_MAX_LENGTH = 200;\nconst CUSTOMER_PHONE_MAX_LENGTH = 20;\nconst CUSTOMER_ADDRESS_MAX_LENGTH = 200;\nconst CUSTOMER_ADDRESS2_MAX_LENGTH = 100;\nconst CUSTOMER_CITY_MAX_LENGTH = 100;\nconst CUSTOMER_STATE_MAX_LENGTH = 50;\n\n// HTTP Status codes\nconst HTTP_STATUS_FORBIDDEN = 403;\n\n// Search defaults\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst CUSTOMER_ZIP_MAX_LENGTH = 20;\nconst CUSTOMER_COUNTRY_MAX_LENGTH = 50;\nconst CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH = 50;\nconst CENTS_PER_DOLLAR = 100;\n\nfunction requireSiteUrl(): string {\n\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\tif (!siteUrl) {\n\t\tthrow new ActionError(\n\t\t\t\"NEXT_PUBLIC_SITE_URL is not configured\",\n\t\t\tERROR_CODES.INTERNAL_SERVER_ERROR,\n\t\t);\n\t}\n\treturn siteUrl.replace(/\\/$/, \"\");\n}\n\nconst customerSchema = z.object({\n\ttype: z\n\t\t.enum([\"residential\", \"commercial\", \"industrial\"])\n\t\t.default(\"residential\"),\n\tfirstName: z\n\t\t.string()\n\t\t.min(1, \"First name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tlastName: z\n\t\t.string()\n\t\t.min(1, \"Last name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tcompanyName: z.string().max(CUSTOMER_COMPANY_MAX_LENGTH).optional(),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z.string().min(1, \"Phone is required\").max(CUSTOMER_PHONE_MAX_LENGTH),\n\tsecondaryPhone: z.string().max(CUSTOMER_PHONE_MAX_LENGTH).optional(),\n\taddress: z.string().max(CUSTOMER_ADDRESS_MAX_LENGTH).optional(),\n\taddress2: z.string().max(CUSTOMER_ADDRESS2_MAX_LENGTH).optional(),\n\tcity: z.string().max(CUSTOMER_CITY_MAX_LENGTH).optional(),\n\tstate: z.string().max(CUSTOMER_STATE_MAX_LENGTH).optional(),\n\tzipCode: z.string().max(CUSTOMER_ZIP_MAX_LENGTH).optional(),\n\tcountry: z.string().max(CUSTOMER_COUNTRY_MAX_LENGTH).default(\"USA\"),\n\tsource: z\n\t\t.enum([\"referral\", \"google\", \"facebook\", \"direct\", \"yelp\", \"other\"])\n\t\t.optional(),\n\treferredBy: z.string().uuid().optional().nullable(),\n\tpreferredContactMethod: z.enum([\"email\", \"phone\", \"sms\"]).default(\"email\"),\n\tpreferredTechnician: z.string().uuid().optional().nullable(),\n\tbillingEmail: z.string().email().optional().nullable(),\n\tpaymentTerms: z\n\t\t.enum([\"due_on_receipt\", \"net_15\", \"net_30\", \"net_60\"])\n\t\t.default(\"due_on_receipt\"),\n\tcreditLimit: z.number().int().min(0).default(0), // In cents\n\ttaxExempt: z.boolean().default(false),\n\ttaxExemptNumber: z\n\t\t.string()\n\t\t.max(CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH)\n\t\t.optional(),\n\ttags: z.array(z.string()).optional(),\n\tnotes: z.string().optional(),\n\tinternalNotes: z.string().optional(),\n});\n\nconst communicationPreferencesSchema = z.object({\n\temail: z.boolean().default(true),\n\tsms: z.boolean().default(true),\n\tphone: z.boolean().default(true),\n\tmarketing: z.boolean().default(false),\n});\n\n// ============================================================================\n// CUSTOMER CRUD OPERATIONS\n// ============================================================================\n\n/**\n * Create a new customer with multiple contacts and properties\n */\nasync function createCustomer(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\t\tconst { contacts, properties, tags } =\n\t\t\tparseCustomerContactsPropertiesAndTags(formData);\n\t\tconst primaryContact = getPrimaryContactOrThrow(contacts);\n\t\tconst primaryProperty = getPrimaryProperty(properties);\n\n\t\tawait assertCustomerEmailNotDuplicate(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tprimaryContact.email,\n\t\t);\n\n\t\tconst customerType = formData.get(\"type\") || \"residential\";\n\t\tconst companyName = formData.get(\"companyName\");\n\t\tconst displayName = buildCustomerDisplayName(\n\t\t\tcustomerType,\n\t\t\tcompanyName,\n\t\t\tprimaryContact,\n\t\t);\n\n\t\tconst communicationPreferences = buildDefaultCommunicationPreferences();\n\t\tconst customerMetadata = buildCustomerMetadata(contacts);\n\n\t\tconst { lat: customerLat, lon: customerLon } =\n\t\t\tawait geocodePrimaryPropertyIfAvailable(primaryProperty);\n\n\t\tconst customer = await insertCustomerRecord(supabase, {\n\t\t\tcompanyId: teamMember.company_id,\n\t\t\tcustomerType,\n\t\t\tprimaryContact,\n\t\t\tcompanyNameValue: companyName,\n\t\t\tdisplayName,\n\t\t\tprimaryProperty,\n\t\t\tcustomerLat,\n\t\t\tcustomerLon,\n\t\t\tformData,\n\t\t\ttags,\n\t\t\tcommunicationPreferences,\n\t\t\tcustomerMetadata,\n\t\t});\n\n\t\tawait insertAdditionalPropertiesIfAny(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tcustomer.id,\n\t\t\tproperties,\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\treturn customer.id;\n\t});\n}\n\ntype ParsedCustomerContact = {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n\tphone: string;\n\trole: string;\n\tisPrimary: boolean;\n};\n\ntype ParsedCustomerProperty = {\n\tname: string;\n\taddress: string;\n\taddress2: string;\n\tcity: string;\n\tstate: string;\n\tzipCode: string;\n\tcountry: string;\n\tpropertyType: string;\n\tisPrimary: boolean;\n\tnotes: string;\n};\n\ntype ParsedCustomerFormCollections = {\n\tcontacts: ParsedCustomerContact[];\n\tproperties: ParsedCustomerProperty[];\n\ttags?: string[];\n};\n\nasync function requireCustomerCompanyMembership(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n) {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember;\n}\n\nfunction parseCustomerContactsPropertiesAndTags(\n\tformData: FormData,\n): ParsedCustomerFormCollections {\n\tconst contacts = parseContacts(formData.get(\"contacts\"));\n\tconst properties = parseProperties(formData.get(\"properties\"));\n\tconst tags = parseTagsField(formData.get(\"tags\"));\n\n\treturn { contacts, properties, tags };\n}\n\nfunction parseContacts(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerContact[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerContact[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid contacts data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseProperties(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerProperty[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerProperty[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid properties data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseTagsField(\n\tvalue: FormDataEntryValue | null,\n): string[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as string[];\n\t} catch {\n\t\treturn value.split(\",\").map((t) => t.trim());\n\t}\n}\n\nfunction getPrimaryContactOrThrow(\n\tcontacts: ParsedCustomerContact[],\n): ParsedCustomerContact {\n\tconst primaryContact = contacts.find((c) => c.isPrimary) || contacts[0];\n\tif (!primaryContact) {\n\t\tthrow new ActionError(\n\t\t\t\"At least one contact is required\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\treturn primaryContact;\n}\n\nfunction getPrimaryProperty(\n\tproperties: ParsedCustomerProperty[],\n): ParsedCustomerProperty | undefined {\n\treturn properties.find((p) => p.isPrimary) || properties[0];\n}\n\nasync function assertCustomerEmailNotDuplicate(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\temail: string,\n) {\n\tconst { data: existingEmail } = await supabase\n\t\t.from(\"customers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"email\", email)\n\t\t.is(\"deleted_at\", null)\n\t\t.single();\n\n\tif (existingEmail) {\n\t\tthrow new ActionError(\n\t\t\t\"A customer with this email already exists\",\n\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t);\n\t}\n}\n\nfunction buildCustomerDisplayName(\n\tcustomerType: FormDataEntryValue | null,\n\tcompanyNameValue: FormDataEntryValue | null,\n\tprimaryContact: ParsedCustomerContact,\n): string {\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\tif (customerType === \"commercial\" && companyName) {\n\t\treturn companyName;\n\t}\n\n\treturn `${primaryContact.firstName} ${primaryContact.lastName}`;\n}\n\nfunction buildDefaultCommunicationPreferences() {\n\treturn {\n\t\temail: true,\n\t\tsms: true,\n\t\tphone: true,\n\t\tmarketing: false,\n\t};\n}\n\nfunction buildCustomerMetadata(contacts: ParsedCustomerContact[]) {\n\treturn {\n\t\tcontacts: contacts.map((c) => ({\n\t\t\tfirstName: c.firstName,\n\t\t\tlastName: c.lastName,\n\t\t\temail: c.email,\n\t\t\tphone: c.phone,\n\t\t\trole: c.role,\n\t\t\tisPrimary: c.isPrimary,\n\t\t})),\n\t};\n}\n\nasync function geocodePrimaryPropertyIfAvailable(\n\tprimaryProperty: ParsedCustomerProperty | undefined,\n): Promise<{ lat: number | null; lon: number | null }> {\n\tif (\n\t\t!(\n\t\t\tprimaryProperty?.address &&\n\t\t\tprimaryProperty.city &&\n\t\t\tprimaryProperty.state &&\n\t\t\tprimaryProperty.zipCode\n\t\t)\n\t) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\tconst geocodeResult = await geocodeAddressSilent(\n\t\tprimaryProperty.address,\n\t\tprimaryProperty.city,\n\t\tprimaryProperty.state,\n\t\tprimaryProperty.zipCode,\n\t\tprimaryProperty.country || \"USA\",\n\t);\n\n\tif (!geocodeResult) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\treturn { lat: geocodeResult.lat, lon: geocodeResult.lon };\n}\n\ntype InsertCustomerParams = {\n\tcompanyId: string;\n\tcustomerType: FormDataEntryValue | null;\n\tprimaryContact: ParsedCustomerContact;\n\tcompanyNameValue: FormDataEntryValue | null;\n\tdisplayName: string;\n\tprimaryProperty?: ParsedCustomerProperty;\n\tcustomerLat: number | null;\n\tcustomerLon: number | null;\n\tformData: FormData;\n\ttags?: string[];\n\tcommunicationPreferences: {\n\t\temail: boolean;\n\t\tsms: boolean;\n\t\tphone: boolean;\n\t\tmarketing: boolean;\n\t};\n\tcustomerMetadata: Record<string, unknown>;\n};\n\nasync function insertCustomerRecord(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tparams: InsertCustomerParams,\n) {\n\tconst payload = buildCustomerInsertPayload(params);\n\n\tconst { data: customer, error: createError } = await supabase\n\t\t.from(\"customers\")\n\t\t.insert(payload)\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (createError || !customer) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(\"create customer\"),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn customer;\n}\n\nfunction buildCustomerInsertPayload(\n\tparams: InsertCustomerParams,\n): Record<string, unknown> {\n\tconst {\n\t\tcompanyId,\n\t\tcustomerType,\n\t\tprimaryContact,\n\t\tcompanyNameValue,\n\t\tdisplayName,\n\t\tprimaryProperty,\n\t\tcustomerLat,\n\t\tcustomerLon,\n\t\tformData,\n\t\ttags,\n\t\tcommunicationPreferences,\n\t\tcustomerMetadata,\n\t} = params;\n\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\ttype: String(customerType || \"residential\"),\n\t\tfirst_name: primaryContact.firstName,\n\t\tlast_name: primaryContact.lastName,\n\t\tcompany_name: companyName,\n\t\tdisplay_name: displayName,\n\t\temail: primaryContact.email,\n\t\tphone: primaryContact.phone,\n\t\tsecondary_phone: null,\n\t\taddress: primaryProperty?.address || null,\n\t\taddress2: primaryProperty?.address2 || null,\n\t\tcity: primaryProperty?.city || null,\n\t\tstate: primaryProperty?.state || null,\n\t\tzip_code: primaryProperty?.zipCode || null,\n\t\tcountry: primaryProperty?.country || \"USA\",\n\t\tlat: customerLat,\n\t\tlon: customerLon,\n\t\tsource: formData.get(\"source\") ? String(formData.get(\"source\")) : null,\n\t\treferred_by: formData.get(\"referredBy\")\n\t\t\t? String(formData.get(\"referredBy\"))\n\t\t\t: null,\n\t\tpreferred_contact_method:\n\t\t\tString(formData.get(\"preferredContactMethod\")) || \"email\",\n\t\tpreferred_technician: formData.get(\"preferredTechnician\")\n\t\t\t? String(formData.get(\"preferredTechnician\"))\n\t\t\t: null,\n\t\tbilling_email: formData.get(\"billingEmail\")\n\t\t\t? String(formData.get(\"billingEmail\"))\n\t\t\t: null,\n\t\tpayment_terms: String(formData.get(\"paymentTerms\")) || \"due_on_receipt\",\n\t\tcredit_limit: formData.get(\"creditLimit\")\n\t\t\t? Number(formData.get(\"creditLimit\")) * CENTS_PER_DOLLAR\n\t\t\t: 0,\n\t\ttax_exempt: formData.get(\"taxExempt\") === \"on\",\n\t\ttax_exempt_number: formData.get(\"taxExemptNumber\")\n\t\t\t? String(formData.get(\"taxExemptNumber\"))\n\t\t\t: null,\n\t\ttags: tags || null,\n\t\tcommunication_preferences: communicationPreferences,\n\t\tnotes: formData.get(\"notes\") ? String(formData.get(\"notes\")) : null,\n\t\tinternal_notes: formData.get(\"internalNotes\")\n\t\t\t? String(formData.get(\"internalNotes\"))\n\t\t\t: null,\n\t\tmetadata: customerMetadata,\n\t\tstatus: \"active\",\n\t\tportal_enabled: false,\n\t\ttotal_revenue: 0,\n\t\ttotal_jobs: 0,\n\t\ttotal_invoices: 0,\n\t\taverage_job_value: 0,\n\t\toutstanding_balance: 0,\n\t};\n}\n\nasync function insertAdditionalPropertiesIfAny(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\tcustomerId: string,\n\tproperties: ParsedCustomerProperty[],\n) {\n\tconst additionalProperties = properties.filter((p) => !p.isPrimary);\n\tif (additionalProperties.length === 0) {\n\t\treturn;\n\t}\n\n\tconst propertiesToInsert = await Promise.all(\n\t\tadditionalProperties.map(async (prop) => {\n\t\t\tlet propLat: number | null = null;\n\t\t\tlet propLon: number | null = null;\n\n\t\t\tif (prop.address && prop.city && prop.state && prop.zipCode) {\n\t\t\t\tconst geocodeResult = await geocodeAddressSilent(\n\t\t\t\t\tprop.address,\n\t\t\t\t\tprop.city,\n\t\t\t\t\tprop.state,\n\t\t\t\t\tprop.zipCode,\n\t\t\t\t\tprop.country || \"USA\",\n\t\t\t\t);\n\n\t\t\t\tif (geocodeResult) {\n\t\t\t\t\tpropLat = geocodeResult.lat;\n\t\t\t\t\tpropLon = geocodeResult.lon;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tname: prop.name || \"Additional Property\",\n\t\t\t\taddress: prop.address,\n\t\t\t\taddress2: prop.address2 || null,\n\t\t\t\tcity: prop.city,\n\t\t\t\tstate: prop.state,\n\t\t\t\tzip_code: prop.zipCode,\n\t\t\t\tcountry: prop.country || \"USA\",\n\t\t\t\tproperty_type: prop.propertyType || \"residential\",\n\t\t\t\tnotes: prop.notes || null,\n\t\t\t\tlat: propLat,\n\t\t\t\tlon: propLon,\n\t\t\t};\n\t\t}),\n\t);\n\n\tawait supabase.from(\"properties\").insert(propertiesToInsert);\n}\n\n/**\n * Update existing customer\n */\nasync function updateCustomer(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Parse tags if provided\n\t\tlet tags: string[] | undefined;\n\t\tconst tagsString = formData.get(\"tags\");\n\t\tif (tagsString && typeof tagsString === \"string\") {\n\t\t\ttry {\n\t\t\t\ttags = JSON.parse(tagsString);\n\t\t\t} catch {\n\t\t\t\ttags = tagsString.split(\",\").map((t) => t.trim());\n\t\t\t}\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = customerSchema.parse({\n\t\t\ttype: formData.get(\"type\") || \"residential\",\n\t\t\tfirstName: formData.get(\"firstName\"),\n\t\t\tlastName: formData.get(\"lastName\"),\n\t\t\tcompanyName: formData.get(\"companyName\") || undefined,\n\t\t\temail: formData.get(\"email\"),\n\t\t\tphone: formData.get(\"phone\"),\n\t\t\tsecondaryPhone: formData.get(\"secondaryPhone\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzipCode: formData.get(\"zipCode\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\tsource: formData.get(\"source\") || undefined,\n\t\t\treferredBy: formData.get(\"referredBy\") || null,\n\t\t\tpreferredContactMethod: formData.get(\"preferredContactMethod\") || \"email\",\n\t\t\tpreferredTechnician: formData.get(\"preferredTechnician\") || null,\n\t\t\tbillingEmail: formData.get(\"billingEmail\") || null,\n\t\t\tpaymentTerms: formData.get(\"paymentTerms\") || \"due_on_receipt\",\n\t\t\tcreditLimit: formData.get(\"creditLimit\")\n\t\t\t\t? Number(formData.get(\"creditLimit\"))\n\t\t\t\t: 0,\n\t\t\ttaxExempt: formData.get(\"taxExempt\") === \"true\",\n\t\t\ttaxExemptNumber: formData.get(\"taxExemptNumber\") || undefined,\n\t\t\ttags,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternalNotes: formData.get(\"internalNotes\") || undefined,\n\t\t});\n\n\t\t// Check if email already exists (excluding current customer)\n\t\tif (data.email !== customer.email) {\n\t\t\tconst { data: existingEmail } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"email\", data.email)\n\t\t\t\t.neq(\"id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (existingEmail) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"A customer with this email already exists\",\n\t\t\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Generate display name\n\t\tconst displayName =\n\t\t\tdata.type === \"commercial\" && data.companyName\n\t\t\t\t? data.companyName\n\t\t\t\t: `${data.firstName} ${data.lastName}`;\n\n\t\tconst companyName = data.companyName ? String(data.companyName) : null;\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttype: data.type,\n\t\t\t\tfirst_name: data.firstName,\n\t\t\t\tlast_name: data.lastName,\n\t\t\t\tcompany_name: companyName,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondaryPhone,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zipCode,\n\t\t\t\tcountry: data.country,\n\t\t\t\tsource: data.source,\n\t\t\t\treferred_by: data.referredBy,\n\t\t\t\tpreferred_contact_method: data.preferredContactMethod,\n\t\t\t\tpreferred_technician: data.preferredTechnician,\n\t\t\t\tbilling_email: data.billingEmail,\n\t\t\t\tpayment_terms: data.paymentTerms,\n\t\t\t\tcredit_limit: data.creditLimit,\n\t\t\t\ttax_exempt: data.taxExempt,\n\t\t\t\ttax_exempt_number: data.taxExemptNumber,\n\t\t\t\ttags: data.tags,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internalNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Delete customer (soft delete/archive)\n */\nexport async function deleteCustomer(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, outstanding_balance\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent deletion if customer has outstanding balance\n\t\tif (customer.outstanding_balance > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot delete customer with outstanding balance. Collect payment first.\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"delete customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t});\n}\n\n// ============================================================================\n// CUSTOMER STATUS & PREFERENCES\n// ============================================================================\n\n/**\n * Update customer status\n */\nasync function updateCustomerStatus(\n\tcustomerId: string,\n\tstatus: \"active\" | \"inactive\" | \"archived\" | \"blocked\",\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Update communication preferences\n */\nasync function updateCommunicationPreferences(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Validate input\n\t\tconst preferences = communicationPreferencesSchema.parse({\n\t\t\temail: formData.get(\"email\") === \"true\",\n\t\t\tsms: formData.get(\"sms\") === \"true\",\n\t\t\tphone: formData.get(\"phone\") === \"true\",\n\t\t\tmarketing: formData.get(\"marketing\") === \"true\",\n\t\t});\n\n\t\t// Update preferences\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ communication_preferences: preferences })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update communication preferences\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// CUSTOMER PORTAL\n// ============================================================================\n\n/**\n * Invite customer to portal\n * Sends an email with a secure token-based invitation link.\n */\nasync function inviteToPortal(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email, display_name, portal_enabled\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (customer.portal_enabled) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer is already invited to portal\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Generate secure portal invitation token\n\t\tconst inviteToken = Buffer.from(\n\t\t\t`${customerId}:${Date.now()}:${Math.random()}`,\n\t\t).toString(\"base64url\");\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tportal_enabled: true,\n\t\t\t\tportal_invited_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"invite customer to portal\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Send invitation email\n\t\tconst siteUrl = requireSiteUrl();\n\t\tconst portalUrl = `${siteUrl}/portal/setup?token=${inviteToken}`;\n\n\t\tconst emailResult = await sendEmail({\n\t\t\tto: customer.email,\n\t\t\tsubject: \"You've been invited to your Customer Portal\",\n\t\t\ttemplate: PortalInvitationEmail({\n\t\t\t\tcustomerName: customer.display_name,\n\t\t\t\tportalUrl,\n\t\t\t\texpiresInHours: 168, // 7 days\n\t\t\t\tsupportEmail: process.env.RESEND_FROM_EMAIL || \"support@thorbis.com\",\n\t\t\t\tsupportPhone: \"(555) 123-4567\",\n\t\t\t}),\n\t\t\ttemplateType: EmailTemplate.PORTAL_INVITATION,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treturn;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Revoke portal access\n */\nasync function revokePortalAccess(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Revoke access\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ portal_enabled: false })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"revoke portal access\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// SEARCH & REPORTING\n// ============================================================================\n\n/**\n * Get customer by phone number\n * Used for incoming call lookups\n */\nexport async function getCustomerByPhone(\n\tphoneNumber: string,\n\tcompanyId: string,\n): Promise<ActionResult<unknown>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Normalize phone number (remove formatting)\n\t\tconst normalizedPhone = phoneNumber.replace(/\\D/g, \"\");\n\n\t\t// Search by primary phone or secondary phone\n\t\tconst { data: customer, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        properties:properties(*)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(\n\t\t\t\t`phone.eq.${phoneNumber},phone.eq.${normalizedPhone},secondary_phone.eq.${phoneNumber},secondary_phone.eq.${normalizedPhone}`,\n\t\t\t)\n\t\t\t.single();\n\n\t\tif (error && error.code !== \"PGRST116\") {\n\t\t\t// PGRST116 = no rows found\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customer || null;\n\t});\n}\n\n/**\n * Search customers by name, email, phone, or company\n */\nexport async function searchCustomers(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the active company ID helper (same as getAllCustomers)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\t// Searches across: first_name, last_name, display_name, email, phone,\n\t\t// secondary_phone, company_name, address, city, state\n\t\t// Returns results ordered by relevance (weighted: name > contact > address)\n\t\tconst { searchCustomersFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst customers = await searchCustomersFullText(\n\t\t\tsupabase,\n\t\t\tactiveCompanyId,\n\t\t\tsearchTerm,\n\t\t\t{\n\t\t\t\tlimit: options?.limit || DEFAULT_SEARCH_LIMIT,\n\t\t\t\toffset: options?.offset || 0,\n\t\t\t},\n\t\t);\n\n\t\treturn customers;\n\t});\n}\n\n/**\n * Get top customers by revenue\n */\nasync function getTopCustomers(\n\tlimit = 10,\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch top customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get customers with outstanding balance\n */\ntype CustomerWithBalance = {\n\tid: string;\n\tdisplay_name: string;\n\tbalance: number;\n};\n\nasync function getCustomersWithBalance(): Promise<\n\tActionResult<CustomerWithBalance[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gt(\"outstanding_balance\", 0)\n\t\t\t.order(\"outstanding_balance\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers with balance\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\ntype CustomerRecord = {\n\tid: string;\n\tcompany_id: string;\n\ttype: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\tcompany_name?: string | null;\n\temail: string;\n\tphone: string;\n\tsecondary_phone?: string;\n\taddress?: string;\n\taddress2?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip_code?: string;\n\tstatus: string;\n\ttotal_revenue?: number;\n\ttotal_jobs?: number;\n\ttotal_invoices?: number;\n\toutstanding_balance?: number;\n\tlast_job_date?: string;\n\tnext_scheduled_job?: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tarchived_at?: string | null;\n\tdeleted_at?: string | null;\n};\n\n/**\n * Get customers for phone dialer (lightweight, no enrichment)\n *\n * PERFORMANCE: Returns only basic contact info needed for dialer.\n * Use this instead of getAllCustomers() in AppHeader to avoid N+1 queries.\n *\n * Expected: 50-100ms (single query)\n * vs getAllCustomers(): 1200-2000ms (151 queries with enrichment)\n */\nexport async function getCustomersForDialer(): Promise<\n\tActionResult<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tfirst_name: string | null;\n\t\t\tlast_name: string | null;\n\t\t\tdisplay_name: string | null;\n\t\t\temail: string | null;\n\t\t\tphone: string | null;\n\t\t\tsecondary_phone?: string | null;\n\t\t\tcompany_name: string | null;\n\t\t\taddress: string | null;\n\t\t\taddress2: string | null;\n\t\t\tcity: string | null;\n\t\t\tstate: string | null;\n\t\t\tzip_code: string | null;\n\t\t}>\n\t>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Single lightweight query - no joins, no enrichment\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t\"id, first_name, last_name, display_name, email, phone, secondary_phone, company_name, address, address2, city, state, zip_code\",\n\t\t\t)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get all customers for the current company (WITH ENRICHMENT)\n *\n * WARNING: This function does 151 database queries for 50 customers (N+1 pattern).\n * Expected time: 1200-2000ms\n *\n * DO NOT use in AppHeader or other frequently rendered components.\n * Use getCustomersForDialer() instead for lightweight contact info.\n *\n * Only use this on dedicated customer list pages where the enriched data is needed.\n */\nasync function getAllCustomers(): Promise<\n\tActionResult<CustomerRecord[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID (from cookie or first available)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\n\t\tconst FORBIDDEN_STATUS_CODE = 403;\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Use RPC function instead of N+1 queries\n\t\t// BEFORE: 151 queries for 50 customers (1 base + 50 Ã— 3 queries each)\n\t\t// AFTER: 1 RPC call with efficient LATERAL joins\n\t\t// Performance gain: 5-10 seconds faster\n\n\t\t// Note: customers variable contains the base customer data from above query\n\t\t// We replace the enrichment logic with a single RPC call\n\t\tconst { data: enrichedData, error: enrichError } = await supabase.rpc(\n\t\t\t\"get_enriched_customers_rpc\",\n\t\t\t{\n\t\t\t\tp_company_id: activeCompanyId,\n\t\t\t},\n\t\t);\n\n\t\tif (enrichError) {\n\t\t\t// Fallback to base customers if enrichment fails\n\t\t\tconsole.error(\"Failed to enrich customers:\", enrichError);\n\t\t\treturn customers as CustomerRecord[];\n\t\t}\n\n\t\t// Merge enriched data with base customer data\n\t\tconst enrichedCustomers = (enrichedData || []).map((customer: any) => ({\n\t\t\t...customer,\n\t\t\t// Override total_jobs and total_revenue with fresh aggregated values\n\t\t\ttotal_jobs: customer.enriched_total_jobs || customer.total_jobs || 0,\n\t\t\ttotal_revenue:\n\t\t\t\tcustomer.enriched_total_revenue || customer.total_revenue || 0,\n\t\t}));\n\n\t\treturn enrichedCustomers as CustomerRecord[];\n\t});\n}\n\n/**\n * Update customer page content (Novel/Tiptap JSON)\n *\n * Saves the customer's editable page layout and content\n * Used by the Novel editor for auto-save functionality\n */\nasync function updateCustomerPageContent(\n\tcustomerId: string,\n\tpageContent: Record<string, unknown>,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"customer\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update page content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tpage_content: pageContent,\n\t\t\t\tcontent_updated_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer page\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;CAUC"}},
    {"offset": {"line": 27, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/customers.ts"],"sourcesContent":["/**\n * Customer Management Server Actions\n *\n * Comprehensive customer relationship management with:\n * - Customer CRUD operations\n * - Customer portal invitation and access\n * - Customer metrics tracking (revenue, jobs, invoices)\n * - Communication preferences\n * - Soft delete/archive support\n * - Customer search and filtering\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { geocodeAddressSilent } from \"@/lib/services/geocoding\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport PortalInvitationEmail from \"../../emails/templates/customer/portal-invitation\";\n\n// ============================================================================\n// VALIDATION SCHEMAS\n// ============================================================================\n\nconst CUSTOMER_NAME_MAX_LENGTH = 100;\nconst CUSTOMER_COMPANY_MAX_LENGTH = 200;\nconst CUSTOMER_PHONE_MAX_LENGTH = 20;\nconst CUSTOMER_ADDRESS_MAX_LENGTH = 200;\nconst CUSTOMER_ADDRESS2_MAX_LENGTH = 100;\nconst CUSTOMER_CITY_MAX_LENGTH = 100;\nconst CUSTOMER_STATE_MAX_LENGTH = 50;\n\n// HTTP Status codes\nconst HTTP_STATUS_FORBIDDEN = 403;\n\n// Search defaults\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst CUSTOMER_ZIP_MAX_LENGTH = 20;\nconst CUSTOMER_COUNTRY_MAX_LENGTH = 50;\nconst CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH = 50;\nconst CENTS_PER_DOLLAR = 100;\n\nfunction requireSiteUrl(): string {\n\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\tif (!siteUrl) {\n\t\tthrow new ActionError(\n\t\t\t\"NEXT_PUBLIC_SITE_URL is not configured\",\n\t\t\tERROR_CODES.INTERNAL_SERVER_ERROR,\n\t\t);\n\t}\n\treturn siteUrl.replace(/\\/$/, \"\");\n}\n\nconst customerSchema = z.object({\n\ttype: z\n\t\t.enum([\"residential\", \"commercial\", \"industrial\"])\n\t\t.default(\"residential\"),\n\tfirstName: z\n\t\t.string()\n\t\t.min(1, \"First name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tlastName: z\n\t\t.string()\n\t\t.min(1, \"Last name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tcompanyName: z.string().max(CUSTOMER_COMPANY_MAX_LENGTH).optional(),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z.string().min(1, \"Phone is required\").max(CUSTOMER_PHONE_MAX_LENGTH),\n\tsecondaryPhone: z.string().max(CUSTOMER_PHONE_MAX_LENGTH).optional(),\n\taddress: z.string().max(CUSTOMER_ADDRESS_MAX_LENGTH).optional(),\n\taddress2: z.string().max(CUSTOMER_ADDRESS2_MAX_LENGTH).optional(),\n\tcity: z.string().max(CUSTOMER_CITY_MAX_LENGTH).optional(),\n\tstate: z.string().max(CUSTOMER_STATE_MAX_LENGTH).optional(),\n\tzipCode: z.string().max(CUSTOMER_ZIP_MAX_LENGTH).optional(),\n\tcountry: z.string().max(CUSTOMER_COUNTRY_MAX_LENGTH).default(\"USA\"),\n\tsource: z\n\t\t.enum([\"referral\", \"google\", \"facebook\", \"direct\", \"yelp\", \"other\"])\n\t\t.optional(),\n\treferredBy: z.string().uuid().optional().nullable(),\n\tpreferredContactMethod: z.enum([\"email\", \"phone\", \"sms\"]).default(\"email\"),\n\tpreferredTechnician: z.string().uuid().optional().nullable(),\n\tbillingEmail: z.string().email().optional().nullable(),\n\tpaymentTerms: z\n\t\t.enum([\"due_on_receipt\", \"net_15\", \"net_30\", \"net_60\"])\n\t\t.default(\"due_on_receipt\"),\n\tcreditLimit: z.number().int().min(0).default(0), // In cents\n\ttaxExempt: z.boolean().default(false),\n\ttaxExemptNumber: z\n\t\t.string()\n\t\t.max(CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH)\n\t\t.optional(),\n\ttags: z.array(z.string()).optional(),\n\tnotes: z.string().optional(),\n\tinternalNotes: z.string().optional(),\n});\n\nconst communicationPreferencesSchema = z.object({\n\temail: z.boolean().default(true),\n\tsms: z.boolean().default(true),\n\tphone: z.boolean().default(true),\n\tmarketing: z.boolean().default(false),\n});\n\n// ============================================================================\n// CUSTOMER CRUD OPERATIONS\n// ============================================================================\n\n/**\n * Create a new customer with multiple contacts and properties\n */\nasync function createCustomer(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\t\tconst { contacts, properties, tags } =\n\t\t\tparseCustomerContactsPropertiesAndTags(formData);\n\t\tconst primaryContact = getPrimaryContactOrThrow(contacts);\n\t\tconst primaryProperty = getPrimaryProperty(properties);\n\n\t\tawait assertCustomerEmailNotDuplicate(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tprimaryContact.email,\n\t\t);\n\n\t\tconst customerType = formData.get(\"type\") || \"residential\";\n\t\tconst companyName = formData.get(\"companyName\");\n\t\tconst displayName = buildCustomerDisplayName(\n\t\t\tcustomerType,\n\t\t\tcompanyName,\n\t\t\tprimaryContact,\n\t\t);\n\n\t\tconst communicationPreferences = buildDefaultCommunicationPreferences();\n\t\tconst customerMetadata = buildCustomerMetadata(contacts);\n\n\t\tconst { lat: customerLat, lon: customerLon } =\n\t\t\tawait geocodePrimaryPropertyIfAvailable(primaryProperty);\n\n\t\tconst customer = await insertCustomerRecord(supabase, {\n\t\t\tcompanyId: teamMember.company_id,\n\t\t\tcustomerType,\n\t\t\tprimaryContact,\n\t\t\tcompanyNameValue: companyName,\n\t\t\tdisplayName,\n\t\t\tprimaryProperty,\n\t\t\tcustomerLat,\n\t\t\tcustomerLon,\n\t\t\tformData,\n\t\t\ttags,\n\t\t\tcommunicationPreferences,\n\t\t\tcustomerMetadata,\n\t\t});\n\n\t\tawait insertAdditionalPropertiesIfAny(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tcustomer.id,\n\t\t\tproperties,\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\treturn customer.id;\n\t});\n}\n\ntype ParsedCustomerContact = {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n\tphone: string;\n\trole: string;\n\tisPrimary: boolean;\n};\n\ntype ParsedCustomerProperty = {\n\tname: string;\n\taddress: string;\n\taddress2: string;\n\tcity: string;\n\tstate: string;\n\tzipCode: string;\n\tcountry: string;\n\tpropertyType: string;\n\tisPrimary: boolean;\n\tnotes: string;\n};\n\ntype ParsedCustomerFormCollections = {\n\tcontacts: ParsedCustomerContact[];\n\tproperties: ParsedCustomerProperty[];\n\ttags?: string[];\n};\n\nasync function requireCustomerCompanyMembership(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n) {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember;\n}\n\nfunction parseCustomerContactsPropertiesAndTags(\n\tformData: FormData,\n): ParsedCustomerFormCollections {\n\tconst contacts = parseContacts(formData.get(\"contacts\"));\n\tconst properties = parseProperties(formData.get(\"properties\"));\n\tconst tags = parseTagsField(formData.get(\"tags\"));\n\n\treturn { contacts, properties, tags };\n}\n\nfunction parseContacts(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerContact[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerContact[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid contacts data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseProperties(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerProperty[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerProperty[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid properties data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseTagsField(\n\tvalue: FormDataEntryValue | null,\n): string[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as string[];\n\t} catch {\n\t\treturn value.split(\",\").map((t) => t.trim());\n\t}\n}\n\nfunction getPrimaryContactOrThrow(\n\tcontacts: ParsedCustomerContact[],\n): ParsedCustomerContact {\n\tconst primaryContact = contacts.find((c) => c.isPrimary) || contacts[0];\n\tif (!primaryContact) {\n\t\tthrow new ActionError(\n\t\t\t\"At least one contact is required\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\treturn primaryContact;\n}\n\nfunction getPrimaryProperty(\n\tproperties: ParsedCustomerProperty[],\n): ParsedCustomerProperty | undefined {\n\treturn properties.find((p) => p.isPrimary) || properties[0];\n}\n\nasync function assertCustomerEmailNotDuplicate(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\temail: string,\n) {\n\tconst { data: existingEmail } = await supabase\n\t\t.from(\"customers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"email\", email)\n\t\t.is(\"deleted_at\", null)\n\t\t.single();\n\n\tif (existingEmail) {\n\t\tthrow new ActionError(\n\t\t\t\"A customer with this email already exists\",\n\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t);\n\t}\n}\n\nfunction buildCustomerDisplayName(\n\tcustomerType: FormDataEntryValue | null,\n\tcompanyNameValue: FormDataEntryValue | null,\n\tprimaryContact: ParsedCustomerContact,\n): string {\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\tif (customerType === \"commercial\" && companyName) {\n\t\treturn companyName;\n\t}\n\n\treturn `${primaryContact.firstName} ${primaryContact.lastName}`;\n}\n\nfunction buildDefaultCommunicationPreferences() {\n\treturn {\n\t\temail: true,\n\t\tsms: true,\n\t\tphone: true,\n\t\tmarketing: false,\n\t};\n}\n\nfunction buildCustomerMetadata(contacts: ParsedCustomerContact[]) {\n\treturn {\n\t\tcontacts: contacts.map((c) => ({\n\t\t\tfirstName: c.firstName,\n\t\t\tlastName: c.lastName,\n\t\t\temail: c.email,\n\t\t\tphone: c.phone,\n\t\t\trole: c.role,\n\t\t\tisPrimary: c.isPrimary,\n\t\t})),\n\t};\n}\n\nasync function geocodePrimaryPropertyIfAvailable(\n\tprimaryProperty: ParsedCustomerProperty | undefined,\n): Promise<{ lat: number | null; lon: number | null }> {\n\tif (\n\t\t!(\n\t\t\tprimaryProperty?.address &&\n\t\t\tprimaryProperty.city &&\n\t\t\tprimaryProperty.state &&\n\t\t\tprimaryProperty.zipCode\n\t\t)\n\t) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\tconst geocodeResult = await geocodeAddressSilent(\n\t\tprimaryProperty.address,\n\t\tprimaryProperty.city,\n\t\tprimaryProperty.state,\n\t\tprimaryProperty.zipCode,\n\t\tprimaryProperty.country || \"USA\",\n\t);\n\n\tif (!geocodeResult) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\treturn { lat: geocodeResult.lat, lon: geocodeResult.lon };\n}\n\ntype InsertCustomerParams = {\n\tcompanyId: string;\n\tcustomerType: FormDataEntryValue | null;\n\tprimaryContact: ParsedCustomerContact;\n\tcompanyNameValue: FormDataEntryValue | null;\n\tdisplayName: string;\n\tprimaryProperty?: ParsedCustomerProperty;\n\tcustomerLat: number | null;\n\tcustomerLon: number | null;\n\tformData: FormData;\n\ttags?: string[];\n\tcommunicationPreferences: {\n\t\temail: boolean;\n\t\tsms: boolean;\n\t\tphone: boolean;\n\t\tmarketing: boolean;\n\t};\n\tcustomerMetadata: Record<string, unknown>;\n};\n\nasync function insertCustomerRecord(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tparams: InsertCustomerParams,\n) {\n\tconst payload = buildCustomerInsertPayload(params);\n\n\tconst { data: customer, error: createError } = await supabase\n\t\t.from(\"customers\")\n\t\t.insert(payload)\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (createError || !customer) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(\"create customer\"),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn customer;\n}\n\nfunction buildCustomerInsertPayload(\n\tparams: InsertCustomerParams,\n): Record<string, unknown> {\n\tconst {\n\t\tcompanyId,\n\t\tcustomerType,\n\t\tprimaryContact,\n\t\tcompanyNameValue,\n\t\tdisplayName,\n\t\tprimaryProperty,\n\t\tcustomerLat,\n\t\tcustomerLon,\n\t\tformData,\n\t\ttags,\n\t\tcommunicationPreferences,\n\t\tcustomerMetadata,\n\t} = params;\n\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\ttype: String(customerType || \"residential\"),\n\t\tfirst_name: primaryContact.firstName,\n\t\tlast_name: primaryContact.lastName,\n\t\tcompany_name: companyName,\n\t\tdisplay_name: displayName,\n\t\temail: primaryContact.email,\n\t\tphone: primaryContact.phone,\n\t\tsecondary_phone: null,\n\t\taddress: primaryProperty?.address || null,\n\t\taddress2: primaryProperty?.address2 || null,\n\t\tcity: primaryProperty?.city || null,\n\t\tstate: primaryProperty?.state || null,\n\t\tzip_code: primaryProperty?.zipCode || null,\n\t\tcountry: primaryProperty?.country || \"USA\",\n\t\tlat: customerLat,\n\t\tlon: customerLon,\n\t\tsource: formData.get(\"source\") ? String(formData.get(\"source\")) : null,\n\t\treferred_by: formData.get(\"referredBy\")\n\t\t\t? String(formData.get(\"referredBy\"))\n\t\t\t: null,\n\t\tpreferred_contact_method:\n\t\t\tString(formData.get(\"preferredContactMethod\")) || \"email\",\n\t\tpreferred_technician: formData.get(\"preferredTechnician\")\n\t\t\t? String(formData.get(\"preferredTechnician\"))\n\t\t\t: null,\n\t\tbilling_email: formData.get(\"billingEmail\")\n\t\t\t? String(formData.get(\"billingEmail\"))\n\t\t\t: null,\n\t\tpayment_terms: String(formData.get(\"paymentTerms\")) || \"due_on_receipt\",\n\t\tcredit_limit: formData.get(\"creditLimit\")\n\t\t\t? Number(formData.get(\"creditLimit\")) * CENTS_PER_DOLLAR\n\t\t\t: 0,\n\t\ttax_exempt: formData.get(\"taxExempt\") === \"on\",\n\t\ttax_exempt_number: formData.get(\"taxExemptNumber\")\n\t\t\t? String(formData.get(\"taxExemptNumber\"))\n\t\t\t: null,\n\t\ttags: tags || null,\n\t\tcommunication_preferences: communicationPreferences,\n\t\tnotes: formData.get(\"notes\") ? String(formData.get(\"notes\")) : null,\n\t\tinternal_notes: formData.get(\"internalNotes\")\n\t\t\t? String(formData.get(\"internalNotes\"))\n\t\t\t: null,\n\t\tmetadata: customerMetadata,\n\t\tstatus: \"active\",\n\t\tportal_enabled: false,\n\t\ttotal_revenue: 0,\n\t\ttotal_jobs: 0,\n\t\ttotal_invoices: 0,\n\t\taverage_job_value: 0,\n\t\toutstanding_balance: 0,\n\t};\n}\n\nasync function insertAdditionalPropertiesIfAny(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\tcustomerId: string,\n\tproperties: ParsedCustomerProperty[],\n) {\n\tconst additionalProperties = properties.filter((p) => !p.isPrimary);\n\tif (additionalProperties.length === 0) {\n\t\treturn;\n\t}\n\n\tconst propertiesToInsert = await Promise.all(\n\t\tadditionalProperties.map(async (prop) => {\n\t\t\tlet propLat: number | null = null;\n\t\t\tlet propLon: number | null = null;\n\n\t\t\tif (prop.address && prop.city && prop.state && prop.zipCode) {\n\t\t\t\tconst geocodeResult = await geocodeAddressSilent(\n\t\t\t\t\tprop.address,\n\t\t\t\t\tprop.city,\n\t\t\t\t\tprop.state,\n\t\t\t\t\tprop.zipCode,\n\t\t\t\t\tprop.country || \"USA\",\n\t\t\t\t);\n\n\t\t\t\tif (geocodeResult) {\n\t\t\t\t\tpropLat = geocodeResult.lat;\n\t\t\t\t\tpropLon = geocodeResult.lon;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tname: prop.name || \"Additional Property\",\n\t\t\t\taddress: prop.address,\n\t\t\t\taddress2: prop.address2 || null,\n\t\t\t\tcity: prop.city,\n\t\t\t\tstate: prop.state,\n\t\t\t\tzip_code: prop.zipCode,\n\t\t\t\tcountry: prop.country || \"USA\",\n\t\t\t\tproperty_type: prop.propertyType || \"residential\",\n\t\t\t\tnotes: prop.notes || null,\n\t\t\t\tlat: propLat,\n\t\t\t\tlon: propLon,\n\t\t\t};\n\t\t}),\n\t);\n\n\tawait supabase.from(\"properties\").insert(propertiesToInsert);\n}\n\n/**\n * Update existing customer\n */\nasync function updateCustomer(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Parse tags if provided\n\t\tlet tags: string[] | undefined;\n\t\tconst tagsString = formData.get(\"tags\");\n\t\tif (tagsString && typeof tagsString === \"string\") {\n\t\t\ttry {\n\t\t\t\ttags = JSON.parse(tagsString);\n\t\t\t} catch {\n\t\t\t\ttags = tagsString.split(\",\").map((t) => t.trim());\n\t\t\t}\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = customerSchema.parse({\n\t\t\ttype: formData.get(\"type\") || \"residential\",\n\t\t\tfirstName: formData.get(\"firstName\"),\n\t\t\tlastName: formData.get(\"lastName\"),\n\t\t\tcompanyName: formData.get(\"companyName\") || undefined,\n\t\t\temail: formData.get(\"email\"),\n\t\t\tphone: formData.get(\"phone\"),\n\t\t\tsecondaryPhone: formData.get(\"secondaryPhone\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzipCode: formData.get(\"zipCode\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\tsource: formData.get(\"source\") || undefined,\n\t\t\treferredBy: formData.get(\"referredBy\") || null,\n\t\t\tpreferredContactMethod: formData.get(\"preferredContactMethod\") || \"email\",\n\t\t\tpreferredTechnician: formData.get(\"preferredTechnician\") || null,\n\t\t\tbillingEmail: formData.get(\"billingEmail\") || null,\n\t\t\tpaymentTerms: formData.get(\"paymentTerms\") || \"due_on_receipt\",\n\t\t\tcreditLimit: formData.get(\"creditLimit\")\n\t\t\t\t? Number(formData.get(\"creditLimit\"))\n\t\t\t\t: 0,\n\t\t\ttaxExempt: formData.get(\"taxExempt\") === \"true\",\n\t\t\ttaxExemptNumber: formData.get(\"taxExemptNumber\") || undefined,\n\t\t\ttags,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternalNotes: formData.get(\"internalNotes\") || undefined,\n\t\t});\n\n\t\t// Check if email already exists (excluding current customer)\n\t\tif (data.email !== customer.email) {\n\t\t\tconst { data: existingEmail } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"email\", data.email)\n\t\t\t\t.neq(\"id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (existingEmail) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"A customer with this email already exists\",\n\t\t\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Generate display name\n\t\tconst displayName =\n\t\t\tdata.type === \"commercial\" && data.companyName\n\t\t\t\t? data.companyName\n\t\t\t\t: `${data.firstName} ${data.lastName}`;\n\n\t\tconst companyName = data.companyName ? String(data.companyName) : null;\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttype: data.type,\n\t\t\t\tfirst_name: data.firstName,\n\t\t\t\tlast_name: data.lastName,\n\t\t\t\tcompany_name: companyName,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondaryPhone,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zipCode,\n\t\t\t\tcountry: data.country,\n\t\t\t\tsource: data.source,\n\t\t\t\treferred_by: data.referredBy,\n\t\t\t\tpreferred_contact_method: data.preferredContactMethod,\n\t\t\t\tpreferred_technician: data.preferredTechnician,\n\t\t\t\tbilling_email: data.billingEmail,\n\t\t\t\tpayment_terms: data.paymentTerms,\n\t\t\t\tcredit_limit: data.creditLimit,\n\t\t\t\ttax_exempt: data.taxExempt,\n\t\t\t\ttax_exempt_number: data.taxExemptNumber,\n\t\t\t\ttags: data.tags,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internalNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Delete customer (soft delete/archive)\n */\nexport async function deleteCustomer(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, outstanding_balance\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent deletion if customer has outstanding balance\n\t\tif (customer.outstanding_balance > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot delete customer with outstanding balance. Collect payment first.\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"delete customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t});\n}\n\n// ============================================================================\n// CUSTOMER STATUS & PREFERENCES\n// ============================================================================\n\n/**\n * Update customer status\n */\nasync function updateCustomerStatus(\n\tcustomerId: string,\n\tstatus: \"active\" | \"inactive\" | \"archived\" | \"blocked\",\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Update communication preferences\n */\nasync function updateCommunicationPreferences(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Validate input\n\t\tconst preferences = communicationPreferencesSchema.parse({\n\t\t\temail: formData.get(\"email\") === \"true\",\n\t\t\tsms: formData.get(\"sms\") === \"true\",\n\t\t\tphone: formData.get(\"phone\") === \"true\",\n\t\t\tmarketing: formData.get(\"marketing\") === \"true\",\n\t\t});\n\n\t\t// Update preferences\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ communication_preferences: preferences })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update communication preferences\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// CUSTOMER PORTAL\n// ============================================================================\n\n/**\n * Invite customer to portal\n * Sends an email with a secure token-based invitation link.\n */\nasync function inviteToPortal(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email, display_name, portal_enabled\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (customer.portal_enabled) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer is already invited to portal\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Generate secure portal invitation token\n\t\tconst inviteToken = Buffer.from(\n\t\t\t`${customerId}:${Date.now()}:${Math.random()}`,\n\t\t).toString(\"base64url\");\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tportal_enabled: true,\n\t\t\t\tportal_invited_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"invite customer to portal\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Send invitation email\n\t\tconst siteUrl = requireSiteUrl();\n\t\tconst portalUrl = `${siteUrl}/portal/setup?token=${inviteToken}`;\n\n\t\tconst emailResult = await sendEmail({\n\t\t\tto: customer.email,\n\t\t\tsubject: \"You've been invited to your Customer Portal\",\n\t\t\ttemplate: PortalInvitationEmail({\n\t\t\t\tcustomerName: customer.display_name,\n\t\t\t\tportalUrl,\n\t\t\t\texpiresInHours: 168, // 7 days\n\t\t\t\tsupportEmail: process.env.RESEND_FROM_EMAIL || \"support@thorbis.com\",\n\t\t\t\tsupportPhone: \"(555) 123-4567\",\n\t\t\t}),\n\t\t\ttemplateType: EmailTemplate.PORTAL_INVITATION,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treturn;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Revoke portal access\n */\nasync function revokePortalAccess(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Revoke access\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ portal_enabled: false })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"revoke portal access\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// SEARCH & REPORTING\n// ============================================================================\n\n/**\n * Get customer by phone number\n * Used for incoming call lookups\n */\nexport async function getCustomerByPhone(\n\tphoneNumber: string,\n\tcompanyId: string,\n): Promise<ActionResult<unknown>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Normalize phone number (remove formatting)\n\t\tconst normalizedPhone = phoneNumber.replace(/\\D/g, \"\");\n\n\t\t// Search by primary phone or secondary phone\n\t\tconst { data: customer, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        properties:properties(*)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(\n\t\t\t\t`phone.eq.${phoneNumber},phone.eq.${normalizedPhone},secondary_phone.eq.${phoneNumber},secondary_phone.eq.${normalizedPhone}`,\n\t\t\t)\n\t\t\t.single();\n\n\t\tif (error && error.code !== \"PGRST116\") {\n\t\t\t// PGRST116 = no rows found\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customer || null;\n\t});\n}\n\n/**\n * Search customers by name, email, phone, or company\n */\nexport async function searchCustomers(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the active company ID helper (same as getAllCustomers)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\t// Searches across: first_name, last_name, display_name, email, phone,\n\t\t// secondary_phone, company_name, address, city, state\n\t\t// Returns results ordered by relevance (weighted: name > contact > address)\n\t\tconst { searchCustomersFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst customers = await searchCustomersFullText(\n\t\t\tsupabase,\n\t\t\tactiveCompanyId,\n\t\t\tsearchTerm,\n\t\t\t{\n\t\t\t\tlimit: options?.limit || DEFAULT_SEARCH_LIMIT,\n\t\t\t\toffset: options?.offset || 0,\n\t\t\t},\n\t\t);\n\n\t\treturn customers;\n\t});\n}\n\n/**\n * Get top customers by revenue\n */\nasync function getTopCustomers(\n\tlimit = 10,\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch top customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get customers with outstanding balance\n */\ntype CustomerWithBalance = {\n\tid: string;\n\tdisplay_name: string;\n\tbalance: number;\n};\n\nasync function getCustomersWithBalance(): Promise<\n\tActionResult<CustomerWithBalance[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gt(\"outstanding_balance\", 0)\n\t\t\t.order(\"outstanding_balance\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers with balance\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\ntype CustomerRecord = {\n\tid: string;\n\tcompany_id: string;\n\ttype: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\tcompany_name?: string | null;\n\temail: string;\n\tphone: string;\n\tsecondary_phone?: string;\n\taddress?: string;\n\taddress2?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip_code?: string;\n\tstatus: string;\n\ttotal_revenue?: number;\n\ttotal_jobs?: number;\n\ttotal_invoices?: number;\n\toutstanding_balance?: number;\n\tlast_job_date?: string;\n\tnext_scheduled_job?: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tarchived_at?: string | null;\n\tdeleted_at?: string | null;\n};\n\n/**\n * Get customers for phone dialer (lightweight, no enrichment)\n *\n * PERFORMANCE: Returns only basic contact info needed for dialer.\n * Use this instead of getAllCustomers() in AppHeader to avoid N+1 queries.\n *\n * Expected: 50-100ms (single query)\n * vs getAllCustomers(): 1200-2000ms (151 queries with enrichment)\n */\nexport async function getCustomersForDialer(): Promise<\n\tActionResult<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tfirst_name: string | null;\n\t\t\tlast_name: string | null;\n\t\t\tdisplay_name: string | null;\n\t\t\temail: string | null;\n\t\t\tphone: string | null;\n\t\t\tsecondary_phone?: string | null;\n\t\t\tcompany_name: string | null;\n\t\t\taddress: string | null;\n\t\t\taddress2: string | null;\n\t\t\tcity: string | null;\n\t\t\tstate: string | null;\n\t\t\tzip_code: string | null;\n\t\t}>\n\t>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Single lightweight query - no joins, no enrichment\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t\"id, first_name, last_name, display_name, email, phone, secondary_phone, company_name, address, address2, city, state, zip_code\",\n\t\t\t)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get all customers for the current company (WITH ENRICHMENT)\n *\n * WARNING: This function does 151 database queries for 50 customers (N+1 pattern).\n * Expected time: 1200-2000ms\n *\n * DO NOT use in AppHeader or other frequently rendered components.\n * Use getCustomersForDialer() instead for lightweight contact info.\n *\n * Only use this on dedicated customer list pages where the enriched data is needed.\n */\nasync function getAllCustomers(): Promise<\n\tActionResult<CustomerRecord[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID (from cookie or first available)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\n\t\tconst FORBIDDEN_STATUS_CODE = 403;\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Use RPC function instead of N+1 queries\n\t\t// BEFORE: 151 queries for 50 customers (1 base + 50 Ã— 3 queries each)\n\t\t// AFTER: 1 RPC call with efficient LATERAL joins\n\t\t// Performance gain: 5-10 seconds faster\n\n\t\t// Note: customers variable contains the base customer data from above query\n\t\t// We replace the enrichment logic with a single RPC call\n\t\tconst { data: enrichedData, error: enrichError } = await supabase.rpc(\n\t\t\t\"get_enriched_customers_rpc\",\n\t\t\t{\n\t\t\t\tp_company_id: activeCompanyId,\n\t\t\t},\n\t\t);\n\n\t\tif (enrichError) {\n\t\t\t// Fallback to base customers if enrichment fails\n\t\t\tconsole.error(\"Failed to enrich customers:\", enrichError);\n\t\t\treturn customers as CustomerRecord[];\n\t\t}\n\n\t\t// Merge enriched data with base customer data\n\t\tconst enrichedCustomers = (enrichedData || []).map((customer: any) => ({\n\t\t\t...customer,\n\t\t\t// Override total_jobs and total_revenue with fresh aggregated values\n\t\t\ttotal_jobs: customer.enriched_total_jobs || customer.total_jobs || 0,\n\t\t\ttotal_revenue:\n\t\t\t\tcustomer.enriched_total_revenue || customer.total_revenue || 0,\n\t\t}));\n\n\t\treturn enrichedCustomers as CustomerRecord[];\n\t});\n}\n\n/**\n * Update customer page content (Novel/Tiptap JSON)\n *\n * Saves the customer's editable page layout and content\n * Used by the Novel editor for auto-save functionality\n */\nasync function updateCustomerPageContent(\n\tcustomerId: string,\n\tpageContent: Record<string, unknown>,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"customer\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update page content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tpage_content: pageContent,\n\t\t\t\tcontent_updated_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer page\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAmuBsB,iBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/customers.ts"],"sourcesContent":["/**\n * Customer Management Server Actions\n *\n * Comprehensive customer relationship management with:\n * - Customer CRUD operations\n * - Customer portal invitation and access\n * - Customer metrics tracking (revenue, jobs, invoices)\n * - Communication preferences\n * - Soft delete/archive support\n * - Customer search and filtering\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { geocodeAddressSilent } from \"@/lib/services/geocoding\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport PortalInvitationEmail from \"../../emails/templates/customer/portal-invitation\";\n\n// ============================================================================\n// VALIDATION SCHEMAS\n// ============================================================================\n\nconst CUSTOMER_NAME_MAX_LENGTH = 100;\nconst CUSTOMER_COMPANY_MAX_LENGTH = 200;\nconst CUSTOMER_PHONE_MAX_LENGTH = 20;\nconst CUSTOMER_ADDRESS_MAX_LENGTH = 200;\nconst CUSTOMER_ADDRESS2_MAX_LENGTH = 100;\nconst CUSTOMER_CITY_MAX_LENGTH = 100;\nconst CUSTOMER_STATE_MAX_LENGTH = 50;\n\n// HTTP Status codes\nconst HTTP_STATUS_FORBIDDEN = 403;\n\n// Search defaults\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst CUSTOMER_ZIP_MAX_LENGTH = 20;\nconst CUSTOMER_COUNTRY_MAX_LENGTH = 50;\nconst CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH = 50;\nconst CENTS_PER_DOLLAR = 100;\n\nfunction requireSiteUrl(): string {\n\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\tif (!siteUrl) {\n\t\tthrow new ActionError(\n\t\t\t\"NEXT_PUBLIC_SITE_URL is not configured\",\n\t\t\tERROR_CODES.INTERNAL_SERVER_ERROR,\n\t\t);\n\t}\n\treturn siteUrl.replace(/\\/$/, \"\");\n}\n\nconst customerSchema = z.object({\n\ttype: z\n\t\t.enum([\"residential\", \"commercial\", \"industrial\"])\n\t\t.default(\"residential\"),\n\tfirstName: z\n\t\t.string()\n\t\t.min(1, \"First name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tlastName: z\n\t\t.string()\n\t\t.min(1, \"Last name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tcompanyName: z.string().max(CUSTOMER_COMPANY_MAX_LENGTH).optional(),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z.string().min(1, \"Phone is required\").max(CUSTOMER_PHONE_MAX_LENGTH),\n\tsecondaryPhone: z.string().max(CUSTOMER_PHONE_MAX_LENGTH).optional(),\n\taddress: z.string().max(CUSTOMER_ADDRESS_MAX_LENGTH).optional(),\n\taddress2: z.string().max(CUSTOMER_ADDRESS2_MAX_LENGTH).optional(),\n\tcity: z.string().max(CUSTOMER_CITY_MAX_LENGTH).optional(),\n\tstate: z.string().max(CUSTOMER_STATE_MAX_LENGTH).optional(),\n\tzipCode: z.string().max(CUSTOMER_ZIP_MAX_LENGTH).optional(),\n\tcountry: z.string().max(CUSTOMER_COUNTRY_MAX_LENGTH).default(\"USA\"),\n\tsource: z\n\t\t.enum([\"referral\", \"google\", \"facebook\", \"direct\", \"yelp\", \"other\"])\n\t\t.optional(),\n\treferredBy: z.string().uuid().optional().nullable(),\n\tpreferredContactMethod: z.enum([\"email\", \"phone\", \"sms\"]).default(\"email\"),\n\tpreferredTechnician: z.string().uuid().optional().nullable(),\n\tbillingEmail: z.string().email().optional().nullable(),\n\tpaymentTerms: z\n\t\t.enum([\"due_on_receipt\", \"net_15\", \"net_30\", \"net_60\"])\n\t\t.default(\"due_on_receipt\"),\n\tcreditLimit: z.number().int().min(0).default(0), // In cents\n\ttaxExempt: z.boolean().default(false),\n\ttaxExemptNumber: z\n\t\t.string()\n\t\t.max(CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH)\n\t\t.optional(),\n\ttags: z.array(z.string()).optional(),\n\tnotes: z.string().optional(),\n\tinternalNotes: z.string().optional(),\n});\n\nconst communicationPreferencesSchema = z.object({\n\temail: z.boolean().default(true),\n\tsms: z.boolean().default(true),\n\tphone: z.boolean().default(true),\n\tmarketing: z.boolean().default(false),\n});\n\n// ============================================================================\n// CUSTOMER CRUD OPERATIONS\n// ============================================================================\n\n/**\n * Create a new customer with multiple contacts and properties\n */\nasync function createCustomer(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\t\tconst { contacts, properties, tags } =\n\t\t\tparseCustomerContactsPropertiesAndTags(formData);\n\t\tconst primaryContact = getPrimaryContactOrThrow(contacts);\n\t\tconst primaryProperty = getPrimaryProperty(properties);\n\n\t\tawait assertCustomerEmailNotDuplicate(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tprimaryContact.email,\n\t\t);\n\n\t\tconst customerType = formData.get(\"type\") || \"residential\";\n\t\tconst companyName = formData.get(\"companyName\");\n\t\tconst displayName = buildCustomerDisplayName(\n\t\t\tcustomerType,\n\t\t\tcompanyName,\n\t\t\tprimaryContact,\n\t\t);\n\n\t\tconst communicationPreferences = buildDefaultCommunicationPreferences();\n\t\tconst customerMetadata = buildCustomerMetadata(contacts);\n\n\t\tconst { lat: customerLat, lon: customerLon } =\n\t\t\tawait geocodePrimaryPropertyIfAvailable(primaryProperty);\n\n\t\tconst customer = await insertCustomerRecord(supabase, {\n\t\t\tcompanyId: teamMember.company_id,\n\t\t\tcustomerType,\n\t\t\tprimaryContact,\n\t\t\tcompanyNameValue: companyName,\n\t\t\tdisplayName,\n\t\t\tprimaryProperty,\n\t\t\tcustomerLat,\n\t\t\tcustomerLon,\n\t\t\tformData,\n\t\t\ttags,\n\t\t\tcommunicationPreferences,\n\t\t\tcustomerMetadata,\n\t\t});\n\n\t\tawait insertAdditionalPropertiesIfAny(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tcustomer.id,\n\t\t\tproperties,\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\treturn customer.id;\n\t});\n}\n\ntype ParsedCustomerContact = {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n\tphone: string;\n\trole: string;\n\tisPrimary: boolean;\n};\n\ntype ParsedCustomerProperty = {\n\tname: string;\n\taddress: string;\n\taddress2: string;\n\tcity: string;\n\tstate: string;\n\tzipCode: string;\n\tcountry: string;\n\tpropertyType: string;\n\tisPrimary: boolean;\n\tnotes: string;\n};\n\ntype ParsedCustomerFormCollections = {\n\tcontacts: ParsedCustomerContact[];\n\tproperties: ParsedCustomerProperty[];\n\ttags?: string[];\n};\n\nasync function requireCustomerCompanyMembership(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n) {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember;\n}\n\nfunction parseCustomerContactsPropertiesAndTags(\n\tformData: FormData,\n): ParsedCustomerFormCollections {\n\tconst contacts = parseContacts(formData.get(\"contacts\"));\n\tconst properties = parseProperties(formData.get(\"properties\"));\n\tconst tags = parseTagsField(formData.get(\"tags\"));\n\n\treturn { contacts, properties, tags };\n}\n\nfunction parseContacts(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerContact[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerContact[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid contacts data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseProperties(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerProperty[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerProperty[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid properties data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseTagsField(\n\tvalue: FormDataEntryValue | null,\n): string[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as string[];\n\t} catch {\n\t\treturn value.split(\",\").map((t) => t.trim());\n\t}\n}\n\nfunction getPrimaryContactOrThrow(\n\tcontacts: ParsedCustomerContact[],\n): ParsedCustomerContact {\n\tconst primaryContact = contacts.find((c) => c.isPrimary) || contacts[0];\n\tif (!primaryContact) {\n\t\tthrow new ActionError(\n\t\t\t\"At least one contact is required\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\treturn primaryContact;\n}\n\nfunction getPrimaryProperty(\n\tproperties: ParsedCustomerProperty[],\n): ParsedCustomerProperty | undefined {\n\treturn properties.find((p) => p.isPrimary) || properties[0];\n}\n\nasync function assertCustomerEmailNotDuplicate(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\temail: string,\n) {\n\tconst { data: existingEmail } = await supabase\n\t\t.from(\"customers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"email\", email)\n\t\t.is(\"deleted_at\", null)\n\t\t.single();\n\n\tif (existingEmail) {\n\t\tthrow new ActionError(\n\t\t\t\"A customer with this email already exists\",\n\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t);\n\t}\n}\n\nfunction buildCustomerDisplayName(\n\tcustomerType: FormDataEntryValue | null,\n\tcompanyNameValue: FormDataEntryValue | null,\n\tprimaryContact: ParsedCustomerContact,\n): string {\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\tif (customerType === \"commercial\" && companyName) {\n\t\treturn companyName;\n\t}\n\n\treturn `${primaryContact.firstName} ${primaryContact.lastName}`;\n}\n\nfunction buildDefaultCommunicationPreferences() {\n\treturn {\n\t\temail: true,\n\t\tsms: true,\n\t\tphone: true,\n\t\tmarketing: false,\n\t};\n}\n\nfunction buildCustomerMetadata(contacts: ParsedCustomerContact[]) {\n\treturn {\n\t\tcontacts: contacts.map((c) => ({\n\t\t\tfirstName: c.firstName,\n\t\t\tlastName: c.lastName,\n\t\t\temail: c.email,\n\t\t\tphone: c.phone,\n\t\t\trole: c.role,\n\t\t\tisPrimary: c.isPrimary,\n\t\t})),\n\t};\n}\n\nasync function geocodePrimaryPropertyIfAvailable(\n\tprimaryProperty: ParsedCustomerProperty | undefined,\n): Promise<{ lat: number | null; lon: number | null }> {\n\tif (\n\t\t!(\n\t\t\tprimaryProperty?.address &&\n\t\t\tprimaryProperty.city &&\n\t\t\tprimaryProperty.state &&\n\t\t\tprimaryProperty.zipCode\n\t\t)\n\t) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\tconst geocodeResult = await geocodeAddressSilent(\n\t\tprimaryProperty.address,\n\t\tprimaryProperty.city,\n\t\tprimaryProperty.state,\n\t\tprimaryProperty.zipCode,\n\t\tprimaryProperty.country || \"USA\",\n\t);\n\n\tif (!geocodeResult) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\treturn { lat: geocodeResult.lat, lon: geocodeResult.lon };\n}\n\ntype InsertCustomerParams = {\n\tcompanyId: string;\n\tcustomerType: FormDataEntryValue | null;\n\tprimaryContact: ParsedCustomerContact;\n\tcompanyNameValue: FormDataEntryValue | null;\n\tdisplayName: string;\n\tprimaryProperty?: ParsedCustomerProperty;\n\tcustomerLat: number | null;\n\tcustomerLon: number | null;\n\tformData: FormData;\n\ttags?: string[];\n\tcommunicationPreferences: {\n\t\temail: boolean;\n\t\tsms: boolean;\n\t\tphone: boolean;\n\t\tmarketing: boolean;\n\t};\n\tcustomerMetadata: Record<string, unknown>;\n};\n\nasync function insertCustomerRecord(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tparams: InsertCustomerParams,\n) {\n\tconst payload = buildCustomerInsertPayload(params);\n\n\tconst { data: customer, error: createError } = await supabase\n\t\t.from(\"customers\")\n\t\t.insert(payload)\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (createError || !customer) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(\"create customer\"),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn customer;\n}\n\nfunction buildCustomerInsertPayload(\n\tparams: InsertCustomerParams,\n): Record<string, unknown> {\n\tconst {\n\t\tcompanyId,\n\t\tcustomerType,\n\t\tprimaryContact,\n\t\tcompanyNameValue,\n\t\tdisplayName,\n\t\tprimaryProperty,\n\t\tcustomerLat,\n\t\tcustomerLon,\n\t\tformData,\n\t\ttags,\n\t\tcommunicationPreferences,\n\t\tcustomerMetadata,\n\t} = params;\n\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\ttype: String(customerType || \"residential\"),\n\t\tfirst_name: primaryContact.firstName,\n\t\tlast_name: primaryContact.lastName,\n\t\tcompany_name: companyName,\n\t\tdisplay_name: displayName,\n\t\temail: primaryContact.email,\n\t\tphone: primaryContact.phone,\n\t\tsecondary_phone: null,\n\t\taddress: primaryProperty?.address || null,\n\t\taddress2: primaryProperty?.address2 || null,\n\t\tcity: primaryProperty?.city || null,\n\t\tstate: primaryProperty?.state || null,\n\t\tzip_code: primaryProperty?.zipCode || null,\n\t\tcountry: primaryProperty?.country || \"USA\",\n\t\tlat: customerLat,\n\t\tlon: customerLon,\n\t\tsource: formData.get(\"source\") ? String(formData.get(\"source\")) : null,\n\t\treferred_by: formData.get(\"referredBy\")\n\t\t\t? String(formData.get(\"referredBy\"))\n\t\t\t: null,\n\t\tpreferred_contact_method:\n\t\t\tString(formData.get(\"preferredContactMethod\")) || \"email\",\n\t\tpreferred_technician: formData.get(\"preferredTechnician\")\n\t\t\t? String(formData.get(\"preferredTechnician\"))\n\t\t\t: null,\n\t\tbilling_email: formData.get(\"billingEmail\")\n\t\t\t? String(formData.get(\"billingEmail\"))\n\t\t\t: null,\n\t\tpayment_terms: String(formData.get(\"paymentTerms\")) || \"due_on_receipt\",\n\t\tcredit_limit: formData.get(\"creditLimit\")\n\t\t\t? Number(formData.get(\"creditLimit\")) * CENTS_PER_DOLLAR\n\t\t\t: 0,\n\t\ttax_exempt: formData.get(\"taxExempt\") === \"on\",\n\t\ttax_exempt_number: formData.get(\"taxExemptNumber\")\n\t\t\t? String(formData.get(\"taxExemptNumber\"))\n\t\t\t: null,\n\t\ttags: tags || null,\n\t\tcommunication_preferences: communicationPreferences,\n\t\tnotes: formData.get(\"notes\") ? String(formData.get(\"notes\")) : null,\n\t\tinternal_notes: formData.get(\"internalNotes\")\n\t\t\t? String(formData.get(\"internalNotes\"))\n\t\t\t: null,\n\t\tmetadata: customerMetadata,\n\t\tstatus: \"active\",\n\t\tportal_enabled: false,\n\t\ttotal_revenue: 0,\n\t\ttotal_jobs: 0,\n\t\ttotal_invoices: 0,\n\t\taverage_job_value: 0,\n\t\toutstanding_balance: 0,\n\t};\n}\n\nasync function insertAdditionalPropertiesIfAny(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\tcustomerId: string,\n\tproperties: ParsedCustomerProperty[],\n) {\n\tconst additionalProperties = properties.filter((p) => !p.isPrimary);\n\tif (additionalProperties.length === 0) {\n\t\treturn;\n\t}\n\n\tconst propertiesToInsert = await Promise.all(\n\t\tadditionalProperties.map(async (prop) => {\n\t\t\tlet propLat: number | null = null;\n\t\t\tlet propLon: number | null = null;\n\n\t\t\tif (prop.address && prop.city && prop.state && prop.zipCode) {\n\t\t\t\tconst geocodeResult = await geocodeAddressSilent(\n\t\t\t\t\tprop.address,\n\t\t\t\t\tprop.city,\n\t\t\t\t\tprop.state,\n\t\t\t\t\tprop.zipCode,\n\t\t\t\t\tprop.country || \"USA\",\n\t\t\t\t);\n\n\t\t\t\tif (geocodeResult) {\n\t\t\t\t\tpropLat = geocodeResult.lat;\n\t\t\t\t\tpropLon = geocodeResult.lon;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tname: prop.name || \"Additional Property\",\n\t\t\t\taddress: prop.address,\n\t\t\t\taddress2: prop.address2 || null,\n\t\t\t\tcity: prop.city,\n\t\t\t\tstate: prop.state,\n\t\t\t\tzip_code: prop.zipCode,\n\t\t\t\tcountry: prop.country || \"USA\",\n\t\t\t\tproperty_type: prop.propertyType || \"residential\",\n\t\t\t\tnotes: prop.notes || null,\n\t\t\t\tlat: propLat,\n\t\t\t\tlon: propLon,\n\t\t\t};\n\t\t}),\n\t);\n\n\tawait supabase.from(\"properties\").insert(propertiesToInsert);\n}\n\n/**\n * Update existing customer\n */\nasync function updateCustomer(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Parse tags if provided\n\t\tlet tags: string[] | undefined;\n\t\tconst tagsString = formData.get(\"tags\");\n\t\tif (tagsString && typeof tagsString === \"string\") {\n\t\t\ttry {\n\t\t\t\ttags = JSON.parse(tagsString);\n\t\t\t} catch {\n\t\t\t\ttags = tagsString.split(\",\").map((t) => t.trim());\n\t\t\t}\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = customerSchema.parse({\n\t\t\ttype: formData.get(\"type\") || \"residential\",\n\t\t\tfirstName: formData.get(\"firstName\"),\n\t\t\tlastName: formData.get(\"lastName\"),\n\t\t\tcompanyName: formData.get(\"companyName\") || undefined,\n\t\t\temail: formData.get(\"email\"),\n\t\t\tphone: formData.get(\"phone\"),\n\t\t\tsecondaryPhone: formData.get(\"secondaryPhone\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzipCode: formData.get(\"zipCode\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\tsource: formData.get(\"source\") || undefined,\n\t\t\treferredBy: formData.get(\"referredBy\") || null,\n\t\t\tpreferredContactMethod: formData.get(\"preferredContactMethod\") || \"email\",\n\t\t\tpreferredTechnician: formData.get(\"preferredTechnician\") || null,\n\t\t\tbillingEmail: formData.get(\"billingEmail\") || null,\n\t\t\tpaymentTerms: formData.get(\"paymentTerms\") || \"due_on_receipt\",\n\t\t\tcreditLimit: formData.get(\"creditLimit\")\n\t\t\t\t? Number(formData.get(\"creditLimit\"))\n\t\t\t\t: 0,\n\t\t\ttaxExempt: formData.get(\"taxExempt\") === \"true\",\n\t\t\ttaxExemptNumber: formData.get(\"taxExemptNumber\") || undefined,\n\t\t\ttags,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternalNotes: formData.get(\"internalNotes\") || undefined,\n\t\t});\n\n\t\t// Check if email already exists (excluding current customer)\n\t\tif (data.email !== customer.email) {\n\t\t\tconst { data: existingEmail } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"email\", data.email)\n\t\t\t\t.neq(\"id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (existingEmail) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"A customer with this email already exists\",\n\t\t\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Generate display name\n\t\tconst displayName =\n\t\t\tdata.type === \"commercial\" && data.companyName\n\t\t\t\t? data.companyName\n\t\t\t\t: `${data.firstName} ${data.lastName}`;\n\n\t\tconst companyName = data.companyName ? String(data.companyName) : null;\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttype: data.type,\n\t\t\t\tfirst_name: data.firstName,\n\t\t\t\tlast_name: data.lastName,\n\t\t\t\tcompany_name: companyName,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondaryPhone,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zipCode,\n\t\t\t\tcountry: data.country,\n\t\t\t\tsource: data.source,\n\t\t\t\treferred_by: data.referredBy,\n\t\t\t\tpreferred_contact_method: data.preferredContactMethod,\n\t\t\t\tpreferred_technician: data.preferredTechnician,\n\t\t\t\tbilling_email: data.billingEmail,\n\t\t\t\tpayment_terms: data.paymentTerms,\n\t\t\t\tcredit_limit: data.creditLimit,\n\t\t\t\ttax_exempt: data.taxExempt,\n\t\t\t\ttax_exempt_number: data.taxExemptNumber,\n\t\t\t\ttags: data.tags,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internalNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Delete customer (soft delete/archive)\n */\nexport async function deleteCustomer(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, outstanding_balance\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent deletion if customer has outstanding balance\n\t\tif (customer.outstanding_balance > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot delete customer with outstanding balance. Collect payment first.\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"delete customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t});\n}\n\n// ============================================================================\n// CUSTOMER STATUS & PREFERENCES\n// ============================================================================\n\n/**\n * Update customer status\n */\nasync function updateCustomerStatus(\n\tcustomerId: string,\n\tstatus: \"active\" | \"inactive\" | \"archived\" | \"blocked\",\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Update communication preferences\n */\nasync function updateCommunicationPreferences(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Validate input\n\t\tconst preferences = communicationPreferencesSchema.parse({\n\t\t\temail: formData.get(\"email\") === \"true\",\n\t\t\tsms: formData.get(\"sms\") === \"true\",\n\t\t\tphone: formData.get(\"phone\") === \"true\",\n\t\t\tmarketing: formData.get(\"marketing\") === \"true\",\n\t\t});\n\n\t\t// Update preferences\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ communication_preferences: preferences })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update communication preferences\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// CUSTOMER PORTAL\n// ============================================================================\n\n/**\n * Invite customer to portal\n * Sends an email with a secure token-based invitation link.\n */\nasync function inviteToPortal(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email, display_name, portal_enabled\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (customer.portal_enabled) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer is already invited to portal\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Generate secure portal invitation token\n\t\tconst inviteToken = Buffer.from(\n\t\t\t`${customerId}:${Date.now()}:${Math.random()}`,\n\t\t).toString(\"base64url\");\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tportal_enabled: true,\n\t\t\t\tportal_invited_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"invite customer to portal\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Send invitation email\n\t\tconst siteUrl = requireSiteUrl();\n\t\tconst portalUrl = `${siteUrl}/portal/setup?token=${inviteToken}`;\n\n\t\tconst emailResult = await sendEmail({\n\t\t\tto: customer.email,\n\t\t\tsubject: \"You've been invited to your Customer Portal\",\n\t\t\ttemplate: PortalInvitationEmail({\n\t\t\t\tcustomerName: customer.display_name,\n\t\t\t\tportalUrl,\n\t\t\t\texpiresInHours: 168, // 7 days\n\t\t\t\tsupportEmail: process.env.RESEND_FROM_EMAIL || \"support@thorbis.com\",\n\t\t\t\tsupportPhone: \"(555) 123-4567\",\n\t\t\t}),\n\t\t\ttemplateType: EmailTemplate.PORTAL_INVITATION,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treturn;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Revoke portal access\n */\nasync function revokePortalAccess(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Revoke access\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ portal_enabled: false })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"revoke portal access\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// SEARCH & REPORTING\n// ============================================================================\n\n/**\n * Get customer by phone number\n * Used for incoming call lookups\n */\nexport async function getCustomerByPhone(\n\tphoneNumber: string,\n\tcompanyId: string,\n): Promise<ActionResult<unknown>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Normalize phone number (remove formatting)\n\t\tconst normalizedPhone = phoneNumber.replace(/\\D/g, \"\");\n\n\t\t// Search by primary phone or secondary phone\n\t\tconst { data: customer, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        properties:properties(*)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(\n\t\t\t\t`phone.eq.${phoneNumber},phone.eq.${normalizedPhone},secondary_phone.eq.${phoneNumber},secondary_phone.eq.${normalizedPhone}`,\n\t\t\t)\n\t\t\t.single();\n\n\t\tif (error && error.code !== \"PGRST116\") {\n\t\t\t// PGRST116 = no rows found\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customer || null;\n\t});\n}\n\n/**\n * Search customers by name, email, phone, or company\n */\nexport async function searchCustomers(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the active company ID helper (same as getAllCustomers)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\t// Searches across: first_name, last_name, display_name, email, phone,\n\t\t// secondary_phone, company_name, address, city, state\n\t\t// Returns results ordered by relevance (weighted: name > contact > address)\n\t\tconst { searchCustomersFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst customers = await searchCustomersFullText(\n\t\t\tsupabase,\n\t\t\tactiveCompanyId,\n\t\t\tsearchTerm,\n\t\t\t{\n\t\t\t\tlimit: options?.limit || DEFAULT_SEARCH_LIMIT,\n\t\t\t\toffset: options?.offset || 0,\n\t\t\t},\n\t\t);\n\n\t\treturn customers;\n\t});\n}\n\n/**\n * Get top customers by revenue\n */\nasync function getTopCustomers(\n\tlimit = 10,\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch top customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get customers with outstanding balance\n */\ntype CustomerWithBalance = {\n\tid: string;\n\tdisplay_name: string;\n\tbalance: number;\n};\n\nasync function getCustomersWithBalance(): Promise<\n\tActionResult<CustomerWithBalance[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gt(\"outstanding_balance\", 0)\n\t\t\t.order(\"outstanding_balance\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers with balance\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\ntype CustomerRecord = {\n\tid: string;\n\tcompany_id: string;\n\ttype: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\tcompany_name?: string | null;\n\temail: string;\n\tphone: string;\n\tsecondary_phone?: string;\n\taddress?: string;\n\taddress2?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip_code?: string;\n\tstatus: string;\n\ttotal_revenue?: number;\n\ttotal_jobs?: number;\n\ttotal_invoices?: number;\n\toutstanding_balance?: number;\n\tlast_job_date?: string;\n\tnext_scheduled_job?: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tarchived_at?: string | null;\n\tdeleted_at?: string | null;\n};\n\n/**\n * Get customers for phone dialer (lightweight, no enrichment)\n *\n * PERFORMANCE: Returns only basic contact info needed for dialer.\n * Use this instead of getAllCustomers() in AppHeader to avoid N+1 queries.\n *\n * Expected: 50-100ms (single query)\n * vs getAllCustomers(): 1200-2000ms (151 queries with enrichment)\n */\nexport async function getCustomersForDialer(): Promise<\n\tActionResult<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tfirst_name: string | null;\n\t\t\tlast_name: string | null;\n\t\t\tdisplay_name: string | null;\n\t\t\temail: string | null;\n\t\t\tphone: string | null;\n\t\t\tsecondary_phone?: string | null;\n\t\t\tcompany_name: string | null;\n\t\t\taddress: string | null;\n\t\t\taddress2: string | null;\n\t\t\tcity: string | null;\n\t\t\tstate: string | null;\n\t\t\tzip_code: string | null;\n\t\t}>\n\t>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Single lightweight query - no joins, no enrichment\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t\"id, first_name, last_name, display_name, email, phone, secondary_phone, company_name, address, address2, city, state, zip_code\",\n\t\t\t)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get all customers for the current company (WITH ENRICHMENT)\n *\n * WARNING: This function does 151 database queries for 50 customers (N+1 pattern).\n * Expected time: 1200-2000ms\n *\n * DO NOT use in AppHeader or other frequently rendered components.\n * Use getCustomersForDialer() instead for lightweight contact info.\n *\n * Only use this on dedicated customer list pages where the enriched data is needed.\n */\nasync function getAllCustomers(): Promise<\n\tActionResult<CustomerRecord[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID (from cookie or first available)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\n\t\tconst FORBIDDEN_STATUS_CODE = 403;\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Use RPC function instead of N+1 queries\n\t\t// BEFORE: 151 queries for 50 customers (1 base + 50 Ã— 3 queries each)\n\t\t// AFTER: 1 RPC call with efficient LATERAL joins\n\t\t// Performance gain: 5-10 seconds faster\n\n\t\t// Note: customers variable contains the base customer data from above query\n\t\t// We replace the enrichment logic with a single RPC call\n\t\tconst { data: enrichedData, error: enrichError } = await supabase.rpc(\n\t\t\t\"get_enriched_customers_rpc\",\n\t\t\t{\n\t\t\t\tp_company_id: activeCompanyId,\n\t\t\t},\n\t\t);\n\n\t\tif (enrichError) {\n\t\t\t// Fallback to base customers if enrichment fails\n\t\t\tconsole.error(\"Failed to enrich customers:\", enrichError);\n\t\t\treturn customers as CustomerRecord[];\n\t\t}\n\n\t\t// Merge enriched data with base customer data\n\t\tconst enrichedCustomers = (enrichedData || []).map((customer: any) => ({\n\t\t\t...customer,\n\t\t\t// Override total_jobs and total_revenue with fresh aggregated values\n\t\t\ttotal_jobs: customer.enriched_total_jobs || customer.total_jobs || 0,\n\t\t\ttotal_revenue:\n\t\t\t\tcustomer.enriched_total_revenue || customer.total_revenue || 0,\n\t\t}));\n\n\t\treturn enrichedCustomers as CustomerRecord[];\n\t});\n}\n\n/**\n * Update customer page content (Novel/Tiptap JSON)\n *\n * Saves the customer's editable page layout and content\n * Used by the Novel editor for auto-save functionality\n */\nasync function updateCustomerPageContent(\n\tcustomerId: string,\n\tpageContent: Record<string, unknown>,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"customer\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update page content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tpage_content: pageContent,\n\t\t\t\tcontent_updated_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer page\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAwoCsB,kBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/web/src/actions/customers.ts"],"sourcesContent":["/**\n * Customer Management Server Actions\n *\n * Comprehensive customer relationship management with:\n * - Customer CRUD operations\n * - Customer portal invitation and access\n * - Customer metrics tracking (revenue, jobs, invoices)\n * - Communication preferences\n * - Soft delete/archive support\n * - Customer search and filtering\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { geocodeAddressSilent } from \"@/lib/services/geocoding\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport PortalInvitationEmail from \"../../emails/templates/customer/portal-invitation\";\n\n// ============================================================================\n// VALIDATION SCHEMAS\n// ============================================================================\n\nconst CUSTOMER_NAME_MAX_LENGTH = 100;\nconst CUSTOMER_COMPANY_MAX_LENGTH = 200;\nconst CUSTOMER_PHONE_MAX_LENGTH = 20;\nconst CUSTOMER_ADDRESS_MAX_LENGTH = 200;\nconst CUSTOMER_ADDRESS2_MAX_LENGTH = 100;\nconst CUSTOMER_CITY_MAX_LENGTH = 100;\nconst CUSTOMER_STATE_MAX_LENGTH = 50;\n\n// HTTP Status codes\nconst HTTP_STATUS_FORBIDDEN = 403;\n\n// Search defaults\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst CUSTOMER_ZIP_MAX_LENGTH = 20;\nconst CUSTOMER_COUNTRY_MAX_LENGTH = 50;\nconst CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH = 50;\nconst CENTS_PER_DOLLAR = 100;\n\nfunction requireSiteUrl(): string {\n\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\tif (!siteUrl) {\n\t\tthrow new ActionError(\n\t\t\t\"NEXT_PUBLIC_SITE_URL is not configured\",\n\t\t\tERROR_CODES.INTERNAL_SERVER_ERROR,\n\t\t);\n\t}\n\treturn siteUrl.replace(/\\/$/, \"\");\n}\n\nconst customerSchema = z.object({\n\ttype: z\n\t\t.enum([\"residential\", \"commercial\", \"industrial\"])\n\t\t.default(\"residential\"),\n\tfirstName: z\n\t\t.string()\n\t\t.min(1, \"First name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tlastName: z\n\t\t.string()\n\t\t.min(1, \"Last name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tcompanyName: z.string().max(CUSTOMER_COMPANY_MAX_LENGTH).optional(),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z.string().min(1, \"Phone is required\").max(CUSTOMER_PHONE_MAX_LENGTH),\n\tsecondaryPhone: z.string().max(CUSTOMER_PHONE_MAX_LENGTH).optional(),\n\taddress: z.string().max(CUSTOMER_ADDRESS_MAX_LENGTH).optional(),\n\taddress2: z.string().max(CUSTOMER_ADDRESS2_MAX_LENGTH).optional(),\n\tcity: z.string().max(CUSTOMER_CITY_MAX_LENGTH).optional(),\n\tstate: z.string().max(CUSTOMER_STATE_MAX_LENGTH).optional(),\n\tzipCode: z.string().max(CUSTOMER_ZIP_MAX_LENGTH).optional(),\n\tcountry: z.string().max(CUSTOMER_COUNTRY_MAX_LENGTH).default(\"USA\"),\n\tsource: z\n\t\t.enum([\"referral\", \"google\", \"facebook\", \"direct\", \"yelp\", \"other\"])\n\t\t.optional(),\n\treferredBy: z.string().uuid().optional().nullable(),\n\tpreferredContactMethod: z.enum([\"email\", \"phone\", \"sms\"]).default(\"email\"),\n\tpreferredTechnician: z.string().uuid().optional().nullable(),\n\tbillingEmail: z.string().email().optional().nullable(),\n\tpaymentTerms: z\n\t\t.enum([\"due_on_receipt\", \"net_15\", \"net_30\", \"net_60\"])\n\t\t.default(\"due_on_receipt\"),\n\tcreditLimit: z.number().int().min(0).default(0), // In cents\n\ttaxExempt: z.boolean().default(false),\n\ttaxExemptNumber: z\n\t\t.string()\n\t\t.max(CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH)\n\t\t.optional(),\n\ttags: z.array(z.string()).optional(),\n\tnotes: z.string().optional(),\n\tinternalNotes: z.string().optional(),\n});\n\nconst communicationPreferencesSchema = z.object({\n\temail: z.boolean().default(true),\n\tsms: z.boolean().default(true),\n\tphone: z.boolean().default(true),\n\tmarketing: z.boolean().default(false),\n});\n\n// ============================================================================\n// CUSTOMER CRUD OPERATIONS\n// ============================================================================\n\n/**\n * Create a new customer with multiple contacts and properties\n */\nasync function createCustomer(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\t\tconst { contacts, properties, tags } =\n\t\t\tparseCustomerContactsPropertiesAndTags(formData);\n\t\tconst primaryContact = getPrimaryContactOrThrow(contacts);\n\t\tconst primaryProperty = getPrimaryProperty(properties);\n\n\t\tawait assertCustomerEmailNotDuplicate(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tprimaryContact.email,\n\t\t);\n\n\t\tconst customerType = formData.get(\"type\") || \"residential\";\n\t\tconst companyName = formData.get(\"companyName\");\n\t\tconst displayName = buildCustomerDisplayName(\n\t\t\tcustomerType,\n\t\t\tcompanyName,\n\t\t\tprimaryContact,\n\t\t);\n\n\t\tconst communicationPreferences = buildDefaultCommunicationPreferences();\n\t\tconst customerMetadata = buildCustomerMetadata(contacts);\n\n\t\tconst { lat: customerLat, lon: customerLon } =\n\t\t\tawait geocodePrimaryPropertyIfAvailable(primaryProperty);\n\n\t\tconst customer = await insertCustomerRecord(supabase, {\n\t\t\tcompanyId: teamMember.company_id,\n\t\t\tcustomerType,\n\t\t\tprimaryContact,\n\t\t\tcompanyNameValue: companyName,\n\t\t\tdisplayName,\n\t\t\tprimaryProperty,\n\t\t\tcustomerLat,\n\t\t\tcustomerLon,\n\t\t\tformData,\n\t\t\ttags,\n\t\t\tcommunicationPreferences,\n\t\t\tcustomerMetadata,\n\t\t});\n\n\t\tawait insertAdditionalPropertiesIfAny(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tcustomer.id,\n\t\t\tproperties,\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\treturn customer.id;\n\t});\n}\n\ntype ParsedCustomerContact = {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n\tphone: string;\n\trole: string;\n\tisPrimary: boolean;\n};\n\ntype ParsedCustomerProperty = {\n\tname: string;\n\taddress: string;\n\taddress2: string;\n\tcity: string;\n\tstate: string;\n\tzipCode: string;\n\tcountry: string;\n\tpropertyType: string;\n\tisPrimary: boolean;\n\tnotes: string;\n};\n\ntype ParsedCustomerFormCollections = {\n\tcontacts: ParsedCustomerContact[];\n\tproperties: ParsedCustomerProperty[];\n\ttags?: string[];\n};\n\nasync function requireCustomerCompanyMembership(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n) {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember;\n}\n\nfunction parseCustomerContactsPropertiesAndTags(\n\tformData: FormData,\n): ParsedCustomerFormCollections {\n\tconst contacts = parseContacts(formData.get(\"contacts\"));\n\tconst properties = parseProperties(formData.get(\"properties\"));\n\tconst tags = parseTagsField(formData.get(\"tags\"));\n\n\treturn { contacts, properties, tags };\n}\n\nfunction parseContacts(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerContact[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerContact[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid contacts data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseProperties(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerProperty[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerProperty[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid properties data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseTagsField(\n\tvalue: FormDataEntryValue | null,\n): string[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as string[];\n\t} catch {\n\t\treturn value.split(\",\").map((t) => t.trim());\n\t}\n}\n\nfunction getPrimaryContactOrThrow(\n\tcontacts: ParsedCustomerContact[],\n): ParsedCustomerContact {\n\tconst primaryContact = contacts.find((c) => c.isPrimary) || contacts[0];\n\tif (!primaryContact) {\n\t\tthrow new ActionError(\n\t\t\t\"At least one contact is required\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\treturn primaryContact;\n}\n\nfunction getPrimaryProperty(\n\tproperties: ParsedCustomerProperty[],\n): ParsedCustomerProperty | undefined {\n\treturn properties.find((p) => p.isPrimary) || properties[0];\n}\n\nasync function assertCustomerEmailNotDuplicate(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\temail: string,\n) {\n\tconst { data: existingEmail } = await supabase\n\t\t.from(\"customers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"email\", email)\n\t\t.is(\"deleted_at\", null)\n\t\t.single();\n\n\tif (existingEmail) {\n\t\tthrow new ActionError(\n\t\t\t\"A customer with this email already exists\",\n\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t);\n\t}\n}\n\nfunction buildCustomerDisplayName(\n\tcustomerType: FormDataEntryValue | null,\n\tcompanyNameValue: FormDataEntryValue | null,\n\tprimaryContact: ParsedCustomerContact,\n): string {\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\tif (customerType === \"commercial\" && companyName) {\n\t\treturn companyName;\n\t}\n\n\treturn `${primaryContact.firstName} ${primaryContact.lastName}`;\n}\n\nfunction buildDefaultCommunicationPreferences() {\n\treturn {\n\t\temail: true,\n\t\tsms: true,\n\t\tphone: true,\n\t\tmarketing: false,\n\t};\n}\n\nfunction buildCustomerMetadata(contacts: ParsedCustomerContact[]) {\n\treturn {\n\t\tcontacts: contacts.map((c) => ({\n\t\t\tfirstName: c.firstName,\n\t\t\tlastName: c.lastName,\n\t\t\temail: c.email,\n\t\t\tphone: c.phone,\n\t\t\trole: c.role,\n\t\t\tisPrimary: c.isPrimary,\n\t\t})),\n\t};\n}\n\nasync function geocodePrimaryPropertyIfAvailable(\n\tprimaryProperty: ParsedCustomerProperty | undefined,\n): Promise<{ lat: number | null; lon: number | null }> {\n\tif (\n\t\t!(\n\t\t\tprimaryProperty?.address &&\n\t\t\tprimaryProperty.city &&\n\t\t\tprimaryProperty.state &&\n\t\t\tprimaryProperty.zipCode\n\t\t)\n\t) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\tconst geocodeResult = await geocodeAddressSilent(\n\t\tprimaryProperty.address,\n\t\tprimaryProperty.city,\n\t\tprimaryProperty.state,\n\t\tprimaryProperty.zipCode,\n\t\tprimaryProperty.country || \"USA\",\n\t);\n\n\tif (!geocodeResult) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\treturn { lat: geocodeResult.lat, lon: geocodeResult.lon };\n}\n\ntype InsertCustomerParams = {\n\tcompanyId: string;\n\tcustomerType: FormDataEntryValue | null;\n\tprimaryContact: ParsedCustomerContact;\n\tcompanyNameValue: FormDataEntryValue | null;\n\tdisplayName: string;\n\tprimaryProperty?: ParsedCustomerProperty;\n\tcustomerLat: number | null;\n\tcustomerLon: number | null;\n\tformData: FormData;\n\ttags?: string[];\n\tcommunicationPreferences: {\n\t\temail: boolean;\n\t\tsms: boolean;\n\t\tphone: boolean;\n\t\tmarketing: boolean;\n\t};\n\tcustomerMetadata: Record<string, unknown>;\n};\n\nasync function insertCustomerRecord(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tparams: InsertCustomerParams,\n) {\n\tconst payload = buildCustomerInsertPayload(params);\n\n\tconst { data: customer, error: createError } = await supabase\n\t\t.from(\"customers\")\n\t\t.insert(payload)\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (createError || !customer) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(\"create customer\"),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn customer;\n}\n\nfunction buildCustomerInsertPayload(\n\tparams: InsertCustomerParams,\n): Record<string, unknown> {\n\tconst {\n\t\tcompanyId,\n\t\tcustomerType,\n\t\tprimaryContact,\n\t\tcompanyNameValue,\n\t\tdisplayName,\n\t\tprimaryProperty,\n\t\tcustomerLat,\n\t\tcustomerLon,\n\t\tformData,\n\t\ttags,\n\t\tcommunicationPreferences,\n\t\tcustomerMetadata,\n\t} = params;\n\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\ttype: String(customerType || \"residential\"),\n\t\tfirst_name: primaryContact.firstName,\n\t\tlast_name: primaryContact.lastName,\n\t\tcompany_name: companyName,\n\t\tdisplay_name: displayName,\n\t\temail: primaryContact.email,\n\t\tphone: primaryContact.phone,\n\t\tsecondary_phone: null,\n\t\taddress: primaryProperty?.address || null,\n\t\taddress2: primaryProperty?.address2 || null,\n\t\tcity: primaryProperty?.city || null,\n\t\tstate: primaryProperty?.state || null,\n\t\tzip_code: primaryProperty?.zipCode || null,\n\t\tcountry: primaryProperty?.country || \"USA\",\n\t\tlat: customerLat,\n\t\tlon: customerLon,\n\t\tsource: formData.get(\"source\") ? String(formData.get(\"source\")) : null,\n\t\treferred_by: formData.get(\"referredBy\")\n\t\t\t? String(formData.get(\"referredBy\"))\n\t\t\t: null,\n\t\tpreferred_contact_method:\n\t\t\tString(formData.get(\"preferredContactMethod\")) || \"email\",\n\t\tpreferred_technician: formData.get(\"preferredTechnician\")\n\t\t\t? String(formData.get(\"preferredTechnician\"))\n\t\t\t: null,\n\t\tbilling_email: formData.get(\"billingEmail\")\n\t\t\t? String(formData.get(\"billingEmail\"))\n\t\t\t: null,\n\t\tpayment_terms: String(formData.get(\"paymentTerms\")) || \"due_on_receipt\",\n\t\tcredit_limit: formData.get(\"creditLimit\")\n\t\t\t? Number(formData.get(\"creditLimit\")) * CENTS_PER_DOLLAR\n\t\t\t: 0,\n\t\ttax_exempt: formData.get(\"taxExempt\") === \"on\",\n\t\ttax_exempt_number: formData.get(\"taxExemptNumber\")\n\t\t\t? String(formData.get(\"taxExemptNumber\"))\n\t\t\t: null,\n\t\ttags: tags || null,\n\t\tcommunication_preferences: communicationPreferences,\n\t\tnotes: formData.get(\"notes\") ? String(formData.get(\"notes\")) : null,\n\t\tinternal_notes: formData.get(\"internalNotes\")\n\t\t\t? String(formData.get(\"internalNotes\"))\n\t\t\t: null,\n\t\tmetadata: customerMetadata,\n\t\tstatus: \"active\",\n\t\tportal_enabled: false,\n\t\ttotal_revenue: 0,\n\t\ttotal_jobs: 0,\n\t\ttotal_invoices: 0,\n\t\taverage_job_value: 0,\n\t\toutstanding_balance: 0,\n\t};\n}\n\nasync function insertAdditionalPropertiesIfAny(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\tcustomerId: string,\n\tproperties: ParsedCustomerProperty[],\n) {\n\tconst additionalProperties = properties.filter((p) => !p.isPrimary);\n\tif (additionalProperties.length === 0) {\n\t\treturn;\n\t}\n\n\tconst propertiesToInsert = await Promise.all(\n\t\tadditionalProperties.map(async (prop) => {\n\t\t\tlet propLat: number | null = null;\n\t\t\tlet propLon: number | null = null;\n\n\t\t\tif (prop.address && prop.city && prop.state && prop.zipCode) {\n\t\t\t\tconst geocodeResult = await geocodeAddressSilent(\n\t\t\t\t\tprop.address,\n\t\t\t\t\tprop.city,\n\t\t\t\t\tprop.state,\n\t\t\t\t\tprop.zipCode,\n\t\t\t\t\tprop.country || \"USA\",\n\t\t\t\t);\n\n\t\t\t\tif (geocodeResult) {\n\t\t\t\t\tpropLat = geocodeResult.lat;\n\t\t\t\t\tpropLon = geocodeResult.lon;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tname: prop.name || \"Additional Property\",\n\t\t\t\taddress: prop.address,\n\t\t\t\taddress2: prop.address2 || null,\n\t\t\t\tcity: prop.city,\n\t\t\t\tstate: prop.state,\n\t\t\t\tzip_code: prop.zipCode,\n\t\t\t\tcountry: prop.country || \"USA\",\n\t\t\t\tproperty_type: prop.propertyType || \"residential\",\n\t\t\t\tnotes: prop.notes || null,\n\t\t\t\tlat: propLat,\n\t\t\t\tlon: propLon,\n\t\t\t};\n\t\t}),\n\t);\n\n\tawait supabase.from(\"properties\").insert(propertiesToInsert);\n}\n\n/**\n * Update existing customer\n */\nasync function updateCustomer(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Parse tags if provided\n\t\tlet tags: string[] | undefined;\n\t\tconst tagsString = formData.get(\"tags\");\n\t\tif (tagsString && typeof tagsString === \"string\") {\n\t\t\ttry {\n\t\t\t\ttags = JSON.parse(tagsString);\n\t\t\t} catch {\n\t\t\t\ttags = tagsString.split(\",\").map((t) => t.trim());\n\t\t\t}\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = customerSchema.parse({\n\t\t\ttype: formData.get(\"type\") || \"residential\",\n\t\t\tfirstName: formData.get(\"firstName\"),\n\t\t\tlastName: formData.get(\"lastName\"),\n\t\t\tcompanyName: formData.get(\"companyName\") || undefined,\n\t\t\temail: formData.get(\"email\"),\n\t\t\tphone: formData.get(\"phone\"),\n\t\t\tsecondaryPhone: formData.get(\"secondaryPhone\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzipCode: formData.get(\"zipCode\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\tsource: formData.get(\"source\") || undefined,\n\t\t\treferredBy: formData.get(\"referredBy\") || null,\n\t\t\tpreferredContactMethod: formData.get(\"preferredContactMethod\") || \"email\",\n\t\t\tpreferredTechnician: formData.get(\"preferredTechnician\") || null,\n\t\t\tbillingEmail: formData.get(\"billingEmail\") || null,\n\t\t\tpaymentTerms: formData.get(\"paymentTerms\") || \"due_on_receipt\",\n\t\t\tcreditLimit: formData.get(\"creditLimit\")\n\t\t\t\t? Number(formData.get(\"creditLimit\"))\n\t\t\t\t: 0,\n\t\t\ttaxExempt: formData.get(\"taxExempt\") === \"true\",\n\t\t\ttaxExemptNumber: formData.get(\"taxExemptNumber\") || undefined,\n\t\t\ttags,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternalNotes: formData.get(\"internalNotes\") || undefined,\n\t\t});\n\n\t\t// Check if email already exists (excluding current customer)\n\t\tif (data.email !== customer.email) {\n\t\t\tconst { data: existingEmail } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"email\", data.email)\n\t\t\t\t.neq(\"id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (existingEmail) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"A customer with this email already exists\",\n\t\t\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Generate display name\n\t\tconst displayName =\n\t\t\tdata.type === \"commercial\" && data.companyName\n\t\t\t\t? data.companyName\n\t\t\t\t: `${data.firstName} ${data.lastName}`;\n\n\t\tconst companyName = data.companyName ? String(data.companyName) : null;\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttype: data.type,\n\t\t\t\tfirst_name: data.firstName,\n\t\t\t\tlast_name: data.lastName,\n\t\t\t\tcompany_name: companyName,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondaryPhone,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zipCode,\n\t\t\t\tcountry: data.country,\n\t\t\t\tsource: data.source,\n\t\t\t\treferred_by: data.referredBy,\n\t\t\t\tpreferred_contact_method: data.preferredContactMethod,\n\t\t\t\tpreferred_technician: data.preferredTechnician,\n\t\t\t\tbilling_email: data.billingEmail,\n\t\t\t\tpayment_terms: data.paymentTerms,\n\t\t\t\tcredit_limit: data.creditLimit,\n\t\t\t\ttax_exempt: data.taxExempt,\n\t\t\t\ttax_exempt_number: data.taxExemptNumber,\n\t\t\t\ttags: data.tags,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internalNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Delete customer (soft delete/archive)\n */\nexport async function deleteCustomer(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, outstanding_balance\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent deletion if customer has outstanding balance\n\t\tif (customer.outstanding_balance > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot delete customer with outstanding balance. Collect payment first.\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"delete customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t});\n}\n\n// ============================================================================\n// CUSTOMER STATUS & PREFERENCES\n// ============================================================================\n\n/**\n * Update customer status\n */\nasync function updateCustomerStatus(\n\tcustomerId: string,\n\tstatus: \"active\" | \"inactive\" | \"archived\" | \"blocked\",\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Update communication preferences\n */\nasync function updateCommunicationPreferences(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Validate input\n\t\tconst preferences = communicationPreferencesSchema.parse({\n\t\t\temail: formData.get(\"email\") === \"true\",\n\t\t\tsms: formData.get(\"sms\") === \"true\",\n\t\t\tphone: formData.get(\"phone\") === \"true\",\n\t\t\tmarketing: formData.get(\"marketing\") === \"true\",\n\t\t});\n\n\t\t// Update preferences\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ communication_preferences: preferences })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update communication preferences\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// CUSTOMER PORTAL\n// ============================================================================\n\n/**\n * Invite customer to portal\n * Sends an email with a secure token-based invitation link.\n */\nasync function inviteToPortal(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email, display_name, portal_enabled\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (customer.portal_enabled) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer is already invited to portal\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Generate secure portal invitation token\n\t\tconst inviteToken = Buffer.from(\n\t\t\t`${customerId}:${Date.now()}:${Math.random()}`,\n\t\t).toString(\"base64url\");\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tportal_enabled: true,\n\t\t\t\tportal_invited_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"invite customer to portal\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Send invitation email\n\t\tconst siteUrl = requireSiteUrl();\n\t\tconst portalUrl = `${siteUrl}/portal/setup?token=${inviteToken}`;\n\n\t\tconst emailResult = await sendEmail({\n\t\t\tto: customer.email,\n\t\t\tsubject: \"You've been invited to your Customer Portal\",\n\t\t\ttemplate: PortalInvitationEmail({\n\t\t\t\tcustomerName: customer.display_name,\n\t\t\t\tportalUrl,\n\t\t\t\texpiresInHours: 168, // 7 days\n\t\t\t\tsupportEmail: process.env.RESEND_FROM_EMAIL || \"support@thorbis.com\",\n\t\t\t\tsupportPhone: \"(555) 123-4567\",\n\t\t\t}),\n\t\t\ttemplateType: EmailTemplate.PORTAL_INVITATION,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treturn;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Revoke portal access\n */\nasync function revokePortalAccess(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Revoke access\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ portal_enabled: false })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"revoke portal access\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// SEARCH & REPORTING\n// ============================================================================\n\n/**\n * Get customer by phone number\n * Used for incoming call lookups\n */\nexport async function getCustomerByPhone(\n\tphoneNumber: string,\n\tcompanyId: string,\n): Promise<ActionResult<unknown>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Normalize phone number (remove formatting)\n\t\tconst normalizedPhone = phoneNumber.replace(/\\D/g, \"\");\n\n\t\t// Search by primary phone or secondary phone\n\t\tconst { data: customer, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        properties:properties(*)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(\n\t\t\t\t`phone.eq.${phoneNumber},phone.eq.${normalizedPhone},secondary_phone.eq.${phoneNumber},secondary_phone.eq.${normalizedPhone}`,\n\t\t\t)\n\t\t\t.single();\n\n\t\tif (error && error.code !== \"PGRST116\") {\n\t\t\t// PGRST116 = no rows found\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customer || null;\n\t});\n}\n\n/**\n * Search customers by name, email, phone, or company\n */\nexport async function searchCustomers(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the active company ID helper (same as getAllCustomers)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\t// Searches across: first_name, last_name, display_name, email, phone,\n\t\t// secondary_phone, company_name, address, city, state\n\t\t// Returns results ordered by relevance (weighted: name > contact > address)\n\t\tconst { searchCustomersFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst customers = await searchCustomersFullText(\n\t\t\tsupabase,\n\t\t\tactiveCompanyId,\n\t\t\tsearchTerm,\n\t\t\t{\n\t\t\t\tlimit: options?.limit || DEFAULT_SEARCH_LIMIT,\n\t\t\t\toffset: options?.offset || 0,\n\t\t\t},\n\t\t);\n\n\t\treturn customers;\n\t});\n}\n\n/**\n * Get top customers by revenue\n */\nasync function getTopCustomers(\n\tlimit = 10,\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch top customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get customers with outstanding balance\n */\ntype CustomerWithBalance = {\n\tid: string;\n\tdisplay_name: string;\n\tbalance: number;\n};\n\nasync function getCustomersWithBalance(): Promise<\n\tActionResult<CustomerWithBalance[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gt(\"outstanding_balance\", 0)\n\t\t\t.order(\"outstanding_balance\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers with balance\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\ntype CustomerRecord = {\n\tid: string;\n\tcompany_id: string;\n\ttype: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\tcompany_name?: string | null;\n\temail: string;\n\tphone: string;\n\tsecondary_phone?: string;\n\taddress?: string;\n\taddress2?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip_code?: string;\n\tstatus: string;\n\ttotal_revenue?: number;\n\ttotal_jobs?: number;\n\ttotal_invoices?: number;\n\toutstanding_balance?: number;\n\tlast_job_date?: string;\n\tnext_scheduled_job?: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tarchived_at?: string | null;\n\tdeleted_at?: string | null;\n};\n\n/**\n * Get customers for phone dialer (lightweight, no enrichment)\n *\n * PERFORMANCE: Returns only basic contact info needed for dialer.\n * Use this instead of getAllCustomers() in AppHeader to avoid N+1 queries.\n *\n * Expected: 50-100ms (single query)\n * vs getAllCustomers(): 1200-2000ms (151 queries with enrichment)\n */\nexport async function getCustomersForDialer(): Promise<\n\tActionResult<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tfirst_name: string | null;\n\t\t\tlast_name: string | null;\n\t\t\tdisplay_name: string | null;\n\t\t\temail: string | null;\n\t\t\tphone: string | null;\n\t\t\tsecondary_phone?: string | null;\n\t\t\tcompany_name: string | null;\n\t\t\taddress: string | null;\n\t\t\taddress2: string | null;\n\t\t\tcity: string | null;\n\t\t\tstate: string | null;\n\t\t\tzip_code: string | null;\n\t\t}>\n\t>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Single lightweight query - no joins, no enrichment\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t\"id, first_name, last_name, display_name, email, phone, secondary_phone, company_name, address, address2, city, state, zip_code\",\n\t\t\t)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get all customers for the current company (WITH ENRICHMENT)\n *\n * WARNING: This function does 151 database queries for 50 customers (N+1 pattern).\n * Expected time: 1200-2000ms\n *\n * DO NOT use in AppHeader or other frequently rendered components.\n * Use getCustomersForDialer() instead for lightweight contact info.\n *\n * Only use this on dedicated customer list pages where the enriched data is needed.\n */\nasync function getAllCustomers(): Promise<\n\tActionResult<CustomerRecord[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID (from cookie or first available)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\n\t\tconst FORBIDDEN_STATUS_CODE = 403;\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Use RPC function instead of N+1 queries\n\t\t// BEFORE: 151 queries for 50 customers (1 base + 50 Ã— 3 queries each)\n\t\t// AFTER: 1 RPC call with efficient LATERAL joins\n\t\t// Performance gain: 5-10 seconds faster\n\n\t\t// Note: customers variable contains the base customer data from above query\n\t\t// We replace the enrichment logic with a single RPC call\n\t\tconst { data: enrichedData, error: enrichError } = await supabase.rpc(\n\t\t\t\"get_enriched_customers_rpc\",\n\t\t\t{\n\t\t\t\tp_company_id: activeCompanyId,\n\t\t\t},\n\t\t);\n\n\t\tif (enrichError) {\n\t\t\t// Fallback to base customers if enrichment fails\n\t\t\tconsole.error(\"Failed to enrich customers:\", enrichError);\n\t\t\treturn customers as CustomerRecord[];\n\t\t}\n\n\t\t// Merge enriched data with base customer data\n\t\tconst enrichedCustomers = (enrichedData || []).map((customer: any) => ({\n\t\t\t...customer,\n\t\t\t// Override total_jobs and total_revenue with fresh aggregated values\n\t\t\ttotal_jobs: customer.enriched_total_jobs || customer.total_jobs || 0,\n\t\t\ttotal_revenue:\n\t\t\t\tcustomer.enriched_total_revenue || customer.total_revenue || 0,\n\t\t}));\n\n\t\treturn enrichedCustomers as CustomerRecord[];\n\t});\n}\n\n/**\n * Update customer page content (Novel/Tiptap JSON)\n *\n * Saves the customer's editable page layout and content\n * Used by the Novel editor for auto-save functionality\n */\nasync function updateCustomerPageContent(\n\tcustomerId: string,\n\tpageContent: Record<string, unknown>,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"customer\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update page content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tpage_content: pageContent,\n\t\t\t\tcontent_updated_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer page\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;IAm2CsB,wBAAA,WAAA,GAAA,IAAA,yZAAA,EAAA,8CAAA,8YAAA,EAAA,KAAA,GAAA,oZAAA,EAAA"}}]
}