{"version":3,"sources":["../../../../../apps/web/src/lib/email/audit-logger.ts","../../../../../apps/web/src/lib/email/gmail-rate-limiter.ts","../../../../../apps/web/src/lib/email/gmail-client.ts"],"sourcesContent":["/**\n * Email Security Audit Logger\n *\n * Logs security-relevant events for compliance, investigation, and monitoring.\n * All logs are stored in the database with retention policies.\n *\n * Events Logged:\n * - Gmail connections/disconnections\n * - Token refresh failures\n * - Permission grants/revokes\n * - Sync errors\n * - Email access (optional, for compliance)\n *\n * Usage:\n * await logAuditEvent('gmail_connected', { teamMemberId, email });\n * await logAuditEvent('permission_granted', { grantedBy, grantedTo, category });\n *\n * Database Table: email_audit_log (to be created)\n *\n * @see /docs/email/SECURITY_AUDIT.md\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport type { EmailCategory } from \"./email-permissions\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Audit event types\n */\nexport type AuditEventType =\n\t// Gmail OAuth events\n\t| \"gmail_connected\"\n\t| \"gmail_disconnected\"\n\t| \"gmail_token_refreshed\"\n\t| \"gmail_token_refresh_failed\"\n\t| \"gmail_token_revoked\"\n\t// Permission events\n\t| \"permission_granted\"\n\t| \"permission_revoked\"\n\t| \"permission_updated\"\n\t| \"permission_check_failed\"\n\t// Sync events\n\t| \"sync_started\"\n\t| \"sync_completed\"\n\t| \"sync_failed\"\n\t| \"sync_rate_limited\"\n\t// Email access events (optional)\n\t| \"email_accessed\"\n\t| \"email_sent\"\n\t| \"email_assigned\"\n\t// Security events\n\t| \"unauthorized_access_attempt\"\n\t| \"permission_escalation_attempt\"\n\t| \"invalid_oauth_state\"\n\t// System events\n\t| \"token_cleanup_executed\"\n\t| \"rate_limit_exceeded\";\n\n/**\n * Audit event severity levels\n */\nexport type AuditSeverity = \"info\" | \"warning\" | \"error\" | \"critical\";\n\n/**\n * Audit event metadata\n */\nexport interface AuditEventMetadata {\n\t// Common fields\n\tteamMemberId?: string;\n\tcompanyId?: string;\n\tuserId?: string; // auth.uid\n\tuserName?: string;\n\n\t// Gmail fields\n\tgmailEmail?: string;\n\tgmailMessageId?: string;\n\tsyncMessageCount?: number;\n\n\t// Permission fields\n\tcategory?: EmailCategory;\n\tgrantedBy?: string;\n\tgrantedTo?: string;\n\tcanRead?: boolean;\n\tcanSend?: boolean;\n\tcanAssign?: boolean;\n\n\t// Email fields\n\tcommunicationId?: string;\n\temailSubject?: string;\n\tfromAddress?: string;\n\ttoAddress?: string;\n\n\t// Error fields\n\terror?: string;\n\terrorCode?: string;\n\tstackTrace?: string;\n\n\t// Rate limiting\n\tretryAfter?: number;\n\trequestsPerMinute?: number;\n\n\t// Additional context\n\tipAddress?: string;\n\tuserAgent?: string;\n\t[key: string]: any;\n}\n\n/**\n * Audit event record\n */\nexport interface AuditEvent {\n\tid: string;\n\teventType: AuditEventType;\n\tseverity: AuditSeverity;\n\tmessage: string;\n\tmetadata: AuditEventMetadata;\n\tcreatedAt: string;\n}\n\n// =============================================================================\n// LOGGING FUNCTIONS\n// =============================================================================\n\n/**\n * Log an audit event\n *\n * @param eventType - Type of event\n * @param metadata - Event metadata\n * @param severity - Event severity (default: info)\n * @param message - Optional custom message\n *\n * @example\n * await logAuditEvent('gmail_connected', {\n *   teamMemberId: 'xxx',\n *   gmailEmail: 'user@gmail.com'\n * });\n */\nexport async function logAuditEvent(\n\teventType: AuditEventType,\n\tmetadata: AuditEventMetadata = {},\n\tseverity: AuditSeverity = \"info\",\n\tmessage?: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Generate default message if not provided\n\t\tconst defaultMessage = generateDefaultMessage(eventType, metadata);\n\n\t\t// In production, store in database\n\t\t// For now, log to console with structured format\n\t\tconst logEntry = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\teventType,\n\t\t\tseverity,\n\t\t\tmessage: message || defaultMessage,\n\t\t\tmetadata,\n\t\t};\n\n\t\t// Console output with color coding\n\t\tconst prefix = `[Email Audit]`;\n\t\tconst severityEmoji = {\n\t\t\tinfo: \"‚ÑπÔ∏è\",\n\t\t\twarning: \"‚ö†Ô∏è\",\n\t\t\terror: \"‚ùå\",\n\t\t\tcritical: \"üö®\",\n\t\t}[severity];\n\n\t\tconsole.log(\n\t\t\t`${prefix} ${severityEmoji} [${severity.toUpperCase()}] ${logEntry.message}`,\n\t\t\tmetadata,\n\t\t);\n\n\t\t// Store in database\n\t\ttry {\n\t\t\tconst supabase = await createServiceSupabaseClient();\n\t\t\tif (supabase) {\n\t\t\t\tawait supabase.from(\"email_audit_log\").insert({\n\t\t\t\t\tcompany_id: metadata.companyId || null,\n\t\t\t\t\tevent_type: eventType,\n\t\t\t\t\tseverity,\n\t\t\t\t\tmessage: logEntry.message,\n\t\t\t\t\tteam_member_id: metadata.teamMemberId || null,\n\t\t\t\t\tuser_id: metadata.userId || null,\n\t\t\t\t\tgmail_email: metadata.gmailEmail || null,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tip_address: metadata.ipAddress || null,\n\t\t\t\t\tuser_agent: metadata.userAgent || null,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (dbError) {\n\t\t\t// Don't fail the audit log if database write fails - console log is still captured\n\t\t\tconsole.error(\"[Email Audit] Failed to store in database:\", dbError);\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to log event:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Generate default message for event type\n */\nfunction generateDefaultMessage(\n\teventType: AuditEventType,\n\tmetadata: AuditEventMetadata,\n): string {\n\tconst name = metadata.userName || metadata.teamMemberId || \"User\";\n\n\tswitch (eventType) {\n\t\tcase \"gmail_connected\":\n\t\t\treturn `${name} connected Gmail account (${metadata.gmailEmail})`;\n\t\tcase \"gmail_disconnected\":\n\t\t\treturn `${name} disconnected Gmail account (${metadata.gmailEmail})`;\n\t\tcase \"gmail_token_refreshed\":\n\t\t\treturn `Gmail token refreshed for ${metadata.gmailEmail}`;\n\t\tcase \"gmail_token_refresh_failed\":\n\t\t\treturn `Failed to refresh Gmail token for ${metadata.gmailEmail}: ${metadata.error}`;\n\t\tcase \"gmail_token_revoked\":\n\t\t\treturn `Gmail token revoked for ${metadata.gmailEmail}`;\n\n\t\tcase \"permission_granted\":\n\t\t\treturn `${metadata.grantedBy} granted ${metadata.category} permissions to ${metadata.grantedTo}`;\n\t\tcase \"permission_revoked\":\n\t\t\treturn `${metadata.grantedBy} revoked ${metadata.category} permissions from ${metadata.grantedTo}`;\n\t\tcase \"permission_updated\":\n\t\t\treturn `${metadata.grantedBy} updated ${metadata.category} permissions for ${metadata.grantedTo}`;\n\t\tcase \"permission_check_failed\":\n\t\t\treturn `Permission check failed for ${name}: ${metadata.error}`;\n\n\t\tcase \"sync_started\":\n\t\t\treturn `${name} started inbox sync`;\n\t\tcase \"sync_completed\":\n\t\t\treturn `${name} completed inbox sync (${metadata.syncMessageCount} messages)`;\n\t\tcase \"sync_failed\":\n\t\t\treturn `Inbox sync failed for ${name}: ${metadata.error}`;\n\t\tcase \"sync_rate_limited\":\n\t\t\treturn `${name} sync rate limited (retry after ${metadata.retryAfter}s)`;\n\n\t\tcase \"email_accessed\":\n\t\t\treturn `${name} accessed email: ${metadata.emailSubject}`;\n\t\tcase \"email_sent\":\n\t\t\treturn `${name} sent email to ${metadata.toAddress}: ${metadata.emailSubject}`;\n\t\tcase \"email_assigned\":\n\t\t\treturn `${name} assigned email to ${metadata.grantedTo}`;\n\n\t\tcase \"unauthorized_access_attempt\":\n\t\t\treturn `Unauthorized access attempt by ${name}: ${metadata.error}`;\n\t\tcase \"permission_escalation_attempt\":\n\t\t\treturn `Permission escalation attempt by ${name}: ${metadata.error}`;\n\t\tcase \"invalid_oauth_state\":\n\t\t\treturn `Invalid OAuth state detected: ${metadata.error}`;\n\n\t\tcase \"token_cleanup_executed\":\n\t\t\treturn `Token cleanup executed: ${metadata.syncMessageCount} tokens removed`;\n\t\tcase \"rate_limit_exceeded\":\n\t\t\treturn `Rate limit exceeded for ${name} (${metadata.requestsPerMinute} req/min)`;\n\n\t\tdefault:\n\t\t\treturn `${eventType} event for ${name}`;\n\t}\n}\n\n// =============================================================================\n// CONVENIENCE FUNCTIONS\n// =============================================================================\n\n/**\n * Log Gmail connection\n */\nexport async function logGmailConnected(\n\tteamMemberId: string,\n\tuserName: string,\n\tgmailEmail: string,\n\tcompanyId: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"gmail_connected\",\n\t\t{ teamMemberId, userName, gmailEmail, companyId },\n\t\t\"info\",\n\t);\n}\n\n/**\n * Log Gmail disconnection\n */\nexport async function logGmailDisconnected(\n\tteamMemberId: string,\n\tuserName: string,\n\tgmailEmail: string,\n\tcompanyId: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"gmail_disconnected\",\n\t\t{ teamMemberId, userName, gmailEmail, companyId },\n\t\t\"info\",\n\t);\n}\n\n/**\n * Log token refresh failure\n */\nexport async function logTokenRefreshFailed(\n\tteamMemberId: string,\n\tgmailEmail: string,\n\terror: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"gmail_token_refresh_failed\",\n\t\t{ teamMemberId, gmailEmail, error },\n\t\t\"warning\",\n\t);\n}\n\n/**\n * Log permission grant\n */\nexport async function logPermissionGranted(\n\tgrantedBy: string,\n\tgrantedByName: string,\n\tgrantedTo: string,\n\tgrantedToName: string,\n\tcategory: EmailCategory,\n\tcompanyId: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"permission_granted\",\n\t\t{\n\t\t\tgrantedBy,\n\t\t\tuserName: grantedByName,\n\t\t\tgrantedTo,\n\t\t\tcategory,\n\t\t\tcompanyId,\n\t\t},\n\t\t\"info\",\n\t);\n}\n\n/**\n * Log permission revocation\n */\nexport async function logPermissionRevoked(\n\trevokedBy: string,\n\trevokedByName: string,\n\trevokedFrom: string,\n\trevokedFromName: string,\n\tcategory: EmailCategory,\n\tcompanyId: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"permission_revoked\",\n\t\t{\n\t\t\tgrantedBy: revokedBy,\n\t\t\tuserName: revokedByName,\n\t\t\tgrantedTo: revokedFrom,\n\t\t\tcategory,\n\t\t\tcompanyId,\n\t\t},\n\t\t\"info\",\n\t);\n}\n\n/**\n * Log sync failure\n */\nexport async function logSyncFailed(\n\tteamMemberId: string,\n\tuserName: string,\n\tgmailEmail: string,\n\terror: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"sync_failed\",\n\t\t{ teamMemberId, userName, gmailEmail, error },\n\t\t\"error\",\n\t);\n}\n\n/**\n * Log unauthorized access attempt\n */\nexport async function logUnauthorizedAccess(\n\tuserId: string,\n\tuserName: string,\n\tresource: string,\n\terror: string,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"unauthorized_access_attempt\",\n\t\t{ userId, userName, error, communicationId: resource },\n\t\t\"warning\",\n\t);\n}\n\n/**\n * Log rate limit exceeded\n */\nexport async function logRateLimitExceeded(\n\tuserId: string,\n\tuserName: string,\n\trequestsPerMinute: number,\n\tretryAfter: number,\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"rate_limit_exceeded\",\n\t\t{ userId, userName, requestsPerMinute, retryAfter },\n\t\t\"warning\",\n\t);\n}\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get audit events for a team member\n *\n * @param teamMemberId - Team member ID\n * @param limit - Max events to return\n * @returns List of audit events\n */\nexport async function getAuditEventsForUser(\n\tteamMemberId: string,\n\tlimit: number = 100,\n): Promise<AuditEvent[]> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tif (!supabase) return [];\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_audit_log\")\n\t\t\t.select(\"id, event_type, severity, message, metadata, created_at\")\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Email Audit] Failed to query events for user:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []).map((row) => ({\n\t\t\tid: row.id,\n\t\t\teventType: row.event_type as AuditEventType,\n\t\t\tseverity: row.severity as AuditSeverity,\n\t\t\tmessage: row.message,\n\t\t\tmetadata: row.metadata || {},\n\t\t\tcreatedAt: row.created_at,\n\t\t}));\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to query events for user:\", error);\n\t\treturn [];\n\t}\n}\n\n/**\n * Get audit events for a company\n *\n * @param companyId - Company ID\n * @param limit - Max events to return\n * @returns List of audit events\n */\nexport async function getAuditEventsForCompany(\n\tcompanyId: string,\n\tlimit: number = 100,\n): Promise<AuditEvent[]> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tif (!supabase) return [];\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_audit_log\")\n\t\t\t.select(\"id, event_type, severity, message, metadata, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Email Audit] Failed to query events for company:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []).map((row) => ({\n\t\t\tid: row.id,\n\t\t\teventType: row.event_type as AuditEventType,\n\t\t\tseverity: row.severity as AuditSeverity,\n\t\t\tmessage: row.message,\n\t\t\tmetadata: row.metadata || {},\n\t\t\tcreatedAt: row.created_at,\n\t\t}));\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to query events for company:\", error);\n\t\treturn [];\n\t}\n}\n\n/**\n * Get critical security events\n *\n * @param limit - Max events to return\n * @returns List of critical events\n */\nexport async function getCriticalSecurityEvents(\n\tlimit: number = 50,\n): Promise<AuditEvent[]> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tif (!supabase) return [];\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_audit_log\")\n\t\t\t.select(\"id, event_type, severity, message, metadata, created_at\")\n\t\t\t.in(\"severity\", [\"error\", \"critical\"])\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Email Audit] Failed to query critical events:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []).map((row) => ({\n\t\t\tid: row.id,\n\t\t\teventType: row.event_type as AuditEventType,\n\t\t\tseverity: row.severity as AuditSeverity,\n\t\t\tmessage: row.message,\n\t\t\tmetadata: row.metadata || {},\n\t\t\tcreatedAt: row.created_at,\n\t\t}));\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to query critical events:\", error);\n\t\treturn [];\n\t}\n}\n","/**\n * Gmail API Rate Limiter\n *\n * Prevents Gmail API quota exhaustion and abuse by implementing rate limits\n * at multiple levels: per-user, per-company, and global.\n *\n * Gmail API Quotas (Google-imposed):\n * - 1 billion quota units per day (project-wide)\n * - 250 quota units/user/second\n * - messages.get = 5 units, messages.list = 5 units\n *\n * Our Limits:\n * - Per-user: 1 sync every 5 minutes (max 12 syncs/hour)\n * - Per-user: Max 100 messages per sync\n * - Global: Max 10 concurrent syncs\n * - API endpoints: 60 requests/minute per user\n *\n * Implementation:\n * - In-memory rate limiting with Map (resets on server restart)\n * - Redis for distributed rate limiting (optional, for multi-server)\n * - Automatic cleanup of stale entries\n *\n * @see https://developers.google.com/gmail/api/reference/quota\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\ninterface RateLimitEntry {\n\tcount: number;\n\tfirstRequest: number;\n\tlastRequest: number;\n}\n\ninterface SyncLock {\n\tteamMemberId: string;\n\tstartedAt: number;\n\texpiresAt: number;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Minimum time between syncs per user (5 minutes) */\nconst SYNC_COOLDOWN_MS = 5 * 60 * 1000;\n\n/** Maximum messages per sync */\nconst MAX_MESSAGES_PER_SYNC = 100;\n\n/** Maximum concurrent syncs globally */\nconst MAX_CONCURRENT_SYNCS = 10;\n\n/** API rate limit: requests per window */\nconst API_RATE_LIMIT = 60;\n\n/** API rate limit window (1 minute) */\nconst API_RATE_WINDOW_MS = 60 * 1000;\n\n/** How long to keep rate limit entries in memory */\nconst RATE_LIMIT_CLEANUP_MS = 60 * 60 * 1000; // 1 hour\n\n/** How long a sync lock is valid (30 minutes max) */\nconst SYNC_LOCK_TIMEOUT_MS = 30 * 60 * 1000;\n\n// =============================================================================\n// IN-MEMORY STORAGE\n// =============================================================================\n\n/** Per-user API rate limits */\nconst apiRateLimits = new Map<string, RateLimitEntry>();\n\n/** Per-user last sync timestamps */\nconst lastSyncTimes = new Map<string, number>();\n\n/** Active sync locks */\nconst activeSyncLocks = new Set<SyncLock>();\n\n/** Cleanup interval */\nlet cleanupInterval: NodeJS.Timeout | null = null;\n\n// =============================================================================\n// RATE LIMIT CHECKING\n// =============================================================================\n\n/**\n * Check if user can make an API request\n *\n * @param userId - User ID (team_member_id)\n * @returns { allowed: boolean, retryAfter?: number }\n */\nexport function checkApiRateLimit(userId: string): {\n\tallowed: boolean;\n\tretryAfter?: number;\n} {\n\tconst now = Date.now();\n\tconst entry = apiRateLimits.get(userId);\n\n\tif (!entry) {\n\t\t// First request - allow and record\n\t\tapiRateLimits.set(userId, {\n\t\t\tcount: 1,\n\t\t\tfirstRequest: now,\n\t\t\tlastRequest: now,\n\t\t});\n\t\treturn { allowed: true };\n\t}\n\n\t// Check if window has expired\n\tconst windowAge = now - entry.firstRequest;\n\tif (windowAge > API_RATE_WINDOW_MS) {\n\t\t// Window expired - reset counter\n\t\tapiRateLimits.set(userId, {\n\t\t\tcount: 1,\n\t\t\tfirstRequest: now,\n\t\t\tlastRequest: now,\n\t\t});\n\t\treturn { allowed: true };\n\t}\n\n\t// Within window - check limit\n\tif (entry.count >= API_RATE_LIMIT) {\n\t\t// Rate limit exceeded\n\t\tconst retryAfter = Math.ceil(\n\t\t\t(entry.firstRequest + API_RATE_WINDOW_MS - now) / 1000,\n\t\t);\n\t\treturn { allowed: false, retryAfter };\n\t}\n\n\t// Increment counter\n\tentry.count++;\n\tentry.lastRequest = now;\n\tapiRateLimits.set(userId, entry);\n\n\treturn { allowed: true };\n}\n\n/**\n * Check if user can start a sync\n *\n * @param teamMemberId - Team member ID\n * @returns { allowed: boolean, reason?: string, retryAfter?: number }\n */\nexport function checkSyncRateLimit(teamMemberId: string): {\n\tallowed: boolean;\n\treason?: string;\n\tretryAfter?: number;\n} {\n\tconst now = Date.now();\n\n\t// Check sync cooldown\n\tconst lastSync = lastSyncTimes.get(teamMemberId);\n\tif (lastSync) {\n\t\tconst timeSinceLastSync = now - lastSync;\n\t\tif (timeSinceLastSync < SYNC_COOLDOWN_MS) {\n\t\t\tconst retryAfter = Math.ceil(\n\t\t\t\t(SYNC_COOLDOWN_MS - timeSinceLastSync) / 1000,\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tallowed: false,\n\t\t\t\treason: \"Sync cooldown active\",\n\t\t\t\tretryAfter,\n\t\t\t};\n\t\t}\n\t}\n\n\t// Check concurrent sync limit\n\tconst activeCount = getActiveSyncCount();\n\tif (activeCount >= MAX_CONCURRENT_SYNCS) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Maximum concurrent syncs reached\",\n\t\t\tretryAfter: 60, // Retry in 1 minute\n\t\t};\n\t}\n\n\t// Check if user already has active sync\n\tconst existingLock = Array.from(activeSyncLocks).find(\n\t\t(lock) => lock.teamMemberId === teamMemberId,\n\t);\n\n\tif (existingLock) {\n\t\t// Check if lock is expired\n\t\tif (now > existingLock.expiresAt) {\n\t\t\t// Lock expired - remove it\n\t\t\tactiveSyncLocks.delete(existingLock);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tallowed: false,\n\t\t\t\treason: \"Sync already in progress\",\n\t\t\t\tretryAfter: Math.ceil((existingLock.expiresAt - now) / 1000),\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { allowed: true };\n}\n\n// =============================================================================\n// SYNC LOCK MANAGEMENT\n// =============================================================================\n\n/**\n * Acquire a sync lock for a user\n *\n * @param teamMemberId - Team member ID\n * @returns Lock ID if acquired, null if failed\n */\nexport function acquireSyncLock(teamMemberId: string): SyncLock | null {\n\tconst check = checkSyncRateLimit(teamMemberId);\n\tif (!check.allowed) {\n\t\treturn null;\n\t}\n\n\tconst now = Date.now();\n\tconst lock: SyncLock = {\n\t\tteamMemberId,\n\t\tstartedAt: now,\n\t\texpiresAt: now + SYNC_LOCK_TIMEOUT_MS,\n\t};\n\n\tactiveSyncLocks.add(lock);\n\tlastSyncTimes.set(teamMemberId, now);\n\n\treturn lock;\n}\n\n/**\n * Release a sync lock\n *\n * @param lock - Lock to release\n */\nexport function releaseSyncLock(lock: SyncLock): void {\n\tactiveSyncLocks.delete(lock);\n}\n\n/**\n * Get count of active syncs\n */\nexport function getActiveSyncCount(): number {\n\t// Clean up expired locks first\n\tconst now = Date.now();\n\tfor (const lock of activeSyncLocks) {\n\t\tif (now > lock.expiresAt) {\n\t\t\tactiveSyncLocks.delete(lock);\n\t\t}\n\t}\n\n\treturn activeSyncLocks.size;\n}\n\n// =============================================================================\n// CLEANUP\n// =============================================================================\n\n/**\n * Clean up stale rate limit entries\n */\nfunction cleanup(): void {\n\tconst now = Date.now();\n\n\t// Clean API rate limits\n\tfor (const [userId, entry] of apiRateLimits.entries()) {\n\t\tconst age = now - entry.lastRequest;\n\t\tif (age > RATE_LIMIT_CLEANUP_MS) {\n\t\t\tapiRateLimits.delete(userId);\n\t\t}\n\t}\n\n\t// Clean last sync times\n\tfor (const [userId, lastSync] of lastSyncTimes.entries()) {\n\t\tconst age = now - lastSync;\n\t\tif (age > RATE_LIMIT_CLEANUP_MS) {\n\t\t\tlastSyncTimes.delete(userId);\n\t\t}\n\t}\n\n\t// Clean expired sync locks\n\tfor (const lock of activeSyncLocks) {\n\t\tif (now > lock.expiresAt) {\n\t\t\tactiveSyncLocks.delete(lock);\n\t\t}\n\t}\n}\n\n/**\n * Start automatic cleanup\n */\nexport function startCleanup(): void {\n\tif (cleanupInterval) {\n\t\treturn; // Already started\n\t}\n\n\t// Run cleanup every 5 minutes\n\tcleanupInterval = setInterval(cleanup, 5 * 60 * 1000);\n\n\tconsole.log(\"[Gmail Rate Limiter] Cleanup scheduled\");\n}\n\n/**\n * Stop automatic cleanup\n */\nexport function stopCleanup(): void {\n\tif (cleanupInterval) {\n\t\tclearInterval(cleanupInterval);\n\t\tcleanupInterval = null;\n\t}\n}\n\n// =============================================================================\n// VALIDATION\n// =============================================================================\n\n/**\n * Validate sync request parameters\n *\n * @param maxResults - Requested message count\n * @returns { valid: boolean, error?: string }\n */\nexport function validateSyncParams(maxResults: number): {\n\tvalid: boolean;\n\terror?: string;\n} {\n\tif (maxResults <= 0) {\n\t\treturn { valid: false, error: \"maxResults must be positive\" };\n\t}\n\n\tif (maxResults > MAX_MESSAGES_PER_SYNC) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: `maxResults cannot exceed ${MAX_MESSAGES_PER_SYNC}`,\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\n// =============================================================================\n// STATISTICS\n// =============================================================================\n\n/**\n * Get rate limiter statistics\n */\nexport function getRateLimiterStats(): {\n\tapiRateLimits: number;\n\tlastSyncTimes: number;\n\tactiveSyncs: number;\n\tmaxConcurrentSyncs: number;\n} {\n\treturn {\n\t\tapiRateLimits: apiRateLimits.size,\n\t\tlastSyncTimes: lastSyncTimes.size,\n\t\tactiveSyncs: getActiveSyncCount(),\n\t\tmaxConcurrentSyncs: MAX_CONCURRENT_SYNCS,\n\t};\n}\n\n/**\n * Reset all rate limits (for testing only!)\n */\nexport function resetRateLimits(): void {\n\tapiRateLimits.clear();\n\tlastSyncTimes.clear();\n\tactiveSyncLocks.clear();\n\tconsole.warn(\"[Gmail Rate Limiter] All rate limits reset\");\n}\n\n// =============================================================================\n// INITIALIZATION\n// =============================================================================\n\n// Start cleanup on module load\nstartCleanup();\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\nexport const RATE_LIMITS = {\n\tSYNC_COOLDOWN_MS,\n\tMAX_MESSAGES_PER_SYNC,\n\tMAX_CONCURRENT_SYNCS,\n\tAPI_RATE_LIMIT,\n\tAPI_RATE_WINDOW_MS,\n} as const;\n","/**\n * Gmail API Client (Company-Level & Per-User / Multi-Tenant)\n *\n * CRITICAL: Reply-to addresses ALWAYS use the platform subdomain (mail.thorbis.com),\n * even when sending from personal Gmail. This ensures replies go to the company's\n * centralized inbox, not the personal Gmail account.\n *\n * Example:\n * - FROM: john@gmail.com (personal Gmail)\n * - REPLY-TO: support@acme-plumbing.mail.thorbis.com (platform subdomain)\n *\n * See: /docs/email/REPLY_TO_ARCHITECTURE.md for full details\n *\n * This module provides Gmail API integration at two levels:\n * 1. Company-Level: One Gmail account for the entire company (sending only)\n * 2. Per-User: Individual team member Gmail accounts (inbox access + sending)\n *\n * Multi-Tenant Architecture:\n * - Each company can configure their own email provider\n * - Options: 'managed' (Resend/Postmark), 'gmail', or 'disabled'\n * - Company tokens stored in company_gmail_tokens table\n * - Per-user tokens stored in user_gmail_tokens table\n *\n * Key Features:\n * - Send emails via company's Gmail API\n * - Per-user inbox access and synchronization\n * - Automatic token refresh before expiration\n * - Token validation and error handling\n * - Integration with provider monitoring\n *\n * How It Works (Company-Level):\n * 1. Company admin connects Gmail via OAuth (grants gmail.send scope)\n * 2. Tokens stored in company_gmail_tokens table\n * 3. Before sending, we check/refresh tokens\n * 4. Use Gmail API to send email as company\n *\n * How It Works (Per-User):\n * 1. Team member connects their Gmail via OAuth (grants gmail.readonly + gmail.send)\n * 2. Tokens stored in user_gmail_tokens table\n * 3. Background sync job fetches inbox emails every 5-10 minutes\n * 4. Emails stored in communications table with mailbox_owner_id\n * 5. Role-based permissions control who can see which emails\n *\n * Rate Limits (Gmail API):\n * - Consumer accounts: 100 emails/day\n * - Google Workspace: 2,000 emails/day\n * - Per-minute limit: 100 messages\n *\n * Required Scopes:\n * - Company: https://www.googleapis.com/auth/gmail.send\n * - Per-User: https://www.googleapis.com/auth/gmail.readonly, gmail.send\n *\n * Environment Variables:\n * - GOOGLE_CLIENT_ID: OAuth client ID\n * - GOOGLE_CLIENT_SECRET: OAuth client secret\n *\n * @see https://developers.google.com/gmail/api/reference/rest\n */\n\n\"use server\";\n\nimport {\n\tlogAuditEvent,\n\tlogGmailConnected,\n\tlogGmailDisconnected,\n\tlogSyncFailed,\n\tlogTokenRefreshFailed,\n} from \"@/lib/email/audit-logger\";\nimport {\n\tacquireSyncLock,\n\tcheckApiRateLimit,\n\tcheckSyncRateLimit,\n\treleaseSyncLock,\n\tvalidateSyncParams,\n} from \"@/lib/email/gmail-rate-limiter\";\nimport { decryptToken, encryptToken } from \"@/lib/email/token-encryption\";\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Company email provider options\n */\nexport type CompanyEmailProvider = \"managed\" | \"gmail\" | \"disabled\";\n\n/**\n * Gmail OAuth token data structure (company-level)\n */\nexport interface CompanyGmailTokenData {\n\tcompanyId: string;\n\tgmailEmail: string;\n\tgmailDisplayName?: string;\n\taccessToken: string;\n\trefreshToken: string;\n\ttokenExpiresAt: Date;\n\tisValid: boolean;\n\tscopes: string[];\n\tconnectedBy?: string;\n\tconnectedByName?: string;\n}\n\n/**\n * Result of sending an email via Gmail\n */\nexport interface GmailSendResult {\n\tsuccess: boolean;\n\tmessageId?: string;\n\tthreadId?: string;\n\terror?: string;\n\tlabelIds?: string[];\n}\n\n/**\n * Email data for Gmail sending\n */\nexport interface GmailEmailData {\n\tto: string | string[];\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\treplyTo?: string;\n\tcc?: string | string[];\n\tbcc?: string | string[];\n\theaders?: Record<string, string>;\n}\n\n/**\n * Token refresh response from Google\n */\ninterface GoogleTokenResponse {\n\taccess_token: string;\n\texpires_in: number;\n\ttoken_type: string;\n\tscope?: string;\n\trefresh_token?: string;\n}\n\n/**\n * Per-user Gmail token data structure\n */\nexport interface UserGmailTokenData {\n\tteamMemberId: string;\n\temailAccountId: string;\n\tgmailEmail: string;\n\taccessToken: string;\n\trefreshToken: string;\n\ttokenExpiresAt: Date;\n\tscopes: string[];\n\tsyncEnabled: boolean;\n\tlastSyncedAt?: Date;\n}\n\n/**\n * Gmail message from API\n */\nexport interface GmailMessage {\n\tid: string;\n\tthreadId: string;\n\tlabelIds: string[];\n\tsnippet: string;\n\tpayload: {\n\t\theaders: Array<{ name: string; value: string }>;\n\t\tparts?: Array<{\n\t\t\tmimeType: string;\n\t\t\tbody: { data?: string; size: number };\n\t\t\tparts?: any[];\n\t\t}>;\n\t\tbody?: { data?: string; size: number };\n\t\tmimeType: string;\n\t};\n\tinternalDate: string;\n\tsizeEstimate: number;\n}\n\n/**\n * Parsed email message\n */\nexport interface ParsedGmailMessage {\n\tgmailMessageId: string;\n\tgmailThreadId: string;\n\tfrom: string;\n\tto: string[];\n\tcc?: string[];\n\tsubject: string;\n\ttextBody?: string;\n\thtmlBody?: string;\n\treceivedAt: Date;\n\thasAttachments: boolean;\n\tlabels: string[];\n}\n\n/**\n * Inbox sync result\n */\nexport interface InboxSyncResult {\n\tsuccess: boolean;\n\tmessagesFetched: number;\n\tmessagesStored: number;\n\terrors: string[];\n\tlastSyncedAt: Date;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst GOOGLE_TOKEN_URL = \"https://oauth2.googleapis.com/token\";\nconst GMAIL_API_URL = \"https://gmail.googleapis.com/gmail/v1\";\nconst GMAIL_SEND_SCOPE = \"https://www.googleapis.com/auth/gmail.send\";\nconst GMAIL_READONLY_SCOPE = \"https://www.googleapis.com/auth/gmail.readonly\";\nconst GMAIL_MODIFY_SCOPE = \"https://www.googleapis.com/auth/gmail.modify\";\nconst TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1000;\n\n// =============================================================================\n// COMPANY EMAIL PROVIDER PREFERENCE\n// =============================================================================\n\n/**\n * Get company's email provider preference\n */\nexport async function getCompanyEmailProvider(\n\tcompanyId: string,\n): Promise<CompanyEmailProvider> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { data } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"email_provider\")\n\t\t\t.eq(\"id\", companyId)\n\t\t\t.single();\n\n\t\treturn (data?.email_provider as CompanyEmailProvider) || \"managed\";\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Error getting company email provider:\", error);\n\t\treturn \"managed\";\n\t}\n}\n\n/**\n * Set company's email provider preference\n */\nexport async function setCompanyEmailProvider(\n\tcompanyId: string,\n\tprovider: CompanyEmailProvider,\n\tupdatedByUserId?: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// If switching to Gmail, verify tokens exist\n\t\tif (provider === \"gmail\") {\n\t\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\t\t\tif (!tokens || !tokens.isValid) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"Gmail is not connected. Please connect Gmail first.\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { error } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.update({\n\t\t\t\temail_provider: provider,\n\t\t\t\temail_provider_updated_at: new Date().toISOString(),\n\t\t\t\temail_provider_updated_by: updatedByUserId || null,\n\t\t\t})\n\t\t\t.eq(\"id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[Gmail] Company ${companyId} email provider set to: ${provider}`,\n\t\t);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// TOKEN MANAGEMENT (COMPANY-LEVEL)\n// =============================================================================\n\n/**\n * Get Gmail tokens for a company\n */\nexport async function getCompanyGmailTokens(\n\tcompanyId: string,\n): Promise<CompanyGmailTokenData | null> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.maybeSingle();\n\n\t\tif (error || !data) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenData: CompanyGmailTokenData = {\n\t\t\tcompanyId: data.company_id,\n\t\t\tgmailEmail: data.gmail_email,\n\t\t\tgmailDisplayName: data.gmail_display_name,\n\t\t\taccessToken: data.access_token,\n\t\t\trefreshToken: data.refresh_token,\n\t\t\ttokenExpiresAt: new Date(data.token_expires_at),\n\t\t\tisValid: data.is_valid,\n\t\t\tscopes: data.scopes || [GMAIL_SEND_SCOPE],\n\t\t\tconnectedBy: data.connected_by,\n\t\t\tconnectedByName: data.connected_by_name,\n\t\t};\n\n\t\t// Check if token needs refresh\n\t\tif (isTokenExpiringSoon(tokenData.tokenExpiresAt)) {\n\t\t\tconsole.log(\n\t\t\t\t`[Gmail] Token expiring soon for company ${companyId}, refreshing...`,\n\t\t\t);\n\t\t\tconst refreshed = await refreshCompanyGmailToken(\n\t\t\t\tcompanyId,\n\t\t\t\ttokenData.refreshToken,\n\t\t\t);\n\t\t\tif (refreshed) {\n\t\t\t\treturn refreshed;\n\t\t\t}\n\t\t\tconsole.warn(\"[Gmail] Token refresh failed, using existing token\");\n\t\t}\n\n\t\treturn tokenData;\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Error getting company tokens:\", error);\n\t\treturn null;\n\t}\n}\n\nfunction isTokenExpiringSoon(expiresAt: Date): boolean {\n\treturn expiresAt.getTime() - Date.now() < TOKEN_REFRESH_BUFFER_MS;\n}\n\n/**\n * Refresh Gmail OAuth token for a company\n */\nexport async function refreshCompanyGmailToken(\n\tcompanyId: string,\n\trefreshToken: string,\n): Promise<CompanyGmailTokenData | null> {\n\ttry {\n\t\tconst clientId = process.env.GOOGLE_CLIENT_ID;\n\t\tconst clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n\n\t\tif (!clientId || !clientSecret) {\n\t\t\tconsole.error(\"[Gmail] Missing GOOGLE_CLIENT_ID or GOOGLE_CLIENT_SECRET\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst response = await fetch(GOOGLE_TOKEN_URL, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tclient_id: clientId,\n\t\t\t\tclient_secret: clientSecret,\n\t\t\t\trefresh_token: refreshToken,\n\t\t\t\tgrant_type: \"refresh_token\",\n\t\t\t}),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error(\n\t\t\t\t`[Gmail] Token refresh failed: ${response.status}`,\n\t\t\t\terrorText,\n\t\t\t);\n\t\t\tif (response.status === 400 || response.status === 401) {\n\t\t\t\tawait markCompanyTokenInvalid(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\t`Refresh failed: ${response.status}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenResponse: GoogleTokenResponse = await response.json();\n\t\tconst expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000);\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.update({\n\t\t\t\taccess_token: tokenResponse.access_token,\n\t\t\t\ttoken_expires_at: expiresAt.toISOString(),\n\t\t\t\t...(tokenResponse.refresh_token && {\n\t\t\t\t\trefresh_token: tokenResponse.refresh_token,\n\t\t\t\t}),\n\t\t\t\tis_valid: true,\n\t\t\t\tlast_error: null,\n\t\t\t})\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select(\"*\")\n\t\t\t.single();\n\n\t\tif (error || !data) {\n\t\t\tconsole.error(\n\t\t\t\t\"[Gmail] Failed to update refreshed token:\",\n\t\t\t\terror?.message,\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tconsole.log(`[Gmail] Token refreshed for company ${companyId}`);\n\n\t\treturn {\n\t\t\tcompanyId: data.company_id,\n\t\t\tgmailEmail: data.gmail_email,\n\t\t\tgmailDisplayName: data.gmail_display_name,\n\t\t\taccessToken: data.access_token,\n\t\t\trefreshToken: data.refresh_token,\n\t\t\ttokenExpiresAt: new Date(data.token_expires_at),\n\t\t\tisValid: data.is_valid,\n\t\t\tscopes: data.scopes || [GMAIL_SEND_SCOPE],\n\t\t\tconnectedBy: data.connected_by,\n\t\t\tconnectedByName: data.connected_by_name,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Token refresh error:\", error);\n\t\treturn null;\n\t}\n}\n\nasync function markCompanyTokenInvalid(\n\tcompanyId: string,\n\treason: string,\n): Promise<void> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.update({ is_valid: false, last_error: reason })\n\t\t\t.eq(\"company_id\", companyId);\n\t\tconsole.log(\n\t\t\t`[Gmail] Marked token invalid for company ${companyId}: ${reason}`,\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Failed to mark token invalid:\", error);\n\t}\n}\n\n/**\n * Store Gmail OAuth tokens for a company\n */\nexport async function storeCompanyGmailTokens(\n\tcompanyId: string,\n\tgmailEmail: string,\n\tdisplayName: string | null,\n\taccessToken: string,\n\trefreshToken: string,\n\texpiresIn: number,\n\tscopes: string[],\n\tconnectedByUserId?: string,\n\tconnectedByName?: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tif (!scopes.includes(GMAIL_SEND_SCOPE)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Missing required scope: ${GMAIL_SEND_SCOPE}`,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst expiresAt = new Date(Date.now() + expiresIn * 1000);\n\n\t\tconst { error } = await supabase.from(\"company_gmail_tokens\").upsert(\n\t\t\t{\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tgmail_email: gmailEmail,\n\t\t\t\tgmail_display_name: displayName,\n\t\t\t\taccess_token: accessToken,\n\t\t\t\trefresh_token: refreshToken,\n\t\t\t\ttoken_expires_at: expiresAt.toISOString(),\n\t\t\t\tscopes,\n\t\t\t\tis_valid: true,\n\t\t\t\tlast_error: null,\n\t\t\t\tconnected_by: connectedByUserId || null,\n\t\t\t\tconnected_by_name: connectedByName || null,\n\t\t\t},\n\t\t\t{ onConflict: \"company_id\" },\n\t\t);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Gmail] Failed to store tokens:\", error.message);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[Gmail] Stored tokens for company ${companyId} (${gmailEmail})`,\n\t\t);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Disconnect Gmail from a company\n */\nexport async function disconnectCompanyGmail(\n\tcompanyId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Get token to revoke\n\t\tconst { data: tokenData } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.select(\"access_token\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\t// Delete from database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.delete()\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// Reset to managed provider\n\t\tawait setCompanyEmailProvider(companyId, \"managed\");\n\n\t\t// Revoke token with Google (best effort)\n\t\tif (tokenData?.access_token) {\n\t\t\ttry {\n\t\t\t\tawait fetch(\n\t\t\t\t\t`https://oauth2.googleapis.com/revoke?token=${tokenData.access_token}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch {\n\t\t\t\tconsole.warn(\"[Gmail] Token revocation request failed (non-critical)\");\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(`[Gmail] Disconnected Gmail for company ${companyId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// EMAIL SENDING\n// =============================================================================\n\n/**\n * Send an email via company's Gmail\n */\nexport async function sendCompanyGmailEmail(\n\tcompanyId: string,\n\temailData: GmailEmailData,\n): Promise<GmailSendResult> {\n\ttry {\n\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\t\tif (!tokens) {\n\t\t\treturn { success: false, error: \"Gmail not connected for this company\" };\n\t\t}\n\n\t\tif (!tokens.isValid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Gmail connection invalid: ${tokens.gmailEmail}`,\n\t\t\t};\n\t\t}\n\n\t\tconst mimeMessage = buildMimeMessage({\n\t\t\tfrom: tokens.gmailDisplayName\n\t\t\t\t? `${tokens.gmailDisplayName} <${tokens.gmailEmail}>`\n\t\t\t\t: tokens.gmailEmail,\n\t\t\tto: Array.isArray(emailData.to) ? emailData.to.join(\", \") : emailData.to,\n\t\t\tsubject: emailData.subject,\n\t\t\thtml: emailData.html,\n\t\t\ttext: emailData.text,\n\t\t\treplyTo: emailData.replyTo,\n\t\t\tcc: emailData.cc\n\t\t\t\t? Array.isArray(emailData.cc)\n\t\t\t\t\t? emailData.cc.join(\", \")\n\t\t\t\t\t: emailData.cc\n\t\t\t\t: undefined,\n\t\t\tbcc: emailData.bcc\n\t\t\t\t? Array.isArray(emailData.bcc)\n\t\t\t\t\t? emailData.bcc.join(\", \")\n\t\t\t\t\t: emailData.bcc\n\t\t\t\t: undefined,\n\t\t\theaders: emailData.headers,\n\t\t});\n\n\t\tconst encodedMessage = base64UrlEncode(mimeMessage);\n\n\t\tconst response = await fetch(`${GMAIL_API_URL}/users/me/messages/send`, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${tokens.accessToken}`,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t\tbody: JSON.stringify({ raw: encodedMessage }),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorData = await response.json().catch(() => ({}));\n\t\t\tconst errorMessage =\n\t\t\t\terrorData.error?.message || `Gmail API error: ${response.status}`;\n\t\t\tconsole.error(`[Gmail] Send failed: ${errorMessage}`);\n\t\t\tif (response.status === 401) {\n\t\t\t\tawait markCompanyTokenInvalid(companyId, \"Authentication failed\");\n\t\t\t}\n\t\t\treturn { success: false, error: errorMessage };\n\t\t}\n\n\t\tconst result = await response.json();\n\n\t\t// Update last used timestamp\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.update({ last_used_at: new Date().toISOString() })\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tconsole.log(\n\t\t\t`[Gmail] Sent email for company ${companyId} (ID: ${result.id})`,\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.id,\n\t\t\tthreadId: result.threadId,\n\t\t\tlabelIds: result.labelIds,\n\t\t};\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\tconsole.error(\"[Gmail] Send error:\", message);\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// MIME MESSAGE BUILDING\n// =============================================================================\n\ninterface MimeMessageParts {\n\tfrom: string;\n\tto: string;\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\treplyTo?: string;\n\tcc?: string;\n\tbcc?: string;\n\theaders?: Record<string, string>;\n}\n\nfunction buildMimeMessage(parts: MimeMessageParts): string {\n\tconst boundary = `boundary_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n\n\tconst lines: string[] = [\n\t\t`From: ${parts.from}`,\n\t\t`To: ${parts.to}`,\n\t\t`Subject: =?UTF-8?B?${Buffer.from(parts.subject).toString(\"base64\")}?=`,\n\t\t\"MIME-Version: 1.0\",\n\t];\n\n\tif (parts.replyTo) lines.push(`Reply-To: ${parts.replyTo}`);\n\tif (parts.cc) lines.push(`Cc: ${parts.cc}`);\n\tif (parts.bcc) lines.push(`Bcc: ${parts.bcc}`);\n\n\tif (parts.headers) {\n\t\tfor (const [key, value] of Object.entries(parts.headers)) {\n\t\t\tlines.push(`${key}: ${value}`);\n\t\t}\n\t}\n\n\tlines.push(`Content-Type: multipart/alternative; boundary=\"${boundary}\"`);\n\tlines.push(\"\");\n\n\tconst textContent = parts.text || extractTextFromHtml(parts.html);\n\tlines.push(`--${boundary}`);\n\tlines.push(\"Content-Type: text/plain; charset=UTF-8\");\n\tlines.push(\"Content-Transfer-Encoding: base64\");\n\tlines.push(\"\");\n\tlines.push(Buffer.from(textContent).toString(\"base64\"));\n\n\tlines.push(`--${boundary}`);\n\tlines.push(\"Content-Type: text/html; charset=UTF-8\");\n\tlines.push(\"Content-Transfer-Encoding: base64\");\n\tlines.push(\"\");\n\tlines.push(Buffer.from(parts.html).toString(\"base64\"));\n\n\tlines.push(`--${boundary}--`);\n\n\treturn lines.join(\"\\r\\n\");\n}\n\nfunction extractTextFromHtml(html: string): string {\n\treturn html\n\t\t.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n\t\t.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n\t\t.replace(/<[^>]+>/g, \" \")\n\t\t.replace(/\\s+/g, \" \")\n\t\t.trim();\n}\n\nfunction base64UrlEncode(str: string): string {\n\treturn Buffer.from(str)\n\t\t.toString(\"base64\")\n\t\t.replace(/\\+/g, \"-\")\n\t\t.replace(/\\//g, \"_\")\n\t\t.replace(/=+$/, \"\");\n}\n\n// =============================================================================\n// HEALTH CHECK\n// =============================================================================\n\n/**\n * Check Gmail health for a company\n */\nexport async function checkCompanyGmailHealth(\n\tcompanyId: string,\n\ttestApi: boolean = false,\n): Promise<{\n\tconnected: boolean;\n\temail?: string;\n\tdisplayName?: string;\n\ttokenValid: boolean;\n\ttokenExpiresAt?: Date;\n\tapiHealthy?: boolean;\n\tconnectedBy?: string;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\n\t\tif (!tokens) {\n\t\t\treturn { connected: false, tokenValid: false };\n\t\t}\n\n\t\tconst result = {\n\t\t\tconnected: true,\n\t\t\temail: tokens.gmailEmail,\n\t\t\tdisplayName: tokens.gmailDisplayName,\n\t\t\ttokenValid: tokens.isValid,\n\t\t\ttokenExpiresAt: tokens.tokenExpiresAt,\n\t\t\tconnectedBy: tokens.connectedByName,\n\t\t\tapiHealthy: undefined as boolean | undefined,\n\t\t};\n\n\t\tif (testApi && tokens.isValid) {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(`${GMAIL_API_URL}/users/me/profile`, {\n\t\t\t\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` },\n\t\t\t\t});\n\t\t\t\tresult.apiHealthy = response.ok;\n\t\t\t} catch {\n\t\t\t\tresult.apiHealthy = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tconnected: false,\n\t\t\ttokenValid: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n// =============================================================================\n// PER-USER TOKEN MANAGEMENT\n// =============================================================================\n\n/**\n * Get Gmail tokens for a specific team member\n */\nexport async function getUserGmailTokens(\n\tteamMemberId: string,\n): Promise<UserGmailTokenData | null> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.select(\"*, user_email_accounts!inner(email_address)\")\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.eq(\"sync_enabled\", true)\n\t\t\t.maybeSingle();\n\n\t\tif (error || !data) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Decrypt tokens before using (CRITICAL SECURITY)\n\t\tconst decryptedAccessToken = decryptToken(data.access_token);\n\t\tconst decryptedRefreshToken = decryptToken(data.refresh_token);\n\n\t\tconst tokenData: UserGmailTokenData = {\n\t\t\tteamMemberId: data.team_member_id,\n\t\t\temailAccountId: data.user_email_account_id,\n\t\t\tgmailEmail: data.user_email_accounts.email_address,\n\t\t\taccessToken: decryptedAccessToken,\n\t\t\trefreshToken: decryptedRefreshToken,\n\t\t\ttokenExpiresAt: new Date(data.token_expiry),\n\t\t\tscopes: data.scopes || [],\n\t\t\tsyncEnabled: data.sync_enabled,\n\t\t\tlastSyncedAt: data.last_synced_at\n\t\t\t\t? new Date(data.last_synced_at)\n\t\t\t\t: undefined,\n\t\t};\n\n\t\t// Check if token needs refresh\n\t\tif (isTokenExpiringSoon(tokenData.tokenExpiresAt)) {\n\t\t\tconsole.log(\n\t\t\t\t`[Gmail] Token expiring soon for user ${teamMemberId}, refreshing...`,\n\t\t\t);\n\t\t\tconst refreshed = await refreshUserGmailToken(\n\t\t\t\tteamMemberId,\n\t\t\t\ttokenData.refreshToken,\n\t\t\t);\n\t\t\tif (refreshed) {\n\t\t\t\treturn refreshed;\n\t\t\t}\n\t\t\tconsole.warn(\"[Gmail] User token refresh failed, using existing token\");\n\t\t}\n\n\t\treturn tokenData;\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Error getting user tokens:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Refresh Gmail OAuth token for a team member\n */\nexport async function refreshUserGmailToken(\n\tteamMemberId: string,\n\trefreshToken: string,\n): Promise<UserGmailTokenData | null> {\n\ttry {\n\t\tconst clientId = process.env.GOOGLE_CLIENT_ID;\n\t\tconst clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n\n\t\tif (!clientId || !clientSecret) {\n\t\t\tconsole.error(\"[Gmail] Missing GOOGLE_CLIENT_ID or GOOGLE_CLIENT_SECRET\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst response = await fetch(GOOGLE_TOKEN_URL, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tclient_id: clientId,\n\t\t\t\tclient_secret: clientSecret,\n\t\t\t\trefresh_token: refreshToken,\n\t\t\t\tgrant_type: \"refresh_token\",\n\t\t\t}),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error(\n\t\t\t\t`[Gmail] User token refresh failed: ${response.status}`,\n\t\t\t\terrorText,\n\t\t\t);\n\n\t\t\t// Log token refresh failure for audit trail\n\t\t\tawait logTokenRefreshFailed(\n\t\t\t\tteamMemberId,\n\t\t\t\t\"Unknown\", // Gmail email not available here\n\t\t\t\t`Token refresh failed: ${response.status} - ${errorText}`,\n\t\t\t);\n\n\t\t\tif (response.status === 400 || response.status === 401) {\n\t\t\t\tawait markUserTokenInvalid(\n\t\t\t\t\tteamMemberId,\n\t\t\t\t\t`Refresh failed: ${response.status}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenResponse: GoogleTokenResponse = await response.json();\n\t\tconst expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000);\n\n\t\t// Encrypt refreshed tokens before storing (CRITICAL SECURITY)\n\t\tconst encryptedAccessToken = encryptToken(tokenResponse.access_token);\n\t\tconst encryptedRefreshToken = tokenResponse.refresh_token\n\t\t\t? encryptToken(tokenResponse.refresh_token)\n\t\t\t: undefined;\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.update({\n\t\t\t\taccess_token: encryptedAccessToken,\n\t\t\t\ttoken_expiry: expiresAt.toISOString(),\n\t\t\t\t...(encryptedRefreshToken && { refresh_token: encryptedRefreshToken }),\n\t\t\t})\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.select(\"*, user_email_accounts!inner(email_address)\")\n\t\t\t.single();\n\n\t\tif (error || !data) {\n\t\t\tconsole.error(\n\t\t\t\t\"[Gmail] Failed to update refreshed user token:\",\n\t\t\t\terror?.message,\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tconsole.log(`[Gmail] User token refreshed for team member ${teamMemberId}`);\n\n\t\t// Decrypt tokens for return (already encrypted in DB)\n\t\tconst decryptedAccessToken = decryptToken(data.access_token);\n\t\tconst decryptedRefreshToken = decryptToken(data.refresh_token);\n\n\t\treturn {\n\t\t\tteamMemberId: data.team_member_id,\n\t\t\temailAccountId: data.user_email_account_id,\n\t\t\tgmailEmail: data.user_email_accounts.email_address,\n\t\t\taccessToken: decryptedAccessToken,\n\t\t\trefreshToken: decryptedRefreshToken,\n\t\t\ttokenExpiresAt: new Date(data.token_expiry),\n\t\t\tscopes: data.scopes || [],\n\t\t\tsyncEnabled: data.sync_enabled,\n\t\t\tlastSyncedAt: data.last_synced_at\n\t\t\t\t? new Date(data.last_synced_at)\n\t\t\t\t: undefined,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] User token refresh error:\", error);\n\t\treturn null;\n\t}\n}\n\nasync function markUserTokenInvalid(\n\tteamMemberId: string,\n\treason: string,\n): Promise<void> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.update({ sync_enabled: false })\n\t\t\t.eq(\"team_member_id\", teamMemberId);\n\t\tconsole.log(\n\t\t\t`[Gmail] Disabled sync for team member ${teamMemberId}: ${reason}`,\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Failed to mark user token invalid:\", error);\n\t}\n}\n\n/**\n * Store Gmail OAuth tokens for a team member\n */\nexport async function storeUserGmailTokens(\n\tteamMemberId: string,\n\temailAccountId: string,\n\taccessToken: string,\n\trefreshToken: string,\n\texpiresIn: number,\n\tscopes: string[],\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tif (\n\t\t\t!scopes.includes(GMAIL_READONLY_SCOPE) &&\n\t\t\t!scopes.includes(GMAIL_MODIFY_SCOPE)\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Missing required scope: ${GMAIL_READONLY_SCOPE} or ${GMAIL_MODIFY_SCOPE}`,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst expiresAt = new Date(Date.now() + expiresIn * 1000);\n\n\t\t// Encrypt tokens before storing (CRITICAL SECURITY)\n\t\tconst encryptedAccessToken = encryptToken(accessToken);\n\t\tconst encryptedRefreshToken = encryptToken(refreshToken);\n\n\t\tconst { error } = await supabase.from(\"user_gmail_tokens\").upsert(\n\t\t\t{\n\t\t\t\tteam_member_id: teamMemberId,\n\t\t\t\tuser_email_account_id: emailAccountId,\n\t\t\t\taccess_token: encryptedAccessToken,\n\t\t\t\trefresh_token: encryptedRefreshToken,\n\t\t\t\ttoken_expiry: expiresAt.toISOString(),\n\t\t\t\tscopes,\n\t\t\t\tsync_enabled: true,\n\t\t\t\tlast_synced_at: null,\n\t\t\t},\n\t\t\t{ onConflict: \"user_email_account_id\" },\n\t\t);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Gmail] Failed to store user tokens:\", error.message);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[Gmail] Stored encrypted tokens for team member ${teamMemberId}`,\n\t\t);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Disconnect Gmail for a team member\n */\nexport async function disconnectUserGmail(\n\tteamMemberId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Get token to revoke\n\t\tconst { data: tokenData } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.select(\"access_token\")\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.single();\n\n\t\t// Delete from database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.delete()\n\t\t\t.eq(\"team_member_id\", teamMemberId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// Revoke token with Google (best effort)\n\t\tif (tokenData?.access_token) {\n\t\t\ttry {\n\t\t\t\tawait fetch(\n\t\t\t\t\t`https://oauth2.googleapis.com/revoke?token=${tokenData.access_token}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"[Gmail] User token revocation request failed (non-critical)\",\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(`[Gmail] Disconnected Gmail for team member ${teamMemberId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// INBOX FETCHING\n// =============================================================================\n\n/**\n * Fetch inbox messages for a team member\n */\nexport async function fetchUserInbox(\n\tteamMemberId: string,\n\tmaxResults: number = 50,\n\tpageToken?: string,\n): Promise<{\n\tmessages: GmailMessage[];\n\tnextPageToken?: string;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst tokens = await getUserGmailTokens(teamMemberId);\n\t\tif (!tokens) {\n\t\t\treturn { messages: [], error: \"Gmail not connected for this user\" };\n\t\t}\n\n\t\t// Build query parameters\n\t\tconst params = new URLSearchParams({\n\t\t\tmaxResults: maxResults.toString(),\n\t\t\tq: \"in:inbox\", // Only fetch inbox messages\n\t\t\t...(pageToken && { pageToken }),\n\t\t});\n\n\t\t// List messages\n\t\tconst listResponse = await fetch(\n\t\t\t`${GMAIL_API_URL}/users/me/messages?${params}`,\n\t\t\t{\n\t\t\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` },\n\t\t\t},\n\t\t);\n\n\t\tif (!listResponse.ok) {\n\t\t\tconst errorText = await listResponse.text();\n\t\t\tconsole.error(\n\t\t\t\t`[Gmail] Inbox fetch failed: ${listResponse.status}`,\n\t\t\t\terrorText,\n\t\t\t);\n\t\t\treturn { messages: [], error: `API error: ${listResponse.status}` };\n\t\t}\n\n\t\tconst listData = await listResponse.json();\n\t\tconst messageIds = listData.messages || [];\n\t\tconst messages: GmailMessage[] = [];\n\n\t\t// Fetch full message details for each message\n\t\tfor (const msgRef of messageIds) {\n\t\t\tconst msgResponse = await fetch(\n\t\t\t\t`${GMAIL_API_URL}/users/me/messages/${msgRef.id}`,\n\t\t\t\t{\n\t\t\t\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` },\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (msgResponse.ok) {\n\t\t\t\tconst msgData = await msgResponse.json();\n\t\t\t\tmessages.push(msgData);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmessages,\n\t\t\tnextPageToken: listData.nextPageToken,\n\t\t};\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\tconsole.error(\"[Gmail] Inbox fetch error:\", message);\n\t\treturn { messages: [], error: message };\n\t}\n}\n\n/**\n * Parse Gmail message to structured format\n */\nfunction parseGmailMessage(message: GmailMessage): ParsedGmailMessage {\n\tconst headers = message.payload.headers;\n\tconst getHeader = (name: string) =>\n\t\theaders.find((h) => h.name.toLowerCase() === name.toLowerCase())?.value ||\n\t\t\"\";\n\n\tconst from = getHeader(\"From\");\n\tconst to = getHeader(\"To\")\n\t\t.split(\",\")\n\t\t.map((e) => e.trim())\n\t\t.filter(Boolean);\n\tconst cc = getHeader(\"Cc\")\n\t\t?.split(\",\")\n\t\t.map((e) => e.trim())\n\t\t.filter(Boolean);\n\tconst subject = getHeader(\"Subject\");\n\n\t// Extract body content\n\tlet textBody: string | undefined;\n\tlet htmlBody: string | undefined;\n\n\tconst extractBody = (part: any): void => {\n\t\tif (part.mimeType === \"text/plain\" && part.body?.data) {\n\t\t\ttextBody = Buffer.from(part.body.data, \"base64\").toString(\"utf-8\");\n\t\t} else if (part.mimeType === \"text/html\" && part.body?.data) {\n\t\t\thtmlBody = Buffer.from(part.body.data, \"base64\").toString(\"utf-8\");\n\t\t}\n\n\t\tif (part.parts) {\n\t\t\tpart.parts.forEach(extractBody);\n\t\t}\n\t};\n\n\tif (message.payload.parts) {\n\t\tmessage.payload.parts.forEach(extractBody);\n\t} else if (message.payload.body?.data) {\n\t\t// Single part message\n\t\tif (message.payload.mimeType === \"text/plain\") {\n\t\t\ttextBody = Buffer.from(message.payload.body.data, \"base64\").toString(\n\t\t\t\t\"utf-8\",\n\t\t\t);\n\t\t} else if (message.payload.mimeType === \"text/html\") {\n\t\t\thtmlBody = Buffer.from(message.payload.body.data, \"base64\").toString(\n\t\t\t\t\"utf-8\",\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\tgmailMessageId: message.id,\n\t\tgmailThreadId: message.threadId,\n\t\tfrom,\n\t\tto,\n\t\tcc,\n\t\tsubject,\n\t\ttextBody,\n\t\thtmlBody,\n\t\treceivedAt: new Date(parseInt(message.internalDate)),\n\t\thasAttachments:\n\t\t\tmessage.payload.parts?.some(\n\t\t\t\t(p) => p.body.size > 0 && p.mimeType.startsWith(\"attachment/\"),\n\t\t\t) || false,\n\t\tlabels: message.labelIds,\n\t};\n}\n\n/**\n * Store Gmail message in communications table\n */\nexport async function storeGmailMessage(\n\tcompanyId: string,\n\tteamMemberId: string,\n\temailAccountId: string,\n\tparsedMessage: ParsedGmailMessage,\n): Promise<{ success: boolean; communicationId?: string; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Check if message already exists\n\t\tconst { data: existing } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"gmail_message_id\", parsedMessage.gmailMessageId)\n\t\t\t.maybeSingle();\n\n\t\tif (existing) {\n\t\t\treturn { success: true, communicationId: existing.id };\n\t\t}\n\n\t\t// Extract customer email from \"from\" field\n\t\tconst fromEmail =\n\t\t\tparsedMessage.from.match(/<(.+?)>/)?.[1] || parsedMessage.from;\n\n\t\t// Try to find customer by email\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"email\", fromEmail)\n\t\t\t.maybeSingle();\n\n\t\t// Insert communication\n\t\tconst { data: communication, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\ttype: \"email\",\n\t\t\t\tdirection: \"inbound\",\n\t\t\t\tstatus: \"received\",\n\t\t\t\tfrom_address: fromEmail,\n\t\t\t\tto_address: parsedMessage.to[0] || \"\",\n\t\t\t\tsubject: parsedMessage.subject,\n\t\t\t\tbody: parsedMessage.htmlBody || parsedMessage.textBody || \"\",\n\t\t\t\tcustomer_id: customer?.id || null,\n\t\t\t\tmailbox_owner_id: teamMemberId,\n\t\t\t\temail_account_id: emailAccountId,\n\t\t\t\tvisibility_scope: \"private\", // Personal inbox emails default to private\n\t\t\t\tgmail_message_id: parsedMessage.gmailMessageId,\n\t\t\t\tgmail_thread_id: parsedMessage.gmailThreadId,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Gmail] Failed to store message:\", error.message);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, communicationId: communication.id };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Sync inbox for a team member\n */\nexport async function syncUserInbox(\n\tcompanyId: string,\n\tteamMemberId: string,\n): Promise<InboxSyncResult> {\n\tconst startTime = new Date();\n\tlet messagesFetched = 0;\n\tlet messagesStored = 0;\n\tconst errors: string[] = [];\n\tlet syncLock: ReturnType<typeof acquireSyncLock> = null;\n\n\ttry {\n\t\t// Check rate limit before syncing (CRITICAL SAFEGUARD)\n\t\tconst rateLimitCheck = checkSyncRateLimit(teamMemberId);\n\t\tif (!rateLimitCheck.allowed) {\n\t\t\tawait logAuditEvent(\n\t\t\t\t\"sync_rate_limited\",\n\t\t\t\t{\n\t\t\t\t\tteamMemberId,\n\t\t\t\t\tretryAfter: rateLimitCheck.retryAfter,\n\t\t\t\t},\n\t\t\t\t\"warning\",\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessagesFetched: 0,\n\t\t\t\tmessagesStored: 0,\n\t\t\t\terrors: [rateLimitCheck.reason || \"Rate limit exceeded\"],\n\t\t\t\tlastSyncedAt: startTime,\n\t\t\t};\n\t\t}\n\n\t\t// Acquire sync lock to prevent concurrent syncs\n\t\tsyncLock = acquireSyncLock(teamMemberId);\n\t\tif (!syncLock) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessagesFetched: 0,\n\t\t\t\tmessagesStored: 0,\n\t\t\t\terrors: [\n\t\t\t\t\t\"Could not acquire sync lock - another sync may be in progress\",\n\t\t\t\t],\n\t\t\t\tlastSyncedAt: startTime,\n\t\t\t};\n\t\t}\n\n\t\tawait logAuditEvent(\"sync_started\", { teamMemberId }, \"info\");\n\n\t\tconst tokens = await getUserGmailTokens(teamMemberId);\n\t\tif (!tokens) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessagesFetched: 0,\n\t\t\t\tmessagesStored: 0,\n\t\t\t\terrors: [\"Gmail not connected\"],\n\t\t\t\tlastSyncedAt: startTime,\n\t\t\t};\n\t\t}\n\n\t\t// Fetch messages since last sync (or all if never synced)\n\t\tlet pageToken: string | undefined;\n\t\tlet hasMore = true;\n\n\t\twhile (hasMore) {\n\t\t\tconst { messages, nextPageToken, error } = await fetchUserInbox(\n\t\t\t\tteamMemberId,\n\t\t\t\t50,\n\t\t\t\tpageToken,\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\terrors.push(error);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmessagesFetched += messages.length;\n\n\t\t\t// Store each message\n\t\t\tfor (const message of messages) {\n\t\t\t\tconst parsed = parseGmailMessage(message);\n\t\t\t\tconst { success, error: storeError } = await storeGmailMessage(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tteamMemberId,\n\t\t\t\t\ttokens.emailAccountId,\n\t\t\t\t\tparsed,\n\t\t\t\t);\n\n\t\t\t\tif (success) {\n\t\t\t\t\tmessagesStored++;\n\t\t\t\t} else if (storeError) {\n\t\t\t\t\terrors.push(storeError);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Continue to next page if available\n\t\t\tpageToken = nextPageToken;\n\t\t\thasMore = !!nextPageToken && messages.length > 0;\n\t\t}\n\n\t\t// Update last synced timestamp\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.update({ last_synced_at: startTime.toISOString() })\n\t\t\t.eq(\"team_member_id\", teamMemberId);\n\n\t\tconsole.log(\n\t\t\t`[Gmail] Synced ${messagesStored}/${messagesFetched} messages for team member ${teamMemberId}`,\n\t\t);\n\n\t\t// Log successful sync\n\t\tawait logAuditEvent(\n\t\t\t\"sync_completed\",\n\t\t\t{\n\t\t\t\tteamMemberId,\n\t\t\t\tsyncMessageCount: messagesStored,\n\t\t\t},\n\t\t\t\"info\",\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: errors.length === 0,\n\t\t\tmessagesFetched,\n\t\t\tmessagesStored,\n\t\t\terrors,\n\t\t\tlastSyncedAt: startTime,\n\t\t};\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\terrors.push(message);\n\n\t\t// Log failed sync\n\t\tawait logAuditEvent(\n\t\t\t\"sync_failed\",\n\t\t\t{\n\t\t\t\tteamMemberId,\n\t\t\t\terror: message,\n\t\t\t},\n\t\t\t\"error\",\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessagesFetched,\n\t\t\tmessagesStored,\n\t\t\terrors,\n\t\t\tlastSyncedAt: startTime,\n\t\t};\n\t} finally {\n\t\t// Always release sync lock (CRITICAL)\n\t\tif (syncLock) {\n\t\t\treleaseSyncLock(syncLock);\n\t\t}\n\t}\n}\n\n// =============================================================================\n// INTEGRATION AVAILABILITY CHECK\n// =============================================================================\n\n/**\n * Check if Gmail integration is available (env vars configured)\n */\nexport async function isGmailIntegrationEnabled(): Promise<boolean> {\n\treturn !!(\n\t\tprocess.env.GOOGLE_CLIENT_ID &&\n\t\tprocess.env.GOOGLE_CLIENT_SECRET &&\n\t\tprocess.env.NEXT_PUBLIC_APP_URL\n\t);\n}\n"],"names":[],"mappings":"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"}