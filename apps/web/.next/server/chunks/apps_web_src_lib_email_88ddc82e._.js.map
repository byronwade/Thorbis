{"version":3,"sources":["../../../../../apps/web/src/lib/email/deliverability-monitor.ts","../../../../../apps/web/src/lib/email/postmark-client.ts","../../../../../apps/web/src/lib/email/provider-monitor.ts"],"sourcesContent":["\"use server\";\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\n/**\n * Deliverability Monitor for Multi-Tenant Email System\n *\n * Features:\n * - Track delivery events (delivered, bounced, complained)\n * - Update domain reputation scores\n * - Auto-suspend domains with poor reputation\n * - Generate deliverability reports\n */\n\nexport type DeliveryEventType =\n\t| \"delivered\"\n\t| \"bounced\"\n\t| \"soft_bounce\"\n\t| \"complained\"\n\t| \"opened\"\n\t| \"clicked\";\n\nexport interface DeliveryEvent {\n\tdomainId: string;\n\teventType: DeliveryEventType;\n\temailId?: string;\n\tmetadata?: Record<string, any>;\n}\n\nexport interface DomainHealth {\n\tdomainId: string;\n\tdomain: string;\n\treputationScore: number;\n\tbounceRate: number;\n\tcomplaintRate: number;\n\tdeliveryRate: number;\n\tstatus: \"healthy\" | \"warning\" | \"critical\" | \"suspended\";\n\ttotalEmailsSent: number;\n\thardBounces: number;\n\tsoftBounces: number;\n\tcomplaints: number;\n\tlastHealthCheck: string | null;\n}\n\n/**\n * Record a delivery event and update domain metrics\n */\nexport async function recordDeliveryEvent(\n\tevent: DeliveryEvent\n): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Use the database function to update reputation\n\tconst { error } = await supabase.rpc(\"update_domain_reputation\", {\n\t\tp_domain_id: event.domainId,\n\t\tp_event_type: event.eventType,\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Error recording delivery event:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true };\n}\n\n/**\n * Process Resend webhook events for deliverability tracking\n */\nexport async function processResendWebhookEvent(webhookData: {\n\ttype: string;\n\tdata: {\n\t\temail_id?: string;\n\t\tfrom?: string;\n\t\tto?: string[];\n\t\tsubject?: string;\n\t\tcreated_at?: string;\n\t\t[key: string]: any;\n\t};\n}): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Map Resend event types to our event types\n\tconst eventTypeMap: Record<string, DeliveryEventType | null> = {\n\t\t\"email.delivered\": \"delivered\",\n\t\t\"email.bounced\": \"bounced\",\n\t\t\"email.complained\": \"complained\",\n\t\t\"email.opened\": \"opened\",\n\t\t\"email.clicked\": \"clicked\",\n\t\t// Soft bounces might come as delivery_delayed in some providers\n\t\t\"email.delivery_delayed\": \"soft_bounce\",\n\t};\n\n\tconst eventType = eventTypeMap[webhookData.type];\n\tif (!eventType) {\n\t\t// Not a delivery event we track\n\t\treturn { success: true };\n\t}\n\n\t// Extract domain from the \"from\" address\n\tconst fromEmail = webhookData.data.from;\n\tif (!fromEmail) {\n\t\treturn { success: true };\n\t}\n\n\tconst domain = fromEmail.includes(\"@\")\n\t\t? fromEmail.split(\"@\")[1]\n\t\t: fromEmail;\n\n\t// Look up the domain in our database\n\tconst { data: domainRecord } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"id\")\n\t\t.eq(\"domain_name\", domain)\n\t\t.maybeSingle();\n\n\tif (!domainRecord) {\n\t\t// Domain not found in our system\n\t\treturn { success: true };\n\t}\n\n\t// Record the event\n\treturn recordDeliveryEvent({\n\t\tdomainId: domainRecord.id,\n\t\teventType,\n\t\temailId: webhookData.data.email_id,\n\t\tmetadata: webhookData.data,\n\t});\n}\n\n/**\n * Get domain health status\n */\nexport async function getDomainHealth(\n\tdomainId: string\n): Promise<DomainHealth | null> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t\"id, domain_name, reputation_score, bounce_rate, total_emails_sent, hard_bounces, soft_bounces, spam_complaints, is_suspended, last_health_check\"\n\t\t)\n\t\t.eq(\"id\", domainId)\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\tconst totalEvents =\n\t\tdata.total_emails_sent + data.hard_bounces + data.soft_bounces;\n\tconst bounceRate =\n\t\ttotalEvents > 0\n\t\t\t? ((data.hard_bounces + data.soft_bounces) / totalEvents) * 100\n\t\t\t: 0;\n\tconst complaintRate =\n\t\tdata.total_emails_sent > 0\n\t\t\t? (data.spam_complaints / data.total_emails_sent) * 100\n\t\t\t: 0;\n\tconst deliveryRate =\n\t\ttotalEvents > 0 ? (data.total_emails_sent / totalEvents) * 100 : 100;\n\n\tlet status: DomainHealth[\"status\"] = \"healthy\";\n\tif (data.is_suspended) {\n\t\tstatus = \"suspended\";\n\t} else if (data.reputation_score < 30 || bounceRate > 10 || complaintRate > 0.5) {\n\t\tstatus = \"critical\";\n\t} else if (data.reputation_score < 60 || bounceRate > 5 || complaintRate > 0.2) {\n\t\tstatus = \"warning\";\n\t}\n\n\treturn {\n\t\tdomainId: data.id,\n\t\tdomain: data.domain_name,\n\t\treputationScore: Number(data.reputation_score),\n\t\tbounceRate: Number(bounceRate.toFixed(2)),\n\t\tcomplaintRate: Number(complaintRate.toFixed(3)),\n\t\tdeliveryRate: Number(deliveryRate.toFixed(2)),\n\t\tstatus,\n\t\ttotalEmailsSent: data.total_emails_sent,\n\t\thardBounces: data.hard_bounces,\n\t\tsoftBounces: data.soft_bounces,\n\t\tcomplaints: data.spam_complaints,\n\t\tlastHealthCheck: data.last_health_check,\n\t};\n}\n\n/**\n * Get all domains health for a company\n */\nexport async function getCompanyDomainsHealth(\n\tcompanyId: string\n): Promise<DomainHealth[]> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t\"id, domain_name, reputation_score, bounce_rate, total_emails_sent, hard_bounces, soft_bounces, spam_complaints, is_suspended, last_health_check\"\n\t\t)\n\t\t.eq(\"company_id\", companyId);\n\n\tif (error || !data) {\n\t\treturn [];\n\t}\n\n\treturn data.map((d) => {\n\t\tconst totalEvents = d.total_emails_sent + d.hard_bounces + d.soft_bounces;\n\t\tconst bounceRate =\n\t\t\ttotalEvents > 0 ? ((d.hard_bounces + d.soft_bounces) / totalEvents) * 100 : 0;\n\t\tconst complaintRate =\n\t\t\td.total_emails_sent > 0 ? (d.spam_complaints / d.total_emails_sent) * 100 : 0;\n\t\tconst deliveryRate =\n\t\t\ttotalEvents > 0 ? (d.total_emails_sent / totalEvents) * 100 : 100;\n\n\t\tlet status: DomainHealth[\"status\"] = \"healthy\";\n\t\tif (d.is_suspended) {\n\t\t\tstatus = \"suspended\";\n\t\t} else if (d.reputation_score < 30 || bounceRate > 10 || complaintRate > 0.5) {\n\t\t\tstatus = \"critical\";\n\t\t} else if (d.reputation_score < 60 || bounceRate > 5 || complaintRate > 0.2) {\n\t\t\tstatus = \"warning\";\n\t\t}\n\n\t\treturn {\n\t\t\tdomainId: d.id,\n\t\t\tdomain: d.domain_name,\n\t\t\treputationScore: Number(d.reputation_score),\n\t\t\tbounceRate: Number(bounceRate.toFixed(2)),\n\t\t\tcomplaintRate: Number(complaintRate.toFixed(3)),\n\t\t\tdeliveryRate: Number(deliveryRate.toFixed(2)),\n\t\t\tstatus,\n\t\t\ttotalEmailsSent: d.total_emails_sent,\n\t\t\thardBounces: d.hard_bounces,\n\t\t\tsoftBounces: d.soft_bounces,\n\t\t\tcomplaints: d.spam_complaints,\n\t\t\tlastHealthCheck: d.last_health_check,\n\t\t};\n\t});\n}\n\n/**\n * Run health check on all domains and update status\n */\nexport async function runHealthCheckForAllDomains(): Promise<{\n\tchecked: number;\n\tsuspended: number;\n\twarnings: number;\n}> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Get all active domains\n\tconst { data: domains } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"id, reputation_score, hard_bounces, soft_bounces, spam_complaints, total_emails_sent\")\n\t\t.eq(\"is_suspended\", false);\n\n\tif (!domains) {\n\t\treturn { checked: 0, suspended: 0, warnings: 0 };\n\t}\n\n\tlet suspended = 0;\n\tlet warnings = 0;\n\n\tfor (const domain of domains) {\n\t\tconst totalEvents =\n\t\t\tdomain.total_emails_sent + domain.hard_bounces + domain.soft_bounces;\n\t\tconst bounceRate =\n\t\t\ttotalEvents > 100\n\t\t\t\t? ((domain.hard_bounces + domain.soft_bounces) / totalEvents) * 100\n\t\t\t\t: 0;\n\t\tconst complaintRate =\n\t\t\tdomain.total_emails_sent > 100\n\t\t\t\t? (domain.spam_complaints / domain.total_emails_sent) * 100\n\t\t\t\t: 0;\n\n\t\t// Auto-suspend if reputation is critical\n\t\tif (domain.reputation_score < 20 || bounceRate > 15 || complaintRate > 1) {\n\t\t\tawait supabase\n\t\t\t\t.from(\"company_email_domains\")\n\t\t\t\t.update({\n\t\t\t\t\tis_suspended: true,\n\t\t\t\t\tsuspension_reason: `Auto-suspended: Reputation ${domain.reputation_score}, Bounce rate ${bounceRate.toFixed(1)}%, Complaint rate ${complaintRate.toFixed(2)}%`,\n\t\t\t\t\tsuspended_at: new Date().toISOString(),\n\t\t\t\t\tlast_health_check: new Date().toISOString(),\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", domain.id);\n\t\t\tsuspended++;\n\t\t} else if (domain.reputation_score < 50 || bounceRate > 8 || complaintRate > 0.3) {\n\t\t\t// Update health check timestamp for warning domains\n\t\t\tawait supabase\n\t\t\t\t.from(\"company_email_domains\")\n\t\t\t\t.update({ last_health_check: new Date().toISOString() })\n\t\t\t\t.eq(\"id\", domain.id);\n\t\t\twarnings++;\n\t\t} else {\n\t\t\t// Healthy, just update timestamp\n\t\t\tawait supabase\n\t\t\t\t.from(\"company_email_domains\")\n\t\t\t\t.update({ last_health_check: new Date().toISOString() })\n\t\t\t\t.eq(\"id\", domain.id);\n\t\t}\n\t}\n\n\treturn {\n\t\tchecked: domains.length,\n\t\tsuspended,\n\t\twarnings,\n\t};\n}\n\n/**\n * Generate deliverability report for a domain\n */\nexport async function generateDeliverabilityReport(domainId: string): Promise<{\n\tdomain: string;\n\tperiod: { start: string; end: string };\n\tmetrics: {\n\t\ttotalSent: number;\n\t\tdelivered: number;\n\t\tbounced: number;\n\t\tcomplained: number;\n\t\tdeliveryRate: number;\n\t\tbounceRate: number;\n\t\tcomplaintRate: number;\n\t};\n\treputation: {\n\t\tcurrent: number;\n\t\tchange: number;\n\t\tstatus: string;\n\t};\n\trecommendations: string[];\n} | null> {\n\tconst health = await getDomainHealth(domainId);\n\tif (!health) {\n\t\treturn null;\n\t}\n\n\tconst recommendations: string[] = [];\n\n\tif (health.bounceRate > 5) {\n\t\trecommendations.push(\n\t\t\t\"High bounce rate detected. Clean your email list and remove invalid addresses.\"\n\t\t);\n\t}\n\n\tif (health.complaintRate > 0.1) {\n\t\trecommendations.push(\n\t\t\t\"Spam complaints detected. Ensure recipients have opted in and make unsubscribe easy.\"\n\t\t);\n\t}\n\n\tif (health.reputationScore < 70) {\n\t\trecommendations.push(\n\t\t\t\"Reputation score is below optimal. Reduce sending volume temporarily and focus on engagement.\"\n\t\t);\n\t}\n\n\tif (health.status === \"warning\" || health.status === \"critical\") {\n\t\trecommendations.push(\n\t\t\t\"Domain health is degraded. Review your email content and sending practices.\"\n\t\t);\n\t}\n\n\tif (recommendations.length === 0) {\n\t\trecommendations.push(\n\t\t\t\"Domain health is good. Continue monitoring and maintain current practices.\"\n\t\t);\n\t}\n\n\treturn {\n\t\tdomain: health.domain,\n\t\tperiod: {\n\t\t\tstart: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\n\t\t\tend: new Date().toISOString(),\n\t\t},\n\t\tmetrics: {\n\t\t\ttotalSent: health.totalEmailsSent,\n\t\t\tdelivered: health.totalEmailsSent - health.hardBounces,\n\t\t\tbounced: health.hardBounces + health.softBounces,\n\t\t\tcomplained: health.complaints,\n\t\t\tdeliveryRate: health.deliveryRate,\n\t\t\tbounceRate: health.bounceRate,\n\t\t\tcomplaintRate: health.complaintRate,\n\t\t},\n\t\treputation: {\n\t\t\tcurrent: health.reputationScore,\n\t\t\tchange: 0, // Would need historical data to calculate\n\t\t\tstatus: health.status,\n\t\t},\n\t\trecommendations,\n\t};\n}\n","/**\n * Postmark Email Client\n *\n * This module provides integration with Postmark as a fallback email provider.\n * Postmark is known for excellent deliverability and is used when Resend fails.\n *\n * Features:\n * - Email sending with automatic retry\n * - Domain/sender signature management\n * - Webhook signature verification\n * - Delivery status tracking\n *\n * Environment Variables Required:\n * - POSTMARK_API_KEY: Your Postmark server API token\n * - POSTMARK_WEBHOOK_SECRET: Secret for verifying webhook signatures (optional)\n *\n * @see https://postmarkapp.com/developer\n */\n\nimport crypto from \"node:crypto\";\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nconst POSTMARK_API_BASE = \"https://api.postmarkapp.com\";\n\n/**\n * Postmark client configuration\n * Checks environment variables and provides defaults\n */\nexport const postmarkConfig = {\n\tapiKey: process.env.POSTMARK_API_KEY || \"\",\n\twebhookSecret: process.env.POSTMARK_WEBHOOK_SECRET || \"\",\n\t// Default \"from\" address for Postmark (must be verified sender signature)\n\tfrom: process.env.POSTMARK_FROM_EMAIL || process.env.EMAIL_FROM || \"notifications@stratos.app\",\n\t// Is Postmark configured and ready to use?\n\tisConfigured: !!process.env.POSTMARK_API_KEY,\n\t// Provider name for logging/monitoring\n\tproviderName: \"postmark\" as const,\n};\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Standard response wrapper for Postmark API calls\n * Matches the pattern used by Resend for consistency\n */\nexport type PostmarkResponse<T> =\n\t| { success: true; data: T }\n\t| { success: false; error: string; errorCode?: number };\n\n/**\n * Postmark email send request\n * @see https://postmarkapp.com/developer/api/email-api\n */\nexport interface PostmarkSendRequest {\n\tFrom: string;\n\tTo: string;\n\tSubject: string;\n\tHtmlBody?: string;\n\tTextBody?: string;\n\tReplyTo?: string;\n\tTag?: string;\n\tTrackOpens?: boolean;\n\tTrackLinks?: \"None\" | \"HtmlAndText\" | \"HtmlOnly\" | \"TextOnly\";\n\tMessageStream?: string;\n\tMetadata?: Record<string, string>;\n}\n\n/**\n * Postmark email send response\n */\nexport interface PostmarkSendResponse {\n\tTo: string;\n\tSubmittedAt: string;\n\tMessageID: string;\n\tErrorCode: number;\n\tMessage: string;\n}\n\n/**\n * Postmark domain (sender signature) data\n * @see https://postmarkapp.com/developer/api/signatures-api\n */\nexport interface PostmarkDomainData {\n\tID: number;\n\tDomain: string;\n\tEmailAddress: string;\n\tReplyToEmailAddress: string;\n\tName: string;\n\tConfirmed: boolean;\n\tSPFVerified: boolean;\n\tSPFHost: string;\n\tSPFTextValue: string;\n\tDKIMVerified: boolean;\n\tWeakDKIM: boolean;\n\tDKIMHost: string;\n\tDKIMTextValue: string;\n\tDKIMPendingHost: string;\n\tDKIMPendingTextValue: string;\n\tDKIMRevokedHost: string;\n\tDKIMRevokedTextValue: string;\n\tSafeToRemoveRevokedKeyFromDNS: boolean;\n\tDKIMUpdateStatus: string;\n\tReturnPathDomain: string;\n\tReturnPathDomainCNAMEValue: string;\n\tReturnPathDomainVerified: boolean;\n}\n\n/**\n * Postmark webhook event types\n */\nexport type PostmarkWebhookEventType =\n\t| \"Delivery\"\n\t| \"Bounce\"\n\t| \"SpamComplaint\"\n\t| \"Open\"\n\t| \"Click\"\n\t| \"SubscriptionChange\";\n\n/**\n * Postmark webhook payload base\n */\nexport interface PostmarkWebhookPayload {\n\tRecordType: PostmarkWebhookEventType;\n\tMessageID: string;\n\tRecipient: string;\n\tTag: string;\n\tDeliveredAt?: string;\n\tBouncedAt?: string;\n\tType?: string; // Bounce type\n\tTypeCode?: number;\n\tDescription?: string;\n\tDetails?: string;\n\tEmail?: string;\n\tFrom?: string;\n\tSubject?: string;\n\tMetadata?: Record<string, string>;\n}\n\n// =============================================================================\n// API REQUEST HELPER\n// =============================================================================\n\n/**\n * Makes authenticated requests to Postmark API\n *\n * @param path - API endpoint path (e.g., \"/email\")\n * @param init - Fetch request options\n * @returns Typed response with success/error handling\n *\n * @example\n * const result = await postmarkRequest<PostmarkSendResponse>(\"/email\", {\n *   method: \"POST\",\n *   body: JSON.stringify(emailData),\n * });\n */\nasync function postmarkRequest<T>(\n\tpath: string,\n\tinit: RequestInit\n): Promise<PostmarkResponse<T>> {\n\t// Check if Postmark is configured\n\tif (!postmarkConfig.apiKey) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Postmark API key is not configured. Set POSTMARK_API_KEY environment variable.\",\n\t\t};\n\t}\n\n\ttry {\n\t\tconst response = await fetch(`${POSTMARK_API_BASE}${path}`, {\n\t\t\t...init,\n\t\t\theaders: {\n\t\t\t\t// Postmark uses X-Postmark-Server-Token for authentication\n\t\t\t\t\"X-Postmark-Server-Token\": postmarkConfig.apiKey,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\tAccept: \"application/json\",\n\t\t\t\t...init.headers,\n\t\t\t},\n\t\t});\n\n\t\t// Parse response body\n\t\tconst body = await response.json().catch(() => ({}));\n\n\t\t// Handle non-OK responses\n\t\tif (!response.ok) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: body.Message || body.message || response.statusText,\n\t\t\t\terrorCode: body.ErrorCode,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: body as T };\n\t} catch (error) {\n\t\t// Network or parsing error\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Postmark request failed\",\n\t\t};\n\t}\n}\n\n// =============================================================================\n// EMAIL SENDING\n// =============================================================================\n\n/**\n * Send an email via Postmark\n *\n * This is the primary email sending function for Postmark.\n * It handles HTML emails with optional tracking.\n *\n * @param options - Email send options\n * @returns Send result with MessageID on success\n *\n * @example\n * const result = await sendPostmarkEmail({\n *   to: \"user@example.com\",\n *   subject: \"Welcome!\",\n *   html: \"<h1>Hello</h1>\",\n *   from: \"hello@mycompany.com\",\n *   tags: { template: \"welcome\" },\n * });\n */\nexport async function sendPostmarkEmail(options: {\n\tto: string | string[];\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\tfrom?: string;\n\treplyTo?: string;\n\ttag?: string;\n\ttrackOpens?: boolean;\n\ttrackLinks?: boolean;\n\tmetadata?: Record<string, string>;\n\tmessageStream?: string;\n}): Promise<PostmarkResponse<PostmarkSendResponse>> {\n\tconst {\n\t\tto,\n\t\tsubject,\n\t\thtml,\n\t\ttext,\n\t\tfrom = postmarkConfig.from,\n\t\treplyTo,\n\t\ttag,\n\t\ttrackOpens = true,\n\t\ttrackLinks = true,\n\t\tmetadata,\n\t\tmessageStream = \"outbound\", // Default message stream\n\t} = options;\n\n\t// Postmark requires single recipient per request for /email endpoint\n\t// For multiple recipients, we'd use /email/batch\n\tconst recipient = Array.isArray(to) ? to.join(\", \") : to;\n\n\tconst request: PostmarkSendRequest = {\n\t\tFrom: from,\n\t\tTo: recipient,\n\t\tSubject: subject,\n\t\tHtmlBody: html,\n\t\tTextBody: text,\n\t\tReplyTo: replyTo,\n\t\tTag: tag,\n\t\tTrackOpens: trackOpens,\n\t\tTrackLinks: trackLinks ? \"HtmlAndText\" : \"None\",\n\t\tMessageStream: messageStream,\n\t\tMetadata: metadata,\n\t};\n\n\t// Log send attempt for monitoring\n\tconsole.log(`[Postmark] Sending email to ${recipient}, subject: \"${subject}\"`);\n\n\tconst result = await postmarkRequest<PostmarkSendResponse>(\"/email\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(request),\n\t});\n\n\t// Log result for monitoring\n\tif (result.success) {\n\t\tconsole.log(`[Postmark] Email sent successfully, MessageID: ${result.data.MessageID}`);\n\t} else {\n\t\tconsole.error(`[Postmark] Email send failed: ${result.error}`);\n\t}\n\n\treturn result;\n}\n\n/**\n * Send batch emails via Postmark (up to 500 per request)\n *\n * @param emails - Array of email options\n * @returns Array of send results\n */\nexport async function sendPostmarkBatchEmails(\n\temails: Array<{\n\t\tto: string;\n\t\tsubject: string;\n\t\thtml: string;\n\t\ttext?: string;\n\t\tfrom?: string;\n\t\treplyTo?: string;\n\t\ttag?: string;\n\t\tmetadata?: Record<string, string>;\n\t}>\n): Promise<PostmarkResponse<PostmarkSendResponse[]>> {\n\tif (emails.length > 500) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Postmark batch limit is 500 emails per request\",\n\t\t};\n\t}\n\n\tconst requests: PostmarkSendRequest[] = emails.map((email) => ({\n\t\tFrom: email.from || postmarkConfig.from,\n\t\tTo: email.to,\n\t\tSubject: email.subject,\n\t\tHtmlBody: email.html,\n\t\tTextBody: email.text,\n\t\tReplyTo: email.replyTo,\n\t\tTag: email.tag,\n\t\tTrackOpens: true,\n\t\tTrackLinks: \"HtmlAndText\",\n\t\tMetadata: email.metadata,\n\t}));\n\n\tconsole.log(`[Postmark] Sending batch of ${emails.length} emails`);\n\n\treturn postmarkRequest<PostmarkSendResponse[]>(\"/email/batch\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(requests),\n\t});\n}\n\n// =============================================================================\n// DOMAIN/SENDER SIGNATURE MANAGEMENT\n// =============================================================================\n\n/**\n * List all sender signatures (domains) in Postmark\n *\n * @returns List of sender signatures\n */\nexport async function listPostmarkDomains(): Promise<\n\tPostmarkResponse<{ TotalCount: number; SenderSignatures: PostmarkDomainData[] }>\n> {\n\tconsole.log(\"[Postmark] Listing sender signatures\");\n\treturn postmarkRequest(\"/senders\", { method: \"GET\" });\n}\n\n/**\n * Get details of a specific sender signature\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Sender signature details\n */\nexport async function getPostmarkDomain(\n\tsignatureId: number\n): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconsole.log(`[Postmark] Getting sender signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}`, { method: \"GET\" });\n}\n\n/**\n * Create a new sender signature in Postmark\n *\n * Note: Postmark uses \"sender signatures\" which can be either:\n * - Individual email addresses\n * - Entire domains\n *\n * @param options - Sender signature options\n * @returns Created sender signature\n */\nexport async function createPostmarkDomain(options: {\n\tfromEmail: string;\n\tname: string;\n\treplyToEmail?: string;\n}): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconst { fromEmail, name, replyToEmail } = options;\n\n\tconsole.log(`[Postmark] Creating sender signature for ${fromEmail}`);\n\n\treturn postmarkRequest(\"/senders\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify({\n\t\t\tFromEmail: fromEmail,\n\t\t\tName: name,\n\t\t\tReplyToEmail: replyToEmail || fromEmail,\n\t\t}),\n\t});\n}\n\n/**\n * Delete a sender signature from Postmark\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Deletion result\n */\nexport async function deletePostmarkDomain(\n\tsignatureId: number\n): Promise<PostmarkResponse<{ Message: string }>> {\n\tconsole.log(`[Postmark] Deleting sender signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}`, { method: \"DELETE\" });\n}\n\n/**\n * Resend confirmation email for a sender signature\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Resend result\n */\nexport async function resendPostmarkConfirmation(\n\tsignatureId: number\n): Promise<PostmarkResponse<{ Message: string }>> {\n\tconsole.log(`[Postmark] Resending confirmation for signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}/resend`, { method: \"POST\" });\n}\n\n/**\n * Verify DKIM for a sender signature\n * Triggers Postmark to check DNS records\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Updated sender signature with verification status\n */\nexport async function verifyPostmarkDKIM(\n\tsignatureId: number\n): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconsole.log(`[Postmark] Verifying DKIM for signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}/verifyDkim`, { method: \"PUT\" });\n}\n\n/**\n * Verify Return-Path for a sender signature\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Updated sender signature with verification status\n */\nexport async function verifyPostmarkReturnPath(\n\tsignatureId: number\n): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconsole.log(`[Postmark] Verifying Return-Path for signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}/verifyReturnPath`, { method: \"PUT\" });\n}\n\n// =============================================================================\n// SERVER/ACCOUNT INFO\n// =============================================================================\n\n/**\n * Get Postmark server information\n * Useful for verifying API key and getting server settings\n *\n * @returns Server information\n */\nexport async function getPostmarkServerInfo(): Promise<\n\tPostmarkResponse<{\n\t\tID: number;\n\t\tName: string;\n\t\tApiTokens: string[];\n\t\tColor: string;\n\t\tSmtpApiActivated: boolean;\n\t\tRawEmailEnabled: boolean;\n\t\tInboundAddress: string;\n\t\tInboundHookUrl: string;\n\t\tBounceHookUrl: string;\n\t\tOpenHookUrl: string;\n\t\tPostFirstOpenOnly: boolean;\n\t\tTrackOpens: boolean;\n\t\tTrackLinks: string;\n\t\tInboundDomain: string;\n\t\tInboundSpamThreshold: number;\n\t}>\n> {\n\tconsole.log(\"[Postmark] Getting server info\");\n\treturn postmarkRequest(\"/server\", { method: \"GET\" });\n}\n\n// =============================================================================\n// WEBHOOK VERIFICATION\n// =============================================================================\n\n/**\n * Verify Postmark webhook signature\n *\n * Postmark webhooks don't use signatures by default, but you can configure\n * basic auth or use the webhook token. This function verifies the token\n * if POSTMARK_WEBHOOK_SECRET is configured.\n *\n * @param options - Webhook verification options\n * @returns Whether the webhook is valid\n *\n * @example\n * const isValid = verifyPostmarkWebhook({\n *   payload: requestBody,\n *   token: request.headers.get(\"X-Postmark-Token\"),\n * });\n */\nexport function verifyPostmarkWebhook(options: {\n\tpayload: string;\n\ttoken?: string | null;\n}): boolean {\n\tconst { token } = options;\n\n\t// If no secret configured, accept all webhooks (not recommended for production)\n\tif (!postmarkConfig.webhookSecret) {\n\t\tconsole.warn(\"[Postmark] No webhook secret configured - accepting webhook without verification\");\n\t\treturn true;\n\t}\n\n\t// Verify the token matches our secret\n\tif (!token) {\n\t\tconsole.error(\"[Postmark] Webhook missing token\");\n\t\treturn false;\n\t}\n\n\t// Use timing-safe comparison to prevent timing attacks\n\ttry {\n\t\tconst expected = Buffer.from(postmarkConfig.webhookSecret);\n\t\tconst received = Buffer.from(token);\n\n\t\tif (expected.length !== received.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn crypto.timingSafeEqual(expected, received);\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n// =============================================================================\n// HEALTH CHECK\n// =============================================================================\n\n/**\n * Check if Postmark is healthy and responsive\n *\n * This function attempts to fetch server info to verify:\n * 1. API key is valid\n * 2. Postmark API is reachable\n * 3. Account is in good standing\n *\n * @returns Health check result\n */\nexport async function checkPostmarkHealth(): Promise<{\n\thealthy: boolean;\n\tprovider: \"postmark\";\n\tlatencyMs: number;\n\terror?: string;\n}> {\n\tconst startTime = Date.now();\n\n\ttry {\n\t\tconst result = await getPostmarkServerInfo();\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tif (result.success) {\n\t\t\tconsole.log(`[Postmark] Health check passed in ${latencyMs}ms`);\n\t\t\treturn {\n\t\t\t\thealthy: true,\n\t\t\t\tprovider: \"postmark\",\n\t\t\t\tlatencyMs,\n\t\t\t};\n\t\t}\n\n\t\tconsole.error(`[Postmark] Health check failed: ${result.error}`);\n\t\treturn {\n\t\t\thealthy: false,\n\t\t\tprovider: \"postmark\",\n\t\t\tlatencyMs,\n\t\t\terror: result.error,\n\t\t};\n\t} catch (error) {\n\t\tconst latencyMs = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\n\t\tconsole.error(`[Postmark] Health check error: ${errorMessage}`);\n\t\treturn {\n\t\t\thealthy: false,\n\t\t\tprovider: \"postmark\",\n\t\t\tlatencyMs,\n\t\t\terror: errorMessage,\n\t\t};\n\t}\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Check if Postmark is properly configured\n *\n * @returns Whether Postmark can be used\n */\nexport function isPostmarkConfigured(): boolean {\n\treturn postmarkConfig.isConfigured;\n}\n\n/**\n * Get DNS records needed for a domain in Postmark format\n *\n * @param domain - Postmark domain data\n * @returns Formatted DNS records for display\n */\nexport function getPostmarkDNSRecords(domain: PostmarkDomainData): Array<{\n\ttype: string;\n\tname: string;\n\tvalue: string;\n\tverified: boolean;\n}> {\n\tconst records: Array<{\n\t\ttype: string;\n\t\tname: string;\n\t\tvalue: string;\n\t\tverified: boolean;\n\t}> = [];\n\n\t// DKIM record\n\tif (domain.DKIMHost && domain.DKIMTextValue) {\n\t\trecords.push({\n\t\t\ttype: \"TXT\",\n\t\t\tname: domain.DKIMHost,\n\t\t\tvalue: domain.DKIMTextValue,\n\t\t\tverified: domain.DKIMVerified,\n\t\t});\n\t}\n\n\t// Return-Path CNAME\n\tif (domain.ReturnPathDomain && domain.ReturnPathDomainCNAMEValue) {\n\t\trecords.push({\n\t\t\ttype: \"CNAME\",\n\t\t\tname: domain.ReturnPathDomain,\n\t\t\tvalue: domain.ReturnPathDomainCNAMEValue,\n\t\t\tverified: domain.ReturnPathDomainVerified,\n\t\t});\n\t}\n\n\treturn records;\n}\n","\"use server\";\n\n/**\n * Email Provider Monitor\n *\n * This module tracks the health and performance of email providers (Resend & Postmark).\n * It records every email send attempt and provides analytics for monitoring.\n *\n * Features:\n * - Track success/failure rates per provider\n * - Record latency metrics\n * - Store detailed error information\n * - Provide real-time health dashboards\n * - Alert on provider degradation\n *\n * Database Tables Used:\n * - email_provider_events: Individual send attempts\n * - email_provider_health: Aggregated health metrics (updated periodically)\n *\n * Usage:\n * ```typescript\n * // Record a successful send\n * await recordProviderEvent({\n *   provider: \"resend\",\n *   eventType: \"send_success\",\n *   messageId: \"abc123\",\n *   latencyMs: 150,\n * });\n *\n * // Get provider health stats\n * const stats = await getProviderStats(\"resend\", \"24h\");\n * ```\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport type { EmailProvider } from \"./email-provider\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Types of events we track for email providers\n */\nexport type ProviderEventType =\n\t| \"send_success\" // Email sent successfully\n\t| \"send_failure\" // Email send failed\n\t| \"health_check_success\" // Health check passed\n\t| \"health_check_failure\" // Health check failed\n\t| \"webhook_received\" // Webhook event received\n\t| \"fallback_triggered\"; // Fallback to secondary provider was used\n\n/**\n * Event data for recording provider activity\n */\nexport interface ProviderEventData {\n\t/** Which provider this event is for */\n\tprovider: EmailProvider;\n\t/** Type of event */\n\teventType: ProviderEventType;\n\t/** Message ID if applicable */\n\tmessageId?: string;\n\t/** Time taken for the operation in milliseconds */\n\tlatencyMs?: number;\n\t/** Error message if this was a failure */\n\terror?: string;\n\t/** Additional metadata */\n\tmetadata?: Record<string, unknown>;\n\t/** Company ID for multi-tenant tracking */\n\tcompanyId?: string;\n\t/** Domain ID if associated with a specific domain */\n\tdomainId?: string;\n}\n\n/**\n * Aggregated statistics for a provider\n */\nexport interface ProviderStats {\n\tprovider: EmailProvider;\n\tperiod: string;\n\ttotalEvents: number;\n\tsuccessCount: number;\n\tfailureCount: number;\n\tsuccessRate: number;\n\taverageLatencyMs: number;\n\tp95LatencyMs: number;\n\tfallbackCount: number;\n\tlastEventAt: Date | null;\n\tlastError: string | null;\n}\n\n/**\n * Real-time health status for dashboard\n */\nexport interface ProviderHealthDashboard {\n\tresend: {\n\t\tstatus: \"healthy\" | \"degraded\" | \"down\" | \"unknown\";\n\t\tsuccessRate24h: number;\n\t\tavgLatencyMs: number;\n\t\ttotalSent24h: number;\n\t\tlastError?: string;\n\t\tlastSuccessAt?: Date;\n\t};\n\tpostmark: {\n\t\tstatus: \"healthy\" | \"degraded\" | \"down\" | \"unknown\";\n\t\tsuccessRate24h: number;\n\t\tavgLatencyMs: number;\n\t\ttotalSent24h: number;\n\t\tlastError?: string;\n\t\tlastSuccessAt?: Date;\n\t};\n\toverall: {\n\t\tprimaryProvider: EmailProvider;\n\t\tfallbackProvider: EmailProvider;\n\t\tfallbackRate24h: number;\n\t\trecommendedAction?: string;\n\t};\n}\n\n// =============================================================================\n// EVENT RECORDING\n// =============================================================================\n\n/**\n * Record a provider event to the database\n *\n * This function logs every email provider interaction for monitoring.\n * Events are stored in the email_provider_events table.\n *\n * @param event - Event data to record\n * @returns Success status\n *\n * @example\n * await recordProviderEvent({\n *   provider: \"resend\",\n *   eventType: \"send_success\",\n *   messageId: \"msg_123\",\n *   latencyMs: 145,\n *   companyId: \"company_abc\",\n * });\n */\nexport async function recordProviderEvent(\n\tevent: ProviderEventData\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Log to console for immediate visibility\n\t\tconst logPrefix = event.eventType.includes(\"success\") ? \"✓\" : \"✗\";\n\t\tconsole.log(\n\t\t\t`[ProviderMonitor] ${logPrefix} ${event.provider}:${event.eventType}` +\n\t\t\t\t(event.latencyMs ? ` (${event.latencyMs}ms)` : \"\") +\n\t\t\t\t(event.error ? ` - ${event.error}` : \"\")\n\t\t);\n\n\t\t// Insert event into database\n\t\tconst { error } = await supabase.from(\"email_provider_events\").insert({\n\t\t\tprovider: event.provider,\n\t\t\tevent_type: event.eventType,\n\t\t\tmessage_id: event.messageId || null,\n\t\t\tlatency_ms: event.latencyMs || null,\n\t\t\terror_message: event.error || null,\n\t\t\tmetadata: event.metadata || null,\n\t\t\tcompany_id: event.companyId || null,\n\t\t\tdomain_id: event.domainId || null,\n\t\t\tcreated_at: new Date().toISOString(),\n\t\t});\n\n\t\tif (error) {\n\t\t\t// Don't fail the main operation if monitoring fails\n\t\t\tconsole.error(`[ProviderMonitor] Failed to record event: ${error.message}`);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\t// Monitoring should never break the main flow\n\t\tconsole.error(\n\t\t\t`[ProviderMonitor] Error recording event: ${error instanceof Error ? error.message : \"Unknown error\"}`\n\t\t);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Record a successful email send\n * Convenience wrapper for recordProviderEvent\n */\nexport async function recordSendSuccess(\n\tprovider: EmailProvider,\n\tmessageId: string,\n\tlatencyMs: number,\n\toptions?: { companyId?: string; domainId?: string; metadata?: Record<string, unknown> }\n): Promise<void> {\n\tawait recordProviderEvent({\n\t\tprovider,\n\t\teventType: \"send_success\",\n\t\tmessageId,\n\t\tlatencyMs,\n\t\t...options,\n\t});\n}\n\n/**\n * Record a failed email send\n * Convenience wrapper for recordProviderEvent\n */\nexport async function recordSendFailure(\n\tprovider: EmailProvider,\n\terror: string,\n\tlatencyMs: number,\n\toptions?: { companyId?: string; domainId?: string; metadata?: Record<string, unknown> }\n): Promise<void> {\n\tawait recordProviderEvent({\n\t\tprovider,\n\t\teventType: \"send_failure\",\n\t\terror,\n\t\tlatencyMs,\n\t\t...options,\n\t});\n}\n\n/**\n * Record when fallback provider was used\n */\nexport async function recordFallbackTriggered(\n\tprimaryProvider: EmailProvider,\n\tfallbackProvider: EmailProvider,\n\tprimaryError: string,\n\toptions?: { companyId?: string; metadata?: Record<string, unknown> }\n): Promise<void> {\n\tawait recordProviderEvent({\n\t\tprovider: primaryProvider,\n\t\teventType: \"fallback_triggered\",\n\t\terror: primaryError,\n\t\tmetadata: {\n\t\t\tfallback_provider: fallbackProvider,\n\t\t\t...options?.metadata,\n\t\t},\n\t\t...options,\n\t});\n}\n\n// =============================================================================\n// STATISTICS & ANALYTICS\n// =============================================================================\n\n/**\n * Get statistics for a specific provider\n *\n * @param provider - Provider to get stats for\n * @param period - Time period (\"1h\", \"24h\", \"7d\", \"30d\")\n * @returns Provider statistics\n */\nexport async function getProviderStats(\n\tprovider: EmailProvider,\n\tperiod: \"1h\" | \"24h\" | \"7d\" | \"30d\" = \"24h\"\n): Promise<ProviderStats | null> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Calculate start time based on period\n\t\tconst now = new Date();\n\t\tconst periodMs = {\n\t\t\t\"1h\": 60 * 60 * 1000,\n\t\t\t\"24h\": 24 * 60 * 60 * 1000,\n\t\t\t\"7d\": 7 * 24 * 60 * 60 * 1000,\n\t\t\t\"30d\": 30 * 24 * 60 * 60 * 1000,\n\t\t};\n\t\tconst startTime = new Date(now.getTime() - periodMs[period]).toISOString();\n\n\t\t// Query events for this provider and period\n\t\tconst { data: events, error } = await supabase\n\t\t\t.from(\"email_provider_events\")\n\t\t\t.select(\"event_type, latency_ms, error_message, created_at\")\n\t\t\t.eq(\"provider\", provider)\n\t\t\t.gte(\"created_at\", startTime)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(`[ProviderMonitor] Failed to get stats: ${error.message}`);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!events || events.length === 0) {\n\t\t\treturn {\n\t\t\t\tprovider,\n\t\t\t\tperiod,\n\t\t\t\ttotalEvents: 0,\n\t\t\t\tsuccessCount: 0,\n\t\t\t\tfailureCount: 0,\n\t\t\t\tsuccessRate: 0,\n\t\t\t\taverageLatencyMs: 0,\n\t\t\t\tp95LatencyMs: 0,\n\t\t\t\tfallbackCount: 0,\n\t\t\t\tlastEventAt: null,\n\t\t\t\tlastError: null,\n\t\t\t};\n\t\t}\n\n\t\t// Calculate statistics\n\t\tconst sendEvents = events.filter(\n\t\t\t(e) => e.event_type === \"send_success\" || e.event_type === \"send_failure\"\n\t\t);\n\t\tconst successEvents = events.filter((e) => e.event_type === \"send_success\");\n\t\tconst failureEvents = events.filter((e) => e.event_type === \"send_failure\");\n\t\tconst fallbackEvents = events.filter((e) => e.event_type === \"fallback_triggered\");\n\n\t\t// Calculate latency metrics\n\t\tconst latencies = successEvents\n\t\t\t.map((e) => e.latency_ms)\n\t\t\t.filter((l): l is number => l !== null)\n\t\t\t.sort((a, b) => a - b);\n\n\t\tconst avgLatency =\n\t\t\tlatencies.length > 0\n\t\t\t\t? latencies.reduce((sum, l) => sum + l, 0) / latencies.length\n\t\t\t\t: 0;\n\n\t\tconst p95Index = Math.floor(latencies.length * 0.95);\n\t\tconst p95Latency = latencies.length > 0 ? latencies[p95Index] || latencies[latencies.length - 1] : 0;\n\n\t\t// Find last error\n\t\tconst lastFailure = failureEvents[0];\n\n\t\treturn {\n\t\t\tprovider,\n\t\t\tperiod,\n\t\t\ttotalEvents: events.length,\n\t\t\tsuccessCount: successEvents.length,\n\t\t\tfailureCount: failureEvents.length,\n\t\t\tsuccessRate:\n\t\t\t\tsendEvents.length > 0\n\t\t\t\t\t? (successEvents.length / sendEvents.length) * 100\n\t\t\t\t\t: 0,\n\t\t\taverageLatencyMs: Math.round(avgLatency),\n\t\t\tp95LatencyMs: Math.round(p95Latency),\n\t\t\tfallbackCount: fallbackEvents.length,\n\t\t\tlastEventAt: events[0] ? new Date(events[0].created_at) : null,\n\t\t\tlastError: lastFailure?.error_message || null,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\n\t\t\t`[ProviderMonitor] Error getting stats: ${error instanceof Error ? error.message : \"Unknown error\"}`\n\t\t);\n\t\treturn null;\n\t}\n}\n\n/**\n * Get health dashboard data for all providers\n *\n * @returns Dashboard data for monitoring UI\n */\nexport async function getProviderHealthDashboard(): Promise<ProviderHealthDashboard> {\n\tconsole.log(\"[ProviderMonitor] Getting health dashboard data...\");\n\n\t// Get stats for both providers\n\tconst [resendStats, postmarkStats] = await Promise.all([\n\t\tgetProviderStats(\"resend\", \"24h\"),\n\t\tgetProviderStats(\"postmark\", \"24h\"),\n\t]);\n\n\t// Determine health status based on success rate\n\tconst getStatus = (\n\t\tstats: ProviderStats | null\n\t): \"healthy\" | \"degraded\" | \"down\" | \"unknown\" => {\n\t\tif (!stats || stats.totalEvents === 0) return \"unknown\";\n\t\tif (stats.successRate >= 99) return \"healthy\";\n\t\tif (stats.successRate >= 95) return \"degraded\";\n\t\treturn \"down\";\n\t};\n\n\t// Calculate fallback rate\n\tconst totalFallbacks = (resendStats?.fallbackCount || 0) + (postmarkStats?.fallbackCount || 0);\n\tconst totalSends =\n\t\t(resendStats?.successCount || 0) +\n\t\t(resendStats?.failureCount || 0) +\n\t\t(postmarkStats?.successCount || 0) +\n\t\t(postmarkStats?.failureCount || 0);\n\tconst fallbackRate = totalSends > 0 ? (totalFallbacks / totalSends) * 100 : 0;\n\n\t// Determine recommended action\n\tlet recommendedAction: string | undefined;\n\tconst resendStatus = getStatus(resendStats);\n\tconst postmarkStatus = getStatus(postmarkStats);\n\n\tif (resendStatus === \"down\" && postmarkStatus === \"down\") {\n\t\trecommendedAction = \"CRITICAL: Both providers are down. Check API keys and provider status.\";\n\t} else if (resendStatus === \"down\") {\n\t\trecommendedAction = \"Primary provider (Resend) is down. Traffic is using fallback.\";\n\t} else if (fallbackRate > 10) {\n\t\trecommendedAction = \"High fallback rate detected. Review primary provider health.\";\n\t} else if (resendStatus === \"degraded\") {\n\t\trecommendedAction = \"Primary provider showing degraded performance. Monitor closely.\";\n\t}\n\n\treturn {\n\t\tresend: {\n\t\t\tstatus: resendStatus,\n\t\t\tsuccessRate24h: resendStats?.successRate || 0,\n\t\t\tavgLatencyMs: resendStats?.averageLatencyMs || 0,\n\t\t\ttotalSent24h: resendStats?.successCount || 0,\n\t\t\tlastError: resendStats?.lastError || undefined,\n\t\t\tlastSuccessAt: resendStats?.lastEventAt || undefined,\n\t\t},\n\t\tpostmark: {\n\t\t\tstatus: postmarkStatus,\n\t\t\tsuccessRate24h: postmarkStats?.successRate || 0,\n\t\t\tavgLatencyMs: postmarkStats?.averageLatencyMs || 0,\n\t\t\ttotalSent24h: postmarkStats?.successCount || 0,\n\t\t\tlastError: postmarkStats?.lastError || undefined,\n\t\t\tlastSuccessAt: postmarkStats?.lastEventAt || undefined,\n\t\t},\n\t\toverall: {\n\t\t\tprimaryProvider: \"resend\",\n\t\t\tfallbackProvider: \"postmark\",\n\t\t\tfallbackRate24h: fallbackRate,\n\t\t\trecommendedAction,\n\t\t},\n\t};\n}\n\n// =============================================================================\n// CLEANUP & MAINTENANCE\n// =============================================================================\n\n/**\n * Clean up old provider events\n * Should be run periodically (e.g., daily cron job)\n *\n * @param retentionDays - Number of days to retain events\n * @returns Number of deleted events\n */\nexport async function cleanupOldEvents(\n\tretentionDays: number = 30\n): Promise<{ deleted: number; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\tconst cutoffDate = new Date();\n\t\tcutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_provider_events\")\n\t\t\t.delete()\n\t\t\t.lt(\"created_at\", cutoffDate.toISOString())\n\t\t\t.select(\"id\");\n\n\t\tif (error) {\n\t\t\tconsole.error(`[ProviderMonitor] Cleanup failed: ${error.message}`);\n\t\t\treturn { deleted: 0, error: error.message };\n\t\t}\n\n\t\tconst deletedCount = data?.length || 0;\n\t\tconsole.log(`[ProviderMonitor] Cleaned up ${deletedCount} events older than ${retentionDays} days`);\n\n\t\treturn { deleted: deletedCount };\n\t} catch (error) {\n\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\tconsole.error(`[ProviderMonitor] Cleanup error: ${errorMessage}`);\n\t\treturn { deleted: 0, error: errorMessage };\n\t}\n}\n\n// =============================================================================\n// ALERTING HELPERS\n// =============================================================================\n\n/**\n * Check if a provider should trigger an alert\n *\n * @param provider - Provider to check\n * @returns Alert status and reason\n */\nexport async function checkProviderAlert(\n\tprovider: EmailProvider\n): Promise<{\n\tshouldAlert: boolean;\n\tseverity: \"info\" | \"warning\" | \"critical\";\n\treason?: string;\n}> {\n\tconst stats = await getProviderStats(provider, \"1h\");\n\n\tif (!stats) {\n\t\treturn { shouldAlert: false, severity: \"info\" };\n\t}\n\n\t// No events in the last hour - might be expected during low traffic\n\tif (stats.totalEvents === 0) {\n\t\treturn { shouldAlert: false, severity: \"info\" };\n\t}\n\n\t// Critical: Success rate below 90%\n\tif (stats.successRate < 90) {\n\t\treturn {\n\t\t\tshouldAlert: true,\n\t\t\tseverity: \"critical\",\n\t\t\treason: `${provider} success rate is ${stats.successRate.toFixed(1)}% (below 90%)`,\n\t\t};\n\t}\n\n\t// Warning: Success rate below 99%\n\tif (stats.successRate < 99) {\n\t\treturn {\n\t\t\tshouldAlert: true,\n\t\t\tseverity: \"warning\",\n\t\t\treason: `${provider} success rate is ${stats.successRate.toFixed(1)}% (below 99%)`,\n\t\t};\n\t}\n\n\t// Warning: High latency\n\tif (stats.averageLatencyMs > 5000) {\n\t\treturn {\n\t\t\tshouldAlert: true,\n\t\t\tseverity: \"warning\",\n\t\t\treason: `${provider} average latency is ${stats.averageLatencyMs}ms (above 5s)`,\n\t\t};\n\t}\n\n\treturn { shouldAlert: false, severity: \"info\" };\n}\n"],"names":[],"mappings":"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"}