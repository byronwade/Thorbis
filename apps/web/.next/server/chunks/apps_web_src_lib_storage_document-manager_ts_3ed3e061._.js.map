{"version":3,"sources":["../../../../../apps/web/src/lib/storage/document-manager.ts","../../../../../apps/web/src/lib/storage/file-validator.ts"],"sourcesContent":["/**\n * Document Manager Service\n *\n * Comprehensive document management for Supabase Storage with:\n * - Context-aware uploads (customer, job, equipment, general)\n * - Automatic path generation\n * - Database tracking\n * - Virus scanning integration\n * - Secure downloads with signed URLs\n * - File operations (move, delete, duplicate)\n */\n\nimport crypto from \"node:crypto\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tformatFileSize,\n\tsanitizeFileName,\n\ttype ValidationOptions,\n\tvalidateFile,\n} from \"./file-validator\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type DocumentContext = {\n\ttype:\n\t\t| \"customer\"\n\t\t| \"job\"\n\t\t| \"equipment\"\n\t\t| \"general\"\n\t\t| \"invoice\"\n\t\t| \"estimate\"\n\t\t| \"contract\";\n\tid?: string; // Entity ID (customer_id, job_id, etc.)\n\tfolder?: string; // Custom folder within context\n};\n\nexport type StorageBucket =\n\t| \"company-files\"\n\t| \"customer-documents\"\n\t| \"documents\"\n\t| \"job-photos\"\n\t| \"invoices\"\n\t| \"estimates\"\n\t| \"contracts\"\n\t| \"avatars\";\n\nexport type UploadOptions = {\n\tcompanyId: string;\n\tcontext: DocumentContext;\n\tbucket?: StorageBucket;\n\tdescription?: string;\n\ttags?: string[];\n\tisPublic?: boolean;\n\tisInternal?: boolean;\n\texpiryDate?: Date;\n\tvalidationOptions?: ValidationOptions;\n\tonProgress?: (progress: number) => void;\n};\n\nexport type UploadResult = {\n\tsuccess: boolean;\n\tattachmentId?: string;\n\tstorageUrl?: string;\n\tstoragePath?: string;\n\tpublicUrl?: string;\n\terror?: string;\n\twarnings?: string[];\n};\n\nexport type DocumentMetadata = {\n\tid: string;\n\tcompanyId: string;\n\tentityType: string;\n\tentityId?: string;\n\tfileName: string;\n\toriginalFileName: string;\n\tfileSize: number;\n\tmimeType: string;\n\tstorageUrl: string;\n\tstoragePath: string;\n\tstorageBucket: string;\n\tfolderPath?: string;\n\tvirusScanStatus: string;\n\tisPublic: boolean;\n\tuploadedBy: string;\n\tuploadedAt: Date;\n\tdescription?: string;\n\ttags?: string[];\n\taccessCount: number;\n\tdownloadCount: number;\n};\n\nexport type ListFilesOptions = {\n\tcompanyId: string;\n\tcontext?: DocumentContext;\n\tfolder?: string;\n\tsearch?: string;\n\tmimeTypes?: string[];\n\tuploadedBy?: string;\n\tvirusScanStatus?: string;\n\tlimit?: number;\n\toffset?: number;\n\tsortBy?: \"created_at\" | \"file_name\" | \"file_size\" | \"access_count\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\n// ============================================================================\n// BUCKET SELECTION\n// ============================================================================\n\n/**\n * Determine appropriate storage bucket based on context\n */\nfunction selectBucket(\n\tcontext: DocumentContext,\n\tcustomBucket?: StorageBucket,\n): StorageBucket {\n\tif (customBucket) {\n\t\treturn customBucket;\n\t}\n\n\tswitch (context.type) {\n\t\tcase \"customer\":\n\t\t\treturn \"customer-documents\";\n\t\tcase \"job\":\n\t\t\treturn \"job-photos\";\n\t\tcase \"invoice\":\n\t\t\treturn \"invoices\";\n\t\tcase \"estimate\":\n\t\t\treturn \"estimates\";\n\t\tcase \"contract\":\n\t\t\treturn \"contracts\";\n\t\tdefault:\n\t\t\treturn \"company-files\";\n\t}\n}\n\n// ============================================================================\n// PATH GENERATION\n// ============================================================================\n\n/**\n * Generate storage path based on context\n * Format: {companyId}/{contextType}/{entityId?}/{folder?}/{timestamp}-{filename}\n */\nfunction generateStoragePath(\n\tcompanyId: string,\n\tcontext: DocumentContext,\n\tfileName: string,\n): string {\n\tconst sanitized = sanitizeFileName(fileName);\n\tconst timestamp = Date.now();\n\tconst random = Math.random().toString(36).substring(2, 8);\n\tconst uniqueFileName = `${timestamp}-${random}-${sanitized}`;\n\n\tconst parts = [companyId];\n\n\t// Add context type\n\tif (context.type !== \"general\") {\n\t\tparts.push(`${context.type}s`); // customers, jobs, etc.\n\t} else {\n\t\tparts.push(\"general\");\n\t}\n\n\t// Add entity ID if provided\n\tif (context.id) {\n\t\tparts.push(context.id);\n\t}\n\n\t// Add custom folder if provided\n\tif (context.folder) {\n\t\tparts.push(context.folder);\n\t}\n\n\t// Add filename\n\tparts.push(uniqueFileName);\n\n\treturn parts.join(\"/\");\n}\n\n/**\n * Generate folder path for database tracking\n */\nfunction generateFolderPath(context: DocumentContext): string {\n\tconst parts: string[] = [];\n\n\tif (context.type === \"general\") {\n\t\tparts.push(\"general\");\n\t} else {\n\t\tparts.push(`${context.type}s`);\n\t}\n\n\tif (context.id) {\n\t\tparts.push(context.id);\n\t}\n\n\tif (context.folder) {\n\t\tparts.push(context.folder);\n\t}\n\n\treturn `/${parts.join(\"/\")}`;\n}\n\n// ============================================================================\n// CHECKSUM GENERATION\n// ============================================================================\n\n/**\n * Generate SHA256 checksum for file integrity\n */\nasync function generateChecksum(file: File): Promise<string> {\n\tconst buffer = await file.arrayBuffer();\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\tconst hashHex = hashArray\n\t\t.map((b) => b.toString(16).padStart(2, \"0\"))\n\t\t.join(\"\");\n\treturn hashHex;\n}\n\n// ============================================================================\n// UPLOAD FUNCTIONS\n// ============================================================================\n\n/**\n * Upload document to storage and track in database\n */\nexport async function uploadDocument(\n\tfile: File,\n\toptions: UploadOptions,\n): Promise<UploadResult> {\n\ttry {\n\t\t// 1. Validate file\n\t\tconst validation = await validateFile(file, options.validationOptions);\n\t\tif (!validation.valid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: validation.errors.join(\"; \"),\n\t\t\t\twarnings: validation.warnings,\n\t\t\t};\n\t\t}\n\n\t\t// 2. Get Supabase client and user\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Supabase client not available\",\n\t\t\t};\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User not authenticated\",\n\t\t\t};\n\t\t}\n\n\t\t// 3. Verify user has access to company\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"id, role\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", options.companyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User does not have access to this company\",\n\t\t\t};\n\t\t}\n\n\t\t// 4. Select bucket and generate path\n\t\tconst bucket = selectBucket(options.context, options.bucket);\n\t\tconst storagePath = generateStoragePath(\n\t\t\toptions.companyId,\n\t\t\toptions.context,\n\t\t\tvalidation.metadata?.sanitizedName || file.name,\n\t\t);\n\n\t\t// 5. Upload to storage\n\t\tconst { data: storageData, error: storageError } = await supabase.storage\n\t\t\t.from(bucket)\n\t\t\t.upload(storagePath, file, {\n\t\t\t\tcacheControl: \"3600\",\n\t\t\t\tupsert: false,\n\t\t\t});\n\n\t\tif (storageError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Storage upload failed: ${storageError.message}`,\n\t\t\t};\n\t\t}\n\n\t\t// 6. Get public URL\n\t\tconst {\n\t\t\tdata: { publicUrl },\n\t\t} = supabase.storage.from(bucket).getPublicUrl(storageData.path);\n\n\t\t// 7. Generate checksum\n\t\tconst checksum = await generateChecksum(file);\n\n\t\t// 8. Track in database\n\t\tconst folderPath = generateFolderPath(options.context);\n\n\t\tconst { data: attachment, error: dbError } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: options.companyId,\n\t\t\t\tentity_type: options.context.type,\n\t\t\t\tentity_id: options.context.id,\n\t\t\t\tfile_name: validation.metadata?.sanitizedName || file.name,\n\t\t\t\toriginal_file_name: file.name,\n\t\t\t\tfile_size: file.size,\n\t\t\t\tmime_type: validation.metadata?.detectedMimeType || file.type,\n\t\t\t\tstorage_provider: \"supabase\",\n\t\t\t\tstorage_url: publicUrl,\n\t\t\t\tstorage_path: storageData.path,\n\t\t\t\tstorage_bucket: bucket,\n\t\t\t\tfolder_path: folderPath,\n\t\t\t\tchecksum,\n\t\t\t\tis_image: file.type.startsWith(\"image/\"),\n\t\t\t\tis_document:\n\t\t\t\t\tfile.type.includes(\"pdf\") || file.type.includes(\"document\"),\n\t\t\t\tis_video: file.type.startsWith(\"video/\"),\n\t\t\t\tis_public: options.isPublic ?? false,\n\t\t\t\tis_internal: options.isInternal ?? false,\n\t\t\t\tdescription: options.description,\n\t\t\t\ttags: options.tags || [],\n\t\t\t\texpiry_date: options.expiryDate,\n\t\t\t\tuploaded_by: user.id,\n\t\t\t\tvirus_scan_status: \"pending\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (dbError) {\n\t\t\t// Rollback: delete from storage\n\t\t\tawait supabase.storage.from(bucket).remove([storageData.path]);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Database tracking failed: ${dbError.message}`,\n\t\t\t};\n\t\t}\n\n\t\t// 9. Queue virus scan (async)\n\t\tqueueVirusScan(attachment.id, bucket, storageData.path).catch(\n\t\t\tconsole.error,\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tattachmentId: attachment.id,\n\t\t\tstorageUrl: publicUrl,\n\t\t\tstoragePath: storageData.path,\n\t\t\tpublicUrl,\n\t\t\twarnings: validation.warnings,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Upload failed\",\n\t\t};\n\t}\n}\n\n/**\n * Upload multiple documents\n */\nexport async function uploadDocuments(\n\tfiles: File[],\n\toptions: UploadOptions,\n): Promise<UploadResult[]> {\n\tconst results: UploadResult[] = [];\n\n\tfor (const file of files) {\n\t\tconst result = await uploadDocument(file, options);\n\t\tresults.push(result);\n\n\t\t// Update progress if callback provided\n\t\tif (options.onProgress) {\n\t\t\tconst progress = (results.length / files.length) * 100;\n\t\t\toptions.onProgress(progress);\n\t\t}\n\t}\n\n\treturn results;\n}\n\n// ============================================================================\n// DOWNLOAD FUNCTIONS\n// ============================================================================\n\n/**\n * Get signed download URL for private files\n */\nexport async function getDownloadUrl(\n\tattachmentId: string,\n\texpiresIn = 3600,\n): Promise<{ url?: string; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { error: \"Supabase client not available\" };\n\t\t}\n\n\t\t// Get attachment details\n\t\tconst { data: attachment, error: fetchError } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"storage_bucket, storage_path, company_id, virus_scan_status\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !attachment) {\n\t\t\treturn { error: \"File not found\" };\n\t\t}\n\n\t\t// Verify user has access to company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { error: \"User not authenticated\" };\n\t\t}\n\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", attachment.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership) {\n\t\t\treturn { error: \"Access denied\" };\n\t\t}\n\n\t\t// Check virus scan status\n\t\tif (attachment.virus_scan_status === \"infected\") {\n\t\t\treturn { error: \"File failed security scan and cannot be downloaded\" };\n\t\t}\n\n\t\t// Generate signed URL\n\t\tconst { data, error } = await supabase.storage\n\t\t\t.from(attachment.storage_bucket)\n\t\t\t.createSignedUrl(attachment.storage_path, expiresIn);\n\n\t\tif (error) {\n\t\t\treturn { error: error.message };\n\t\t}\n\n\t\t// Track download\n\t\tawait supabase.rpc(\"track_file_download\", {\n\t\t\tp_attachment_id: attachmentId,\n\t\t});\n\n\t\treturn { url: data.signedUrl };\n\t} catch (error) {\n\t\treturn {\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to generate download URL\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// LIST AND SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * List documents with filtering and pagination\n */\nexport async function listDocuments(\n\toptions: ListFilesOptions,\n): Promise<{ documents: DocumentMetadata[]; total: number; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tdocuments: [],\n\t\t\t\ttotal: 0,\n\t\t\t\terror: \"Supabase client not available\",\n\t\t\t};\n\t\t}\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"company_id\", options.companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\t// Apply filters\n\t\tif (options.context) {\n\t\t\tquery = query.eq(\"entity_type\", options.context.type);\n\t\t\tif (options.context.id) {\n\t\t\t\tquery = query.eq(\"entity_id\", options.context.id);\n\t\t\t}\n\t\t}\n\n\t\tif (options.folder) {\n\t\t\tquery = query.eq(\"folder_path\", options.folder);\n\t\t}\n\n\t\tif (options.search) {\n\t\t\tquery = query.or(\n\t\t\t\t`file_name.ilike.%${options.search}%,description.ilike.%${options.search}%`,\n\t\t\t);\n\t\t}\n\n\t\tif (options.mimeTypes && options.mimeTypes.length > 0) {\n\t\t\tquery = query.in(\"mime_type\", options.mimeTypes);\n\t\t}\n\n\t\tif (options.uploadedBy) {\n\t\t\tquery = query.eq(\"uploaded_by\", options.uploadedBy);\n\t\t}\n\n\t\tif (options.virusScanStatus) {\n\t\t\tquery = query.eq(\"virus_scan_status\", options.virusScanStatus);\n\t\t}\n\n\t\t// Apply sorting\n\t\tconst sortBy = options.sortBy || \"created_at\";\n\t\tconst sortOrder = options.sortOrder || \"desc\";\n\t\tquery = query.order(sortBy, { ascending: sortOrder === \"asc\" });\n\n\t\t// Apply pagination\n\t\tconst limit = options.limit || 50;\n\t\tconst offset = options.offset || 0;\n\t\tquery = query.range(offset, offset + limit - 1);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn { documents: [], total: 0, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tdocuments: data as DocumentMetadata[],\n\t\t\ttotal: count || 0,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tdocuments: [],\n\t\t\ttotal: 0,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to list documents\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// FILE OPERATIONS\n// ============================================================================\n\n/**\n * Delete document (soft delete)\n */\nexport async function deleteDocument(\n\tattachmentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Supabase client not available\" };\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"User not authenticated\" };\n\t\t}\n\n\t\t// Get attachment to verify access\n\t\tconst { data: attachment } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (!attachment) {\n\t\t\treturn { success: false, error: \"File not found\" };\n\t\t}\n\n\t\t// Verify access\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"role\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", attachment.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership) {\n\t\t\treturn { success: false, error: \"Access denied\" };\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", attachmentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Delete failed\",\n\t\t};\n\t}\n}\n\n/**\n * Move document to different folder\n */\nexport async function moveDocument(\n\tattachmentId: string,\n\tnewFolderPath: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Supabase client not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.update({\n\t\t\t\tfolder_path: newFolderPath,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", attachmentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Move failed\",\n\t\t};\n\t}\n}\n\n/**\n * Update document metadata\n */\nexport async function updateDocumentMetadata(\n\tattachmentId: string,\n\tupdates: {\n\t\tdescription?: string;\n\t\ttags?: string[];\n\t\tisPublic?: boolean;\n\t\tisInternal?: boolean;\n\t\tisFavorite?: boolean;\n\t},\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Supabase client not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.update({ ...updates, updated_at: new Date().toISOString() })\n\t\t\t.eq(\"id\", attachmentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Update failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// VIRUS SCANNING\n// ============================================================================\n\n/**\n * Queue file for virus scanning\n */\nasync function queueVirusScan(\n\tattachmentId: string,\n\tbucket: string,\n\tpath: string,\n): Promise<void> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Call Edge Function to handle scanning\n\t\tawait supabase.functions.invoke(\"virus-scan\", {\n\t\t\tbody: { attachmentId, bucket, path },\n\t\t});\n\t} catch (_error) {}\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get document statistics for company\n */\nexport async function getDocumentStats(companyId: string): Promise<{\n\ttotalFiles: number;\n\ttotalSize: number;\n\tbyType: Record<string, number>;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\ttotalFiles: 0,\n\t\t\t\ttotalSize: 0,\n\t\t\t\tbyType: {},\n\t\t\t\terror: \"Supabase client not available\",\n\t\t\t};\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"file_size, mime_type\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\tif (error) {\n\t\t\treturn { totalFiles: 0, totalSize: 0, byType: {}, error: error.message };\n\t\t}\n\n\t\tconst totalFiles = data.length;\n\t\tconst totalSize = data.reduce((sum, file) => sum + file.file_size, 0);\n\t\tconst byType: Record<string, number> = {};\n\n\t\tdata.forEach((file) => {\n\t\t\tconst category = file.mime_type.split(\"/\")[0];\n\t\t\tbyType[category] = (byType[category] || 0) + 1;\n\t\t});\n\n\t\treturn { totalFiles, totalSize, byType };\n\t} catch (error) {\n\t\treturn {\n\t\t\ttotalFiles: 0,\n\t\t\ttotalSize: 0,\n\t\t\tbyType: {},\n\t\t\terror: error instanceof Error ? error.message : \"Failed to get stats\",\n\t\t};\n\t}\n}\n\n;\n","/**\n * File Validation and Security\n *\n * Comprehensive file validation with:\n * - Extension blocklist (dangerous file types)\n * - Magic number/signature verification\n * - Size limits by context\n * - MIME type validation\n * - Filename sanitization\n * - Content inspection\n */\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n/**\n * Blocked file extensions - Executable and potentially dangerous files\n * These can never be uploaded regardless of context\n */\nconst BLOCKED_EXTENSIONS = [\n\t// Windows executables\n\t\".exe\",\n\t\".bat\",\n\t\".cmd\",\n\t\".com\",\n\t\".scr\",\n\t\".pif\",\n\t\".application\",\n\t\".gadget\",\n\t\".msi\",\n\t\".msp\",\n\t\".msc\",\n\t\".vbs\",\n\t\".vbe\",\n\t\".js\",\n\t\".jse\",\n\t\".ws\",\n\t\".wsf\",\n\t\".wsc\",\n\t\".wsh\",\n\t\".ps1\",\n\t\".ps1xml\",\n\t\".ps2\",\n\t\".ps2xml\",\n\t\".psc1\",\n\t\".psc2\",\n\t\".msh\",\n\t\".msh1\",\n\t\".msh2\",\n\t\".mshxml\",\n\t\".msh1xml\",\n\t\".msh2xml\",\n\n\t// MacOS executables\n\t\".app\",\n\t\".dmg\",\n\t\".pkg\",\n\t\".mpkg\",\n\t\".command\",\n\n\t// Linux executables\n\t\".sh\",\n\t\".bash\",\n\t\".zsh\",\n\t\".fish\",\n\t\".ksh\",\n\t\".csh\",\n\t\".run\",\n\t\".bin\",\n\t\".deb\",\n\t\".rpm\",\n\t\".snap\",\n\n\t// Archives that can contain executables\n\t\".jar\",\n\t\".war\",\n\t\".ear\",\n\n\t// System files\n\t\".dll\",\n\t\".sys\",\n\t\".drv\",\n\n\t// Scripts and code that could be auto-executed\n\t\".cpl\",\n\t\".inf\",\n\t\".ins\",\n\t\".isp\",\n\t\".lnk\",\n\t\".mde\",\n\t\".mdt\",\n\t\".mdw\",\n\t\".mdz\",\n\t\".ops\",\n\t\".pcd\",\n\t\".prg\",\n\t\".reg\",\n\t\".scf\",\n\t\".sct\",\n\t\".shb\",\n\t\".shs\",\n\t\".url\",\n\n\t// Database files that could contain macros\n\t\".ade\",\n\t\".adp\",\n\t\".mdb\",\n\t\".accdb\",\n\n\t// Potentially dangerous compressed files\n\t\".ace\",\n\t\".arj\",\n\t\".cab\",\n];\n\n/**\n * File size limits by context (in bytes)\n */\nconst SIZE_LIMITS = {\n\tavatar: 5 * 1024 * 1024, // 5MB\n\timage: 20 * 1024 * 1024, // 20MB\n\tdocument: 100 * 1024 * 1024, // 100MB\n\tvideo: 250 * 1024 * 1024, // 250MB\n\tgeneral: 250 * 1024 * 1024, // 250MB\n\tinvoice: 20 * 1024 * 1024, // 20MB\n\testimate: 20 * 1024 * 1024, // 20MB\n\tcontract: 50 * 1024 * 1024, // 50MB\n} as const;\n\n/**\n * Allowed MIME types by category\n */\nconst ALLOWED_MIME_TYPES = {\n\timage: [\n\t\t\"image/jpeg\",\n\t\t\"image/png\",\n\t\t\"image/gif\",\n\t\t\"image/webp\",\n\t\t\"image/svg+xml\",\n\t\t\"image/bmp\",\n\t\t\"image/tiff\",\n\t\t\"image/heic\",\n\t\t\"image/heif\",\n\t],\n\tdocument: [\n\t\t\"application/pdf\",\n\t\t\"application/msword\",\n\t\t\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n\t\t\"application/vnd.ms-excel\",\n\t\t\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n\t\t\"application/vnd.ms-powerpoint\",\n\t\t\"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n\t\t\"application/vnd.oasis.opendocument.text\",\n\t\t\"application/vnd.oasis.opendocument.spreadsheet\",\n\t\t\"application/vnd.oasis.opendocument.presentation\",\n\t\t\"text/plain\",\n\t\t\"text/csv\",\n\t\t\"application/rtf\",\n\t],\n\tvideo: [\n\t\t\"video/mp4\",\n\t\t\"video/mpeg\",\n\t\t\"video/quicktime\",\n\t\t\"video/x-msvideo\",\n\t\t\"video/webm\",\n\t\t\"video/x-matroska\",\n\t],\n\taudio: [\n\t\t\"audio/mpeg\",\n\t\t\"audio/mp4\",\n\t\t\"audio/wav\",\n\t\t\"audio/webm\",\n\t\t\"audio/ogg\",\n\t\t\"audio/flac\",\n\t],\n\tarchive: [\n\t\t\"application/zip\",\n\t\t\"application/x-rar-compressed\",\n\t\t\"application/x-7z-compressed\",\n\t\t\"application/x-tar\",\n\t\t\"application/gzip\",\n\t],\n\tcad: [\n\t\t\"application/acad\",\n\t\t\"application/x-acad\",\n\t\t\"application/autocad_dwg\",\n\t\t\"image/vnd.dwg\",\n\t\t\"image/vnd.dxf\",\n\t],\n} as const;\n\n/**\n * File magic numbers (signatures) for validation\n * First few bytes of common file types\n */\nconst FILE_SIGNATURES: Record<string, { bytes: number[]; offset: number }[]> = {\n\t\"image/jpeg\": [{ bytes: [0xff, 0xd8, 0xff], offset: 0 }],\n\t\"image/png\": [{ bytes: [0x89, 0x50, 0x4e, 0x47], offset: 0 }],\n\t\"image/gif\": [{ bytes: [0x47, 0x49, 0x46, 0x38], offset: 0 }],\n\t\"image/webp\": [{ bytes: [0x52, 0x49, 0x46, 0x46], offset: 0 }],\n\t\"application/pdf\": [{ bytes: [0x25, 0x50, 0x44, 0x46], offset: 0 }],\n\t\"application/zip\": [{ bytes: [0x50, 0x4b, 0x03, 0x04], offset: 0 }],\n\t\"video/mp4\": [{ bytes: [0x66, 0x74, 0x79, 0x70], offset: 4 }],\n};\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type FileContext = keyof typeof SIZE_LIMITS;\n\nexport type ValidationResult = {\n\tvalid: boolean;\n\terrors: string[];\n\twarnings: string[];\n\tmetadata?: {\n\t\tsanitizedName: string;\n\t\tdetectedMimeType?: string;\n\t\tcategory?: string;\n\t};\n};\n\nexport type ValidationOptions = {\n\tcontext?: FileContext;\n\tmaxSize?: number;\n\tallowedMimeTypes?: string[];\n\tcheckMagicNumbers?: boolean;\n\tstrictMode?: boolean;\n};\n\n// ============================================================================\n// MAIN VALIDATION FUNCTION\n// ============================================================================\n\n/**\n * Validate a file for upload\n *\n * @param file - The file to validate\n * @param options - Validation options\n * @returns Validation result with errors and metadata\n */\nexport async function validateFile(\n\tfile: File,\n\toptions: ValidationOptions = {},\n): Promise<ValidationResult> {\n\tconst {\n\t\tcontext = \"general\",\n\t\tmaxSize,\n\t\tallowedMimeTypes,\n\t\tcheckMagicNumbers = true,\n\t\tstrictMode = false,\n\t} = options;\n\n\tconst errors: string[] = [];\n\tconst warnings: string[] = [];\n\n\t// 1. Basic file checks\n\tif (!(file && file instanceof File)) {\n\t\terrors.push(\"Invalid file object\");\n\t\treturn { valid: false, errors, warnings };\n\t}\n\n\tif (!file.name || file.name.trim() === \"\") {\n\t\terrors.push(\"File must have a name\");\n\t\treturn { valid: false, errors, warnings };\n\t}\n\n\t// 2. Sanitize filename\n\tconst sanitizedName = sanitizeFileName(file.name);\n\tif (sanitizedName !== file.name) {\n\t\twarnings.push(\"Filename was sanitized for security\");\n\t}\n\n\t// 3. Check for blocked extensions\n\tconst extension = getFileExtension(file.name).toLowerCase();\n\tif (isBlockedExtension(extension)) {\n\t\terrors.push(`File type \"${extension}\" is not allowed for security reasons`);\n\t\treturn { valid: false, errors, warnings };\n\t}\n\n\t// 4. Check file size\n\tconst sizeLimit = maxSize ?? SIZE_LIMITS[context];\n\tif (file.size > sizeLimit) {\n\t\terrors.push(\n\t\t\t`File size (${formatFileSize(file.size)}) exceeds maximum allowed size (${formatFileSize(sizeLimit)})`,\n\t\t);\n\t}\n\n\tif (file.size === 0) {\n\t\terrors.push(\"File is empty\");\n\t}\n\n\t// 5. Check MIME type\n\tif (\n\t\tallowedMimeTypes &&\n\t\tallowedMimeTypes.length > 0 &&\n\t\t!allowedMimeTypes.includes(file.type)\n\t) {\n\t\terrors.push(\n\t\t\t`File type \"${file.type}\" is not allowed. Allowed types: ${allowedMimeTypes.join(\", \")}`,\n\t\t);\n\t}\n\n\t// Detect file category\n\tconst category = detectFileCategory(file.type);\n\n\t// 6. Verify magic numbers (file signature)\n\tlet detectedMimeType: string | undefined;\n\tif (checkMagicNumbers && file.size > 0) {\n\t\ttry {\n\t\t\tdetectedMimeType = (await verifyFileSignature(file)) ?? undefined;\n\n\t\t\tif (detectedMimeType && detectedMimeType !== file.type) {\n\t\t\t\tif (strictMode) {\n\t\t\t\t\terrors.push(\n\t\t\t\t\t\t`File signature mismatch. Claimed: \"${file.type}\", Detected: \"${detectedMimeType}\"`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\twarnings.push(\n\t\t\t\t\t\t`File type mismatch detected. Using detected type: ${detectedMimeType}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (_error) {\n\t\t\twarnings.push(\"Could not verify file signature\");\n\t\t}\n\t}\n\n\t// 7. Additional security checks\n\tconst securityChecks = performSecurityChecks(file, sanitizedName);\n\terrors.push(...securityChecks.errors);\n\twarnings.push(...securityChecks.warnings);\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t\twarnings,\n\t\tmetadata: {\n\t\t\tsanitizedName,\n\t\t\tdetectedMimeType,\n\t\t\tcategory,\n\t\t},\n\t};\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Check if extension is blocked\n */\nfunction isBlockedExtension(extension: string): boolean {\n\tconst ext = extension.toLowerCase();\n\treturn BLOCKED_EXTENSIONS.includes(ext);\n}\n\n/**\n * Get file extension from filename\n */\nfunction getFileExtension(filename: string): string {\n\tconst lastDot = filename.lastIndexOf(\".\");\n\tif (lastDot === -1 || lastDot === filename.length - 1) {\n\t\treturn \"\";\n\t}\n\treturn filename.substring(lastDot);\n}\n\n/**\n * Sanitize filename for security\n * - Remove or replace dangerous characters\n * - Prevent path traversal\n * - Limit length\n */\nexport function sanitizeFileName(fileName: string): string {\n\t// Get extension first\n\tconst extension = getFileExtension(fileName);\n\tconst nameWithoutExt = fileName.substring(\n\t\t0,\n\t\tfileName.length - extension.length,\n\t);\n\n\t// Remove path traversal attempts\n\tlet sanitized = nameWithoutExt.replace(/\\.\\./g, \"\");\n\n\t// Remove or replace dangerous characters\n\tsanitized = sanitized\n\t\t.replace(/[<>:\"|?*]/g, \"\") // Windows invalid chars\n\t\t.replace(/[\\x00-\\x1F\\x80-\\x9F]/g, \"\") // Control characters\n\t\t.replace(/^\\.+/, \"\") // Leading dots\n\t\t.replace(/\\s+/g, \"-\") // Replace spaces with hyphens\n\t\t.replace(/--+/g, \"-\") // Multiple hyphens to single\n\t\t.replace(/^-|-$/g, \"\"); // Trim hyphens\n\n\t// Limit length (max 200 chars for name, excluding extension)\n\tif (sanitized.length > 200) {\n\t\tsanitized = sanitized.substring(0, 200);\n\t}\n\n\t// Ensure we have a name\n\tif (!sanitized) {\n\t\tsanitized = `file-${Date.now()}`;\n\t}\n\n\treturn sanitized + extension.toLowerCase();\n}\n\n/**\n * Verify file signature (magic numbers)\n */\nasync function verifyFileSignature(file: File): Promise<string | null> {\n\t// Read first 8KB of file\n\tconst chunk = file.slice(0, 8192);\n\tconst buffer = await chunk.arrayBuffer();\n\tconst bytes = new Uint8Array(buffer);\n\n\t// Check against known signatures\n\tfor (const [mimeType, signatures] of Object.entries(FILE_SIGNATURES)) {\n\t\tfor (const sig of signatures) {\n\t\t\tconst matches = sig.bytes.every(\n\t\t\t\t(byte, index) => bytes[sig.offset + index] === byte,\n\t\t\t);\n\t\t\tif (matches) {\n\t\t\t\treturn mimeType;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Detect file category from MIME type\n */\nfunction detectFileCategory(mimeType: string): string | undefined {\n\tfor (const [category, types] of Object.entries(ALLOWED_MIME_TYPES)) {\n\t\tif ((types as readonly string[]).includes(mimeType)) {\n\t\t\treturn category;\n\t\t}\n\t}\n\n\t// Fallback to general category detection\n\tif (mimeType.startsWith(\"image/\")) {\n\t\treturn \"image\";\n\t}\n\tif (mimeType.startsWith(\"video/\")) {\n\t\treturn \"video\";\n\t}\n\tif (mimeType.startsWith(\"audio/\")) {\n\t\treturn \"audio\";\n\t}\n\tif (mimeType.startsWith(\"text/\")) {\n\t\treturn \"document\";\n\t}\n\n\treturn;\n}\n\n/**\n * Perform additional security checks\n */\nfunction performSecurityChecks(\n\tfile: File,\n\tsanitizedName: string,\n): { errors: string[]; warnings: string[] } {\n\tconst errors: string[] = [];\n\tconst warnings: string[] = [];\n\n\t// Check for double extensions (e.g., file.pdf.exe)\n\tconst parts = sanitizedName.split(\".\");\n\tif (parts.length > 2) {\n\t\tconst secondExt = `.${parts.at(-2)}`;\n\t\tif (isBlockedExtension(secondExt)) {\n\t\t\terrors.push(\n\t\t\t\t\"File has suspicious double extension that could hide malicious content\",\n\t\t\t);\n\t\t}\n\t}\n\n\t// Check for very long filenames (potential buffer overflow)\n\tif (sanitizedName.length > 255) {\n\t\terrors.push(\"Filename is too long\");\n\t}\n\n\t// Check for null bytes (can cause issues in some systems)\n\tif (file.name.includes(\"\\0\")) {\n\t\terrors.push(\"Filename contains null bytes\");\n\t}\n\n\t// Warn about unusual MIME types\n\tif (!file.type || file.type === \"application/octet-stream\") {\n\t\twarnings.push(\"File type could not be determined. Upload may be rejected.\");\n\t}\n\n\treturn { errors, warnings };\n}\n\n/**\n * Format file size for display\n */\nexport function formatFileSize(bytes: number): string {\n\tif (bytes === 0) {\n\t\treturn \"0 Bytes\";\n\t}\n\n\tconst k = 1024;\n\tconst sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn `${Number.parseFloat((bytes / k ** i).toFixed(2))} ${sizes[i]}`;\n}\n\n// ============================================================================\n// SPECIFIC VALIDATORS\n// ============================================================================\n\n/**\n * Validate image file\n */\nasync function validateImage(\n\tfile: File,\n\tmaxSize = SIZE_LIMITS.image,\n): Promise<ValidationResult> {\n\treturn validateFile(file, {\n\t\tcontext: \"image\",\n\t\tmaxSize,\n\t\tallowedMimeTypes: [...ALLOWED_MIME_TYPES.image],\n\t\tcheckMagicNumbers: true,\n\t\tstrictMode: true,\n\t});\n}\n\n/**\n * Validate document file\n */\nasync function validateDocument(\n\tfile: File,\n\tmaxSize = SIZE_LIMITS.document,\n): Promise<ValidationResult> {\n\treturn validateFile(file, {\n\t\tcontext: \"document\",\n\t\tmaxSize,\n\t\tallowedMimeTypes: [...ALLOWED_MIME_TYPES.document],\n\t\tcheckMagicNumbers: true,\n\t});\n}\n\n/**\n * Validate video file\n */\nasync function validateVideo(\n\tfile: File,\n\tmaxSize = SIZE_LIMITS.video,\n): Promise<ValidationResult> {\n\treturn validateFile(file, {\n\t\tcontext: \"video\",\n\t\tmaxSize,\n\t\tallowedMimeTypes: [...ALLOWED_MIME_TYPES.video],\n\t\tcheckMagicNumbers: false, // Video signatures are complex\n\t});\n}\n\n/**\n * Validate avatar image\n */\nasync function validateAvatar(file: File): Promise<ValidationResult> {\n\tconst result = await validateImage(file, SIZE_LIMITS.avatar);\n\n\t// Additional avatar-specific validation\n\tif (result.valid && file.type === \"image/svg+xml\") {\n\t\tresult.warnings.push(\n\t\t\t\"SVG avatars may be sanitized to remove potential scripts\",\n\t\t);\n\t}\n\n\treturn result;\n}\n\n/**\n * Batch validate multiple files\n */\nasync function validateFiles(\n\tfiles: File[],\n\toptions: ValidationOptions = {},\n): Promise<Map<string, ValidationResult>> {\n\tconst results = new Map<string, ValidationResult>();\n\n\tconst validations = files.map(async (file) => {\n\t\tconst result = await validateFile(file, options);\n\t\tresults.set(file.name, result);\n\t});\n\n\tawait Promise.all(validations);\n\n\treturn results;\n}\n\n/**\n * Check if file passes validation\n */\nasync function isValidFile(\n\tfile: File,\n\toptions: ValidationOptions = {},\n): Promise<boolean> {\n\tconst result = await validateFile(file, options);\n\treturn result.valid;\n}\n\n/**\n * Get validation errors as string\n */\nfunction getValidationErrorMessage(result: ValidationResult): string {\n\tif (result.valid) {\n\t\treturn \"\";\n\t}\n\n\treturn result.errors.join(\"; \");\n}\n"],"names":[],"mappings":"+CAYA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QCOA,IAAM,EAAqB,CAE1B,OACA,OACA,OACA,OACA,OACA,OACA,eACA,UACA,OACA,OACA,OACA,OACA,OACA,MACA,OACA,MACA,OACA,OACA,OACA,OACA,UACA,OACA,UACA,QACA,QACA,OACA,QACA,QACA,UACA,WACA,WAGA,OACA,OACA,OACA,QACA,WAGA,MACA,QACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,QAGA,OACA,OACA,OAGA,OACA,OACA,OAGA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAGA,OACA,OACA,OACA,SAGA,OACA,OACA,OACA,CAKK,EAAc,CACnB,OAAQ,IAAI,IACZ,GADmB,GACZ,KAAK,KACZ,EADmB,OACT,MAAM,IAChB,GADuB,GAChB,MAAM,GACb,IADoB,IACX,MAAM,GACf,IADsB,IACb,KAAK,KACd,EADqB,OACX,KAAK,KACf,EADsB,OACZ,KAAK,IAChB,EAKM,CANiB,CAMI,CAC1B,MAAO,CACN,aACA,YACA,YACA,aACA,gBACA,YACA,aACA,aACA,aACA,CACD,SAAU,CACT,kBACA,qBACA,0EACA,2BACA,oEACA,gCACA,4EACA,0CACA,iDACA,kDACA,aACA,WACA,kBACA,CACD,MAAO,CACN,YACA,aACA,kBACA,kBACA,aACA,mBACA,CACD,MAAO,CACN,aACA,YACA,YACA,aACA,YACA,aACA,CACD,QAAS,CACR,kBACA,+BACA,8BACA,oBACA,mBACA,CACD,IAAK,CACJ,mBACA,qBACA,0BACA,gBACA,gBACA,AACF,EAMM,EAAyE,CAC9E,aAAc,CAAC,CAAE,MAAO,CAAC,IAAM,IAAM,IAAK,CAAE,OAAQ,CAAE,EAAE,CACxD,YAAa,CAAC,CAAE,MAAO,CAAC,IAAM,GAAM,GAAM,GAAK,CAAE,OAAQ,CAAE,EAAE,CAC7D,YAAa,CAAC,CAAE,MAAO,CAAC,GAAM,GAAM,GAAM,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"}