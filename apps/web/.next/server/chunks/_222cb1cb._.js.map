{"version":3,"sources":["../../../../../apps/web/src/lib/telnyx/logger.ts","../../../../../apps/web/src/lib/telnyx/retry.ts","../../../../../apps/web/src/lib/telnyx/errors.ts","../../../../../apps/web/src/lib/telnyx/metrics.ts"],"sourcesContent":["/**\n * Telnyx Structured Logger\n *\n * Provides structured JSON logging with PII redaction,\n * log levels, and correlation ID support.\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nexport interface LogContext {\n\tcorrelationId?: string;\n\tendpoint?: string;\n\tcompanyId?: string;\n\tphoneNumber?: string;\n\tcallControlId?: string;\n\tmessageSid?: string;\n\tattempt?: number;\n\tdelayMs?: number;\n\tlatencyMs?: number;\n\tstatusCode?: number;\n\terror?: string;\n\t[key: string]: unknown;\n}\n\nexport interface LogEntry {\n\ttimestamp: string;\n\tlevel: LogLevel;\n\tservice: string;\n\tmessage: string;\n\tcontext?: LogContext;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n\tdebug: 0,\n\tinfo: 1,\n\twarn: 2,\n\terror: 3,\n};\n\n// Default to 'info' in production, 'debug' in development\nconst currentLogLevel: LogLevel =\n\t(process.env.TELNYX_LOG_LEVEL as LogLevel) ||\n\t(process.env.NODE_ENV === \"production\" ? \"info\" : \"debug\");\n\n// PII patterns to redact\nconst PII_PATTERNS = [\n\t// Phone numbers (various formats)\n\t/\\+?1?\\d{10,15}/g,\n\t// Email addresses\n\t/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n];\n\n// Fields that should be redacted\nconst SENSITIVE_FIELDS = [\n\t\"phone\",\n\t\"phoneNumber\",\n\t\"phone_number\",\n\t\"from\",\n\t\"to\",\n\t\"fromNumber\",\n\t\"toNumber\",\n\t\"from_number\",\n\t\"to_number\",\n\t\"apiKey\",\n\t\"api_key\",\n\t\"authToken\",\n\t\"auth_token\",\n\t\"password\",\n\t\"secret\",\n\t\"token\",\n];\n\n// =============================================================================\n// PII REDACTION\n// =============================================================================\n\n/**\n * Mask a phone number, keeping last 4 digits\n */\nfunction maskPhoneNumber(phone: string): string {\n\tconst digits = phone.replace(/\\D/g, \"\");\n\tif (digits.length < 4) return \"****\";\n\treturn `***${digits.slice(-4)}`;\n}\n\n/**\n * Mask an email address\n */\nfunction maskEmail(email: string): string {\n\tconst [local, domain] = email.split(\"@\");\n\tif (!domain) return \"***@***\";\n\tconst maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length - 1]}` : \"***\";\n\treturn `${maskedLocal}@${domain}`;\n}\n\n/**\n * Redact PII from a string\n */\nfunction redactString(value: string): string {\n\tlet result = value;\n\n\t// Redact phone numbers\n\tresult = result.replace(/\\+?1?\\d{10,15}/g, (match) => maskPhoneNumber(match));\n\n\t// Redact email addresses\n\tresult = result.replace(\n\t\t/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n\t\t(match) => maskEmail(match)\n\t);\n\n\treturn result;\n}\n\n/**\n * Recursively redact PII from an object\n */\nfunction redactPII(obj: unknown, depth = 0): unknown {\n\t// Prevent infinite recursion\n\tif (depth > 10) return \"[MAX_DEPTH]\";\n\n\tif (obj === null || obj === undefined) {\n\t\treturn obj;\n\t}\n\n\tif (typeof obj === \"string\") {\n\t\treturn redactString(obj);\n\t}\n\n\tif (typeof obj === \"number\" || typeof obj === \"boolean\") {\n\t\treturn obj;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => redactPII(item, depth + 1));\n\t}\n\n\tif (typeof obj === \"object\") {\n\t\tconst result: Record<string, unknown> = {};\n\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\t// Check if this is a sensitive field\n\t\t\tconst isSensitive = SENSITIVE_FIELDS.some(\n\t\t\t\t(field) => key.toLowerCase().includes(field.toLowerCase())\n\t\t\t);\n\n\t\t\tif (isSensitive) {\n\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t// Mask the value\n\t\t\t\t\tif (value.includes(\"@\")) {\n\t\t\t\t\t\tresult[key] = maskEmail(value);\n\t\t\t\t\t} else if (/\\d/.test(value)) {\n\t\t\t\t\t\tresult[key] = maskPhoneNumber(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[key] = \"[REDACTED]\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = \"[REDACTED]\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[key] = redactPII(value, depth + 1);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treturn obj;\n}\n\n// =============================================================================\n// LOGGER CLASS\n// =============================================================================\n\nclass TelnyxLogger {\n\tprivate service = \"telnyx\";\n\tprivate defaultContext: LogContext = {};\n\n\t/**\n\t * Set default context for all log entries\n\t */\n\tsetDefaultContext(context: LogContext): void {\n\t\tthis.defaultContext = { ...this.defaultContext, ...context };\n\t}\n\n\t/**\n\t * Clear default context\n\t */\n\tclearDefaultContext(): void {\n\t\tthis.defaultContext = {};\n\t}\n\n\t/**\n\t * Check if a log level should be output\n\t */\n\tprivate shouldLog(level: LogLevel): boolean {\n\t\treturn LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel];\n\t}\n\n\t/**\n\t * Format and output a log entry\n\t */\n\tprivate log(level: LogLevel, message: string, context?: LogContext): void {\n\t\tif (!this.shouldLog(level)) return;\n\n\t\tconst entry: LogEntry = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tlevel,\n\t\t\tservice: this.service,\n\t\t\tmessage,\n\t\t};\n\n\t\t// Merge default context with provided context\n\t\tconst fullContext = { ...this.defaultContext, ...context };\n\n\t\tif (Object.keys(fullContext).length > 0) {\n\t\t\t// Redact PII from context\n\t\t\tentry.context = redactPII(fullContext) as LogContext;\n\t\t}\n\n\t\t// Output as JSON in production, pretty print in development\n\t\tif (process.env.NODE_ENV === \"production\") {\n\t\t\tconst output = JSON.stringify(entry);\n\n\t\t\tswitch (level) {\n\t\t\t\tcase \"error\":\n\t\t\t\t\tconsole.error(output);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"warn\":\n\t\t\t\t\tconsole.warn(output);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(output);\n\t\t\t}\n\t\t} else {\n\t\t\t// Development: more readable format\n\t\t\tconst contextStr = entry.context\n\t\t\t\t? ` ${JSON.stringify(entry.context, null, 2)}`\n\t\t\t\t: \"\";\n\n\t\t\tconst prefix = `[${entry.timestamp}] [${level.toUpperCase()}] [${this.service}]`;\n\n\t\t\tswitch (level) {\n\t\t\t\tcase \"error\":\n\t\t\t\t\tconsole.error(`${prefix} ${message}${contextStr}`);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"warn\":\n\t\t\t\t\tconsole.warn(`${prefix} ${message}${contextStr}`);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"debug\":\n\t\t\t\t\tconsole.debug(`${prefix} ${message}${contextStr}`);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`${prefix} ${message}${contextStr}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Log at debug level\n\t */\n\tdebug(message: string, context?: LogContext): void {\n\t\tthis.log(\"debug\", message, context);\n\t}\n\n\t/**\n\t * Log at info level\n\t */\n\tinfo(message: string, context?: LogContext): void {\n\t\tthis.log(\"info\", message, context);\n\t}\n\n\t/**\n\t * Log at warn level\n\t */\n\twarn(message: string, context?: LogContext): void {\n\t\tthis.log(\"warn\", message, context);\n\t}\n\n\t/**\n\t * Log at error level\n\t */\n\terror(message: string, context?: LogContext): void {\n\t\tthis.log(\"error\", message, context);\n\t}\n\n\t/**\n\t * Create a child logger with additional default context\n\t */\n\tchild(context: LogContext): TelnyxChildLogger {\n\t\treturn new TelnyxChildLogger(this, context);\n\t}\n\n\t/**\n\t * Log a request start\n\t */\n\tlogRequestStart(\n\t\tmethod: string,\n\t\tendpoint: string,\n\t\tcontext?: LogContext\n\t): { correlationId: string; startTime: number } {\n\t\tconst correlationId =\n\t\t\tcontext?.correlationId ||\n\t\t\t`tlx_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n\t\tconst startTime = Date.now();\n\n\t\tthis.debug(`${method} ${endpoint} started`, {\n\t\t\t...context,\n\t\t\tcorrelationId,\n\t\t\tendpoint,\n\t\t});\n\n\t\treturn { correlationId, startTime };\n\t}\n\n\t/**\n\t * Log a request completion\n\t */\n\tlogRequestEnd(\n\t\tmethod: string,\n\t\tendpoint: string,\n\t\tstatusCode: number,\n\t\tstartTime: number,\n\t\tcontext?: LogContext\n\t): void {\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tconst logFn = statusCode >= 400 ? this.warn.bind(this) : this.info.bind(this);\n\n\t\tlogFn(`${method} ${endpoint} completed`, {\n\t\t\t...context,\n\t\t\tendpoint,\n\t\t\tstatusCode,\n\t\t\tlatencyMs,\n\t\t});\n\t}\n\n\t/**\n\t * Log a request error\n\t */\n\tlogRequestError(\n\t\tmethod: string,\n\t\tendpoint: string,\n\t\terror: Error,\n\t\tstartTime: number,\n\t\tcontext?: LogContext\n\t): void {\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tthis.error(`${method} ${endpoint} failed`, {\n\t\t\t...context,\n\t\t\tendpoint,\n\t\t\terror: error.message,\n\t\t\tlatencyMs,\n\t\t});\n\t}\n}\n\n/**\n * Child logger with inherited context\n */\nclass TelnyxChildLogger {\n\tconstructor(\n\t\tprivate parent: TelnyxLogger,\n\t\tprivate context: LogContext\n\t) {}\n\n\tdebug(message: string, context?: LogContext): void {\n\t\tthis.parent.debug(message, { ...this.context, ...context });\n\t}\n\n\tinfo(message: string, context?: LogContext): void {\n\t\tthis.parent.info(message, { ...this.context, ...context });\n\t}\n\n\twarn(message: string, context?: LogContext): void {\n\t\tthis.parent.warn(message, { ...this.context, ...context });\n\t}\n\n\terror(message: string, context?: LogContext): void {\n\t\tthis.parent.error(message, { ...this.context, ...context });\n\t}\n}\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\n/**\n * Singleton logger instance\n */\nexport const telnyxLogger = new TelnyxLogger();\n\n/**\n * Create a request-scoped logger\n */\nexport function createRequestLogger(correlationId: string): TelnyxChildLogger {\n\treturn telnyxLogger.child({ correlationId });\n}\n\n/**\n * Utility to redact PII from any object (exported for testing)\n */\nexport { redactPII };\n","/**\n * Telnyx Retry Logic\n *\n * Implements exponential backoff with jitter and circuit breaker pattern\n * for resilient API calls to Telnyx.\n */\n\nimport { telnyxLogger } from \"./logger\";\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nexport interface RetryConfig {\n\tmaxRetries: number;\n\tbaseDelayMs: number;\n\tmaxDelayMs: number;\n\tjitterFactor: number; // 0-1, adds randomness to delay\n\tretryableStatusCodes: number[];\n\tretryableErrorCodes: string[];\n}\n\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n\tmaxRetries: 5,\n\tbaseDelayMs: 1000, // 1 second\n\tmaxDelayMs: 32000, // 32 seconds max\n\tjitterFactor: 0.3, // 30% jitter\n\tretryableStatusCodes: [408, 429, 500, 502, 503, 504],\n\tretryableErrorCodes: [\n\t\t\"ECONNRESET\",\n\t\t\"ETIMEDOUT\",\n\t\t\"ECONNREFUSED\",\n\t\t\"EPIPE\",\n\t\t\"ENOTFOUND\",\n\t\t\"ENETUNREACH\",\n\t\t\"EAI_AGAIN\",\n\t],\n};\n\n// =============================================================================\n// CIRCUIT BREAKER\n// =============================================================================\n\nexport interface CircuitBreakerConfig {\n\tfailureThreshold: number; // Failures before opening circuit\n\tresetTimeoutMs: number; // Time before trying again\n\thalfOpenRequests: number; // Requests to allow in half-open state\n}\n\nexport const DEFAULT_CIRCUIT_BREAKER_CONFIG: CircuitBreakerConfig = {\n\tfailureThreshold: 5,\n\tresetTimeoutMs: 60000, // 1 minute\n\thalfOpenRequests: 3,\n};\n\ntype CircuitState = \"closed\" | \"open\" | \"half-open\";\n\ninterface CircuitBreakerState {\n\tstate: CircuitState;\n\tfailures: number;\n\tlastFailureTime: number;\n\thalfOpenSuccesses: number;\n\thalfOpenFailures: number;\n}\n\n// Per-endpoint circuit breakers\nconst circuitBreakers = new Map<string, CircuitBreakerState>();\n\nfunction getCircuitBreaker(endpoint: string): CircuitBreakerState {\n\tif (!circuitBreakers.has(endpoint)) {\n\t\tcircuitBreakers.set(endpoint, {\n\t\t\tstate: \"closed\",\n\t\t\tfailures: 0,\n\t\t\tlastFailureTime: 0,\n\t\t\thalfOpenSuccesses: 0,\n\t\t\thalfOpenFailures: 0,\n\t\t});\n\t}\n\treturn circuitBreakers.get(endpoint)!;\n}\n\nfunction updateCircuitState(\n\tendpoint: string,\n\tsuccess: boolean,\n\tconfig: CircuitBreakerConfig = DEFAULT_CIRCUIT_BREAKER_CONFIG\n): void {\n\tconst breaker = getCircuitBreaker(endpoint);\n\tconst now = Date.now();\n\n\tif (success) {\n\t\tif (breaker.state === \"half-open\") {\n\t\t\tbreaker.halfOpenSuccesses++;\n\t\t\tif (breaker.halfOpenSuccesses >= config.halfOpenRequests) {\n\t\t\t\t// Enough successes, close the circuit\n\t\t\t\tbreaker.state = \"closed\";\n\t\t\t\tbreaker.failures = 0;\n\t\t\t\tbreaker.halfOpenSuccesses = 0;\n\t\t\t\tbreaker.halfOpenFailures = 0;\n\t\t\t\ttelnyxLogger.info(\"Circuit breaker closed\", { endpoint });\n\t\t\t}\n\t\t} else if (breaker.state === \"closed\") {\n\t\t\t// Reset failure count on success\n\t\t\tbreaker.failures = 0;\n\t\t}\n\t} else {\n\t\tbreaker.lastFailureTime = now;\n\n\t\tif (breaker.state === \"half-open\") {\n\t\t\tbreaker.halfOpenFailures++;\n\t\t\t// Any failure in half-open reopens the circuit\n\t\t\tbreaker.state = \"open\";\n\t\t\tbreaker.halfOpenSuccesses = 0;\n\t\t\tbreaker.halfOpenFailures = 0;\n\t\t\ttelnyxLogger.warn(\"Circuit breaker reopened\", { endpoint });\n\t\t} else if (breaker.state === \"closed\") {\n\t\t\tbreaker.failures++;\n\t\t\tif (breaker.failures >= config.failureThreshold) {\n\t\t\t\tbreaker.state = \"open\";\n\t\t\t\ttelnyxLogger.error(\"Circuit breaker opened\", {\n\t\t\t\t\tendpoint,\n\t\t\t\t\tfailures: breaker.failures,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction canAttempt(\n\tendpoint: string,\n\tconfig: CircuitBreakerConfig = DEFAULT_CIRCUIT_BREAKER_CONFIG\n): boolean {\n\tconst breaker = getCircuitBreaker(endpoint);\n\tconst now = Date.now();\n\n\tif (breaker.state === \"closed\") {\n\t\treturn true;\n\t}\n\n\tif (breaker.state === \"open\") {\n\t\t// Check if reset timeout has passed\n\t\tif (now - breaker.lastFailureTime >= config.resetTimeoutMs) {\n\t\t\tbreaker.state = \"half-open\";\n\t\t\tbreaker.halfOpenSuccesses = 0;\n\t\t\tbreaker.halfOpenFailures = 0;\n\t\t\ttelnyxLogger.info(\"Circuit breaker half-open\", { endpoint });\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Half-open: allow limited requests\n\treturn true;\n}\n\n// =============================================================================\n// RETRY LOGIC\n// =============================================================================\n\nexport interface RetryError extends Error {\n\tstatusCode?: number;\n\terrorCode?: string;\n\tretryable: boolean;\n\tattempts: number;\n\tlastError?: Error;\n}\n\nexport function createRetryError(\n\tmessage: string,\n\toptions: {\n\t\tstatusCode?: number;\n\t\terrorCode?: string;\n\t\tretryable: boolean;\n\t\tattempts: number;\n\t\tlastError?: Error;\n\t}\n): RetryError {\n\tconst error = new Error(message) as RetryError;\n\terror.name = \"RetryError\";\n\terror.statusCode = options.statusCode;\n\terror.errorCode = options.errorCode;\n\terror.retryable = options.retryable;\n\terror.attempts = options.attempts;\n\terror.lastError = options.lastError;\n\treturn error;\n}\n\n/**\n * Check if an error is retryable\n */\nexport function isRetryable(\n\terror: unknown,\n\tconfig: RetryConfig = DEFAULT_RETRY_CONFIG\n): boolean {\n\tif (!error) return false;\n\n\t// Check for network errors\n\tif (error instanceof Error) {\n\t\tconst errorCode = (error as NodeJS.ErrnoException).code;\n\t\tif (errorCode && config.retryableErrorCodes.includes(errorCode)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for fetch/network errors\n\t\tif (\n\t\t\terror.message.includes(\"fetch failed\") ||\n\t\t\terror.message.includes(\"network\") ||\n\t\t\terror.message.includes(\"timeout\") ||\n\t\t\terror.message.includes(\"ECONNRESET\")\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Check for HTTP status codes\n\tif (typeof error === \"object\" && error !== null) {\n\t\tconst statusCode = (error as { statusCode?: number; status?: number })\n\t\t\t.statusCode ||\n\t\t\t(error as { statusCode?: number; status?: number }).status;\n\t\tif (statusCode && config.retryableStatusCodes.includes(statusCode)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Calculate delay with exponential backoff and jitter\n */\nexport function calculateDelay(\n\tattempt: number,\n\tconfig: RetryConfig = DEFAULT_RETRY_CONFIG\n): number {\n\t// Exponential backoff: baseDelay * 2^attempt\n\tconst exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\n\n\t// Cap at max delay\n\tconst cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n\n\t// Add jitter (randomness to spread out retries)\n\tconst jitter = cappedDelay * config.jitterFactor * Math.random();\n\n\treturn Math.floor(cappedDelay + jitter);\n}\n\n/**\n * Sleep for specified milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Extract Retry-After header value in milliseconds\n */\nexport function parseRetryAfter(response: Response): number | null {\n\tconst retryAfter = response.headers.get(\"Retry-After\");\n\tif (!retryAfter) return null;\n\n\t// Check if it's a number (seconds)\n\tconst seconds = parseInt(retryAfter, 10);\n\tif (!isNaN(seconds)) {\n\t\treturn seconds * 1000;\n\t}\n\n\t// Check if it's a date\n\tconst date = Date.parse(retryAfter);\n\tif (!isNaN(date)) {\n\t\treturn Math.max(0, date - Date.now());\n\t}\n\n\treturn null;\n}\n\n// =============================================================================\n// RETRY WRAPPER\n// =============================================================================\n\nexport interface RetryOptions {\n\tendpoint?: string; // For circuit breaker tracking\n\tconfig?: Partial<RetryConfig>;\n\tcircuitBreakerConfig?: Partial<CircuitBreakerConfig>;\n\tonRetry?: (attempt: number, error: Error, delayMs: number) => void;\n\tcorrelationId?: string;\n}\n\n/**\n * Execute a function with retry logic and circuit breaker\n */\nexport async function withRetry<T>(\n\tfn: () => Promise<T>,\n\toptions: RetryOptions = {}\n): Promise<T> {\n\tconst config = { ...DEFAULT_RETRY_CONFIG, ...options.config };\n\tconst circuitConfig = {\n\t\t...DEFAULT_CIRCUIT_BREAKER_CONFIG,\n\t\t...options.circuitBreakerConfig,\n\t};\n\tconst endpoint = options.endpoint || \"default\";\n\tconst correlationId = options.correlationId || generateCorrelationId();\n\n\t// Check circuit breaker\n\tif (!canAttempt(endpoint, circuitConfig)) {\n\t\tconst error = createRetryError(\n\t\t\t`Circuit breaker open for endpoint: ${endpoint}`,\n\t\t\t{\n\t\t\t\tretryable: false,\n\t\t\t\tattempts: 0,\n\t\t\t}\n\t\t);\n\t\ttelnyxLogger.warn(\"Request blocked by circuit breaker\", {\n\t\t\tendpoint,\n\t\t\tcorrelationId,\n\t\t});\n\t\tthrow error;\n\t}\n\n\tlet lastError: Error | undefined;\n\tlet attempt = 0;\n\n\twhile (attempt <= config.maxRetries) {\n\t\ttry {\n\t\t\tconst result = await fn();\n\n\t\t\t// Success - update circuit breaker\n\t\t\tupdateCircuitState(endpoint, true, circuitConfig);\n\n\t\t\tif (attempt > 0) {\n\t\t\t\ttelnyxLogger.info(\"Request succeeded after retry\", {\n\t\t\t\t\tendpoint,\n\t\t\t\t\tattempt,\n\t\t\t\t\tcorrelationId,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\n\t\t\tconst retryable = isRetryable(error, config);\n\n\t\t\ttelnyxLogger.warn(\"Request failed\", {\n\t\t\t\tendpoint,\n\t\t\t\tattempt,\n\t\t\t\tretryable,\n\t\t\t\terror: lastError.message,\n\t\t\t\tcorrelationId,\n\t\t\t});\n\n\t\t\t// Update circuit breaker on failure\n\t\t\tupdateCircuitState(endpoint, false, circuitConfig);\n\n\t\t\t// Don't retry if not retryable or max retries reached\n\t\t\tif (!retryable || attempt >= config.maxRetries) {\n\t\t\t\tthrow createRetryError(\n\t\t\t\t\t`Request failed after ${attempt + 1} attempt(s): ${lastError.message}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tretryable,\n\t\t\t\t\t\tattempts: attempt + 1,\n\t\t\t\t\t\tlastError,\n\t\t\t\t\t\tstatusCode: (error as { statusCode?: number }).statusCode,\n\t\t\t\t\t\terrorCode: (error as { code?: string }).code,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Calculate delay\n\t\t\tlet delayMs = calculateDelay(attempt, config);\n\n\t\t\t// Check for Retry-After header (if error has response)\n\t\t\tif (\n\t\t\t\ttypeof error === \"object\" &&\n\t\t\t\terror !== null &&\n\t\t\t\t\"response\" in error\n\t\t\t) {\n\t\t\t\tconst response = (error as { response?: Response }).response;\n\t\t\t\tif (response) {\n\t\t\t\t\tconst retryAfter = parseRetryAfter(response);\n\t\t\t\t\tif (retryAfter) {\n\t\t\t\t\t\tdelayMs = Math.min(retryAfter, config.maxDelayMs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call onRetry callback\n\t\t\tif (options.onRetry) {\n\t\t\t\toptions.onRetry(attempt, lastError, delayMs);\n\t\t\t}\n\n\t\t\ttelnyxLogger.info(\"Retrying request\", {\n\t\t\t\tendpoint,\n\t\t\t\tattempt: attempt + 1,\n\t\t\t\tdelayMs,\n\t\t\t\tcorrelationId,\n\t\t\t});\n\n\t\t\tawait sleep(delayMs);\n\t\t\tattempt++;\n\t\t}\n\t}\n\n\t// Should never reach here, but just in case\n\tthrow createRetryError(\n\t\t`Request failed after ${config.maxRetries + 1} attempts`,\n\t\t{\n\t\t\tretryable: false,\n\t\t\tattempts: config.maxRetries + 1,\n\t\t\tlastError,\n\t\t}\n\t);\n}\n\n// =============================================================================\n// BULK RETRY (for rate-limited batch operations)\n// =============================================================================\n\nexport interface BulkRetryOptions<T, R> {\n\titems: T[];\n\toperation: (item: T) => Promise<R>;\n\tconcurrency?: number;\n\tretryOptions?: RetryOptions;\n\tonProgress?: (completed: number, total: number, failed: number) => void;\n}\n\nexport interface BulkRetryResult<T, R> {\n\tsuccessful: Array<{ item: T; result: R }>;\n\tfailed: Array<{ item: T; error: Error }>;\n}\n\n/**\n * Process items in bulk with retry logic and concurrency control\n */\nexport async function withBulkRetry<T, R>(\n\toptions: BulkRetryOptions<T, R>\n): Promise<BulkRetryResult<T, R>> {\n\tconst { items, operation, concurrency = 10, retryOptions, onProgress } = options;\n\n\tconst successful: Array<{ item: T; result: R }> = [];\n\tconst failed: Array<{ item: T; error: Error }> = [];\n\tlet completed = 0;\n\n\t// Process in batches\n\tfor (let i = 0; i < items.length; i += concurrency) {\n\t\tconst batch = items.slice(i, i + concurrency);\n\n\t\tconst results = await Promise.allSettled(\n\t\t\tbatch.map(async (item) => {\n\t\t\t\tconst result = await withRetry(\n\t\t\t\t\t() => operation(item),\n\t\t\t\t\tretryOptions\n\t\t\t\t);\n\t\t\t\treturn { item, result };\n\t\t\t})\n\t\t);\n\n\t\tfor (const result of results) {\n\t\t\tcompleted++;\n\n\t\t\tif (result.status === \"fulfilled\") {\n\t\t\t\tsuccessful.push(result.value);\n\t\t\t} else {\n\t\t\t\tconst item = batch[results.indexOf(result)];\n\t\t\t\tfailed.push({\n\t\t\t\t\titem,\n\t\t\t\t\terror:\n\t\t\t\t\t\tresult.reason instanceof Error\n\t\t\t\t\t\t\t? result.reason\n\t\t\t\t\t\t\t: new Error(String(result.reason)),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (onProgress) {\n\t\t\tonProgress(completed, items.length, failed.length);\n\t\t}\n\n\t\t// Small delay between batches to avoid rate limiting\n\t\tif (i + concurrency < items.length) {\n\t\t\tawait sleep(100);\n\t\t}\n\t}\n\n\treturn { successful, failed };\n}\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Generate a correlation ID for request tracking\n */\nexport function generateCorrelationId(): string {\n\treturn `tlx_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Get circuit breaker status for monitoring\n */\nexport function getCircuitBreakerStatus(endpoint?: string): {\n\tendpoints: Record<string, CircuitBreakerState>;\n\tsummary: {\n\t\ttotal: number;\n\t\topen: number;\n\t\thalfOpen: number;\n\t\tclosed: number;\n\t};\n} {\n\tconst endpoints: Record<string, CircuitBreakerState> = {};\n\n\tif (endpoint) {\n\t\tconst breaker = circuitBreakers.get(endpoint);\n\t\tif (breaker) {\n\t\t\tendpoints[endpoint] = breaker;\n\t\t}\n\t} else {\n\t\tcircuitBreakers.forEach((state, ep) => {\n\t\t\tendpoints[ep] = state;\n\t\t});\n\t}\n\n\tconst states = Object.values(endpoints);\n\treturn {\n\t\tendpoints,\n\t\tsummary: {\n\t\t\ttotal: states.length,\n\t\t\topen: states.filter((s) => s.state === \"open\").length,\n\t\t\thalfOpen: states.filter((s) => s.state === \"half-open\").length,\n\t\t\tclosed: states.filter((s) => s.state === \"closed\").length,\n\t\t},\n\t};\n}\n\n/**\n * Reset circuit breaker for an endpoint (for testing/manual reset)\n */\nexport function resetCircuitBreaker(endpoint: string): void {\n\tcircuitBreakers.delete(endpoint);\n\ttelnyxLogger.info(\"Circuit breaker reset\", { endpoint });\n}\n\n/**\n * Reset all circuit breakers\n */\nexport function resetAllCircuitBreakers(): void {\n\tcircuitBreakers.clear();\n\ttelnyxLogger.info(\"All circuit breakers reset\");\n}\n","/**\n * Telnyx Custom Error Classes\n *\n * Provides typed error classes for different failure scenarios\n * with error codes, metadata, and retry information.\n */\n\n// =============================================================================\n// ERROR CODES\n// =============================================================================\n\nexport enum TelnyxErrorCode {\n\t// Network errors\n\tNETWORK_ERROR = \"TELNYX_NETWORK_ERROR\",\n\tTIMEOUT = \"TELNYX_TIMEOUT\",\n\tCONNECTION_REFUSED = \"TELNYX_CONNECTION_REFUSED\",\n\n\t// Authentication errors\n\tINVALID_API_KEY = \"TELNYX_INVALID_API_KEY\",\n\tUNAUTHORIZED = \"TELNYX_UNAUTHORIZED\",\n\tFORBIDDEN = \"TELNYX_FORBIDDEN\",\n\n\t// Rate limiting\n\tRATE_LIMIT_EXCEEDED = \"TELNYX_RATE_LIMIT_EXCEEDED\",\n\n\t// Validation errors\n\tINVALID_PHONE_NUMBER = \"TELNYX_INVALID_PHONE_NUMBER\",\n\tINVALID_REQUEST = \"TELNYX_INVALID_REQUEST\",\n\tMISSING_REQUIRED_FIELD = \"TELNYX_MISSING_REQUIRED_FIELD\",\n\n\t// Resource errors\n\tNOT_FOUND = \"TELNYX_NOT_FOUND\",\n\tRESOURCE_CONFLICT = \"TELNYX_RESOURCE_CONFLICT\",\n\n\t// Provider errors\n\tPROVIDER_ERROR = \"TELNYX_PROVIDER_ERROR\",\n\tCARRIER_ERROR = \"TELNYX_CARRIER_ERROR\",\n\tDELIVERY_FAILED = \"TELNYX_DELIVERY_FAILED\",\n\n\t// Call-specific errors\n\tCALL_REJECTED = \"TELNYX_CALL_REJECTED\",\n\tCALL_BUSY = \"TELNYX_CALL_BUSY\",\n\tCALL_NO_ANSWER = \"TELNYX_CALL_NO_ANSWER\",\n\tCALL_FAILED = \"TELNYX_CALL_FAILED\",\n\n\t// SMS-specific errors\n\tSMS_DELIVERY_FAILED = \"TELNYX_SMS_DELIVERY_FAILED\",\n\tSMS_BLOCKED = \"TELNYX_SMS_BLOCKED\",\n\tSMS_SPAM_DETECTED = \"TELNYX_SMS_SPAM_DETECTED\",\n\n\t// Webhook errors\n\tWEBHOOK_VALIDATION_FAILED = \"TELNYX_WEBHOOK_VALIDATION_FAILED\",\n\tWEBHOOK_SIGNATURE_INVALID = \"TELNYX_WEBHOOK_SIGNATURE_INVALID\",\n\tWEBHOOK_TIMESTAMP_INVALID = \"TELNYX_WEBHOOK_TIMESTAMP_INVALID\",\n\tWEBHOOK_REPLAY_DETECTED = \"TELNYX_WEBHOOK_REPLAY_DETECTED\",\n\n\t// Circuit breaker\n\tCIRCUIT_BREAKER_OPEN = \"TELNYX_CIRCUIT_BREAKER_OPEN\",\n\n\t// Generic\n\tUNKNOWN_ERROR = \"TELNYX_UNKNOWN_ERROR\",\n\tINTERNAL_ERROR = \"TELNYX_INTERNAL_ERROR\",\n}\n\n// =============================================================================\n// BASE ERROR CLASS\n// =============================================================================\n\nexport interface TelnyxErrorMetadata {\n\tcorrelationId?: string;\n\tendpoint?: string;\n\tmethod?: string;\n\tstatusCode?: number;\n\tcompanyId?: string;\n\tphoneNumber?: string;\n\tcallControlId?: string;\n\tmessageSid?: string;\n\tattempt?: number;\n\tretryable?: boolean;\n\tretryAfterMs?: number;\n\toriginalError?: Error;\n\ttelnyxErrorCode?: string;\n\ttelnyxErrorDetail?: string;\n\t[key: string]: unknown;\n}\n\nexport class TelnyxError extends Error {\n\tpublic readonly code: TelnyxErrorCode;\n\tpublic readonly metadata: TelnyxErrorMetadata;\n\tpublic readonly timestamp: Date;\n\tpublic readonly retryable: boolean;\n\tpublic readonly retryAfterMs?: number;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode = TelnyxErrorCode.UNKNOWN_ERROR,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"TelnyxError\";\n\t\tthis.code = code;\n\t\tthis.metadata = metadata;\n\t\tthis.timestamp = new Date();\n\t\tthis.retryable = metadata.retryable ?? this.isRetryableCode(code);\n\t\tthis.retryAfterMs = metadata.retryAfterMs;\n\n\t\t// Capture stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, TelnyxError);\n\t\t}\n\t}\n\n\tprivate isRetryableCode(code: TelnyxErrorCode): boolean {\n\t\tconst retryableCodes = [\n\t\t\tTelnyxErrorCode.NETWORK_ERROR,\n\t\t\tTelnyxErrorCode.TIMEOUT,\n\t\t\tTelnyxErrorCode.CONNECTION_REFUSED,\n\t\t\tTelnyxErrorCode.RATE_LIMIT_EXCEEDED,\n\t\t\tTelnyxErrorCode.PROVIDER_ERROR,\n\t\t\tTelnyxErrorCode.INTERNAL_ERROR,\n\t\t];\n\t\treturn retryableCodes.includes(code);\n\t}\n\n\t/**\n\t * Convert to JSON for logging/serialization\n\t */\n\ttoJSON(): Record<string, unknown> {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tcode: this.code,\n\t\t\tmetadata: this.metadata,\n\t\t\ttimestamp: this.timestamp.toISOString(),\n\t\t\tretryable: this.retryable,\n\t\t\tretryAfterMs: this.retryAfterMs,\n\t\t\tstack: this.stack,\n\t\t};\n\t}\n\n\t/**\n\t * Create a user-friendly error message\n\t */\n\ttoUserMessage(): string {\n\t\tswitch (this.code) {\n\t\t\tcase TelnyxErrorCode.INVALID_PHONE_NUMBER:\n\t\t\t\treturn \"The phone number provided is invalid. Please check and try again.\";\n\t\t\tcase TelnyxErrorCode.RATE_LIMIT_EXCEEDED:\n\t\t\t\treturn \"Too many requests. Please wait a moment and try again.\";\n\t\t\tcase TelnyxErrorCode.CALL_BUSY:\n\t\t\t\treturn \"The number is busy. Please try again later.\";\n\t\t\tcase TelnyxErrorCode.CALL_NO_ANSWER:\n\t\t\t\treturn \"No answer. The call was not picked up.\";\n\t\t\tcase TelnyxErrorCode.SMS_BLOCKED:\n\t\t\t\treturn \"Message could not be delivered. The recipient may have blocked messages.\";\n\t\t\tcase TelnyxErrorCode.UNAUTHORIZED:\n\t\t\tcase TelnyxErrorCode.INVALID_API_KEY:\n\t\t\t\treturn \"Authentication failed. Please contact support.\";\n\t\t\tcase TelnyxErrorCode.NETWORK_ERROR:\n\t\t\tcase TelnyxErrorCode.TIMEOUT:\n\t\t\t\treturn \"Connection issue. Please try again.\";\n\t\t\tdefault:\n\t\t\t\treturn \"An error occurred. Please try again or contact support.\";\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SPECIALIZED ERROR CLASSES\n// =============================================================================\n\n/**\n * Network-related errors (connectivity, timeout, etc.)\n */\nexport class TelnyxNetworkError extends TelnyxError {\n\tconstructor(message: string, metadata: TelnyxErrorMetadata = {}) {\n\t\tsuper(message, TelnyxErrorCode.NETWORK_ERROR, {\n\t\t\t...metadata,\n\t\t\tretryable: true,\n\t\t});\n\t\tthis.name = \"TelnyxNetworkError\";\n\t}\n}\n\n/**\n * Timeout errors\n */\nexport class TelnyxTimeoutError extends TelnyxError {\n\tpublic readonly timeoutMs: number;\n\n\tconstructor(\n\t\tmessage: string,\n\t\ttimeoutMs: number,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.TIMEOUT, {\n\t\t\t...metadata,\n\t\t\tretryable: true,\n\t\t});\n\t\tthis.name = \"TelnyxTimeoutError\";\n\t\tthis.timeoutMs = timeoutMs;\n\t}\n}\n\n/**\n * Rate limit errors\n */\nexport class TelnyxRateLimitError extends TelnyxError {\n\tconstructor(\n\t\tmessage: string,\n\t\tretryAfterMs: number,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.RATE_LIMIT_EXCEEDED, {\n\t\t\t...metadata,\n\t\t\tretryable: true,\n\t\t\tretryAfterMs,\n\t\t});\n\t\tthis.name = \"TelnyxRateLimitError\";\n\t}\n}\n\n/**\n * Authentication/Authorization errors\n */\nexport class TelnyxAuthError extends TelnyxError {\n\tconstructor(message: string, metadata: TelnyxErrorMetadata = {}) {\n\t\tconst code = metadata.statusCode === 403\n\t\t\t? TelnyxErrorCode.FORBIDDEN\n\t\t\t: TelnyxErrorCode.UNAUTHORIZED;\n\t\tsuper(message, code, {\n\t\t\t...metadata,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxAuthError\";\n\t}\n}\n\n/**\n * Validation errors\n */\nexport class TelnyxValidationError extends TelnyxError {\n\tpublic readonly field?: string;\n\tpublic readonly validationDetails?: Record<string, string[]>;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tmetadata: TelnyxErrorMetadata & {\n\t\t\tfield?: string;\n\t\t\tvalidationDetails?: Record<string, string[]>;\n\t\t} = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.INVALID_REQUEST, {\n\t\t\t...metadata,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxValidationError\";\n\t\tthis.field = metadata.field;\n\t\tthis.validationDetails = metadata.validationDetails;\n\t}\n}\n\n/**\n * Phone number validation errors\n */\nexport class TelnyxPhoneNumberError extends TelnyxError {\n\tpublic readonly phoneNumber: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tphoneNumber: string,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.INVALID_PHONE_NUMBER, {\n\t\t\t...metadata,\n\t\t\tphoneNumber,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxPhoneNumberError\";\n\t\tthis.phoneNumber = phoneNumber;\n\t}\n}\n\n/**\n * Webhook validation errors\n */\nexport class TelnyxWebhookError extends TelnyxError {\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode = TelnyxErrorCode.WEBHOOK_VALIDATION_FAILED,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, code, {\n\t\t\t...metadata,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxWebhookError\";\n\t}\n}\n\n/**\n * Circuit breaker errors\n */\nexport class TelnyxCircuitBreakerError extends TelnyxError {\n\tpublic readonly endpoint: string;\n\n\tconstructor(endpoint: string, metadata: TelnyxErrorMetadata = {}) {\n\t\tsuper(\n\t\t\t`Circuit breaker is open for endpoint: ${endpoint}`,\n\t\t\tTelnyxErrorCode.CIRCUIT_BREAKER_OPEN,\n\t\t\t{\n\t\t\t\t...metadata,\n\t\t\t\tendpoint,\n\t\t\t\tretryable: false,\n\t\t\t}\n\t\t);\n\t\tthis.name = \"TelnyxCircuitBreakerError\";\n\t\tthis.endpoint = endpoint;\n\t}\n}\n\n/**\n * Call-specific errors\n */\nexport class TelnyxCallError extends TelnyxError {\n\tpublic readonly callControlId?: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, code, metadata);\n\t\tthis.name = \"TelnyxCallError\";\n\t\tthis.callControlId = metadata.callControlId;\n\t}\n}\n\n/**\n * SMS-specific errors\n */\nexport class TelnyxSmsError extends TelnyxError {\n\tpublic readonly messageSid?: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, code, metadata);\n\t\tthis.name = \"TelnyxSmsError\";\n\t\tthis.messageSid = metadata.messageSid;\n\t}\n}\n\n// =============================================================================\n// ERROR FACTORY\n// =============================================================================\n\n/**\n * Create appropriate error from HTTP response\n */\nexport function createErrorFromResponse(\n\tstatusCode: number,\n\tbody: unknown,\n\tmetadata: TelnyxErrorMetadata = {}\n): TelnyxError {\n\tconst errorBody = body as {\n\t\terrors?: Array<{ code?: string; title?: string; detail?: string }>;\n\t\terror?: string;\n\t\tmessage?: string;\n\t};\n\n\tconst errorDetail = errorBody?.errors?.[0]?.detail ||\n\t\terrorBody?.error ||\n\t\terrorBody?.message ||\n\t\t\"Unknown error\";\n\n\tconst telnyxErrorCode = errorBody?.errors?.[0]?.code;\n\n\tconst fullMetadata = {\n\t\t...metadata,\n\t\tstatusCode,\n\t\ttelnyxErrorCode,\n\t\ttelnyxErrorDetail: errorDetail,\n\t};\n\n\tswitch (statusCode) {\n\t\tcase 400:\n\t\t\treturn new TelnyxValidationError(errorDetail, fullMetadata);\n\n\t\tcase 401:\n\t\t\treturn new TelnyxAuthError(\"Invalid API key or unauthorized\", fullMetadata);\n\n\t\tcase 403:\n\t\t\treturn new TelnyxAuthError(\"Access forbidden\", fullMetadata);\n\n\t\tcase 404:\n\t\t\treturn new TelnyxError(\"Resource not found\", TelnyxErrorCode.NOT_FOUND, {\n\t\t\t\t...fullMetadata,\n\t\t\t\tretryable: false,\n\t\t\t});\n\n\t\tcase 409:\n\t\t\treturn new TelnyxError(\"Resource conflict\", TelnyxErrorCode.RESOURCE_CONFLICT, {\n\t\t\t\t...fullMetadata,\n\t\t\t\tretryable: false,\n\t\t\t});\n\n\t\tcase 429:\n\t\t\tconst retryAfter = parseInt(\n\t\t\t\t(body as { retry_after?: string })?.retry_after || \"60\",\n\t\t\t\t10\n\t\t\t) * 1000;\n\t\t\treturn new TelnyxRateLimitError(\n\t\t\t\t\"Rate limit exceeded\",\n\t\t\t\tretryAfter,\n\t\t\t\tfullMetadata\n\t\t\t);\n\n\t\tcase 500:\n\t\tcase 502:\n\t\tcase 503:\n\t\tcase 504:\n\t\t\treturn new TelnyxError(\n\t\t\t\t\"Telnyx service error\",\n\t\t\t\tTelnyxErrorCode.PROVIDER_ERROR,\n\t\t\t\t{\n\t\t\t\t\t...fullMetadata,\n\t\t\t\t\tretryable: true,\n\t\t\t\t}\n\t\t\t);\n\n\t\tdefault:\n\t\t\treturn new TelnyxError(errorDetail, TelnyxErrorCode.UNKNOWN_ERROR, fullMetadata);\n\t}\n}\n\n/**\n * Create error from network/fetch error\n */\nexport function createErrorFromException(\n\terror: unknown,\n\tmetadata: TelnyxErrorMetadata = {}\n): TelnyxError {\n\tif (error instanceof TelnyxError) {\n\t\treturn error;\n\t}\n\n\tconst originalError = error instanceof Error ? error : new Error(String(error));\n\tconst errorCode = (originalError as NodeJS.ErrnoException).code;\n\n\tconst fullMetadata = {\n\t\t...metadata,\n\t\toriginalError,\n\t};\n\n\t// Check for specific error types\n\tif (originalError.name === \"AbortError\" || originalError.message.includes(\"timeout\")) {\n\t\treturn new TelnyxTimeoutError(\n\t\t\t\"Request timed out\",\n\t\t\tmetadata.timeout as number || 30000,\n\t\t\tfullMetadata\n\t\t);\n\t}\n\n\tif (\n\t\terrorCode === \"ECONNRESET\" ||\n\t\terrorCode === \"ECONNREFUSED\" ||\n\t\terrorCode === \"ENOTFOUND\" ||\n\t\terrorCode === \"ENETUNREACH\" ||\n\t\toriginalError.message.includes(\"fetch failed\") ||\n\t\toriginalError.message.includes(\"network\")\n\t) {\n\t\treturn new TelnyxNetworkError(\n\t\t\t`Network error: ${originalError.message}`,\n\t\t\tfullMetadata\n\t\t);\n\t}\n\n\treturn new TelnyxError(\n\t\toriginalError.message,\n\t\tTelnyxErrorCode.UNKNOWN_ERROR,\n\t\tfullMetadata\n\t);\n}\n\n// =============================================================================\n// ERROR UTILITIES\n// =============================================================================\n\n/**\n * Check if an error is a TelnyxError\n */\nexport function isTelnyxError(error: unknown): error is TelnyxError {\n\treturn error instanceof TelnyxError;\n}\n\n/**\n * Check if an error is retryable\n */\nexport function isRetryableError(error: unknown): boolean {\n\tif (error instanceof TelnyxError) {\n\t\treturn error.retryable;\n\t}\n\n\t// Check for network errors\n\tif (error instanceof Error) {\n\t\tconst errorCode = (error as NodeJS.ErrnoException).code;\n\t\tconst retryableErrorCodes = [\n\t\t\t\"ECONNRESET\",\n\t\t\t\"ETIMEDOUT\",\n\t\t\t\"ECONNREFUSED\",\n\t\t\t\"EPIPE\",\n\t\t\t\"ENOTFOUND\",\n\t\t\t\"ENETUNREACH\",\n\t\t\t\"EAI_AGAIN\",\n\t\t];\n\t\tif (errorCode && retryableErrorCodes.includes(errorCode)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Wrap an error to ensure it's a TelnyxError\n */\nexport function wrapError(\n\terror: unknown,\n\tmetadata: TelnyxErrorMetadata = {}\n): TelnyxError {\n\tif (error instanceof TelnyxError) {\n\t\t// Merge metadata\n\t\treturn new TelnyxError(error.message, error.code, {\n\t\t\t...error.metadata,\n\t\t\t...metadata,\n\t\t});\n\t}\n\n\treturn createErrorFromException(error, metadata);\n}\n","/**\n * Telnyx Metrics & Monitoring\n *\n * Tracks API performance, error rates, and usage statistics.\n */\n\nimport { telnyxLogger } from \"./logger\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface RequestMetrics {\n\tendpoint: string;\n\tmethod: string;\n\tstatusCode: number;\n\tlatencyMs: number;\n\tsuccess: boolean;\n\ttimestamp: Date;\n\tcompanyId?: string;\n\tcorrelationId?: string;\n}\n\nexport interface AggregatedMetrics {\n\ttotalRequests: number;\n\tsuccessfulRequests: number;\n\tfailedRequests: number;\n\terrorRate: number;\n\tlatency: {\n\t\tp50: number;\n\t\tp95: number;\n\t\tp99: number;\n\t\tavg: number;\n\t\tmin: number;\n\t\tmax: number;\n\t};\n\tbyEndpoint: Record<\n\t\tstring,\n\t\t{\n\t\t\tcount: number;\n\t\t\terrors: number;\n\t\t\tavgLatency: number;\n\t\t}\n\t>;\n\tbyStatusCode: Record<number, number>;\n}\n\nexport interface OperationMetrics {\n\tsmsSent: number;\n\tsmsDelivered: number;\n\tsmsFailed: number;\n\tcallsInitiated: number;\n\tcallsCompleted: number;\n\tcallsFailed: number;\n\twebhooksReceived: number;\n\twebhooksProcessed: number;\n\twebhooksFailed: number;\n}\n\n// =============================================================================\n// METRICS COLLECTOR\n// =============================================================================\n\nclass MetricsCollector {\n\tprivate requests: RequestMetrics[] = [];\n\tprivate operations: OperationMetrics = {\n\t\tsmsSent: 0,\n\t\tsmsDelivered: 0,\n\t\tsmsFailed: 0,\n\t\tcallsInitiated: 0,\n\t\tcallsCompleted: 0,\n\t\tcallsFailed: 0,\n\t\twebhooksReceived: 0,\n\t\twebhooksProcessed: 0,\n\t\twebhooksFailed: 0,\n\t};\n\tprivate retentionMs: number = 60 * 60 * 1000; // 1 hour\n\tprivate maxEntries: number = 10000;\n\tprivate cleanupInterval?: NodeJS.Timeout;\n\n\tconstructor() {\n\t\tthis.startCleanup();\n\t}\n\n\t/**\n\t * Start periodic cleanup\n\t */\n\tprivate startCleanup(): void {\n\t\tthis.cleanupInterval = setInterval(() => {\n\t\t\tthis.cleanup();\n\t\t}, 60000); // Every minute\n\n\t\tif (this.cleanupInterval.unref) {\n\t\t\tthis.cleanupInterval.unref();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up old metrics\n\t */\n\tprivate cleanup(): void {\n\t\tconst cutoff = Date.now() - this.retentionMs;\n\t\tconst initialCount = this.requests.length;\n\n\t\tthis.requests = this.requests.filter(\n\t\t\t(r) => r.timestamp.getTime() > cutoff\n\t\t);\n\n\t\t// Also trim if over max entries\n\t\tif (this.requests.length > this.maxEntries) {\n\t\t\tthis.requests = this.requests.slice(-this.maxEntries);\n\t\t}\n\n\t\tconst removed = initialCount - this.requests.length;\n\t\tif (removed > 0) {\n\t\t\ttelnyxLogger.debug(\"Metrics cleanup\", { removed });\n\t\t}\n\t}\n\n\t/**\n\t * Record a request\n\t */\n\trecordRequest(metrics: RequestMetrics): void {\n\t\tthis.requests.push(metrics);\n\n\t\t// Log slow requests\n\t\tif (metrics.latencyMs > 2000) {\n\t\t\ttelnyxLogger.warn(\"Slow request detected\", {\n\t\t\t\tendpoint: metrics.endpoint,\n\t\t\t\tlatencyMs: metrics.latencyMs,\n\t\t\t\tcorrelationId: metrics.correlationId,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Record SMS sent\n\t */\n\trecordSmsSent(success: boolean): void {\n\t\tthis.operations.smsSent++;\n\t\tif (!success) {\n\t\t\tthis.operations.smsFailed++;\n\t\t}\n\t}\n\n\t/**\n\t * Record SMS delivered\n\t */\n\trecordSmsDelivered(): void {\n\t\tthis.operations.smsDelivered++;\n\t}\n\n\t/**\n\t * Record call initiated\n\t */\n\trecordCallInitiated(success: boolean): void {\n\t\tthis.operations.callsInitiated++;\n\t\tif (!success) {\n\t\t\tthis.operations.callsFailed++;\n\t\t}\n\t}\n\n\t/**\n\t * Record call completed\n\t */\n\trecordCallCompleted(): void {\n\t\tthis.operations.callsCompleted++;\n\t}\n\n\t/**\n\t * Record webhook received\n\t */\n\trecordWebhook(processed: boolean): void {\n\t\tthis.operations.webhooksReceived++;\n\t\tif (processed) {\n\t\t\tthis.operations.webhooksProcessed++;\n\t\t} else {\n\t\t\tthis.operations.webhooksFailed++;\n\t\t}\n\t}\n\n\t/**\n\t * Get aggregated metrics for a time window\n\t */\n\tgetAggregatedMetrics(windowMs: number = 5 * 60 * 1000): AggregatedMetrics {\n\t\tconst cutoff = Date.now() - windowMs;\n\t\tconst filtered = this.requests.filter(\n\t\t\t(r) => r.timestamp.getTime() > cutoff\n\t\t);\n\n\t\tconst successfulRequests = filtered.filter((r) => r.success).length;\n\t\tconst failedRequests = filtered.length - successfulRequests;\n\t\tconst latencies = filtered.map((r) => r.latencyMs).sort((a, b) => a - b);\n\n\t\t// Calculate percentiles\n\t\tconst getPercentile = (arr: number[], p: number): number => {\n\t\t\tif (arr.length === 0) return 0;\n\t\t\tconst index = Math.ceil((p / 100) * arr.length) - 1;\n\t\t\treturn arr[Math.max(0, index)];\n\t\t};\n\n\t\t// Group by endpoint\n\t\tconst byEndpoint: Record<\n\t\t\tstring,\n\t\t\t{ count: number; errors: number; totalLatency: number }\n\t\t> = {};\n\t\tfor (const r of filtered) {\n\t\t\tif (!byEndpoint[r.endpoint]) {\n\t\t\t\tbyEndpoint[r.endpoint] = { count: 0, errors: 0, totalLatency: 0 };\n\t\t\t}\n\t\t\tbyEndpoint[r.endpoint].count++;\n\t\t\tbyEndpoint[r.endpoint].totalLatency += r.latencyMs;\n\t\t\tif (!r.success) {\n\t\t\t\tbyEndpoint[r.endpoint].errors++;\n\t\t\t}\n\t\t}\n\n\t\t// Group by status code\n\t\tconst byStatusCode: Record<number, number> = {};\n\t\tfor (const r of filtered) {\n\t\t\tbyStatusCode[r.statusCode] = (byStatusCode[r.statusCode] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotalRequests: filtered.length,\n\t\t\tsuccessfulRequests,\n\t\t\tfailedRequests,\n\t\t\terrorRate:\n\t\t\t\tfiltered.length > 0 ? failedRequests / filtered.length : 0,\n\t\t\tlatency: {\n\t\t\t\tp50: getPercentile(latencies, 50),\n\t\t\t\tp95: getPercentile(latencies, 95),\n\t\t\t\tp99: getPercentile(latencies, 99),\n\t\t\t\tavg:\n\t\t\t\t\tlatencies.length > 0\n\t\t\t\t\t\t? latencies.reduce((a, b) => a + b, 0) / latencies.length\n\t\t\t\t\t\t: 0,\n\t\t\t\tmin: latencies[0] || 0,\n\t\t\t\tmax: latencies[latencies.length - 1] || 0,\n\t\t\t},\n\t\t\tbyEndpoint: Object.fromEntries(\n\t\t\t\tObject.entries(byEndpoint).map(([ep, data]) => [\n\t\t\t\t\tep,\n\t\t\t\t\t{\n\t\t\t\t\t\tcount: data.count,\n\t\t\t\t\t\terrors: data.errors,\n\t\t\t\t\t\tavgLatency: data.totalLatency / data.count,\n\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t),\n\t\t\tbyStatusCode,\n\t\t};\n\t}\n\n\t/**\n\t * Get operation metrics\n\t */\n\tgetOperationMetrics(): OperationMetrics {\n\t\treturn { ...this.operations };\n\t}\n\n\t/**\n\t * Get health score (0-100)\n\t */\n\tgetHealthScore(windowMs: number = 5 * 60 * 1000): number {\n\t\tconst metrics = this.getAggregatedMetrics(windowMs);\n\n\t\tif (metrics.totalRequests === 0) {\n\t\t\treturn 100; // No requests, assume healthy\n\t\t}\n\n\t\t// Factors:\n\t\t// - Error rate (weight: 50%)\n\t\t// - Latency (weight: 30%)\n\t\t// - 5xx errors (weight: 20%)\n\n\t\t// Error rate score (0 = 100%, 10%+ = 0)\n\t\tconst errorScore = Math.max(0, 100 - metrics.errorRate * 1000);\n\n\t\t// Latency score (0ms = 100, 3000ms+ = 0)\n\t\tconst latencyScore = Math.max(0, 100 - (metrics.latency.p95 / 3000) * 100);\n\n\t\t// 5xx score\n\t\tconst total5xx = Object.entries(metrics.byStatusCode)\n\t\t\t.filter(([code]) => parseInt(code) >= 500)\n\t\t\t.reduce((sum, [, count]) => sum + count, 0);\n\t\tconst rate5xx = total5xx / metrics.totalRequests;\n\t\tconst score5xx = Math.max(0, 100 - rate5xx * 1000);\n\n\t\treturn Math.round(errorScore * 0.5 + latencyScore * 0.3 + score5xx * 0.2);\n\t}\n\n\t/**\n\t * Reset metrics\n\t */\n\treset(): void {\n\t\tthis.requests = [];\n\t\tthis.operations = {\n\t\t\tsmsSent: 0,\n\t\t\tsmsDelivered: 0,\n\t\t\tsmsFailed: 0,\n\t\t\tcallsInitiated: 0,\n\t\t\tcallsCompleted: 0,\n\t\t\tcallsFailed: 0,\n\t\t\twebhooksReceived: 0,\n\t\t\twebhooksProcessed: 0,\n\t\t\twebhooksFailed: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Stop cleanup interval\n\t */\n\tstop(): void {\n\t\tif (this.cleanupInterval) {\n\t\t\tclearInterval(this.cleanupInterval);\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SINGLETON INSTANCE\n// =============================================================================\n\nexport const telnyxMetrics = new MetricsCollector();\n\n// =============================================================================\n// CONVENIENCE FUNCTIONS\n// =============================================================================\n\n/**\n * Create a request timer\n */\nexport function startRequestTimer(\n\tendpoint: string,\n\tmethod: string,\n\tcompanyId?: string,\n\tcorrelationId?: string\n): { end: (statusCode: number, success: boolean) => void } {\n\tconst startTime = Date.now();\n\n\treturn {\n\t\tend: (statusCode: number, success: boolean) => {\n\t\t\ttelnyxMetrics.recordRequest({\n\t\t\t\tendpoint,\n\t\t\t\tmethod,\n\t\t\t\tstatusCode,\n\t\t\t\tlatencyMs: Date.now() - startTime,\n\t\t\t\tsuccess,\n\t\t\t\ttimestamp: new Date(),\n\t\t\t\tcompanyId,\n\t\t\t\tcorrelationId,\n\t\t\t});\n\t\t},\n\t};\n}\n\n/**\n * Get a summary for monitoring dashboards\n */\nexport function getMetricsSummary(): {\n\thealth: number;\n\tmetrics: AggregatedMetrics;\n\toperations: OperationMetrics;\n} {\n\treturn {\n\t\thealth: telnyxMetrics.getHealthScore(),\n\t\tmetrics: telnyxMetrics.getAggregatedMetrics(),\n\t\toperations: telnyxMetrics.getOperationMetrics(),\n\t};\n}\n\n/**\n * Format metrics for logging\n */\nexport function formatMetricsForLogging(): string {\n\tconst summary = getMetricsSummary();\n\tconst { metrics, operations, health } = summary;\n\n\treturn [\n\t\t`Health Score: ${health}/100`,\n\t\t`Requests: ${metrics.totalRequests} (${metrics.failedRequests} failed)`,\n\t\t`Error Rate: ${(metrics.errorRate * 100).toFixed(2)}%`,\n\t\t`Latency: p50=${metrics.latency.p50}ms p95=${metrics.latency.p95}ms`,\n\t\t`SMS: ${operations.smsSent} sent, ${operations.smsDelivered} delivered, ${operations.smsFailed} failed`,\n\t\t`Calls: ${operations.callsInitiated} initiated, ${operations.callsCompleted} completed`,\n\t\t`Webhooks: ${operations.webhooksReceived} received, ${operations.webhooksFailed} failed`,\n\t].join(\" | \");\n}\n"],"names":[],"mappings":"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"}