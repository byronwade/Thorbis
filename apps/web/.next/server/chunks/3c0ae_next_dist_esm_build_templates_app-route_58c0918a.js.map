{"version":3,"sources":["../../../../../node_modules/.pnpm/next%4016.0.4_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/dist/esm/build/templates/app-route.js","../../../../../apps/web/src/app/api/schedule/unscheduled/route.ts","../../../../../apps/web/src/lib/schedule/supabase-client.ts","../../../../../node_modules/.pnpm/date-fns%404.1.0/node_modules/date-fns/constants.js","../../../../../node_modules/.pnpm/date-fns%404.1.0/node_modules/date-fns/subDays.js","../../../../../node_modules/.pnpm/date-fns%404.1.0/node_modules/date-fns/addDays.js","../../../../../node_modules/.pnpm/date-fns%404.1.0/node_modules/date-fns/constructFrom.js","../../../../../node_modules/.pnpm/date-fns%404.1.0/node_modules/date-fns/toDate.js","../../../../../apps/web/src/lib/schedule-bootstrap.ts","../../../../../apps/web/src/components/schedule/schedule-types.ts","../../../../../apps/web/src/lib/schedule-data.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/schedule/unscheduled/route\",\n        pathname: \"/api/schedule/unscheduled\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/apps/web/src/app/api/schedule/unscheduled/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/schedule/unscheduled/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { NextResponse } from \"next/server\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { getSchedulingSupabaseClient } from \"@/lib/schedule/supabase-client\";\nimport { serializeJob } from \"@/lib/schedule-bootstrap\";\nimport { fetchAdditionalUnscheduledJobs } from \"@/lib/schedule-data\";\n\nexport async function POST(request: Request) {\n\ttry {\n\t\tconst body = await request.json().catch(() => ({}));\n\t\tconst search = typeof body?.search === \"string\" ? body.search : \"\";\n\t\tconst limit =\n\t\t\ttypeof body?.limit === \"number\" && body.limit > 0\n\t\t\t\t? body.limit\n\t\t\t\t: undefined;\n\t\tconst offset =\n\t\t\ttypeof body?.offset === \"number\" && body.offset >= 0 ? body.offset : 0;\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\treturn NextResponse.json(\n\t\t\t\t{ error: \"No active company selected\" },\n\t\t\t\t{ status: 401 },\n\t\t\t);\n\t\t}\n\n\t\tconst supabase = await getSchedulingSupabaseClient();\n\t\tif (!supabase) {\n\t\t\treturn NextResponse.json(\n\t\t\t\t{ error: \"Database unavailable\" },\n\t\t\t\t{ status: 500 },\n\t\t\t);\n\t\t}\n\n\t\tconst { jobs, meta } = await fetchAdditionalUnscheduledJobs({\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t\tlimit,\n\t\t\toffset,\n\t\t\tsearch,\n\t\t});\n\n\t\treturn NextResponse.json({\n\t\t\tjobs: jobs.map(serializeJob),\n\t\t\tmeta,\n\t\t});\n\t} catch (error) {\n\t\tconsole.error(\n\t\t\t\"[Schedule] Failed to load additional unscheduled jobs\",\n\t\t\terror,\n\t\t);\n\t\treturn NextResponse.json(\n\t\t\t{\n\t\t\t\terror:\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t: \"Unable to load unscheduled jobs\",\n\t\t\t},\n\t\t\t{ status: 500 },\n\t\t);\n\t}\n}\n","import { createClient } from \"@/lib/supabase/server\";\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\n/**\n * Returns the preferred Supabase client for scheduling operations.\n * Uses the service role when available (for cross-company visibility)\n * and falls back to the authenticated server client otherwise.\n */\nexport async function getSchedulingSupabaseClient() {\n\ttry {\n\t\treturn await createServiceSupabaseClient();\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"[Schedule] Service role unavailable, falling back to authenticated client\",\n\t\t\terror,\n\t\t);\n\t\treturn await createClient();\n\t}\n}\n","/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"./constants/date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n\n/**\n * @constant\n * @name constructFromSymbol\n * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n *\n * The symbol is used to enable the `constructFrom` function to construct a date\n * using a reference date and a value. It allows to transfer extra properties\n * from the reference date to the new date. It's useful for extensions like\n * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n * a constructor argument.\n */\nexport const constructFromSymbol = Symbol.for(\"constructDateFrom\");\n","import { addDays } from \"./addDays.js\";\n\n/**\n * The {@link subDays} function options.\n */\n\n/**\n * @name subDays\n * @category Day Helpers\n * @summary Subtract the specified number of days from the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of days to be subtracted.\n * @param options - An object with options\n *\n * @returns The new date with the days subtracted\n *\n * @example\n * // Subtract 10 days from 1 September 2014:\n * const result = subDays(new Date(2014, 8, 1), 10)\n * //=> Fri Aug 22 2014 00:00:00\n */\nexport function subDays(date, amount, options) {\n  return addDays(date, -amount, options);\n}\n\n// Fallback for modularized imports:\nexport default subDays;\n","import { constructFrom } from \"./constructFrom.js\";\nimport { toDate } from \"./toDate.js\";\n\n/**\n * The {@link addDays} function options.\n */\n\n/**\n * @name addDays\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of days to be added.\n * @param options - An object with options\n *\n * @returns The new date with the days added\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * const result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\nexport function addDays(date, amount, options) {\n  const _date = toDate(date, options?.in);\n  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);\n\n  // If 0 days, no-op to avoid changing times in the hour before end of DST\n  if (!amount) return _date;\n\n  _date.setDate(_date.getDate() + amount);\n  return _date;\n}\n\n// Fallback for modularized imports:\nexport default addDays;\n","import { constructFromSymbol } from \"./constants.js\";\n\n/**\n * @name constructFrom\n * @category Generic Helpers\n * @summary Constructs a date using the reference date and the value\n *\n * @description\n * The function constructs a new date using the constructor from the reference\n * date and the given value. It helps to build generic functions that accept\n * date extensions.\n *\n * It defaults to `Date` if the passed reference date is a number or a string.\n *\n * Starting from v3.7.0, it allows to construct a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The reference date to take constructor from\n * @param value - The value to create the date\n *\n * @returns Date initialized using the given date and value\n *\n * @example\n * import { constructFrom } from \"./constructFrom/date-fns\";\n *\n * // A function that clones a date preserving the original type\n * function cloneDate<DateType extends Date>(date: DateType): DateType {\n *   return constructFrom(\n *     date, // Use constructor from the given date\n *     date.getTime() // Use the date value to create a new date\n *   );\n * }\n */\nexport function constructFrom(date, value) {\n  if (typeof date === \"function\") return date(value);\n\n  if (date && typeof date === \"object\" && constructFromSymbol in date)\n    return date[constructFromSymbol](value);\n\n  if (date instanceof Date) return new date.constructor(value);\n\n  return new Date(value);\n}\n\n// Fallback for modularized imports:\nexport default constructFrom;\n","import { constructFrom } from \"./constructFrom.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate(argument, context) {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\n// Fallback for modularized imports:\nexport default toDate;\n","import type {\n\tCustomer,\n\tJob,\n\tRecurrenceRule,\n\tTechnician,\n\tTechnicianSchedule,\n} from \"@/components/schedule/schedule-types\";\nimport type { UnassignedJobsMeta } from \"@/lib/schedule/types\";\n\nexport type SerializedRecurrenceRule = Omit<RecurrenceRule, \"endDate\"> & {\n\tendDate?: string;\n};\n\nexport type SerializedCustomer = Omit<Customer, \"createdAt\" | \"updatedAt\"> & {\n\tcreatedAt: string;\n\tupdatedAt: string;\n};\n\nexport type SerializedTechnicianSchedule = Omit<\n\tTechnicianSchedule,\n\t\"daysOff\"\n> & {\n\tdaysOff: string[];\n};\n\nexport type SerializedTechnician = Omit<\n\tTechnician,\n\t\"createdAt\" | \"updatedAt\" | \"schedule\"\n> & {\n\tcreatedAt: string;\n\tupdatedAt: string;\n\tschedule: SerializedTechnicianSchedule;\n};\n\nexport type SerializedJob = Omit<\n\tJob,\n\t| \"startTime\"\n\t| \"endTime\"\n\t| \"createdAt\"\n\t| \"updatedAt\"\n\t| \"customer\"\n\t| \"recurrence\"\n> & {\n\tstartTime: string;\n\tendTime: string;\n\tcreatedAt: string;\n\tupdatedAt: string;\n\tcustomer: SerializedCustomer;\n\trecurrence?: SerializedRecurrenceRule;\n};\n\nexport type ScheduleBootstrapSerialized = {\n\tcompanyId: string;\n\trange: {\n\t\tstart: string;\n\t\tend: string;\n\t};\n\tlastSync: string;\n\tjobs: SerializedJob[];\n\ttechnicians: SerializedTechnician[];\n\tunassignedMeta?: UnassignedJobsMeta;\n};\n\nexport type ScheduleHydrationPayload = {\n\tcompanyId: string;\n\trange: {\n\t\tstart: Date;\n\t\tend: Date;\n\t};\n\tlastSync: Date;\n\tjobs: Job[];\n\ttechnicians: Technician[];\n\tunassignedMeta?: UnassignedJobsMeta;\n};\n\nexport function serializeScheduleBootstrap(\n\tpayload: ScheduleHydrationPayload,\n): ScheduleBootstrapSerialized {\n\treturn {\n\t\tcompanyId: payload.companyId,\n\t\trange: {\n\t\t\tstart: payload.range.start.toISOString(),\n\t\t\tend: payload.range.end.toISOString(),\n\t\t},\n\t\tlastSync: payload.lastSync.toISOString(),\n\t\tjobs: payload.jobs.map(serializeJob),\n\t\ttechnicians: payload.technicians.map(serializeTechnician),\n\t\tunassignedMeta: payload.unassignedMeta,\n\t};\n}\n\nexport function deserializeScheduleBootstrap(\n\tpayload: ScheduleBootstrapSerialized,\n): ScheduleHydrationPayload {\n\treturn {\n\t\tcompanyId: payload.companyId,\n\t\trange: {\n\t\t\tstart: new Date(payload.range.start),\n\t\t\tend: new Date(payload.range.end),\n\t\t},\n\t\tlastSync: new Date(payload.lastSync),\n\t\tjobs: payload.jobs.map(deserializeJob),\n\t\ttechnicians: payload.technicians.map(deserializeTechnician),\n\t\tunassignedMeta: payload.unassignedMeta,\n\t};\n}\n\nexport function serializeJob(job: Job): SerializedJob {\n\treturn {\n\t\t...job,\n\t\tstartTime: job.startTime.toISOString(),\n\t\tendTime: job.endTime.toISOString(),\n\t\tcreatedAt: job.createdAt.toISOString(),\n\t\tupdatedAt: job.updatedAt.toISOString(),\n\t\tcustomer: {\n\t\t\t...job.customer,\n\t\t\tcreatedAt: job.customer.createdAt.toISOString(),\n\t\t\tupdatedAt: job.customer.updatedAt.toISOString(),\n\t\t},\n\t\trecurrence: job.recurrence\n\t\t\t? serializeRecurrence(job.recurrence)\n\t\t\t: undefined,\n\t};\n}\n\nexport function deserializeJob(job: SerializedJob): Job {\n\treturn {\n\t\t...job,\n\t\tstartTime: new Date(job.startTime),\n\t\tendTime: new Date(job.endTime),\n\t\tcreatedAt: new Date(job.createdAt),\n\t\tupdatedAt: new Date(job.updatedAt),\n\t\tcustomer: {\n\t\t\t...job.customer,\n\t\t\tcreatedAt: new Date(job.customer.createdAt),\n\t\t\tupdatedAt: new Date(job.customer.updatedAt),\n\t\t},\n\t\trecurrence: job.recurrence\n\t\t\t? deserializeRecurrence(job.recurrence)\n\t\t\t: undefined,\n\t};\n}\n\nfunction serializeTechnician(technician: Technician): SerializedTechnician {\n\treturn {\n\t\t...technician,\n\t\tcreatedAt: technician.createdAt.toISOString(),\n\t\tupdatedAt: technician.updatedAt.toISOString(),\n\t\tschedule: serializeTechnicianSchedule(technician.schedule),\n\t};\n}\n\nfunction deserializeTechnician(technician: SerializedTechnician): Technician {\n\treturn {\n\t\t...technician,\n\t\tcreatedAt: new Date(technician.createdAt),\n\t\tupdatedAt: new Date(technician.updatedAt),\n\t\tschedule: deserializeTechnicianSchedule(technician.schedule),\n\t};\n}\n\nfunction serializeTechnicianSchedule(\n\tschedule: TechnicianSchedule,\n): SerializedTechnicianSchedule {\n\treturn {\n\t\t...schedule,\n\t\tdaysOff: schedule.daysOff.map((date) => date.toISOString()),\n\t};\n}\n\nfunction deserializeTechnicianSchedule(\n\tschedule: SerializedTechnicianSchedule,\n): TechnicianSchedule {\n\treturn {\n\t\t...schedule,\n\t\tdaysOff: schedule.daysOff.map((value) => new Date(value)),\n\t};\n}\n\nfunction serializeRecurrence(\n\trecurrence: RecurrenceRule,\n): SerializedRecurrenceRule {\n\treturn {\n\t\t...recurrence,\n\t\tendDate: recurrence.endDate ? recurrence.endDate.toISOString() : undefined,\n\t};\n}\n\nfunction deserializeRecurrence(\n\trecurrence: SerializedRecurrenceRule,\n): RecurrenceRule {\n\treturn {\n\t\t...recurrence,\n\t\tendDate: recurrence.endDate ? new Date(recurrence.endDate) : undefined,\n\t};\n}\n","// ============================================\n// CORE DATA TYPES\n// ============================================\n\nexport type Address = {\n\tstreet: string;\n\tcity: string;\n\tstate: string;\n\tzip: string;\n\tcountry: string;\n};\n\nexport type Location = {\n\taddress: Address;\n\tcoordinates: {\n\t\tlat: number;\n\t\tlng: number;\n\t};\n\tplaceId?: string; // Google Places ID\n};\n\nexport type Customer = {\n\tid: string;\n\tname: string;\n\temail?: string;\n\tphone?: string;\n\tcompany?: string;\n\tlocation: Location;\n\tnotes?: string;\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n};\n\nexport type RecurrenceRule = {\n\tfrequency: \"daily\" | \"weekly\" | \"monthly\" | \"yearly\";\n\tinterval: number; // Every N days/weeks/months/years\n\tendDate?: Date;\n\tcount?: number; // Stop after N occurrences\n\tdaysOfWeek?: number[]; // 0-6 (Sunday-Saturday)\n\tdayOfMonth?: number; // 1-31\n\tmonthOfYear?: number; // 1-12\n};\n\nexport type JobMetadata = {\n\testimatedDuration?: number; // minutes\n\tactualDuration?: number; // minutes\n\tmaterials?: string[];\n\tnotes?: string;\n\tinternalNotes?: string;\n\tattachments?: string[]; // URLs\n\ttags?: string[];\n\tcustomFields?: Record<string, any>;\n};\n\nexport type JobAssignmentRole = \"primary\" | \"assistant\" | \"crew\" | \"supervisor\";\n\nexport type JobAssignment = {\n\ttechnicianId: string | null;\n\tteamMemberId?: string | null;\n\tdisplayName: string;\n\tavatar?: string | null;\n\trole: JobAssignmentRole;\n\tstatus?: Technician[\"status\"];\n\tisActive: boolean;\n};\n\nexport type JobType =\n\t| \"service\"\n\t| \"service_call\"\n\t| \"repair\"\n\t| \"installation\"\n\t| \"maintenance\"\n\t| \"premium_maintenance\"\n\t| \"inspection\"\n\t| \"emergency\"\n\t| \"estimate\"\n\t| \"callback\"\n\t| \"other\";\n\n// Appointment category for visual differentiation (meeting vs job vs event)\nexport type AppointmentCategory = \"job\" | \"meeting\" | \"event\";\n\n// Maps database appointment types to display categories\nexport function getAppointmentCategory(\n\ttype?: string | null,\n\tallDay?: boolean,\n): AppointmentCategory {\n\t// All-day appointments are events\n\tif (allDay) return \"event\";\n\n\tswitch (type?.toLowerCase()) {\n\t\tcase \"meeting\":\n\t\tcase \"appointment\":\n\t\tcase \"follow_up\":\n\t\tcase \"consultation\":\n\t\tcase \"call\":\n\t\t\treturn \"meeting\";\n\t\tcase \"event\":\n\t\tcase \"training\":\n\t\tcase \"conference\":\n\t\tcase \"holiday\":\n\t\t\treturn \"event\";\n\t\tcase \"job\":\n\t\tcase \"service\":\n\t\tcase \"repair\":\n\t\tcase \"installation\":\n\t\tcase \"maintenance\":\n\t\tcase \"inspection\":\n\t\tcase \"estimate\":\n\t\tcase \"callback\":\n\t\tdefault:\n\t\t\treturn \"job\";\n\t}\n}\n\nexport type Job = {\n\tid: string; // Schedule ID\n\tjobId?: string; // Actual job ID (for linking to job details)\n\ttechnicianId: string; // Primary technician id (falls back to first assignment or empty string)\n\tassignments: JobAssignment[];\n\tisUnassigned: boolean;\n\n\t// Job details\n\ttitle: string;\n\tdescription?: string;\n\tjobType?: JobType;\n\tappointmentType?: string; // Raw type from appointments table (job, appointment, meeting, etc.)\n\tappointmentCategory?: AppointmentCategory; // Derived: job | meeting | event\n\tcustomer: Customer;\n\tlocation: Location;\n\n\t// Scheduling\n\tstartTime: Date;\n\tendTime: Date;\n\tallDay?: boolean; // For meetings, events\n\n\t// Status\n\tstatus:\n\t\t| \"scheduled\"\n\t\t| \"dispatched\"\n\t\t| \"arrived\"\n\t\t| \"in-progress\"\n\t\t| \"closed\"\n\t\t| \"completed\"\n\t\t| \"cancelled\";\n\tpriority: \"low\" | \"medium\" | \"high\" | \"urgent\";\n\n\t// Recurrence\n\trecurrence?: RecurrenceRule;\n\tparentJobId?: string; // For recurring job instances\n\n\t// Metadata\n\tmetadata: JobMetadata;\n\n\t// Audit\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n\tcreatedBy?: string;\n\tupdatedBy?: string;\n};\n\nexport type TechnicianSchedule = {\n\tavailableHours: {\n\t\tstart: number; // 0-23\n\t\tend: number; // 0-23\n\t};\n\tdaysOff: Date[];\n\tbreakTimes?: Array<{\n\t\tstart: number; // minutes from day start\n\t\tend: number;\n\t}>;\n};\n\nexport type Technician = {\n\tid: string;\n\tuserId?: string;\n\tteamMemberId?: string;\n\tname: string;\n\temail?: string;\n\tphone?: string;\n\tavatar?: string;\n\tcolor?: string;\n\n\t// Employment\n\trole: string;\n\tdepartment?: string;\n\tskills?: string[];\n\tcertifications?: string[];\n\n\t// Status\n\tstatus: \"available\" | \"on-job\" | \"on-break\" | \"offline\";\n\tisActive?: boolean;\n\tcurrentLocation?: Location;\n\n\t// Schedule\n\tschedule: TechnicianSchedule;\n\n\t// Audit\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n};\n\n// ============================================\n// LEGACY COMPATIBILITY (for migration)\n// ============================================\n\n/** @deprecated Use Job with Date objects instead */\nexport type LegacyJob = {\n\tid: string;\n\ttitle: string;\n\tcustomer: string;\n\tstartTime: string; // HH:MM format\n\tendTime: string; // HH:MM format\n\tstatus: \"scheduled\" | \"in-progress\" | \"completed\" | \"cancelled\";\n\tpriority: \"low\" | \"medium\" | \"high\" | \"urgent\";\n\tlocation: string;\n\taddress: string;\n\tlat: number;\n\tlng: number;\n\tdescription?: string;\n\testimatedDuration?: string;\n};\n\n","import { cache } from \"react\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { addDays, subDays } from \"date-fns\";\nimport {\n\ttype Job,\n\ttype JobAssignment,\n\ttype Technician,\n\tgetAppointmentCategory,\n} from \"@/components/schedule/schedule-types\";\nimport type { UnassignedJobsMeta } from \"@/lib/schedule/types\";\nimport type { ScheduleHydrationPayload } from \"@/lib/schedule-bootstrap\";\nimport type { Database } from \"@/types/supabase\";\n\ntype Tables = Database[\"public\"][\"Tables\"];\n\ntype ScheduleRow = Tables[\"appointments\"][\"Row\"];\ntype CustomerRow = Tables[\"customers\"][\"Row\"];\ntype PropertyRow = Tables[\"properties\"][\"Row\"];\ntype JobRow = Tables[\"jobs\"][\"Row\"];\ntype TeamMemberRow = Tables[\"team_members\"][\"Row\"];\ntype JobTeamAssignmentRow = Tables[\"job_team_assignments\"][\"Row\"];\ntype JobRecord = Tables[\"jobs\"][\"Row\"];\n\ntype JobCustomer = Pick<\n\tCustomerRow,\n\t| \"id\"\n\t| \"first_name\"\n\t| \"last_name\"\n\t| \"email\"\n\t| \"phone\"\n\t| \"created_at\"\n\t| \"updated_at\"\n>;\n\ntype JobRowWithRelations = JobRecord & {\n\tcustomer?: JobCustomer | JobCustomer[] | null;\n\tproperty?: ScheduleProperty | ScheduleProperty[] | null;\n\tjob_team_assignments?: Array<\n\t\tJobTeamAssignmentRow & {\n\t\t\tteam_member: TeamMemberRow | null;\n\t\t}\n\t> | null;\n};\n\nexport type ScheduleRecord = ScheduleRow & {\n\tcustomer: Pick<\n\t\tCustomerRow,\n\t\t\"id\" | \"first_name\" | \"last_name\" | \"email\" | \"phone\"\n\t> | null;\n\tjob:\n\t\t| (JobRow & {\n\t\t\t\tjob_team_assignments: Array<\n\t\t\t\t\tJobTeamAssignmentRow & {\n\t\t\t\t\t\tteam_member: TeamMemberRow | null;\n\t\t\t\t\t}\n\t\t\t\t> | null;\n\t\t  })\n\t\t| null;\n};\n\ntype ScheduleProperty = Pick<\n\tPropertyRow,\n\t| \"id\"\n\t| \"name\"\n\t| \"address\"\n\t| \"address2\"\n\t| \"city\"\n\t| \"state\"\n\t| \"zip_code\"\n\t| \"country\"\n\t| \"lat\"\n\t| \"lon\"\n>;\n\ntype Range = {\n\tstart: Date;\n\tend: Date;\n};\n\ntype LoadParams = {\n\tsupabase: SupabaseClient<Database>;\n\tcompanyId: string;\n\trange?: Range;\n\tunscheduledLimit?: number;\n\tunscheduledOffset?: number;\n\tunscheduledSearch?: string;\n};\n\ntype TeamMemberRecord = TeamMemberRow & {\n\tusers: {\n\t\tid: string;\n\t\tname: string | null;\n\t\temail: string | null;\n\t\tphone: string | null;\n\t\tavatar: string | null;\n\t} | null;\n};\n\nexport type TechniciansLookup = {\n\ttechnicians: Technician[];\n\tbyId: Map<string, Technician>;\n\tbyUserId: Map<string, Technician>;\n\tbyTeamMemberId: Map<string, Technician>;\n};\n\nconst UNASSIGNED_TECHNICIAN_ID = \"__unassigned\";\n\n// Retry utility with exponential backoff for resilient data fetching\ntype RetryOptions = {\n\tmaxRetries?: number;\n\tinitialDelay?: number;\n\tmaxDelay?: number;\n\tbackoffFactor?: number;\n\tshouldRetry?: (error: unknown) => boolean;\n};\n\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n\tmaxRetries: 3,\n\tinitialDelay: 500,\n\tmaxDelay: 5000,\n\tbackoffFactor: 2,\n\tshouldRetry: (error) => {\n\t\t// Retry on network errors, timeouts, and server errors (5xx)\n\t\tif (error instanceof Error) {\n\t\t\tconst message = error.message.toLowerCase();\n\t\t\treturn (\n\t\t\t\tmessage.includes(\"network\") ||\n\t\t\t\tmessage.includes(\"timeout\") ||\n\t\t\t\tmessage.includes(\"connection\") ||\n\t\t\t\tmessage.includes(\"fetch failed\") ||\n\t\t\t\tmessage.includes(\"econnreset\") ||\n\t\t\t\tmessage.includes(\"500\") ||\n\t\t\t\tmessage.includes(\"502\") ||\n\t\t\t\tmessage.includes(\"503\") ||\n\t\t\t\tmessage.includes(\"504\")\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t},\n};\n\nasync function withRetry<T>(\n\tfn: () => Promise<T>,\n\tcontext: string,\n\toptions: RetryOptions = {},\n): Promise<T> {\n\tconst opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\n\tlet lastError: unknown;\n\tlet delay = opts.initialDelay;\n\n\tfor (let attempt = 0; attempt <= opts.maxRetries; attempt++) {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tif (attempt === opts.maxRetries || !opts.shouldRetry(error)) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`[Schedule] ${context} failed after ${attempt + 1} attempt(s):`,\n\t\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t\t);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tconsole.warn(\n\t\t\t\t`[Schedule] ${context} attempt ${attempt + 1} failed, retrying in ${delay}ms...`,\n\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t);\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, delay));\n\t\t\tdelay = Math.min(delay * opts.backoffFactor, opts.maxDelay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\nconst scheduleSelect = `\n  *,\n  customer:customers(\n    id,\n    first_name,\n    last_name,\n    email,\n    phone\n  ),\n  job:jobs(\n    id,\n    job_number,\n    title,\n    job_type,\n    company_id,\n    job_team_assignments:job_team_assignments!job_team_assignments_job_id_fkey(\n      id,\n      role,\n      team_member_id,\n      removed_at,\n      team_member:team_members(\n        id,\n        company_id,\n        status,\n        job_title,\n        department,\n        archived_at,\n        user_id,\n        phone,\n        email,\n        invited_name,\n        created_at,\n        updated_at\n      )\n    )\n  )\n`;\n\nconst UNSCHEDULED_JOBS_SELECT = `\n  *,\n  customer:customers!customer_id(\n    id,\n    first_name,\n    last_name,\n    email,\n    phone,\n    created_at,\n    updated_at\n  ),\n  property:properties!property_id(\n    id,\n    name,\n    address,\n    address2,\n    city,\n    state,\n    zip_code,\n    country,\n    lat,\n    lon\n  ),\n  job_team_assignments:job_team_assignments!job_team_assignments_job_id_fkey(\n    id,\n    role,\n    team_member_id,\n    removed_at,\n    team_member:team_members(\n      id,\n      company_id,\n      status,\n      job_title,\n      department,\n      archived_at,\n      user_id,\n      phone,\n      email,\n      invited_name,\n      created_at,\n      updated_at\n    )\n  )\n`;\n\nconst DEFAULT_TECHNICIAN_COLOR = \"#3B82F6\";\n\nconst DEFAULT_SCHEDULE = {\n\tworkingHours: { start: \"08:00\", end: \"17:00\" },\n\tdaysOff: [] as Date[],\n\tavailableHours: { start: 0, end: 40 },\n};\n\nconst DEFAULT_LOCATION = {\n\taddress: {\n\t\tstreet: \"\",\n\t\tcity: \"\",\n\t\tstate: \"\",\n\t\tzip: \"\",\n\t\tcountry: \"\",\n\t},\n\tcoordinates: {\n\t\tlat: 0,\n\t\tlng: 0,\n\t},\n};\n\nconst DEFAULT_UNSCHEDULED_DURATION_MINUTES = 60;\nconst DEFAULT_UNSCHEDULED_PAGE_SIZE = 50;\n\ntype UnscheduledQueryOptions = {\n\tlimit?: number;\n\toffset?: number;\n\tsearch?: string;\n};\n\nexport async function fetchScheduleData({\n\tsupabase,\n\tcompanyId,\n\trange,\n\tunscheduledLimit = DEFAULT_UNSCHEDULED_PAGE_SIZE,\n\tunscheduledOffset = 0,\n\tunscheduledSearch = \"\",\n}: LoadParams): Promise<{\n\tjobs: Job[];\n\ttechnicians: Technician[];\n\tunassignedMeta: UnassignedJobsMeta;\n}> {\n\tconst scheduleQuery = supabase\n\t\t.from(\"appointments\")\n\t\t.select(scheduleSelect)\n\t\t.eq(\"company_id\", companyId)\n\t\t.is(\"deleted_at\", null)\n\t\t.is(\"archived_at\", null)\n\t\t.order(\"start_time\", { ascending: true });\n\n\tif (range) {\n\t\tscheduleQuery.lte(\"start_time\", range.end.toISOString());\n\t\tscheduleQuery.gte(\"end_time\", range.start.toISOString());\n\t}\n\n\t// Fetch all three queries in parallel with retry logic (eliminates waterfall)\n\tlet scheduleResult;\n\tlet teamMembers;\n\tlet unscheduledResult;\n\n\ttry {\n\t\t[scheduleResult, teamMembers, unscheduledResult] = await withRetry(\n\t\t\t() =>\n\t\t\t\tPromise.all([\n\t\t\t\t\tscheduleQuery,\n\t\t\t\t\tfetchTeamMembersWithUsers(supabase, companyId),\n\t\t\t\t\tfetchUnscheduledJobs(supabase, companyId, {\n\t\t\t\t\t\tlimit: unscheduledLimit,\n\t\t\t\t\t\toffset: unscheduledOffset,\n\t\t\t\t\t\tsearch: unscheduledSearch,\n\t\t\t\t\t}),\n\t\t\t\t]),\n\t\t\t\"fetchScheduleData parallel queries\",\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(\"[Schedule] Failed to fetch schedule data:\", error);\n\t\tthrow new Error(\n\t\t\t`Schedule data query failed: ${error instanceof Error ? error.message : String(error)}`,\n\t\t);\n\t}\n\n\tconst scheduleRows = scheduleResult.data ?? [];\n\tconst scheduleError = scheduleResult.error;\n\n\tif (scheduleError) {\n\t\tconsole.error(\"Appointments query error:\", scheduleError);\n\t\tthrow new Error(`Appointments query failed: ${scheduleError.message}`);\n\t}\n\n\tconst scheduledJobIds = new Set(\n\t\tscheduleRows\n\t\t\t.map((row) => (row as ScheduleRow).job_id)\n\t\t\t.filter((id): id is string => Boolean(id)),\n\t);\n\n\tconst unscheduledJobRows = unscheduledResult.rows.filter(\n\t\t(row) => !scheduledJobIds.has(row.id),\n\t);\n\tconst unscheduledMeta = {\n\t\ttotalCount: unscheduledResult.totalCount,\n\t\thasMore: unscheduledResult.hasMore,\n\t\tfetchedCount: unscheduledResult.rows.length,\n\t};\n\n\tlet propertyMap;\n\ttry {\n\t\tpropertyMap = await withRetry(\n\t\t\t() =>\n\t\t\t\tfetchPropertiesByIds(\n\t\t\t\t\tsupabase,\n\t\t\t\t\tcollectPropertyIds(scheduleRows as ScheduleRow[], unscheduledJobRows),\n\t\t\t\t),\n\t\t\t\"fetchPropertiesByIds\",\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(\"[Schedule] Failed to fetch properties:\", error);\n\t\t// Return empty map as fallback - jobs will still work but without property details\n\t\tpropertyMap = new Map<string, ScheduleProperty>();\n\t}\n\n\tconst technicianLookups = mapTeamMembersToTechnicians(teamMembers);\n\n\tconst normalizedSchedules = scheduleRows as unknown as ScheduleRecord[];\n\n\tconst scheduledJobs = normalizedSchedules.map((schedule) =>\n\t\tmapScheduleToJob(\n\t\t\tschedule,\n\t\t\ttechnicianLookups,\n\t\t\tpropertyMap.get(schedule.property_id ?? \"\") ?? null,\n\t\t),\n\t);\n\n\tconst unscheduledJobs = unscheduledJobRows.map((jobRow) =>\n\t\tmapJobRowToUnscheduledJob(\n\t\t\tjobRow,\n\t\t\ttechnicianLookups,\n\t\t\tpropertyMap.get(jobRow.property_id ?? \"\") ?? null,\n\t\t),\n\t);\n\n\tconst jobs = [...scheduledJobs, ...unscheduledJobs];\n\n\treturn {\n\t\tjobs,\n\t\ttechnicians: technicianLookups.technicians,\n\t\tunassignedMeta: {\n\t\t\tlimit: unscheduledLimit,\n\t\t\tnextOffset: unscheduledOffset + unscheduledMeta.fetchedCount,\n\t\t\thasMore: unscheduledMeta.hasMore,\n\t\t\tsearch: unscheduledSearch,\n\t\t\ttotalCount: unscheduledMeta.totalCount,\n\t\t},\n\t};\n}\n\nfunction resolveScheduleRange(\n\trange?: Range,\n\tanchor: Date = new Date(),\n): Range {\n\tif (range) {\n\t\treturn range;\n\t}\n\n\tconst start = subDays(anchor, 7);\n\tconst end = addDays(anchor, 30);\n\treturn { start, end };\n}\n\nasync function loadScheduleSnapshot(\n\tparams: LoadParams & { range?: Range },\n): Promise<ScheduleHydrationPayload> {\n\tconst resolvedRange = resolveScheduleRange(params.range);\n\tconst { jobs, technicians, unassignedMeta } = await fetchScheduleData({\n\t\t...params,\n\t\trange: resolvedRange,\n\t});\n\n\treturn {\n\t\tcompanyId: params.companyId,\n\t\trange: resolvedRange,\n\t\tlastSync: new Date(),\n\t\tjobs,\n\t\ttechnicians,\n\t\tunassignedMeta,\n\t};\n}\n\nfunction createTechnicianJobMap(jobs: Job[]): Record<string, Job[]> {\n\treturn jobs.reduce<Record<string, Job[]>>((acc, job) => {\n\t\tconst key = job.technicianId || UNASSIGNED_TECHNICIAN_ID;\n\t\tif (!acc[key]) {\n\t\t\tacc[key] = [];\n\t\t}\n\t\tacc[key].push(job);\n\t\treturn acc;\n\t}, {});\n}\n\n// Optimized: Single query with join instead of N+1 pattern\nasync function fetchTeamMembersWithUsers(\n\tsupabase: SupabaseClient<Database>,\n\tcompanyId: string,\n): Promise<TeamMemberRecord[]> {\n\t// Use a single query with left join to profiles via user_id\n\tconst { data: membersWithUsers, error } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(`\n\t\t\t*,\n\t\t\tusers:profiles!company_memberships_profile_id_fkey(\n\t\t\t\tid,\n\t\t\t\tfull_name,\n\t\t\t\temail,\n\t\t\t\tphone,\n\t\t\t\tavatar_url\n\t\t\t)\n\t\t`)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.is(\"archived_at\", null);\n\n\tif (error) {\n\t\t// Fallback to the old two-query approach if join fails\n\t\tconsole.warn(\"Join query failed, falling back to sequential queries:\", error.message);\n\t\treturn fetchTeamMembersWithUsersFallback(supabase, companyId);\n\t}\n\n\treturn (membersWithUsers ?? []).map((member) => ({\n\t\t...member,\n\t\tusers: member.users ? {\n\t\t\tid: member.users.id,\n\t\t\tname: member.users.full_name,\n\t\t\temail: member.users.email,\n\t\t\tphone: member.users.phone,\n\t\t\tavatar: member.users.avatar_url,\n\t\t} : null,\n\t})) as TeamMemberRecord[];\n}\n\n// Fallback function if the join doesn't work\nasync function fetchTeamMembersWithUsersFallback(\n\tsupabase: SupabaseClient<Database>,\n\tcompanyId: string,\n): Promise<TeamMemberRecord[]> {\n\tconst { data: bareMembers, error: bareError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.is(\"archived_at\", null);\n\n\tif (bareError) {\n\t\tthrow bareError;\n\t}\n\n\tconst userIds = Array.from(\n\t\tnew Set(\n\t\t\t(bareMembers ?? [])\n\t\t\t\t.map((member) => member.user_id)\n\t\t\t\t.filter((id): id is string => Boolean(id)),\n\t\t),\n\t);\n\n\tconst usersById = new Map<string, TeamMemberRecord[\"users\"]>();\n\tif (userIds.length > 0) {\n\t\tconst { data: users, error: userError } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"id, full_name, email, phone, avatar_url\")\n\t\t\t.in(\"id\", userIds);\n\t\tif (userError) {\n\t\t\tthrow userError;\n\t\t}\n\t\t(users ?? []).forEach((user) => {\n\t\t\tusersById.set(user.id, user);\n\t\t});\n\t}\n\n\treturn (bareMembers ?? []).map((member) => ({\n\t\t...member,\n\t\tusers: member.user_id ? (usersById.get(member.user_id) ?? null) : null,\n\t})) as TeamMemberRecord[];\n}\n\nasync function fetchUnscheduledJobs(\n\tsupabase: SupabaseClient<Database>,\n\tcompanyId: string,\n\toptions: UnscheduledQueryOptions,\n): Promise<{\n\trows: JobRowWithRelations[];\n\ttotalCount: number;\n\thasMore: boolean;\n}> {\n\tconst limit = options.limit ?? DEFAULT_UNSCHEDULED_PAGE_SIZE;\n\tconst offset = options.offset ?? 0;\n\n\tlet query = supabase\n\t\t.from(\"jobs\")\n\t\t.select(UNSCHEDULED_JOBS_SELECT, { count: \"exact\" })\n\t\t.eq(\"company_id\", companyId)\n\t\t.is(\"deleted_at\", null)\n\t\t.is(\"archived_at\", null)\n\t\t.is(\"scheduled_start\", null)\n\t\t.is(\"scheduled_end\", null)\n\t\t.not(\"status\", \"in\", '(\"completed\",\"cancelled\")')\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.range(offset, offset + limit - 1);\n\n\tif (options.search?.trim()) {\n\t\tconst sanitized = options.search.trim().replace(/,/g, \"\\\\,\");\n\t\tconst term = `%${sanitized}%`;\n\t\tquery = query.or(\n\t\t\t`title.ilike.${term},job_number.ilike.${term},description.ilike.${term}`,\n\t\t);\n\t}\n\n\tlet data;\n\tlet count;\n\tlet error;\n\n\ttry {\n\t\tconst result = await query;\n\t\tdata = result.data;\n\t\tcount = result.count;\n\t\terror = result.error;\n\t} catch (fetchError) {\n\t\tconsole.error(\"[Schedule] Unscheduled jobs fetch failed:\", fetchError);\n\t\t// Return empty result instead of throwing - allows schedule to still load with scheduled jobs\n\t\treturn { rows: [], totalCount: 0, hasMore: false };\n\t}\n\n\tif (error) {\n\t\tconsole.error(\"[Schedule] Unscheduled jobs query error:\", error);\n\t\t// Return empty result as fallback\n\t\treturn { rows: [], totalCount: 0, hasMore: false };\n\t}\n\n\tconst rows = (data ?? []) as JobRowWithRelations[];\n\tconst totalCount = typeof count === \"number\" ? count : rows.length;\n\tconst hasMore = offset + rows.length < totalCount;\n\n\treturn { rows, totalCount, hasMore };\n}\n\nasync function fetchPropertiesByIds(\n\tsupabase: SupabaseClient<Database>,\n\tpropertyIds: string[],\n): Promise<Map<string, ScheduleProperty>> {\n\tconst map = new Map<string, ScheduleProperty>();\n\tif (propertyIds.length === 0) {\n\t\treturn map;\n\t}\n\n\tconst chunkSize = 100;\n\tfor (let i = 0; i < propertyIds.length; i += chunkSize) {\n\t\tconst chunk = propertyIds.slice(i, i + chunkSize);\n\t\ttry {\n\t\t\tconst { data, error } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\n\t\t\t\t\t\"id, name, address, address2, city, state, zip_code, country, lat, lon\",\n\t\t\t\t)\n\t\t\t\t.in(\"id\", chunk);\n\n\t\t\tif (error) {\n\t\t\t\tconsole.error(\"[Schedule] Properties query error:\", error);\n\t\t\t\t// Continue with next chunk instead of failing completely\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t(data ?? []).forEach((property) => map.set(property.id, property));\n\t\t} catch (chunkError) {\n\t\t\tconsole.error(`[Schedule] Failed to fetch properties chunk ${i / chunkSize + 1}:`, chunkError);\n\t\t\t// Continue with next chunk - graceful degradation\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn map;\n}\n\nfunction mapTeamMembersToTechnicians(\n\tteamMembers: TeamMemberRecord[],\n): TechniciansLookup {\n\tconst technicians: Technician[] = [];\n\tconst byId = new Map<string, Technician>();\n\tconst byUserId = new Map<string, Technician>();\n\tconst byTeamMemberId = new Map<string, Technician>();\n\n\tteamMembers.forEach((member) => {\n\t\tconst technicianId = member.user_id ?? member.id;\n\t\tif (!technicianId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst user = member.users;\n\t\tconst technician: Technician = {\n\t\t\tid: technicianId,\n\t\t\tuserId: member.user_id ?? undefined,\n\t\t\tteamMemberId: member.id,\n\t\t\tname:\n\t\t\t\tuser?.name || member.invited_name || member.job_title || \"Team Member\",\n\t\t\temail: user?.email || member.email || undefined,\n\t\t\tphone: user?.phone || member.phone || undefined,\n\t\t\tavatar: user?.avatar || undefined,\n\t\t\trole: member.job_title || member.role || \"Team Member\",\n\t\t\tdepartment: member.department || undefined,\n\t\t\tstatus: member.status === \"active\" ? \"available\" : \"offline\",\n\t\t\tisActive: member.status === \"active\" && !member.archived_at,\n\t\t\tschedule: { ...DEFAULT_SCHEDULE },\n\t\t\tcolor: DEFAULT_TECHNICIAN_COLOR,\n\t\t\tcreatedAt: new Date(member.created_at),\n\t\t\tupdatedAt: new Date(member.updated_at),\n\t\t};\n\n\t\ttechnicians.push(technician);\n\t\tbyId.set(technician.id, technician);\n\t\tif (technician.userId) {\n\t\t\tbyUserId.set(technician.userId, technician);\n\t\t}\n\t\tif (technician.teamMemberId) {\n\t\t\tbyTeamMemberId.set(technician.teamMemberId, technician);\n\t\t}\n\t});\n\n\treturn { technicians, byId, byUserId, byTeamMemberId };\n}\n\nfunction collectPropertyIds(\n\tschedules: ScheduleRow[],\n\tunscheduledJobs: JobRowWithRelations[],\n): string[] {\n\tconst ids = new Set<string>();\n\tschedules.forEach((row) => {\n\t\tif (row.property_id) {\n\t\t\tids.add(row.property_id);\n\t\t}\n\t});\n\tunscheduledJobs.forEach((job) => {\n\t\tif (job.property_id) {\n\t\t\tids.add(job.property_id);\n\t\t}\n\t});\n\treturn Array.from(ids);\n}\n\nfunction normalizeSingleRecord<T>(value: T | T[] | null | undefined): T | null {\n\tif (Array.isArray(value)) {\n\t\treturn value[0] ?? null;\n\t}\n\treturn value ?? null;\n}\n\nfunction mapJobRowToUnscheduledJob(\n\tjob: JobRowWithRelations,\n\tlookups: TechniciansLookup,\n\tproperty: ScheduleProperty | null,\n): Job {\n\tconst location = buildLocation(property);\n\tconst customer = buildJobCustomer(job, location.address.street);\n\tconst assignments = buildAssignmentsFromJobRow(job, lookups);\n\tconst startTime = job.scheduled_start\n\t\t? new Date(job.scheduled_start)\n\t\t: new Date(job.created_at);\n\tconst endTime = job.scheduled_end\n\t\t? new Date(job.scheduled_end)\n\t\t: new Date(\n\t\t\t\tstartTime.getTime() + DEFAULT_UNSCHEDULED_DURATION_MINUTES * 60 * 1000,\n\t\t\t);\n\n\treturn {\n\t\tid: job.id,\n\t\tjobId: job.id,\n\t\ttechnicianId: \"\",\n\t\tassignments,\n\t\tisUnassigned: true,\n\t\ttitle: job.title || job.job_number || \"Job\",\n\t\tdescription: job.description || undefined,\n\t\tjobType: (job.job_type as Job[\"jobType\"]) || undefined,\n\t\tcustomer,\n\t\tlocation,\n\t\tstartTime,\n\t\tendTime,\n\t\tstatus: mapJobStatus(job.status),\n\t\tpriority: mapJobPriority(job.priority),\n\t\tmetadata: buildJobMetadata(job),\n\t\tcreatedAt: new Date(job.created_at),\n\t\tupdatedAt: new Date(job.updated_at),\n\t};\n}\n\nfunction buildAssignmentsFromJobRow(\n\tjob: JobRowWithRelations,\n\tlookups: TechniciansLookup,\n): JobAssignment[] {\n\tconst assignments: JobAssignment[] = [];\n\n\tif (job.assigned_to) {\n\t\tconst technician =\n\t\t\tlookups.byUserId.get(job.assigned_to) ||\n\t\t\tlookups.byId.get(job.assigned_to);\n\t\tassignments.push({\n\t\t\ttechnicianId: null,\n\t\t\tteamMemberId: technician?.teamMemberId,\n\t\t\tdisplayName: technician?.name || \"Primary Technician\",\n\t\t\tavatar: technician?.avatar ?? null,\n\t\t\trole: \"primary\",\n\t\t\tstatus: technician?.status ?? \"available\",\n\t\t\tisActive: technician?.isActive ?? true,\n\t\t});\n\t}\n\n\tconst crewAssignments = Array.isArray(job.job_team_assignments)\n\t\t? job.job_team_assignments\n\t\t: job.job_team_assignments\n\t\t\t? [job.job_team_assignments]\n\t\t\t: [];\n\n\tcrewAssignments\n\t\t.filter((assignment) => !assignment.removed_at)\n\t\t.forEach((assignment) => {\n\t\t\tconst teamMember = assignment.team_member;\n\t\t\tif (!teamMember) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst technician =\n\t\t\t\t(teamMember.user_id && lookups.byUserId.get(teamMember.user_id)) ||\n\t\t\t\tlookups.byTeamMemberId.get(teamMember.id);\n\n\t\t\tassignments.push({\n\t\t\t\ttechnicianId: null,\n\t\t\t\tteamMemberId: teamMember.id,\n\t\t\t\tdisplayName:\n\t\t\t\t\ttechnician?.name ||\n\t\t\t\t\tteamMember.invited_name ||\n\t\t\t\t\tteamMember.job_title ||\n\t\t\t\t\t\"Crew Member\",\n\t\t\t\tavatar: technician?.avatar ?? null,\n\t\t\t\trole: (assignment.role as JobAssignment[\"role\"]) || \"crew\",\n\t\t\t\tstatus: technician?.status ?? deriveTechnicianStatus(teamMember.status),\n\t\t\t\tisActive: technician?.isActive ?? teamMember.status === \"active\",\n\t\t\t});\n\t\t});\n\n\treturn dedupeAssignments(assignments);\n}\n\nfunction buildJobCustomer(\n\tjob: JobRowWithRelations,\n\tfallbackStreet: string,\n): Job[\"customer\"] {\n\tconst customerRecord = normalizeSingleRecord(job.customer);\n\tconst name = [\n\t\tcustomerRecord?.first_name?.trim() ?? \"\",\n\t\tcustomerRecord?.last_name?.trim() ?? \"\",\n\t]\n\t\t.filter(Boolean)\n\t\t.join(\" \")\n\t\t.trim();\n\n\treturn {\n\t\tid: customerRecord?.id || job.customer_id || `customer-${job.id}`,\n\t\tname: name || job.title || \"Unspecified Customer\",\n\t\temail: customerRecord?.email || undefined,\n\t\tphone: customerRecord?.phone || undefined,\n\t\tlocation: {\n\t\t\t...DEFAULT_LOCATION,\n\t\t\taddress: {\n\t\t\t\t...DEFAULT_LOCATION.address,\n\t\t\t\tstreet: fallbackStreet,\n\t\t\t},\n\t\t},\n\t\tcreatedAt: new Date(customerRecord?.created_at ?? job.created_at),\n\t\tupdatedAt: new Date(customerRecord?.updated_at ?? job.updated_at),\n\t};\n}\n\nfunction buildJobMetadata(job: JobRowWithRelations): Job[\"metadata\"] {\n\tconst baseMetadata =\n\t\tjob.metadata && typeof job.metadata === \"object\"\n\t\t\t? (job.metadata as Job[\"metadata\"])\n\t\t\t: {};\n\tconst metadata = { ...baseMetadata };\n\tif (job.notes) {\n\t\tmetadata.notes = job.notes;\n\t}\n\treturn metadata;\n}\n\nfunction mapJobPriority(value?: string | null): Job[\"priority\"] {\n\tif (!value) {\n\t\treturn \"medium\";\n\t}\n\tconst normalized = value.toLowerCase();\n\tswitch (normalized) {\n\t\tcase \"low\":\n\t\tcase \"medium\":\n\t\tcase \"high\":\n\t\tcase \"urgent\":\n\t\t\treturn normalized as Job[\"priority\"];\n\t\tcase \"critical\":\n\t\tcase \"emergency\":\n\t\t\treturn \"urgent\";\n\t\tdefault:\n\t\t\treturn \"medium\";\n\t}\n}\n\nfunction mapJobStatus(value?: string | null): Job[\"status\"] {\n\tif (!value) {\n\t\treturn \"scheduled\";\n\t}\n\tconst normalized = value.toLowerCase();\n\tswitch (normalized) {\n\t\tcase \"scheduled\":\n\t\tcase \"dispatched\":\n\t\tcase \"arrived\":\n\t\tcase \"closed\":\n\t\tcase \"cancelled\":\n\t\t\treturn normalized as Job[\"status\"];\n\t\tcase \"in-progress\":\n\t\tcase \"in_progress\":\n\t\t\treturn \"in-progress\";\n\t\tcase \"completed\":\n\t\tcase \"complete\":\n\t\tcase \"done\":\n\t\t\treturn \"completed\";\n\t\tcase \"inprogress\":\n\t\t\treturn \"in-progress\";\n\t\tcase \"open\":\n\t\tcase \"pending\":\n\t\tcase \"draft\":\n\t\tdefault:\n\t\t\treturn \"scheduled\";\n\t}\n}\n\nfunction mapScheduleToJob(\n\tschedule: ScheduleRecord,\n\tlookups: TechniciansLookup,\n\tproperty: ScheduleProperty | null,\n): Job {\n\tconst location = buildLocation(property);\n\tconst customer = buildCustomer(schedule, location.address.street);\n\tconst assignments = buildAssignments(schedule, lookups);\n\n\tconst primaryAssignment = assignments.find(\n\t\t(assignment) => assignment.role === \"primary\",\n\t);\n\tconst technicianId = primaryAssignment?.technicianId ?? \"\";\n\n\treturn {\n\t\tid: schedule.id,\n\t\tjobId: schedule.job_id || undefined,\n\t\ttechnicianId,\n\t\tassignments,\n\t\tisUnassigned: assignments.length === 0,\n\t\ttitle: schedule.title || schedule.job?.title || \"Appointment\",\n\t\tdescription: schedule.description || undefined,\n\t\tjobType: (schedule.job?.job_type as Job[\"jobType\"]) || undefined,\n\t\tappointmentType: schedule.type || undefined,\n\t\tappointmentCategory: getAppointmentCategory(schedule.type, schedule.all_day ?? false),\n\t\tcustomer,\n\t\tlocation,\n\t\tstartTime: new Date(schedule.start_time),\n\t\tendTime: new Date(schedule.end_time),\n\t\tallDay: schedule.all_day,\n\t\tstatus:\n\t\t\t(schedule.status as Job[\"status\"]) && isJobStatus(schedule.status)\n\t\t\t\t? (schedule.status as Job[\"status\"])\n\t\t\t\t: \"scheduled\",\n\t\tpriority: \"medium\",\n\t\trecurrence: schedule.is_recurring\n\t\t\t? {\n\t\t\t\t\tfrequency: \"weekly\",\n\t\t\t\t\tinterval: 1,\n\t\t\t\t\tendDate: schedule.recurrence_end_date\n\t\t\t\t\t\t? new Date(schedule.recurrence_end_date)\n\t\t\t\t\t\t: undefined,\n\t\t\t\t}\n\t\t\t: undefined,\n\t\tmetadata: {\n\t\t\testimatedDuration: schedule.duration,\n\t\t\tnotes: schedule.notes || undefined,\n\t\t},\n\t\tcreatedAt: new Date(schedule.created_at),\n\t\tupdatedAt: new Date(schedule.updated_at),\n\t};\n}\n\nfunction buildAssignments(\n\tschedule: ScheduleRecord,\n\tlookups: TechniciansLookup,\n): JobAssignment[] {\n\tconst assignments: JobAssignment[] = [];\n\n\tif (schedule.assigned_to) {\n\t\tconst technician =\n\t\t\tlookups.byUserId.get(schedule.assigned_to) ||\n\t\t\tlookups.byId.get(schedule.assigned_to);\n\t\tassignments.push({\n\t\t\ttechnicianId: technician?.id ?? schedule.assigned_to,\n\t\t\tteamMemberId: technician?.teamMemberId,\n\t\t\tdisplayName: technician?.name || \"Primary Technician\",\n\t\t\tavatar: technician?.avatar || null,\n\t\t\trole: \"primary\",\n\t\t\tstatus: technician?.status ?? \"available\",\n\t\t\tisActive: technician?.isActive ?? true,\n\t\t});\n\t}\n\n\tconst crewAssignments =\n\t\tschedule.job?.job_team_assignments?.filter(\n\t\t\t(assignment) => !assignment.removed_at,\n\t\t) ?? [];\n\n\tcrewAssignments.forEach((assignment) => {\n\t\tconst teamMember = assignment.team_member;\n\t\tif (!teamMember) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst technician =\n\t\t\t(teamMember.user_id && lookups.byUserId.get(teamMember.user_id)) ||\n\t\t\tlookups.byTeamMemberId.get(teamMember.id);\n\n\t\tconst displayName =\n\t\t\ttechnician?.name ||\n\t\t\tteamMember.invited_name ||\n\t\t\tteamMember.job_title ||\n\t\t\t\"Crew Member\";\n\n\t\tassignments.push({\n\t\t\ttechnicianId: technician?.id ?? teamMember.user_id ?? teamMember.id,\n\t\t\tteamMemberId: teamMember.id,\n\t\t\tdisplayName,\n\t\t\tavatar: technician?.avatar || null,\n\t\t\trole: (assignment.role as JobAssignment[\"role\"]) || \"crew\",\n\t\t\tstatus: technician?.status ?? deriveTechnicianStatus(teamMember.status),\n\t\t\tisActive: technician?.isActive ?? teamMember.status === \"active\",\n\t\t});\n\t});\n\n\treturn dedupeAssignments(assignments);\n}\n\nfunction dedupeAssignments(assignments: JobAssignment[]): JobAssignment[] {\n\tconst seen = new Set<string>();\n\n\treturn assignments.filter((assignment) => {\n\t\tconst key = `${assignment.role}-${assignment.technicianId ?? assignment.teamMemberId ?? \"\"}`;\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nfunction buildCustomer(\n\tschedule: ScheduleRecord,\n\tfallbackStreet: string,\n): Job[\"customer\"] {\n\tconst customerRecord = schedule.customer;\n\tconst name =\n\t\tcustomerRecord &&\n\t\t`${customerRecord.first_name ?? \"\"} ${customerRecord.last_name ?? \"\"}`.trim();\n\n\treturn {\n\t\tid: customerRecord?.id || schedule.customer_id || `customer-${schedule.id}`,\n\t\tname: name && name.length > 0 ? name : \"Unspecified Customer\",\n\t\temail: customerRecord?.email || undefined,\n\t\tphone: customerRecord?.phone || undefined,\n\t\tlocation: {\n\t\t\t...DEFAULT_LOCATION,\n\t\t\taddress: {\n\t\t\t\t...DEFAULT_LOCATION.address,\n\t\t\t\tstreet: fallbackStreet,\n\t\t\t},\n\t\t},\n\t\tcreatedAt: new Date(schedule.created_at),\n\t\tupdatedAt: new Date(schedule.updated_at),\n\t};\n}\n\nfunction buildLocation(property: ScheduleProperty | null): Job[\"location\"] {\n\tif (!property) {\n\t\treturn { ...DEFAULT_LOCATION };\n\t}\n\n\treturn {\n\t\taddress: {\n\t\t\tstreet: property.address || property.address2 || property.name || \"\",\n\t\t\tcity: property.city || \"\",\n\t\t\tstate: property.state || \"\",\n\t\t\tzip: property.zip_code || \"\",\n\t\t\tcountry: property.country || \"\",\n\t\t},\n\t\tcoordinates: {\n\t\t\tlat: property.lat || 0,\n\t\t\tlng: property.lon || 0,\n\t\t},\n\t};\n}\n\nfunction deriveTechnicianStatus(status?: string | null): Technician[\"status\"] {\n\treturn status === \"active\" ? \"available\" : \"offline\";\n}\n\nfunction isJobStatus(value: string): value is Job[\"status\"] {\n\treturn [\n\t\t\"scheduled\",\n\t\t\"dispatched\",\n\t\t\"arrived\",\n\t\t\"in-progress\",\n\t\t\"closed\",\n\t\t\"completed\",\n\t\t\"cancelled\",\n\t].includes(value);\n}\n\nexport async function fetchAdditionalUnscheduledJobs({\n\tsupabase,\n\tcompanyId,\n\tlimit = DEFAULT_UNSCHEDULED_PAGE_SIZE,\n\toffset = 0,\n\tsearch = \"\",\n}: {\n\tsupabase: SupabaseClient<Database>;\n\tcompanyId: string;\n\tlimit?: number;\n\toffset?: number;\n\tsearch?: string;\n}): Promise<{ jobs: Job[]; meta: UnassignedJobsMeta }> {\n\tconst teamMembers = await fetchTeamMembersWithUsers(supabase, companyId);\n\tconst technicianLookups = mapTeamMembersToTechnicians(teamMembers);\n\tconst { rows, totalCount, hasMore } = await fetchUnscheduledJobs(\n\t\tsupabase,\n\t\tcompanyId,\n\t\t{\n\t\t\tlimit,\n\t\t\toffset,\n\t\t\tsearch,\n\t\t},\n\t);\n\n\tconst propertyMap = await fetchPropertiesByIds(\n\t\tsupabase,\n\t\tcollectPropertyIds([], rows),\n\t);\n\tconst jobs = rows.map((row) =>\n\t\tmapJobRowToUnscheduledJob(\n\t\t\trow,\n\t\t\ttechnicianLookups,\n\t\t\tpropertyMap.get(row.property_id ?? \"\") ?? null,\n\t\t),\n\t);\n\n\treturn {\n\t\tjobs,\n\t\tmeta: {\n\t\t\tlimit,\n\t\t\tnextOffset: offset + rows.length,\n\t\t\thasMore,\n\t\t\tsearch,\n\t\t\ttotalCount,\n\t\t},\n\t};\n}\n"],"names":[],"mappings":"wCAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,CAAA,CAAA,QAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QCjBA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QCDA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAOO,eAAe,IACrB,GAAI,CACH,OAAO,MAAM,CAAA,EAAA,EAAA,2BAAA,AAA2B,GACzC,CAAE,MAAO,EAAO,CAKf,OAJA,QAAQ,IAAI,CACX,4EACA,GAEM,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,GAC1B,CACD,CMyFO,SAAS,EAAa,CAAQ,MAyEpC,EAxEA,MAAO,CACN,CAuEyB,EAvEtB,CAAG,CACN,UAAW,EAAI,SAAS,CAAC,WAAW,GACpC,QAAS,EAAI,OAAO,CAAC,WAAW,GAChC,UAAW,EAAI,SAAS,CAAC,WAAW,GACpC,UAAW,EAAI,SAAS,CAAC,WAAW,GACpC,SAAU,CACT,GAAG,EAAI,QAAQ,CACf,UAAW,EAAI,QAAQ,CAAC,SAAS,CAAC,WAAW,GAC7C,UAAW,EAAI,QAAQ,CAAC,SAAS,CAAC,WAAW,EAC9C,EACA,WAAY,EAAI,UAAU,CA+DpB,EA9DH,IAAoB,EAAI,UAAU,AA+DrC,CACA,EADG,MACM,EAAW,EADP,KACc,CAAG,EAAW,OAAO,CAAC,WAAW,GAAK,MAClE,OAhEI,CACJ,CACD,CL4FmC,OAAO,GAAG,CAAC,qBOA9C,IAAM,EAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CjC,CAAC,CAIK,EAAmB,CACxB,aAAc,CAAE,MAAO,QAAS,IAAK,OAAQ,EAC7C,QAAS,EAAE,CACX,eAAgB,CAAE,MAAO,EAAG,IAAK,EAAG,CACrC,EAEM,EAAmB,CACxB,QAAS,CACR,OAAQ,GACR,KAAM,GACN,MAAO,GACP,IAAK,GACL,QAAS,EACV,EACA,YAAa,CACZ,IAAK,EACL,IAAK,CACN,CACD,EAoLA,eAAe,EACd,CAAkC,CAClC,CAAiB,EAGjB,GAAM,CAAE,KAAM,CAAgB,OAAE,CAAK,CAAE,CAAG,MAAM,EAC9C,IAAI,CAAC,uBACL,MAAM,CAAC,CAAC;;;;;;;;;EAST,CAAC,EACA,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,SAAU,UACb,EAAE,CAAC,cAAe,aAEpB,AAAI,GAEH,IAFU,IAEF,IAAI,CAAC,yDAA0D,EAAM,OAAO,EAC7E,EAAkC,EAAU,IAG7C,CAAC,GAAoB,EAAA,AAAE,EAAE,GAAG,CAAE,AAAD,IAAa,CAChD,GAAG,CAAM,AADsC,CAE/C,MAAO,EAAO,KAAK,CAAG,CACrB,GAAI,EAAO,KAAK,CAAC,EAAE,CACnB,KAAM,EAAO,KAAK,CAAC,SAAS,CAC5B,MAAO,EAAO,KAAK,CAAC,KAAK,CACzB,MAAO,EAAO,KAAK,CAAC,KAAK,CACzB,OAAQ,EAAO,KAAK,CAAC,UAAU,AAChC,EAAI,KACL,CAAC,CACF,CAGA,eAAe,EACd,CAAkC,CAClC,CAAiB,EAEjB,GAAM,CAAE,KAAM,CAAW,CAAE,MAAO,CAAS,CAAE,CAAG,MAAM,EACpD,IAAI,CAAC,uBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,SAAU,UACb,EAAE,CAAC,cAAe,MAEpB,GAAI,EACH,MAAM,EAGP,CAJe,GAIT,EAAU,MAAM,IAAI,CACzB,IAAI,IACH,CAAC,GAAe,EAAA,AAAE,EAChB,GAAG,CAAC,AAAC,GAAW,EAAO,OAAO,EAC9B,MAAM,CAAC,AAAC,IAAqB,CAAQ,KAInC,EAAY,IAAI,IACtB,GAAI,EAAQ,MAAM,CAAG,EAAG,CACvB,GAAM,CAAE,KAAM,CAAK,CAAE,MAAO,CAAS,CAAE,CAAG,MAAM,EAC9C,IAAI,CAAC,YACL,MAAM,CAAC,2CACP,EAAE,CAAC,KAAM,GACX,GAAI,EACH,MAAM,EAEP,AAAC,CAHc,GAGL,EAAA,AAAE,EAAE,OAAO,CAAC,AAAC,IACtB,EAAU,GAAG,CAAC,EAAK,EAAE,CAAE,EACxB,EACD,CAEA,MAAO,AAAC,IAAe,EAAE,AAAF,EAAI,GAAG,CAAC,AAAC,GAAY,EAC3C,GAAG,CADuC,AACjC,CACT,MAAO,EAAO,OAAO,CAAI,EAAU,GAAG,CAAC,EAAO,OAAO,GAAK,KAAQ,KACnE,CAAC,CACF,CAEA,eAAe,EACd,CAAkC,CAClC,CAAiB,CACjB,CAAgC,EAMhC,IAuBI,EACA,EACA,EAzBE,EAAQ,EAAQ,KAAK,IAAI,CACzB,EAAS,EAAQ,MAAM,EAAI,EAE7B,EAAQ,EACV,IAAI,CAAC,QACL,MAAM,CAAC,EAAyB,CAAE,MAAO,OAAQ,GACjD,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,aAAc,MACjB,EAAE,CAAC,cAAe,MAClB,EAAE,CAAC,kBAAmB,MACtB,EAAE,CAAC,gBAAiB,MACpB,GAAG,CAAC,SAAU,KAAM,6BACpB,KAAK,CAAC,aAAc,CAAE,WAAW,CAAM,GACvC,KAAK,CAAC,EAAQ,EAAS,EAAQ,GAEjC,GAAI,EAAQ,MAAM,EAAE,OAAQ,CAC3B,IAAM,EAAY,EAAQ,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,KAAM,OAChD,EAAO,CAAC,CAAC,EAAE,EAAU,CAAC,CAAC,CAC7B,EAAQ,EAAM,EAAE,CACf,CAAC,YAAY,EAAE,EAAK,kBAAkB,EAAE,EAAK,mBAAmB,EAAE,EAAA,CAAM,CAE1E,CAMA,GAAI,CACH,IAAM,EAAS,MAAM,EACrB,EAAO,EAAO,IAAI,CAClB,EAAQ,EAAO,KAAK,CACpB,EAAQ,EAAO,KAAK,AACrB,CAAE,MAAO,EAAY,CAGpB,OAFA,QAAQ,KAAK,CAAC,4CAA6C,GAEpD,CAAE,KAAM,EAAE,CAAE,WAAY,EAAG,SAAS,CAAM,CAClD,CAEA,GAAI,EAGH,KAHU,EACV,QAAQ,KAAK,CAAC,2CAA4C,GAEnD,CAAE,KAAM,EAAE,CAAE,WAAY,EAAG,SAAS,CAAM,EAGlD,IAAM,EAAQ,GAAQ,EAAE,CAClB,EAA8B,UAAjB,OAAO,EAAqB,EAAQ,EAAK,MAAM,CAC5D,EAAU,EAAS,EAAK,MAAM,CAAG,EAEvC,MAAO,MAAE,EAAM,qBAAY,CAAQ,CACpC,CAEA,eAAe,EACd,CAAkC,CAClC,CAAqB,EAErB,IAAM,EAAM,IAAI,IAChB,GAA2B,GAAG,CAA1B,EAAY,MAAM,CACrB,OAAO,EAIR,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,MAAM,CAAE,KAAK,EAAW,CACvD,IAAM,EAAQ,EAAY,KAAK,CAAC,EAAG,IAAI,GACvC,GAAI,CACH,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC5B,IAAI,CAAC,cACL,MAAM,CACN,yEAEA,EAAE,CAAC,KAAM,GAEX,GAAI,EAAO,CACV,QAAQ,KAAK,CAAC,qCAAsC,GAEpD,QACD,CAEA,CAAC,GAAQ,EAAA,AAAE,EAAE,OAAO,CAAE,AAAD,GAAc,EAAI,GAAG,CAAC,EAAS,EAAE,CAAE,GACzD,CAAE,MAAO,EAAY,CACpB,QAAQ,KAAK,CAAC,CAAC,4CAA4C,EAAE,EAnB7C,EAmBiD,EAAY,EAAE,CAAC,CAAC,CAAE,GAEnF,QACD,CACD,CACA,OAAO,CACR,CA2bO,eAAe,EAA+B,UACpD,CAAQ,WACR,CAAS,OACT,EAhyBqC,EAgyBA,IAA7B,IACR,EAAS,CAAC,QACV,EAAS,EAAE,CAOX,MApcA,EA+CA,MA7CM,EACA,CA4CkB,AA/CO,EAgD/B,GAEM,EAoZA,KADc,KArZkB,CAqZZ,EAA0B,EAAU,KACpC,AApcQ,EAAE,GACvB,IAAI,IACX,EAAW,IAAI,IACf,EAAiB,GAic+B,CAjc3B,IAE3B,EAAY,OAAO,CAAC,AAAC,IACpB,IAAM,EAAe,EAAO,OAAO,EAAI,EAAO,EAAE,CAChD,GAAI,CAAC,EACJ,OAGD,IAAM,CAJa,CAIN,EAAO,KAAK,CACnB,EAAyB,CAC9B,GAAI,EACJ,OAAQ,EAAO,OAAO,OAAI,EAC1B,aAAc,EAAO,EAAE,CACvB,KACC,GAAM,MAAQ,EAAO,YAAY,EAAI,EAAO,SAAS,EAAI,cAC1D,MAAO,GAAM,OAAS,EAAO,KAAK,OAAI,EACtC,MAAO,GAAM,OAAS,EAAO,KAAK,EAAI,OACtC,OAAQ,GAAM,aAAU,EACxB,KAAM,EAAO,SAAS,EAAI,EAAO,IAAI,EAAI,cACzC,WAAY,EAAO,UAAU,OAAI,EACjC,OAAQ,AAAkB,aAAX,MAAM,CAAgB,YAAc,UACnD,SAA4B,WAAlB,EAAO,MAAM,EAAiB,CAAC,EAAO,WAAW,CAC3D,SAAU,CAAE,GAAG,CAAgB,AAAC,EAChC,MAxZ8B,CAwZvB,SACP,UAAW,IAAI,KAAK,EAAO,UAAU,EACrC,UAAW,IAAI,KAAK,EAAO,UAAU,CACtC,EAEA,EAAY,IAAI,CAAC,GACjB,EAAK,GAAG,CAAC,EAAW,EAAE,CAAE,GACpB,EAAW,MAAM,EAAE,AACtB,EAAS,GAAG,CAAC,EAAW,MAAM,CAAE,GAE7B,EAAW,YAAY,EAAE,AAC5B,EAAe,GAAG,CAAC,EAAW,YAAY,CAAE,EAE9C,GAEO,aAAE,EAAa,OAAM,0BAAU,CAAe,GA4Z/C,MAAE,CAAI,YAAE,CAAU,SAAE,CAAO,CAAE,CAAG,MAAM,EAC3C,EACA,EACA,OACC,SACA,SACA,CACD,GAGK,EAAc,MAAM,EACzB,KACmB,EAAE,GAjaV,AAiaX,IAjae,IAChB,EAAU,OAAO,CAAC,AAAC,IACd,EAAI,WAAW,EAAE,AACpB,EAAI,GAAG,CAAC,EAAI,WAAW,CAEzB,GACA,AA2ZwB,EA3ZR,OAAO,CAAC,AAAC,IACpB,EAAI,WAAW,EAAE,AACpB,EAAI,GAAG,CAAC,EAAI,WAAW,CAEzB,GACO,MAAM,IAAI,CAAC,KAgalB,MAAO,CACN,KATY,EAAK,GAAG,CAAC,AAAC,MACtB,EAlEqB,IA5OtB,IA4OuD,MAxUjD,EACA,EA2FgB,MAEhB,CA9FW,CA+FX,CA9FW,YAwUjB,AAzU+B,EA8FR,CA+SrB,CApEE,CAAC,AAoES,AA5YoB,GA4YjB,CAAC,EAAI,IApEP,OAoEkB,EAAI,KAAO,MAhErC,CACN,QAAS,CACR,OAAQ,EAAS,OAAO,EAAI,EAAS,QAAQ,EAAI,EAAS,IAAI,EAAI,GAClE,KAAM,EAAS,IAAI,EAAI,GACvB,MAAO,EAAS,KAAK,EAAI,GACzB,IAAK,EAAS,QAAQ,EAAI,GAC1B,QAAS,EAAS,OAAO,EAAI,EAC9B,EACA,YAAa,CACZ,IAAK,EAAS,GAAG,EAAI,EACrB,IAAK,EAAS,GAAG,EAAI,CACtB,CACD,EAfQ,CAAE,GAAG,CAAgB,AAAC,EA/O9B,GAAwB,GA1Fe,EAAS,OAAO,CAAC,MAAM,GAZ9D,AAAI,MAAM,OAAO,CADgB,AACf,EAyG2B,EAAI,CA1GiB,GACxC,IAyG+B,EAxGjD,CAAK,CAAC,EAAE,EAAI,KAEb,GAAS,OAuGH,CACZ,GAAgB,YAAY,QAAU,GACtC,GAAgB,WAAW,QAAU,GACrC,CACC,MAAM,CAAC,SACP,IAAI,CAAC,KACL,IAAI,KAEC,CACN,GAAI,GAAgB,IAAM,EAAI,WAAW,EAAI,CAAC,SAAS,EAAE,EAAI,EAAE,CAAA,CAAE,CACjE,KAAM,GAAQ,EAAI,KAAK,EAAI,uBAC3B,MAAO,GAAgB,YAAS,EAChC,MAAO,GAAgB,YAAS,EAChC,SAAU,CACT,GAAG,CAAgB,CACnB,QAAS,CACR,GAAG,EAAiB,OAAO,CAC3B,OAAQ,CACT,CACD,EACA,UAAW,IAAI,KAAK,GAAgB,YAAc,EAAI,UAAU,EAChE,UAAW,IAAI,KAAK,GAAgB,YAAc,EAAI,UAAU,CACjE,EAnHM,EA+BP,AA/BqB,SA+BZ,AACR,CAAwB,CACxB,CAA0B,MA8PA,EA5P1B,MAAM,CAnCyC,CAmCV,CA4PiB,CA5Pf,CAEvC,CArCoD,EAqChD,EAAI,WAAW,CAAE,CACpB,IAAM,EACL,EAAQ,QAAQ,CAAC,GAAG,CAAC,EAAI,WAAW,GACpC,EAAQ,IAAI,CAAC,GAAG,CAAC,EAAI,WAAW,EACjC,EAAY,IAAI,CAAC,CAChB,aAAc,KACd,aAAc,GAAY,aAC1B,YAAa,GAAY,MAAQ,qBACjC,OAAQ,GAAY,QAAU,KAC9B,KAAM,UACN,OAAQ,GAAY,QAAU,YAC9B,SAAU,GAAY,WAAY,CACnC,EACD,CAmCA,MA3BA,CANwB,AAiCjB,MAjCuB,OAAO,CAAC,EAAI,oBAAoB,EAC3D,EAAI,oBAAoB,CACxB,EAAI,oBAAoB,CACvB,CAAC,EAAI,oBAAoB,CAAC,CAC1B,EAAA,AAAE,EAGJ,MAAM,CAAC,AAAC,GAAe,CAAC,EAAW,UAAU,EAC7C,OAAO,CAAC,AAAC,IACT,IAAM,EAAa,EAAW,WAAW,CACzC,GAAI,CAAC,EACJ,OAGD,GAJiB,CAIX,EACJ,EAAW,OAAO,EAAI,EAAQ,QAAQ,CAAC,GAAG,CAAC,EAAW,OAAO,GAC9D,EAAQ,cAAc,CAAC,GAAG,CAAC,EAAW,EAAE,EAEzC,EAAY,IAAI,CAAC,CAChB,aAAc,KACd,aAAc,EAAW,EAAE,CAC3B,YACC,GAAY,MACZ,EAAW,YAAY,EACvB,EAAW,SAAS,EACpB,cACD,OAAQ,GAAY,QAAU,KAC9B,KAAO,EAAW,IAAI,EAA8B,OACpD,OAAQ,GAAY,SA2QhB,AAAW,CA3Qe,UAAuB,EAAW,MAAM,CA2Q5C,YAAc,SAAA,EA1QxC,SAAU,GAAY,UAAkC,WAAtB,EAAW,MAAM,AACpD,EACD,KAEwB,EA2MnB,EAAO,IAAI,IAEV,EAAY,MAAM,CAAC,AAAC,IAC1B,IAAM,EAAM,CAAA,EAAG,EAAW,IAAI,CAAC,CAAC,EAAE,EAAW,YAAY,EAAI,EAAW,YAAY,EAAI,GAAA,CAAI,OAC5F,CAAI,EAAK,GAAG,CAAC,KAGb,CAHmB,CAGd,GAAG,CAAC,IACF,EACR,EAnND,IAoTG,GAzYI,MACC,KADW,EAAI,eAAe,CACzB,EAAT,AAAa,eAAe,CACnB,EAAI,CAAb,IAAI,KAAmB,EACpB,MACC,KADS,EAAI,aAAa,CACrB,EAAT,AAAa,aAAa,CAE1B,EAAU,CADV,IAAI,EACa,GAAK,MAGlB,CACN,GAAI,EAAI,EAAE,CACV,MAAO,EAAI,EAAE,CACb,aAN+D,AAMjD,KANsD,UAOpE,EACA,cAAc,EACd,MAAO,EAAI,KAAK,EAAI,AAyXnB,EAzXuB,UAAU,EAAI,MACtC,YAAa,EAAI,WAAW,OAAI,EAChC,QAAS,EAAK,QAAQ,OAAuB,WAC7C,WACA,EACA,YACA,UACA,OAAQ,AA8HV,SAAS,AAAa,CAAqB,EAC1C,GAAI,CAAC,EACJ,KADW,CACJ,YAER,IAAM,EAAa,EAAM,WAAW,GACpC,OAAQ,GACP,IAAK,YACL,IAAK,aACL,IAAK,UACL,IAAK,SACL,IAAK,YACJ,OAAO,CACR,KAAK,cACL,IAAK,cAML,IAAK,aALJ,MAAO,aACR,KAAK,YACL,IAAK,WACL,IAAK,OACJ,MAAO,WAGR,KAAK,IAIJ,MAAO,WACT,CACD,EAzJuB,EAAI,MAAM,EAC/B,SAAU,AA0GZ,SAAS,AAAe,CAAqB,EAC5C,GAAI,CAAC,EACJ,KADW,CACJ,SAER,IAAM,EAAa,EAAM,WAAW,GACpC,OAAQ,GACP,IAAK,MACL,IAAK,SACL,IAAK,OACL,IAAK,SACJ,OAAO,CACR,KAAK,WACL,IAAK,YACJ,MAAO,QACR,SACC,MAAO,QACT,CACD,EA3H2B,EAAI,QAAQ,EACrC,QAAA,EAkGK,AAlGK,EAkGM,CADZ,GAFJ,CAFwB,GAAwB,EAE5C,KA/FuB,GA+Ff,EAA4B,UAAxB,OAAO,EAAI,QAAQ,CAC/B,EAAI,QAAQ,CACb,CAAC,CACc,AAAgB,EAC/B,CADkB,CACd,KAAK,EAAE,CACd,EAAS,CAFwB,IAEnB,CAAG,EAAI,KAAA,AAAK,EAEpB,GArGN,UAAW,IAAI,KAAK,EAAI,UAAU,EAClC,UAAW,IAAI,KAAK,EAAI,UAAU,CACnC,IAqXC,KAAM,OACL,EACA,WAAY,EAAS,EAAK,MAAM,CAChC,UACA,SACA,YACD,CACD,CACD,CTjmCO,eAAe,EAAK,CAAgB,EAC1C,GAAI,CACH,IAAM,EAAO,MAAM,EAAQ,IAAI,GAAG,KAAK,CAAC,IAAM,AAAC,GAAC,CAAC,EAC3C,EAAiC,AAAxB,iBAAO,GAAM,OAAsB,EAAK,MAAM,CAAG,GAC1D,EACkB,UAAvB,OAAO,GAAM,OAAsB,EAAK,KAAK,CAAG,EAC7C,EAAK,KAAK,MACV,EACE,EACmB,UAAxB,OAAO,GAAM,QAAuB,EAAK,MAAM,EAAI,EAAI,EAAK,MAAM,CAAG,EAEhE,EAAY,MAAM,CAAA,EAAA,EAAA,kBAAA,AAAkB,IAC1C,GAAI,CAAC,EACJ,OAAO,EADQ,AACR,YAAY,CAAC,IAAI,CACvB,CAAE,MAAO,4BAA6B,EACtC,CAAE,OAAQ,GAAI,GAIhB,IAAM,EAAW,MAAM,IACvB,GAAI,CAAC,EACJ,OAAO,CADO,CACP,YAAY,CAAC,IAAI,CACvB,CAAE,MAAO,sBAAuB,EAChC,CAAE,OAAQ,GAAI,GAIhB,GAAM,MAAE,CAAI,MAAE,CAAI,CAAE,CAAG,MAAM,EAA+B,UAC3D,YACA,QACA,SACA,SACA,CACD,GAEA,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CACxB,KAAM,EAAK,GAAG,CAAC,QACf,CACD,EACD,CAAE,MAAO,EAAO,CAKf,OAJA,QAAQ,KAAK,CACZ,wDACA,GAEM,EAAA,YAAY,CAAC,IAAI,CACvB,CACC,MACC,aAAiB,MACd,EAAM,OAAO,CACb,iCACL,EACA,CAAE,OAAQ,GAAI,EAEhB,CACD,4BD1CA,IAAA,EAAA,EAAA,CAAA,CAAA,QAIA,IAAM,EAAc,IAAI,EAAA,mBAAmB,CAAC,CACxC,WAAY,CACR,KAAM,EAAA,SAAS,CAAC,SAAS,CACzB,KAAM,kCACN,SAAU,4BACV,SAAU,QACV,WAAY,EAChB,EACA,QAAS,CAAA,OACT,IADiD,eACc,CAA3C,EACpB,iBAAkB,+DAClB,iBAZqB,GAarB,SAAA,CACJ,GAIM,kBAAE,CAAgB,sBAAE,CAAoB,aAAE,CAAW,CAAE,CAAG,EAChE,SAAS,IACL,MAAO,CAAA,EAAA,EAAA,UAAA,AAAW,EAAC,kBACf,uBACA,CACJ,EACJ,CAEO,eAAe,EAAQ,CAAG,CAAE,CAAG,CAAE,CAAG,EACnC,EAAY,KAAK,EACjB,AADmB,CACnB,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,+BAAgC,QAAQ,MAAM,CAAC,MAAM,IAE7E,IAAI,EAAU,kCAKV,EAAU,EAAQ,OAAO,CAAC,WAAY,KAAO,IAMjD,IAAM,EAAgB,MAAM,EAAY,OAAO,CAAC,EAAK,EAAK,SACtD,EACA,mBAHE,CAAA,CAIN,GACA,GAAI,CAAC,EAID,OAHA,EAAI,IADY,MACF,CAAG,IACjB,EAAI,GAAG,CAAC,eACS,MAAjB,CAAwB,CAApB,IAAyB,KAAhB,EAAoB,EAAI,SAAS,CAAC,IAAI,CAAC,EAAK,QAAQ,OAAO,IACjE,KAEX,GAAM,SAAE,CAAO,QAAE,CAAM,YAAE,CAAU,WAAE,CAAS,aAAE,CAAW,CAAE,mBAAiB,CAAE,qBAAmB,sBAAE,CAAoB,yBAAE,CAAuB,kBAAE,CAAgB,yBAAE,CAAuB,uBAAE,CAAqB,CAAE,CAAG,EACnN,EAAoB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,GACvC,GAAQ,EAAQ,EAAkB,aAAa,CAAC,EAAkB,EAAI,EAAkB,MAAM,CAAC,EAAA,AAAiB,EAC9G,EAAY,WAEa,MAAvB,EAA8B,KAAK,EAAI,EAAoB,SAAA,AAAS,EAAE,AACtE,MAAM,EAAoB,SAAS,CAAC,EAAK,EAAK,GAAW,GAEzD,EAAI,GAAG,CAAC,gCAEL,MAEX,GAAI,GAAS,CAAC,EAAa,CACvB,IAAM,GAAgB,CAAQ,EAAkB,MAAM,CAAC,EAAiB,CAClE,EAAgB,EAAkB,aAAa,CAAC,EAAkB,CACxE,GAAI,IAC+B,IAA3B,EAAc,KADH,GACW,EAAc,CAAC,EAAe,CACpD,GAAI,EAAW,YAAY,CAAC,WAAW,CACnC,CADqC,MAC9B,MAAM,GAEjB,OAAM,IAAI,EAAA,eAAe,AAC7B,CAER,CACA,IAAI,EAAW,MACX,GAAU,EAAY,IAAb,CAAkB,EAAK,EAAD,EAG/B,EAAW,AAAa,OAHqB,KAC7C,EAAW,CAAA,EAEwB,IAAM,CAAA,EAE7C,IAAM,GACgB,IAAtB,EAAY,EAAkB,GAAb,EAEjB,CAAC,EAKK,EAAqB,GAAS,CAAC,EAIjC,GAAyB,GACzB,CAAA,EAAA,EAAA,iBADkD,aAClD,AAA8B,EAAC,CAC3B,KAAM,EACN,EAd2F,8CAe3F,EACA,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,uBACnC,CACJ,EACJ,GAEJ,IAAM,EAAS,EAAI,MAAM,EAAI,MACvB,EAAS,CAAA,EAAA,EAAA,SAAA,AAAS,IAClB,EAAa,EAAO,kBAAkB,GACtC,EAAU,QACZ,oBACA,EACA,WAAY,CACR,aAAc,CACV,gBAAgB,CAAQ,EAAW,YAAY,CAAC,cAAc,AAClE,EACA,iBAAiB,CAAQ,EAAW,eAAe,yBACnD,EACA,iBAAkB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,oBACtC,kBAAmB,EAAW,SAAS,CACvC,UAAW,EAAI,SAAS,CACxB,QAAS,AAAC,IACN,EAAI,EAAE,CAAC,QAAS,EACpB,EACA,sBAAkB,EAClB,8BAA+B,CAAC,EAAO,EAAU,IAAe,EAAY,cAAc,CAAC,EAAK,EAAO,EAAc,EACzH,EACA,cAAe,SACX,CACJ,CACJ,EACM,EAAc,IAAI,EAAA,eAAe,CAAC,GAClC,EAAc,IAAI,EAAA,gBAAgB,CAAC,GACnC,EAAU,EAAA,kBAAkB,CAAC,mBAAmB,CAAC,EAAa,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,IAC3F,GAAI,CACA,IAAM,EAAoB,MAAO,GACtB,EAAY,MAAM,CAAC,EAAS,GAAS,OAAO,CAAC,KAChD,GAAI,CAAC,EAAM,OACX,EAAK,aAAa,CAAC,CACf,mBAAoB,EAAI,UAAU,CAClC,YAAY,CAChB,GACA,IAAM,EAAqB,EAAO,qBAAqB,GAEvD,GAAI,CAAC,EACD,OAEJ,GAAI,EAAmB,GAAG,CAAC,EAHF,kBAGwB,EAAA,cAAc,CAAC,aAAa,CAAE,YAC3E,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,EAAmB,GAAG,CAAC,kBAAkB,qEAAqE,CAAC,EAG9J,IAAM,EAAQ,EAAmB,GAAG,CAAC,cACrC,GAAI,EAAO,CACP,IAAM,EAAO,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAO,CACjC,EAAK,aAAa,CAAC,CACf,aAAc,EACd,aAAc,EACd,iBAAkB,CACtB,GACA,EAAK,UAAU,CAAC,EACpB,MACI,CADG,CACE,UAAU,CAAC,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAE9C,GAEE,GAAgB,CAAoC,CAAA,EAAA,EAAA,EAA5B,YAA4B,AAAc,EAAC,EAAK,eACxE,EAAiB,MAAO,QACtB,EA2FI,EA1FR,IAAM,EAAoB,MAAO,CAAE,oBAAkB,CAAE,IACnD,GAAI,CACA,GAAI,CAAC,GAAiB,GAAwB,GAA2B,CAAC,EAKtE,OAJA,EAAI,SADsF,CAC5E,CAAG,IAEjB,EAAI,SAAS,CAAC,iBAAkB,eAChC,EAAI,GAAG,CAAC,gCACD,KAEX,IAAM,EAAW,MAAM,EAAkB,GACzC,EAAI,YAAY,CAAG,EAAQ,UAAU,CAAC,YAAY,CAClD,IAAI,EAAmB,EAAQ,UAAU,CAAC,gBAAgB,CAGtD,GACI,EAAI,SAAS,EAAE,CACf,CAFc,CAEV,SAAS,CAAC,GACd,OAAmB,GAG3B,IAAM,EAAY,EAAQ,UAAU,CAAC,aAAa,CAGlD,IAAI,EA6BA,OADA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,EAAU,EAAQ,UAAU,CAAC,gBAAgB,EACnF,IA7BA,EACP,IAAM,EAAO,MAAM,EAAS,IAAI,GAE1B,EAAU,CAAA,EAAA,EAAA,yBAAA,AAAyB,EAAC,EAAS,OAAO,EACtD,IACA,CAAO,CAAC,EAAA,GADG,mBACmB,CAAC,CAAG,CAAA,EAElC,CAAC,CAAO,CAAC,eAAe,EAAI,EAAK,IAAI,EAAE,CACvC,CAAO,CAAC,eAAe,CAAG,EAAK,IAAA,AAAI,EAEvC,IAAM,EAAa,KAAkD,IAA3C,EAAQ,UAAU,CAAC,mBAAmB,IAAoB,EAAQ,UAAU,CAAC,mBAAmB,EAAI,EAAA,cAAA,AAAc,GAAG,AAAQ,EAAQ,UAAU,CAAC,mBAAmB,CACvL,EAAS,KAA8C,IAAvC,EAAQ,UAAU,CAAC,eAAe,EAAoB,EAAQ,UAAU,CAAC,eAAe,EAAI,EAAA,cAAc,MAAG,EAAY,EAAQ,UAAU,CAAC,eAAe,CAcjL,MAZmB,CAYZ,AAXH,MAAO,CACH,KAAM,EAAA,eAAe,CAAC,SAAS,CAC/B,OAAQ,EAAS,MAAM,CACvB,KAAM,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,YACxC,CACJ,EACA,aAAc,CACV,aACA,QACJ,CACJ,CAEJ,CAKJ,CAAE,KALS,CAKF,EAAK,CAcV,MAX0B,MAAtB,EAA6B,KAAK,EAAI,EAAmB,OAAA,AAAO,EAAE,CAClE,MAAM,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,oBAClC,uBACA,CACJ,EACJ,EAAG,GAED,CACV,CACJ,EACM,EAAa,MAAM,EAAY,cAAc,CAAC,KAChD,aACA,WACA,EACA,UAAW,EAAA,SAAS,CAAC,SAAS,CAC9B,YAAY,oBACZ,EACA,mBAAmB,uBACnB,0BACA,oBACA,EACA,UAAW,EAAI,SAAS,eACxB,CACJ,GAEA,GAAI,CAAC,EACD,KADQ,EACD,KAEX,GAAI,CAAe,MAAd,CAAqB,EAAS,AAA0C,GAA9C,IAAK,EAAoB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAkB,IAAI,IAAM,EAAA,eAAe,CAAC,SAAS,CAE9I,CAFgJ,KAE1I,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,kDAAkD,EAAgB,MAAd,CAAqB,EAAoD,AAA3C,GAAJ,IAAK,EAAqB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAmB,IAAI,CAAA,CAAE,EAAG,oBAAqB,CACjO,MAAO,OACP,WAAY,GACZ,aAAc,EAClB,EAEA,CAAC,GACD,EAAI,SAAS,CADG,AACF,iBAAkB,EAAuB,cAAgB,EAAW,MAAM,CAAG,OAAS,EAAW,OAAO,CAAG,QAAU,OAGnI,GACA,EAAI,QADS,CACA,CAAC,gBAAiB,2DAEnC,IAAM,EAAU,CAAA,EAAA,EAAA,2BAA2B,AAA3B,EAA4B,EAAW,KAAK,CAAC,OAAO,EAcpE,OAbI,AAAE,CAAD,EAAkB,GACnB,EADwB,AAChB,GADmB,GACb,CAAC,EAAA,sBAAsB,GAIrC,EAAW,YAAY,EAAK,EAAI,AAAL,SAAc,CAAC,kBAAqB,EAAD,AAAS,GAAG,CAAC,kBAAkB,AAC7F,EAAQ,GAAG,CAAC,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,EAAW,YAAY,GAE9E,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAChC,IAAI,SAAS,EAAW,KAAK,CAAC,IAAI,CAAE,SAChC,EACA,OAAQ,EAAW,KAAK,CAAC,MAAM,EAAI,GACvC,IACO,IACX,EAGI,EACA,MAAM,EAAe,EADT,CAGZ,MAAM,EAAO,qBAAqB,CAAC,EAAI,OAAO,CAAE,IAAI,EAAO,KAAK,CAAC,EAAA,cAAc,CAAC,aAAa,CAAE,CACvF,SAAU,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAChC,KAAM,EAAA,QAAQ,CAAC,MAAM,CACrB,WAAY,CACR,cAAe,EACf,cAAe,EAAI,GAAG,AAC1B,CACJ,EAAG,GAEf,CAAE,MAAO,EAAK,CAcV,GAbI,AAAE,CAAD,YAAgB,EAAA,eAAe,EAChC,CADmC,KAC7B,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,oBAClC,uBACA,CACJ,EACJ,GAIA,EAAO,MAAM,EAKjB,OAHA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,IAAI,SAAS,KAAM,CAC5D,OAAQ,GACZ,IACO,IACX,CACJ,EAEA,qCAAqC","ignoreList":[0,3,4,5,6,7]}