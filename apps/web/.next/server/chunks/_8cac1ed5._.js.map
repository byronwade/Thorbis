{"version":3,"sources":["../../../../../apps/web/src/lib/telnyx/errors.ts","../../../../../apps/web/src/lib/telnyx/metrics.ts","../../../../../apps/web/src/lib/telnyx/api.ts","../../../../../apps/web/src/lib/telnyx/rate-limiter.ts","../../../../../apps/web/src/lib/telnyx/ten-dlc.ts"],"sourcesContent":["/**\n * Telnyx Custom Error Classes\n *\n * Provides typed error classes for different failure scenarios\n * with error codes, metadata, and retry information.\n */\n\n// =============================================================================\n// ERROR CODES\n// =============================================================================\n\nexport enum TelnyxErrorCode {\n\t// Network errors\n\tNETWORK_ERROR = \"TELNYX_NETWORK_ERROR\",\n\tTIMEOUT = \"TELNYX_TIMEOUT\",\n\tCONNECTION_REFUSED = \"TELNYX_CONNECTION_REFUSED\",\n\n\t// Authentication errors\n\tINVALID_API_KEY = \"TELNYX_INVALID_API_KEY\",\n\tUNAUTHORIZED = \"TELNYX_UNAUTHORIZED\",\n\tFORBIDDEN = \"TELNYX_FORBIDDEN\",\n\n\t// Rate limiting\n\tRATE_LIMIT_EXCEEDED = \"TELNYX_RATE_LIMIT_EXCEEDED\",\n\n\t// Validation errors\n\tINVALID_PHONE_NUMBER = \"TELNYX_INVALID_PHONE_NUMBER\",\n\tINVALID_REQUEST = \"TELNYX_INVALID_REQUEST\",\n\tMISSING_REQUIRED_FIELD = \"TELNYX_MISSING_REQUIRED_FIELD\",\n\n\t// Resource errors\n\tNOT_FOUND = \"TELNYX_NOT_FOUND\",\n\tRESOURCE_CONFLICT = \"TELNYX_RESOURCE_CONFLICT\",\n\n\t// Provider errors\n\tPROVIDER_ERROR = \"TELNYX_PROVIDER_ERROR\",\n\tCARRIER_ERROR = \"TELNYX_CARRIER_ERROR\",\n\tDELIVERY_FAILED = \"TELNYX_DELIVERY_FAILED\",\n\n\t// Call-specific errors\n\tCALL_REJECTED = \"TELNYX_CALL_REJECTED\",\n\tCALL_BUSY = \"TELNYX_CALL_BUSY\",\n\tCALL_NO_ANSWER = \"TELNYX_CALL_NO_ANSWER\",\n\tCALL_FAILED = \"TELNYX_CALL_FAILED\",\n\n\t// SMS-specific errors\n\tSMS_DELIVERY_FAILED = \"TELNYX_SMS_DELIVERY_FAILED\",\n\tSMS_BLOCKED = \"TELNYX_SMS_BLOCKED\",\n\tSMS_SPAM_DETECTED = \"TELNYX_SMS_SPAM_DETECTED\",\n\n\t// Webhook errors\n\tWEBHOOK_VALIDATION_FAILED = \"TELNYX_WEBHOOK_VALIDATION_FAILED\",\n\tWEBHOOK_SIGNATURE_INVALID = \"TELNYX_WEBHOOK_SIGNATURE_INVALID\",\n\tWEBHOOK_TIMESTAMP_INVALID = \"TELNYX_WEBHOOK_TIMESTAMP_INVALID\",\n\tWEBHOOK_REPLAY_DETECTED = \"TELNYX_WEBHOOK_REPLAY_DETECTED\",\n\n\t// Circuit breaker\n\tCIRCUIT_BREAKER_OPEN = \"TELNYX_CIRCUIT_BREAKER_OPEN\",\n\n\t// Generic\n\tUNKNOWN_ERROR = \"TELNYX_UNKNOWN_ERROR\",\n\tINTERNAL_ERROR = \"TELNYX_INTERNAL_ERROR\",\n}\n\n// =============================================================================\n// BASE ERROR CLASS\n// =============================================================================\n\nexport interface TelnyxErrorMetadata {\n\tcorrelationId?: string;\n\tendpoint?: string;\n\tmethod?: string;\n\tstatusCode?: number;\n\tcompanyId?: string;\n\tphoneNumber?: string;\n\tcallControlId?: string;\n\tmessageSid?: string;\n\tattempt?: number;\n\tretryable?: boolean;\n\tretryAfterMs?: number;\n\toriginalError?: Error;\n\ttelnyxErrorCode?: string;\n\ttelnyxErrorDetail?: string;\n\t[key: string]: unknown;\n}\n\nexport class TelnyxError extends Error {\n\tpublic readonly code: TelnyxErrorCode;\n\tpublic readonly metadata: TelnyxErrorMetadata;\n\tpublic readonly timestamp: Date;\n\tpublic readonly retryable: boolean;\n\tpublic readonly retryAfterMs?: number;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode = TelnyxErrorCode.UNKNOWN_ERROR,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"TelnyxError\";\n\t\tthis.code = code;\n\t\tthis.metadata = metadata;\n\t\tthis.timestamp = new Date();\n\t\tthis.retryable = metadata.retryable ?? this.isRetryableCode(code);\n\t\tthis.retryAfterMs = metadata.retryAfterMs;\n\n\t\t// Capture stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, TelnyxError);\n\t\t}\n\t}\n\n\tprivate isRetryableCode(code: TelnyxErrorCode): boolean {\n\t\tconst retryableCodes = [\n\t\t\tTelnyxErrorCode.NETWORK_ERROR,\n\t\t\tTelnyxErrorCode.TIMEOUT,\n\t\t\tTelnyxErrorCode.CONNECTION_REFUSED,\n\t\t\tTelnyxErrorCode.RATE_LIMIT_EXCEEDED,\n\t\t\tTelnyxErrorCode.PROVIDER_ERROR,\n\t\t\tTelnyxErrorCode.INTERNAL_ERROR,\n\t\t];\n\t\treturn retryableCodes.includes(code);\n\t}\n\n\t/**\n\t * Convert to JSON for logging/serialization\n\t */\n\ttoJSON(): Record<string, unknown> {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tcode: this.code,\n\t\t\tmetadata: this.metadata,\n\t\t\ttimestamp: this.timestamp.toISOString(),\n\t\t\tretryable: this.retryable,\n\t\t\tretryAfterMs: this.retryAfterMs,\n\t\t\tstack: this.stack,\n\t\t};\n\t}\n\n\t/**\n\t * Create a user-friendly error message\n\t */\n\ttoUserMessage(): string {\n\t\tswitch (this.code) {\n\t\t\tcase TelnyxErrorCode.INVALID_PHONE_NUMBER:\n\t\t\t\treturn \"The phone number provided is invalid. Please check and try again.\";\n\t\t\tcase TelnyxErrorCode.RATE_LIMIT_EXCEEDED:\n\t\t\t\treturn \"Too many requests. Please wait a moment and try again.\";\n\t\t\tcase TelnyxErrorCode.CALL_BUSY:\n\t\t\t\treturn \"The number is busy. Please try again later.\";\n\t\t\tcase TelnyxErrorCode.CALL_NO_ANSWER:\n\t\t\t\treturn \"No answer. The call was not picked up.\";\n\t\t\tcase TelnyxErrorCode.SMS_BLOCKED:\n\t\t\t\treturn \"Message could not be delivered. The recipient may have blocked messages.\";\n\t\t\tcase TelnyxErrorCode.UNAUTHORIZED:\n\t\t\tcase TelnyxErrorCode.INVALID_API_KEY:\n\t\t\t\treturn \"Authentication failed. Please contact support.\";\n\t\t\tcase TelnyxErrorCode.NETWORK_ERROR:\n\t\t\tcase TelnyxErrorCode.TIMEOUT:\n\t\t\t\treturn \"Connection issue. Please try again.\";\n\t\t\tdefault:\n\t\t\t\treturn \"An error occurred. Please try again or contact support.\";\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SPECIALIZED ERROR CLASSES\n// =============================================================================\n\n/**\n * Network-related errors (connectivity, timeout, etc.)\n */\nexport class TelnyxNetworkError extends TelnyxError {\n\tconstructor(message: string, metadata: TelnyxErrorMetadata = {}) {\n\t\tsuper(message, TelnyxErrorCode.NETWORK_ERROR, {\n\t\t\t...metadata,\n\t\t\tretryable: true,\n\t\t});\n\t\tthis.name = \"TelnyxNetworkError\";\n\t}\n}\n\n/**\n * Timeout errors\n */\nexport class TelnyxTimeoutError extends TelnyxError {\n\tpublic readonly timeoutMs: number;\n\n\tconstructor(\n\t\tmessage: string,\n\t\ttimeoutMs: number,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.TIMEOUT, {\n\t\t\t...metadata,\n\t\t\tretryable: true,\n\t\t});\n\t\tthis.name = \"TelnyxTimeoutError\";\n\t\tthis.timeoutMs = timeoutMs;\n\t}\n}\n\n/**\n * Rate limit errors\n */\nexport class TelnyxRateLimitError extends TelnyxError {\n\tconstructor(\n\t\tmessage: string,\n\t\tretryAfterMs: number,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.RATE_LIMIT_EXCEEDED, {\n\t\t\t...metadata,\n\t\t\tretryable: true,\n\t\t\tretryAfterMs,\n\t\t});\n\t\tthis.name = \"TelnyxRateLimitError\";\n\t}\n}\n\n/**\n * Authentication/Authorization errors\n */\nexport class TelnyxAuthError extends TelnyxError {\n\tconstructor(message: string, metadata: TelnyxErrorMetadata = {}) {\n\t\tconst code = metadata.statusCode === 403\n\t\t\t? TelnyxErrorCode.FORBIDDEN\n\t\t\t: TelnyxErrorCode.UNAUTHORIZED;\n\t\tsuper(message, code, {\n\t\t\t...metadata,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxAuthError\";\n\t}\n}\n\n/**\n * Validation errors\n */\nexport class TelnyxValidationError extends TelnyxError {\n\tpublic readonly field?: string;\n\tpublic readonly validationDetails?: Record<string, string[]>;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tmetadata: TelnyxErrorMetadata & {\n\t\t\tfield?: string;\n\t\t\tvalidationDetails?: Record<string, string[]>;\n\t\t} = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.INVALID_REQUEST, {\n\t\t\t...metadata,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxValidationError\";\n\t\tthis.field = metadata.field;\n\t\tthis.validationDetails = metadata.validationDetails;\n\t}\n}\n\n/**\n * Phone number validation errors\n */\nexport class TelnyxPhoneNumberError extends TelnyxError {\n\tpublic readonly phoneNumber: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tphoneNumber: string,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, TelnyxErrorCode.INVALID_PHONE_NUMBER, {\n\t\t\t...metadata,\n\t\t\tphoneNumber,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxPhoneNumberError\";\n\t\tthis.phoneNumber = phoneNumber;\n\t}\n}\n\n/**\n * Webhook validation errors\n */\nexport class TelnyxWebhookError extends TelnyxError {\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode = TelnyxErrorCode.WEBHOOK_VALIDATION_FAILED,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, code, {\n\t\t\t...metadata,\n\t\t\tretryable: false,\n\t\t});\n\t\tthis.name = \"TelnyxWebhookError\";\n\t}\n}\n\n/**\n * Circuit breaker errors\n */\nexport class TelnyxCircuitBreakerError extends TelnyxError {\n\tpublic readonly endpoint: string;\n\n\tconstructor(endpoint: string, metadata: TelnyxErrorMetadata = {}) {\n\t\tsuper(\n\t\t\t`Circuit breaker is open for endpoint: ${endpoint}`,\n\t\t\tTelnyxErrorCode.CIRCUIT_BREAKER_OPEN,\n\t\t\t{\n\t\t\t\t...metadata,\n\t\t\t\tendpoint,\n\t\t\t\tretryable: false,\n\t\t\t}\n\t\t);\n\t\tthis.name = \"TelnyxCircuitBreakerError\";\n\t\tthis.endpoint = endpoint;\n\t}\n}\n\n/**\n * Call-specific errors\n */\nexport class TelnyxCallError extends TelnyxError {\n\tpublic readonly callControlId?: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, code, metadata);\n\t\tthis.name = \"TelnyxCallError\";\n\t\tthis.callControlId = metadata.callControlId;\n\t}\n}\n\n/**\n * SMS-specific errors\n */\nexport class TelnyxSmsError extends TelnyxError {\n\tpublic readonly messageSid?: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tcode: TelnyxErrorCode,\n\t\tmetadata: TelnyxErrorMetadata = {}\n\t) {\n\t\tsuper(message, code, metadata);\n\t\tthis.name = \"TelnyxSmsError\";\n\t\tthis.messageSid = metadata.messageSid;\n\t}\n}\n\n// =============================================================================\n// ERROR FACTORY\n// =============================================================================\n\n/**\n * Create appropriate error from HTTP response\n */\nexport function createErrorFromResponse(\n\tstatusCode: number,\n\tbody: unknown,\n\tmetadata: TelnyxErrorMetadata = {}\n): TelnyxError {\n\tconst errorBody = body as {\n\t\terrors?: Array<{ code?: string; title?: string; detail?: string }>;\n\t\terror?: string;\n\t\tmessage?: string;\n\t};\n\n\tconst errorDetail = errorBody?.errors?.[0]?.detail ||\n\t\terrorBody?.error ||\n\t\terrorBody?.message ||\n\t\t\"Unknown error\";\n\n\tconst telnyxErrorCode = errorBody?.errors?.[0]?.code;\n\n\tconst fullMetadata = {\n\t\t...metadata,\n\t\tstatusCode,\n\t\ttelnyxErrorCode,\n\t\ttelnyxErrorDetail: errorDetail,\n\t};\n\n\tswitch (statusCode) {\n\t\tcase 400:\n\t\t\treturn new TelnyxValidationError(errorDetail, fullMetadata);\n\n\t\tcase 401:\n\t\t\treturn new TelnyxAuthError(\"Invalid API key or unauthorized\", fullMetadata);\n\n\t\tcase 403:\n\t\t\treturn new TelnyxAuthError(\"Access forbidden\", fullMetadata);\n\n\t\tcase 404:\n\t\t\treturn new TelnyxError(\"Resource not found\", TelnyxErrorCode.NOT_FOUND, {\n\t\t\t\t...fullMetadata,\n\t\t\t\tretryable: false,\n\t\t\t});\n\n\t\tcase 409:\n\t\t\treturn new TelnyxError(\"Resource conflict\", TelnyxErrorCode.RESOURCE_CONFLICT, {\n\t\t\t\t...fullMetadata,\n\t\t\t\tretryable: false,\n\t\t\t});\n\n\t\tcase 429:\n\t\t\tconst retryAfter = parseInt(\n\t\t\t\t(body as { retry_after?: string })?.retry_after || \"60\",\n\t\t\t\t10\n\t\t\t) * 1000;\n\t\t\treturn new TelnyxRateLimitError(\n\t\t\t\t\"Rate limit exceeded\",\n\t\t\t\tretryAfter,\n\t\t\t\tfullMetadata\n\t\t\t);\n\n\t\tcase 500:\n\t\tcase 502:\n\t\tcase 503:\n\t\tcase 504:\n\t\t\treturn new TelnyxError(\n\t\t\t\t\"Telnyx service error\",\n\t\t\t\tTelnyxErrorCode.PROVIDER_ERROR,\n\t\t\t\t{\n\t\t\t\t\t...fullMetadata,\n\t\t\t\t\tretryable: true,\n\t\t\t\t}\n\t\t\t);\n\n\t\tdefault:\n\t\t\treturn new TelnyxError(errorDetail, TelnyxErrorCode.UNKNOWN_ERROR, fullMetadata);\n\t}\n}\n\n/**\n * Create error from network/fetch error\n */\nexport function createErrorFromException(\n\terror: unknown,\n\tmetadata: TelnyxErrorMetadata = {}\n): TelnyxError {\n\tif (error instanceof TelnyxError) {\n\t\treturn error;\n\t}\n\n\tconst originalError = error instanceof Error ? error : new Error(String(error));\n\tconst errorCode = (originalError as NodeJS.ErrnoException).code;\n\n\tconst fullMetadata = {\n\t\t...metadata,\n\t\toriginalError,\n\t};\n\n\t// Check for specific error types\n\tif (originalError.name === \"AbortError\" || originalError.message.includes(\"timeout\")) {\n\t\treturn new TelnyxTimeoutError(\n\t\t\t\"Request timed out\",\n\t\t\tmetadata.timeout as number || 30000,\n\t\t\tfullMetadata\n\t\t);\n\t}\n\n\tif (\n\t\terrorCode === \"ECONNRESET\" ||\n\t\terrorCode === \"ECONNREFUSED\" ||\n\t\terrorCode === \"ENOTFOUND\" ||\n\t\terrorCode === \"ENETUNREACH\" ||\n\t\toriginalError.message.includes(\"fetch failed\") ||\n\t\toriginalError.message.includes(\"network\")\n\t) {\n\t\treturn new TelnyxNetworkError(\n\t\t\t`Network error: ${originalError.message}`,\n\t\t\tfullMetadata\n\t\t);\n\t}\n\n\treturn new TelnyxError(\n\t\toriginalError.message,\n\t\tTelnyxErrorCode.UNKNOWN_ERROR,\n\t\tfullMetadata\n\t);\n}\n\n// =============================================================================\n// ERROR UTILITIES\n// =============================================================================\n\n/**\n * Check if an error is a TelnyxError\n */\nexport function isTelnyxError(error: unknown): error is TelnyxError {\n\treturn error instanceof TelnyxError;\n}\n\n/**\n * Check if an error is retryable\n */\nexport function isRetryableError(error: unknown): boolean {\n\tif (error instanceof TelnyxError) {\n\t\treturn error.retryable;\n\t}\n\n\t// Check for network errors\n\tif (error instanceof Error) {\n\t\tconst errorCode = (error as NodeJS.ErrnoException).code;\n\t\tconst retryableErrorCodes = [\n\t\t\t\"ECONNRESET\",\n\t\t\t\"ETIMEDOUT\",\n\t\t\t\"ECONNREFUSED\",\n\t\t\t\"EPIPE\",\n\t\t\t\"ENOTFOUND\",\n\t\t\t\"ENETUNREACH\",\n\t\t\t\"EAI_AGAIN\",\n\t\t];\n\t\tif (errorCode && retryableErrorCodes.includes(errorCode)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Wrap an error to ensure it's a TelnyxError\n */\nexport function wrapError(\n\terror: unknown,\n\tmetadata: TelnyxErrorMetadata = {}\n): TelnyxError {\n\tif (error instanceof TelnyxError) {\n\t\t// Merge metadata\n\t\treturn new TelnyxError(error.message, error.code, {\n\t\t\t...error.metadata,\n\t\t\t...metadata,\n\t\t});\n\t}\n\n\treturn createErrorFromException(error, metadata);\n}\n","/**\n * Telnyx Metrics & Monitoring\n *\n * Tracks API performance, error rates, and usage statistics.\n */\n\nimport { telnyxLogger } from \"./logger\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface RequestMetrics {\n\tendpoint: string;\n\tmethod: string;\n\tstatusCode: number;\n\tlatencyMs: number;\n\tsuccess: boolean;\n\ttimestamp: Date;\n\tcompanyId?: string;\n\tcorrelationId?: string;\n}\n\nexport interface AggregatedMetrics {\n\ttotalRequests: number;\n\tsuccessfulRequests: number;\n\tfailedRequests: number;\n\terrorRate: number;\n\tlatency: {\n\t\tp50: number;\n\t\tp95: number;\n\t\tp99: number;\n\t\tavg: number;\n\t\tmin: number;\n\t\tmax: number;\n\t};\n\tbyEndpoint: Record<\n\t\tstring,\n\t\t{\n\t\t\tcount: number;\n\t\t\terrors: number;\n\t\t\tavgLatency: number;\n\t\t}\n\t>;\n\tbyStatusCode: Record<number, number>;\n}\n\nexport interface OperationMetrics {\n\tsmsSent: number;\n\tsmsDelivered: number;\n\tsmsFailed: number;\n\tcallsInitiated: number;\n\tcallsCompleted: number;\n\tcallsFailed: number;\n\twebhooksReceived: number;\n\twebhooksProcessed: number;\n\twebhooksFailed: number;\n}\n\n// =============================================================================\n// METRICS COLLECTOR\n// =============================================================================\n\nclass MetricsCollector {\n\tprivate requests: RequestMetrics[] = [];\n\tprivate operations: OperationMetrics = {\n\t\tsmsSent: 0,\n\t\tsmsDelivered: 0,\n\t\tsmsFailed: 0,\n\t\tcallsInitiated: 0,\n\t\tcallsCompleted: 0,\n\t\tcallsFailed: 0,\n\t\twebhooksReceived: 0,\n\t\twebhooksProcessed: 0,\n\t\twebhooksFailed: 0,\n\t};\n\tprivate retentionMs: number = 60 * 60 * 1000; // 1 hour\n\tprivate maxEntries: number = 10000;\n\tprivate cleanupInterval?: NodeJS.Timeout;\n\n\tconstructor() {\n\t\tthis.startCleanup();\n\t}\n\n\t/**\n\t * Start periodic cleanup\n\t */\n\tprivate startCleanup(): void {\n\t\tthis.cleanupInterval = setInterval(() => {\n\t\t\tthis.cleanup();\n\t\t}, 60000); // Every minute\n\n\t\tif (this.cleanupInterval.unref) {\n\t\t\tthis.cleanupInterval.unref();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up old metrics\n\t */\n\tprivate cleanup(): void {\n\t\tconst cutoff = Date.now() - this.retentionMs;\n\t\tconst initialCount = this.requests.length;\n\n\t\tthis.requests = this.requests.filter(\n\t\t\t(r) => r.timestamp.getTime() > cutoff\n\t\t);\n\n\t\t// Also trim if over max entries\n\t\tif (this.requests.length > this.maxEntries) {\n\t\t\tthis.requests = this.requests.slice(-this.maxEntries);\n\t\t}\n\n\t\tconst removed = initialCount - this.requests.length;\n\t\tif (removed > 0) {\n\t\t\ttelnyxLogger.debug(\"Metrics cleanup\", { removed });\n\t\t}\n\t}\n\n\t/**\n\t * Record a request\n\t */\n\trecordRequest(metrics: RequestMetrics): void {\n\t\tthis.requests.push(metrics);\n\n\t\t// Log slow requests\n\t\tif (metrics.latencyMs > 2000) {\n\t\t\ttelnyxLogger.warn(\"Slow request detected\", {\n\t\t\t\tendpoint: metrics.endpoint,\n\t\t\t\tlatencyMs: metrics.latencyMs,\n\t\t\t\tcorrelationId: metrics.correlationId,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Record SMS sent\n\t */\n\trecordSmsSent(success: boolean): void {\n\t\tthis.operations.smsSent++;\n\t\tif (!success) {\n\t\t\tthis.operations.smsFailed++;\n\t\t}\n\t}\n\n\t/**\n\t * Record SMS delivered\n\t */\n\trecordSmsDelivered(): void {\n\t\tthis.operations.smsDelivered++;\n\t}\n\n\t/**\n\t * Record call initiated\n\t */\n\trecordCallInitiated(success: boolean): void {\n\t\tthis.operations.callsInitiated++;\n\t\tif (!success) {\n\t\t\tthis.operations.callsFailed++;\n\t\t}\n\t}\n\n\t/**\n\t * Record call completed\n\t */\n\trecordCallCompleted(): void {\n\t\tthis.operations.callsCompleted++;\n\t}\n\n\t/**\n\t * Record webhook received\n\t */\n\trecordWebhook(processed: boolean): void {\n\t\tthis.operations.webhooksReceived++;\n\t\tif (processed) {\n\t\t\tthis.operations.webhooksProcessed++;\n\t\t} else {\n\t\t\tthis.operations.webhooksFailed++;\n\t\t}\n\t}\n\n\t/**\n\t * Get aggregated metrics for a time window\n\t */\n\tgetAggregatedMetrics(windowMs: number = 5 * 60 * 1000): AggregatedMetrics {\n\t\tconst cutoff = Date.now() - windowMs;\n\t\tconst filtered = this.requests.filter(\n\t\t\t(r) => r.timestamp.getTime() > cutoff\n\t\t);\n\n\t\tconst successfulRequests = filtered.filter((r) => r.success).length;\n\t\tconst failedRequests = filtered.length - successfulRequests;\n\t\tconst latencies = filtered.map((r) => r.latencyMs).sort((a, b) => a - b);\n\n\t\t// Calculate percentiles\n\t\tconst getPercentile = (arr: number[], p: number): number => {\n\t\t\tif (arr.length === 0) return 0;\n\t\t\tconst index = Math.ceil((p / 100) * arr.length) - 1;\n\t\t\treturn arr[Math.max(0, index)];\n\t\t};\n\n\t\t// Group by endpoint\n\t\tconst byEndpoint: Record<\n\t\t\tstring,\n\t\t\t{ count: number; errors: number; totalLatency: number }\n\t\t> = {};\n\t\tfor (const r of filtered) {\n\t\t\tif (!byEndpoint[r.endpoint]) {\n\t\t\t\tbyEndpoint[r.endpoint] = { count: 0, errors: 0, totalLatency: 0 };\n\t\t\t}\n\t\t\tbyEndpoint[r.endpoint].count++;\n\t\t\tbyEndpoint[r.endpoint].totalLatency += r.latencyMs;\n\t\t\tif (!r.success) {\n\t\t\t\tbyEndpoint[r.endpoint].errors++;\n\t\t\t}\n\t\t}\n\n\t\t// Group by status code\n\t\tconst byStatusCode: Record<number, number> = {};\n\t\tfor (const r of filtered) {\n\t\t\tbyStatusCode[r.statusCode] = (byStatusCode[r.statusCode] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotalRequests: filtered.length,\n\t\t\tsuccessfulRequests,\n\t\t\tfailedRequests,\n\t\t\terrorRate:\n\t\t\t\tfiltered.length > 0 ? failedRequests / filtered.length : 0,\n\t\t\tlatency: {\n\t\t\t\tp50: getPercentile(latencies, 50),\n\t\t\t\tp95: getPercentile(latencies, 95),\n\t\t\t\tp99: getPercentile(latencies, 99),\n\t\t\t\tavg:\n\t\t\t\t\tlatencies.length > 0\n\t\t\t\t\t\t? latencies.reduce((a, b) => a + b, 0) / latencies.length\n\t\t\t\t\t\t: 0,\n\t\t\t\tmin: latencies[0] || 0,\n\t\t\t\tmax: latencies[latencies.length - 1] || 0,\n\t\t\t},\n\t\t\tbyEndpoint: Object.fromEntries(\n\t\t\t\tObject.entries(byEndpoint).map(([ep, data]) => [\n\t\t\t\t\tep,\n\t\t\t\t\t{\n\t\t\t\t\t\tcount: data.count,\n\t\t\t\t\t\terrors: data.errors,\n\t\t\t\t\t\tavgLatency: data.totalLatency / data.count,\n\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t),\n\t\t\tbyStatusCode,\n\t\t};\n\t}\n\n\t/**\n\t * Get operation metrics\n\t */\n\tgetOperationMetrics(): OperationMetrics {\n\t\treturn { ...this.operations };\n\t}\n\n\t/**\n\t * Get health score (0-100)\n\t */\n\tgetHealthScore(windowMs: number = 5 * 60 * 1000): number {\n\t\tconst metrics = this.getAggregatedMetrics(windowMs);\n\n\t\tif (metrics.totalRequests === 0) {\n\t\t\treturn 100; // No requests, assume healthy\n\t\t}\n\n\t\t// Factors:\n\t\t// - Error rate (weight: 50%)\n\t\t// - Latency (weight: 30%)\n\t\t// - 5xx errors (weight: 20%)\n\n\t\t// Error rate score (0 = 100%, 10%+ = 0)\n\t\tconst errorScore = Math.max(0, 100 - metrics.errorRate * 1000);\n\n\t\t// Latency score (0ms = 100, 3000ms+ = 0)\n\t\tconst latencyScore = Math.max(0, 100 - (metrics.latency.p95 / 3000) * 100);\n\n\t\t// 5xx score\n\t\tconst total5xx = Object.entries(metrics.byStatusCode)\n\t\t\t.filter(([code]) => parseInt(code) >= 500)\n\t\t\t.reduce((sum, [, count]) => sum + count, 0);\n\t\tconst rate5xx = total5xx / metrics.totalRequests;\n\t\tconst score5xx = Math.max(0, 100 - rate5xx * 1000);\n\n\t\treturn Math.round(errorScore * 0.5 + latencyScore * 0.3 + score5xx * 0.2);\n\t}\n\n\t/**\n\t * Reset metrics\n\t */\n\treset(): void {\n\t\tthis.requests = [];\n\t\tthis.operations = {\n\t\t\tsmsSent: 0,\n\t\t\tsmsDelivered: 0,\n\t\t\tsmsFailed: 0,\n\t\t\tcallsInitiated: 0,\n\t\t\tcallsCompleted: 0,\n\t\t\tcallsFailed: 0,\n\t\t\twebhooksReceived: 0,\n\t\t\twebhooksProcessed: 0,\n\t\t\twebhooksFailed: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Stop cleanup interval\n\t */\n\tstop(): void {\n\t\tif (this.cleanupInterval) {\n\t\t\tclearInterval(this.cleanupInterval);\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SINGLETON INSTANCE\n// =============================================================================\n\nexport const telnyxMetrics = new MetricsCollector();\n\n// =============================================================================\n// CONVENIENCE FUNCTIONS\n// =============================================================================\n\n/**\n * Create a request timer\n */\nexport function startRequestTimer(\n\tendpoint: string,\n\tmethod: string,\n\tcompanyId?: string,\n\tcorrelationId?: string\n): { end: (statusCode: number, success: boolean) => void } {\n\tconst startTime = Date.now();\n\n\treturn {\n\t\tend: (statusCode: number, success: boolean) => {\n\t\t\ttelnyxMetrics.recordRequest({\n\t\t\t\tendpoint,\n\t\t\t\tmethod,\n\t\t\t\tstatusCode,\n\t\t\t\tlatencyMs: Date.now() - startTime,\n\t\t\t\tsuccess,\n\t\t\t\ttimestamp: new Date(),\n\t\t\t\tcompanyId,\n\t\t\t\tcorrelationId,\n\t\t\t});\n\t\t},\n\t};\n}\n\n/**\n * Get a summary for monitoring dashboards\n */\nexport function getMetricsSummary(): {\n\thealth: number;\n\tmetrics: AggregatedMetrics;\n\toperations: OperationMetrics;\n} {\n\treturn {\n\t\thealth: telnyxMetrics.getHealthScore(),\n\t\tmetrics: telnyxMetrics.getAggregatedMetrics(),\n\t\toperations: telnyxMetrics.getOperationMetrics(),\n\t};\n}\n\n/**\n * Format metrics for logging\n */\nexport function formatMetricsForLogging(): string {\n\tconst summary = getMetricsSummary();\n\tconst { metrics, operations, health } = summary;\n\n\treturn [\n\t\t`Health Score: ${health}/100`,\n\t\t`Requests: ${metrics.totalRequests} (${metrics.failedRequests} failed)`,\n\t\t`Error Rate: ${(metrics.errorRate * 100).toFixed(2)}%`,\n\t\t`Latency: p50=${metrics.latency.p50}ms p95=${metrics.latency.p95}ms`,\n\t\t`SMS: ${operations.smsSent} sent, ${operations.smsDelivered} delivered, ${operations.smsFailed} failed`,\n\t\t`Calls: ${operations.callsInitiated} initiated, ${operations.callsCompleted} completed`,\n\t\t`Webhooks: ${operations.webhooksReceived} received, ${operations.webhooksFailed} failed`,\n\t].join(\" | \");\n}\n","/**\n * Telnyx API Client\n *\n * Production-ready API client with:\n * - Configurable timeouts\n * - Automatic retries with exponential backoff\n * - Rate limiting\n * - Circuit breaker protection\n * - Structured logging\n * - Metrics collection\n */\n\nimport \"server-only\";\n\nimport { telnyxLogger } from \"./logger\";\nimport { withRetry, generateCorrelationId, type RetryOptions } from \"./retry\";\nimport { withRateLimit, type RateLimitEndpoint } from \"./rate-limiter\";\nimport {\n\tcreateErrorFromResponse,\n\tcreateErrorFromException,\n\tTelnyxError,\n\tTelnyxTimeoutError,\n} from \"./errors\";\nimport { startRequestTimer } from \"./metrics\";\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nconst TELNYX_BASE_URL = \"https://api.telnyx.com/v2\";\nconst TELNYX_PUBLIC_BASE_URL = \"https://api.telnyx.com\";\n\n// Timeout configuration by operation type\nexport const TIMEOUT_CONFIG = {\n\tdefault: 30000, // 30 seconds\n\tsms: 10000, // 10 seconds\n\tvoice: 30000, // 30 seconds\n\tlookup: 5000, // 5 seconds\n\twebhook: 2000, // 2 seconds\n\tbalance: 5000, // 5 seconds\n} as const;\n\nexport type TimeoutType = keyof typeof TIMEOUT_CONFIG;\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface TelnyxRequestOptions {\n\tmethod?: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n\tbody?: Record<string, unknown>;\n\ttimeout?: number;\n\ttimeoutType?: TimeoutType;\n\trateLimitEndpoint?: RateLimitEndpoint;\n\tcompanyId?: string;\n\tcorrelationId?: string;\n\tskipRetry?: boolean;\n\tskipRateLimit?: boolean;\n\tretryOptions?: Partial<RetryOptions>;\n}\n\nexport interface TelnyxResponse<T> {\n\tsuccess: boolean;\n\tdata?: T;\n\terror?: string;\n\terrorCode?: string;\n\tcorrelationId?: string;\n\tlatencyMs?: number;\n}\n\n// =============================================================================\n// CORE REQUEST FUNCTION\n// =============================================================================\n\n/**\n * Make an authenticated request to the Telnyx API\n * with full production features (retry, rate limit, timeout, metrics)\n */\nexport async function telnyxRequest<TResponse>(\n\tpath: string,\n\toptions: TelnyxRequestOptions = {}\n): Promise<TelnyxResponse<TResponse>> {\n\tconst {\n\t\tmethod = \"GET\",\n\t\tbody,\n\t\ttimeout,\n\t\ttimeoutType = \"default\",\n\t\trateLimitEndpoint = \"default\",\n\t\tcompanyId,\n\t\tcorrelationId = generateCorrelationId(),\n\t\tskipRetry = false,\n\t\tskipRateLimit = false,\n\t\tretryOptions = {},\n\t} = options;\n\n\tconst apiKey = process.env.TELNYX_API_KEY;\n\tif (!apiKey) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"TELNYX_API_KEY is not configured\",\n\t\t\terrorCode: \"CONFIG_ERROR\",\n\t\t\tcorrelationId,\n\t\t};\n\t}\n\n\t// Build request URL\n\tconst hasProtocol = /^https?:\\/\\//i.test(path);\n\tconst normalizedPath =\n\t\thasProtocol || path.startsWith(\"/\") ? path : `/${path}`;\n\tconst requestUrl = hasProtocol\n\t\t? normalizedPath\n\t\t: normalizedPath.startsWith(\"/public/\")\n\t\t\t? `${TELNYX_PUBLIC_BASE_URL}${normalizedPath}`\n\t\t\t: `${TELNYX_BASE_URL}${normalizedPath}`;\n\n\t// Determine timeout\n\tconst effectiveTimeout = timeout || TIMEOUT_CONFIG[timeoutType];\n\n\t// Log request start\n\ttelnyxLogger.debug(\"API request started\", {\n\t\tcorrelationId,\n\t\tendpoint: path,\n\t\tmethod,\n\t\tcompanyId,\n\t});\n\n\t// Start metrics timer\n\tconst timer = startRequestTimer(path, method, companyId, correlationId);\n\n\t// Create the actual fetch function\n\tconst executeFetch = async (): Promise<TelnyxResponse<TResponse>> => {\n\t\tconst startTime = Date.now();\n\n\t\t// Create AbortController for timeout\n\t\tconst controller = new AbortController();\n\t\tconst timeoutId = setTimeout(() => controller.abort(), effectiveTimeout);\n\n\t\ttry {\n\t\t\tconst response = await fetch(requestUrl, {\n\t\t\t\tmethod,\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${apiKey}`,\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\"X-Correlation-ID\": correlationId,\n\t\t\t\t},\n\t\t\t\tbody: body ? JSON.stringify(body) : undefined,\n\t\t\t\tsignal: controller.signal,\n\t\t\t\t// Enable keep-alive for connection reuse\n\t\t\t\tkeepalive: true,\n\t\t\t});\n\n\t\t\tclearTimeout(timeoutId);\n\n\t\t\tconst latencyMs = Date.now() - startTime;\n\n\t\t\t// Parse response\n\t\t\tconst payload = (await response.json().catch(() => ({}))) as\n\t\t\t\t| {\n\t\t\t\t\t\tdata?: TResponse;\n\t\t\t\t\t\terrors?: Array<{ detail?: string; code?: string }>;\n\t\t\t\t  }\n\t\t\t\t| undefined;\n\n\t\t\tif (!response.ok) {\n\t\t\t\t// Record failure metric\n\t\t\t\ttimer.end(response.status, false);\n\n\t\t\t\t// Create typed error\n\t\t\t\tconst error = createErrorFromResponse(response.status, payload, {\n\t\t\t\t\tcorrelationId,\n\t\t\t\t\tendpoint: path,\n\t\t\t\t\tmethod,\n\t\t\t\t\tcompanyId,\n\t\t\t\t});\n\n\t\t\t\ttelnyxLogger.warn(\"API request failed\", {\n\t\t\t\t\tcorrelationId,\n\t\t\t\t\tendpoint: path,\n\t\t\t\t\tstatusCode: response.status,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tlatencyMs,\n\t\t\t\t});\n\n\t\t\t\t// Throw to trigger retry if retryable\n\t\t\t\tif (error.retryable) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\terrorCode: error.code,\n\t\t\t\t\tcorrelationId,\n\t\t\t\t\tlatencyMs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Record success metric\n\t\t\ttimer.end(response.status, true);\n\n\t\t\t// Telnyx API sometimes wraps response in \"data\", sometimes returns directly\n\t\t\tconst responseData = payload?.data || payload;\n\n\t\t\ttelnyxLogger.debug(\"API request completed\", {\n\t\t\t\tcorrelationId,\n\t\t\t\tendpoint: path,\n\t\t\t\tstatusCode: response.status,\n\t\t\t\tlatencyMs,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: responseData as TResponse,\n\t\t\t\tcorrelationId,\n\t\t\t\tlatencyMs,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tclearTimeout(timeoutId);\n\n\t\t\tconst latencyMs = Date.now() - startTime;\n\n\t\t\t// Handle timeout\n\t\t\tif (error instanceof Error && error.name === \"AbortError\") {\n\t\t\t\ttimer.end(0, false);\n\n\t\t\t\tconst timeoutError = new TelnyxTimeoutError(\n\t\t\t\t\t`Request timed out after ${effectiveTimeout}ms`,\n\t\t\t\t\teffectiveTimeout,\n\t\t\t\t\t{ correlationId, endpoint: path, method }\n\t\t\t\t);\n\n\t\t\t\ttelnyxLogger.error(\"API request timed out\", {\n\t\t\t\t\tcorrelationId,\n\t\t\t\t\tendpoint: path,\n\t\t\t\t\ttimeoutMs: effectiveTimeout,\n\t\t\t\t\tlatencyMs,\n\t\t\t\t});\n\n\t\t\t\tthrow timeoutError; // Throw to trigger retry\n\t\t\t}\n\n\t\t\t// Handle TelnyxError (already processed)\n\t\t\tif (error instanceof TelnyxError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Handle network/other errors\n\t\t\ttimer.end(0, false);\n\n\t\t\tconst wrappedError = createErrorFromException(error, {\n\t\t\t\tcorrelationId,\n\t\t\t\tendpoint: path,\n\t\t\t\tmethod,\n\t\t\t});\n\n\t\t\ttelnyxLogger.error(\"API request error\", {\n\t\t\t\tcorrelationId,\n\t\t\t\tendpoint: path,\n\t\t\t\terror: wrappedError.message,\n\t\t\t\tlatencyMs,\n\t\t\t});\n\n\t\t\tthrow wrappedError;\n\t\t}\n\t};\n\n\t// Apply rate limiting and retry logic\n\ttry {\n\t\tlet fetchFn = executeFetch;\n\n\t\t// Wrap with retry logic if not skipped\n\t\tif (!skipRetry) {\n\t\t\tconst originalFn = fetchFn;\n\t\t\tfetchFn = () =>\n\t\t\t\twithRetry(originalFn, {\n\t\t\t\t\tendpoint: path,\n\t\t\t\t\tcorrelationId,\n\t\t\t\t\tconfig: retryOptions.config,\n\t\t\t\t\tonRetry: (attempt, error, delayMs) => {\n\t\t\t\t\t\ttelnyxLogger.info(\"Retrying request\", {\n\t\t\t\t\t\t\tcorrelationId,\n\t\t\t\t\t\t\tendpoint: path,\n\t\t\t\t\t\t\tattempt,\n\t\t\t\t\t\t\tdelayMs,\n\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t}\n\n\t\t// Wrap with rate limiting if not skipped\n\t\tif (!skipRateLimit) {\n\t\t\tconst fnWithRetry = fetchFn;\n\t\t\tfetchFn = () =>\n\t\t\t\twithRateLimit(fnWithRetry, {\n\t\t\t\t\tendpoint: rateLimitEndpoint,\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tcorrelationId,\n\t\t\t\t});\n\t\t}\n\n\t\treturn await fetchFn();\n\t} catch (error) {\n\t\t// Convert any remaining errors to response format\n\t\tif (error instanceof TelnyxError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t\terrorCode: error.code,\n\t\t\t\tcorrelationId,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t\tcorrelationId,\n\t\t};\n\t}\n}\n\n// =============================================================================\n// CONVENIENCE METHODS\n// =============================================================================\n\n/**\n * GET request\n */\nexport async function telnyxGet<T>(\n\tpath: string,\n\toptions: Omit<TelnyxRequestOptions, \"method\" | \"body\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, { ...options, method: \"GET\" });\n}\n\n/**\n * POST request\n */\nexport async function telnyxPost<T>(\n\tpath: string,\n\tbody: Record<string, unknown>,\n\toptions: Omit<TelnyxRequestOptions, \"method\" | \"body\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, { ...options, method: \"POST\", body });\n}\n\n/**\n * PUT request\n */\nexport async function telnyxPut<T>(\n\tpath: string,\n\tbody: Record<string, unknown>,\n\toptions: Omit<TelnyxRequestOptions, \"method\" | \"body\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, { ...options, method: \"PUT\", body });\n}\n\n/**\n * PATCH request\n */\nexport async function telnyxPatch<T>(\n\tpath: string,\n\tbody: Record<string, unknown>,\n\toptions: Omit<TelnyxRequestOptions, \"method\" | \"body\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, { ...options, method: \"PATCH\", body });\n}\n\n/**\n * DELETE request\n */\nexport async function telnyxDelete<T>(\n\tpath: string,\n\toptions: Omit<TelnyxRequestOptions, \"method\" | \"body\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, { ...options, method: \"DELETE\" });\n}\n\n// =============================================================================\n// SPECIALIZED REQUESTS\n// =============================================================================\n\n/**\n * SMS-specific request with appropriate timeout and rate limiting\n */\nexport async function telnyxSmsRequest<T>(\n\tpath: string,\n\toptions: Omit<TelnyxRequestOptions, \"timeoutType\" | \"rateLimitEndpoint\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, {\n\t\t...options,\n\t\ttimeoutType: \"sms\",\n\t\trateLimitEndpoint: \"sms\",\n\t});\n}\n\n/**\n * Voice-specific request with appropriate timeout and rate limiting\n */\nexport async function telnyxVoiceRequest<T>(\n\tpath: string,\n\toptions: Omit<TelnyxRequestOptions, \"timeoutType\" | \"rateLimitEndpoint\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, {\n\t\t...options,\n\t\ttimeoutType: \"voice\",\n\t\trateLimitEndpoint: \"voice\",\n\t});\n}\n\n/**\n * Lookup-specific request with appropriate timeout\n */\nexport async function telnyxLookupRequest<T>(\n\tpath: string,\n\toptions: Omit<TelnyxRequestOptions, \"timeoutType\" | \"rateLimitEndpoint\"> = {}\n): Promise<TelnyxResponse<T>> {\n\treturn telnyxRequest<T>(path, {\n\t\t...options,\n\t\ttimeoutType: \"lookup\",\n\t\trateLimitEndpoint: \"lookup\",\n\t});\n}\n","/**\n * Telnyx Rate Limiter\n *\n * Implements token bucket algorithm with per-company and per-endpoint\n * rate limiting to prevent API rate limit errors.\n */\n\nimport { telnyxLogger } from \"./logger\";\nimport { sleep } from \"./retry\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface RateLimitConfig {\n\tmaxTokens: number; // Maximum tokens in bucket\n\trefillRate: number; // Tokens added per second\n\trefillInterval: number; // Milliseconds between refills\n}\n\nexport interface RateLimitResult {\n\tallowed: boolean;\n\tremainingTokens: number;\n\tretryAfterMs?: number;\n\twaitTime?: number; // Time waited if queued\n}\n\ninterface TokenBucket {\n\ttokens: number;\n\tlastRefill: number;\n\tqueue: Array<{\n\t\tresolve: (result: RateLimitResult) => void;\n\t\trequestedAt: number;\n\t}>;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\n// Default rate limits based on Telnyx API limits\nexport const RATE_LIMIT_CONFIGS: Record<string, RateLimitConfig> = {\n\t// General API: 100 requests per minute\n\tdefault: {\n\t\tmaxTokens: 100,\n\t\trefillRate: 100 / 60, // ~1.67 tokens/second\n\t\trefillInterval: 1000,\n\t},\n\t// SMS: 1 message per second per number (aggregate)\n\tsms: {\n\t\tmaxTokens: 60,\n\t\trefillRate: 1,\n\t\trefillInterval: 1000,\n\t},\n\t// Voice: more relaxed\n\tvoice: {\n\t\tmaxTokens: 30,\n\t\trefillRate: 0.5,\n\t\trefillInterval: 1000,\n\t},\n\t// Lookup: can be higher\n\tlookup: {\n\t\tmaxTokens: 200,\n\t\trefillRate: 200 / 60,\n\t\trefillInterval: 1000,\n\t},\n\t// Webhook (incoming): protect against floods\n\twebhook: {\n\t\tmaxTokens: 1000,\n\t\trefillRate: 100,\n\t\trefillInterval: 1000,\n\t},\n};\n\n// =============================================================================\n// TOKEN BUCKET IMPLEMENTATION\n// =============================================================================\n\nclass TokenBucketLimiter {\n\tprivate buckets = new Map<string, TokenBucket>();\n\tprivate processingQueue = new Map<string, boolean>();\n\n\t/**\n\t * Get or create a bucket for a key\n\t */\n\tprivate getBucket(key: string, config: RateLimitConfig): TokenBucket {\n\t\tif (!this.buckets.has(key)) {\n\t\t\tthis.buckets.set(key, {\n\t\t\t\ttokens: config.maxTokens,\n\t\t\t\tlastRefill: Date.now(),\n\t\t\t\tqueue: [],\n\t\t\t});\n\t\t}\n\t\treturn this.buckets.get(key)!;\n\t}\n\n\t/**\n\t * Refill tokens based on elapsed time\n\t */\n\tprivate refillTokens(bucket: TokenBucket, config: RateLimitConfig): void {\n\t\tconst now = Date.now();\n\t\tconst elapsed = now - bucket.lastRefill;\n\t\tconst intervalsElapsed = Math.floor(elapsed / config.refillInterval);\n\n\t\tif (intervalsElapsed > 0) {\n\t\t\tconst tokensToAdd = intervalsElapsed * config.refillRate;\n\t\t\tbucket.tokens = Math.min(config.maxTokens, bucket.tokens + tokensToAdd);\n\t\t\tbucket.lastRefill = now;\n\t\t}\n\t}\n\n\t/**\n\t * Process queued requests\n\t */\n\tprivate async processQueue(key: string, config: RateLimitConfig): Promise<void> {\n\t\tif (this.processingQueue.get(key)) return;\n\t\tthis.processingQueue.set(key, true);\n\n\t\tconst bucket = this.getBucket(key, config);\n\n\t\twhile (bucket.queue.length > 0) {\n\t\t\tthis.refillTokens(bucket, config);\n\n\t\t\tif (bucket.tokens >= 1) {\n\t\t\t\tconst request = bucket.queue.shift();\n\t\t\t\tif (request) {\n\t\t\t\t\tbucket.tokens -= 1;\n\t\t\t\t\tconst waitTime = Date.now() - request.requestedAt;\n\t\t\t\t\trequest.resolve({\n\t\t\t\t\t\tallowed: true,\n\t\t\t\t\t\tremainingTokens: bucket.tokens,\n\t\t\t\t\t\twaitTime,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Calculate time until next token\n\t\t\t\tconst timeUntilToken = config.refillInterval / config.refillRate;\n\t\t\t\tawait sleep(Math.ceil(timeUntilToken));\n\t\t\t}\n\t\t}\n\n\t\tthis.processingQueue.set(key, false);\n\t}\n\n\t/**\n\t * Attempt to acquire a token (immediate, no queue)\n\t */\n\ttryAcquire(key: string, config: RateLimitConfig = RATE_LIMIT_CONFIGS.default): RateLimitResult {\n\t\tconst bucket = this.getBucket(key, config);\n\t\tthis.refillTokens(bucket, config);\n\n\t\tif (bucket.tokens >= 1) {\n\t\t\tbucket.tokens -= 1;\n\t\t\treturn {\n\t\t\t\tallowed: true,\n\t\t\t\tremainingTokens: bucket.tokens,\n\t\t\t};\n\t\t}\n\n\t\t// Calculate retry after\n\t\tconst timeUntilToken = Math.ceil(config.refillInterval / config.refillRate);\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\tremainingTokens: 0,\n\t\t\tretryAfterMs: timeUntilToken,\n\t\t};\n\t}\n\n\t/**\n\t * Acquire a token, waiting in queue if necessary\n\t */\n\tasync acquire(\n\t\tkey: string,\n\t\tconfig: RateLimitConfig = RATE_LIMIT_CONFIGS.default,\n\t\tmaxWaitMs: number = 30000\n\t): Promise<RateLimitResult> {\n\t\t// Try immediate acquisition\n\t\tconst immediate = this.tryAcquire(key, config);\n\t\tif (immediate.allowed) {\n\t\t\treturn immediate;\n\t\t}\n\n\t\t// Queue the request\n\t\tconst bucket = this.getBucket(key, config);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst requestedAt = Date.now();\n\t\t\tconst timeoutId = setTimeout(() => {\n\t\t\t\t// Remove from queue on timeout\n\t\t\t\tconst index = bucket.queue.findIndex((r) => r.requestedAt === requestedAt);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tbucket.queue.splice(index, 1);\n\t\t\t\t}\n\t\t\t\tresolve({\n\t\t\t\t\tallowed: false,\n\t\t\t\t\tremainingTokens: 0,\n\t\t\t\t\tretryAfterMs: maxWaitMs,\n\t\t\t\t});\n\t\t\t}, maxWaitMs);\n\n\t\t\tbucket.queue.push({\n\t\t\t\tresolve: (result) => {\n\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\tresolve(result);\n\t\t\t\t},\n\t\t\t\trequestedAt,\n\t\t\t});\n\n\t\t\t// Start processing queue\n\t\t\tthis.processQueue(key, config);\n\t\t});\n\t}\n\n\t/**\n\t * Get current bucket status\n\t */\n\tgetStatus(key: string, config: RateLimitConfig = RATE_LIMIT_CONFIGS.default): {\n\t\ttokens: number;\n\t\tmaxTokens: number;\n\t\tqueueLength: number;\n\t\tutilizationPercent: number;\n\t} {\n\t\tconst bucket = this.getBucket(key, config);\n\t\tthis.refillTokens(bucket, config);\n\n\t\treturn {\n\t\t\ttokens: Math.floor(bucket.tokens),\n\t\t\tmaxTokens: config.maxTokens,\n\t\t\tqueueLength: bucket.queue.length,\n\t\t\tutilizationPercent: Math.round(((config.maxTokens - bucket.tokens) / config.maxTokens) * 100),\n\t\t};\n\t}\n\n\t/**\n\t * Reset a bucket (for testing)\n\t */\n\treset(key: string): void {\n\t\tthis.buckets.delete(key);\n\t}\n\n\t/**\n\t * Reset all buckets\n\t */\n\tresetAll(): void {\n\t\tthis.buckets.clear();\n\t}\n}\n\n// =============================================================================\n// RATE LIMITER INSTANCES\n// =============================================================================\n\n// Global rate limiter\nconst globalLimiter = new TokenBucketLimiter();\n\n// Per-company rate limiters\nconst companyLimiters = new Map<string, TokenBucketLimiter>();\n\nfunction getCompanyLimiter(companyId: string): TokenBucketLimiter {\n\tif (!companyLimiters.has(companyId)) {\n\t\tcompanyLimiters.set(companyId, new TokenBucketLimiter());\n\t}\n\treturn companyLimiters.get(companyId)!;\n}\n\n// =============================================================================\n// PUBLIC API\n// =============================================================================\n\nexport type RateLimitEndpoint = keyof typeof RATE_LIMIT_CONFIGS;\n\n/**\n * Check if a request is rate limited (immediate check, no queue)\n */\nexport function checkRateLimit(\n\tendpoint: RateLimitEndpoint = \"default\",\n\tcompanyId?: string\n): RateLimitResult {\n\tconst config = RATE_LIMIT_CONFIGS[endpoint] || RATE_LIMIT_CONFIGS.default;\n\n\t// Check global rate limit\n\tconst globalKey = `global:${endpoint}`;\n\tconst globalResult = globalLimiter.tryAcquire(globalKey, config);\n\n\tif (!globalResult.allowed) {\n\t\ttelnyxLogger.warn(\"Global rate limit hit\", {\n\t\t\tendpoint,\n\t\t\tretryAfterMs: globalResult.retryAfterMs,\n\t\t});\n\t\treturn globalResult;\n\t}\n\n\t// Check per-company rate limit if provided\n\tif (companyId) {\n\t\tconst companyLimiter = getCompanyLimiter(companyId);\n\t\tconst companyResult = companyLimiter.tryAcquire(endpoint, config);\n\n\t\tif (!companyResult.allowed) {\n\t\t\ttelnyxLogger.warn(\"Company rate limit hit\", {\n\t\t\t\tendpoint,\n\t\t\t\tcompanyId,\n\t\t\t\tretryAfterMs: companyResult.retryAfterMs,\n\t\t\t});\n\t\t\treturn companyResult;\n\t\t}\n\t}\n\n\treturn globalResult;\n}\n\n/**\n * Acquire a rate limit token, waiting if necessary\n */\nexport async function acquireRateLimit(\n\tendpoint: RateLimitEndpoint = \"default\",\n\tcompanyId?: string,\n\tmaxWaitMs: number = 30000\n): Promise<RateLimitResult> {\n\tconst config = RATE_LIMIT_CONFIGS[endpoint] || RATE_LIMIT_CONFIGS.default;\n\n\t// Acquire global token\n\tconst globalKey = `global:${endpoint}`;\n\tconst globalResult = await globalLimiter.acquire(globalKey, config, maxWaitMs);\n\n\tif (!globalResult.allowed) {\n\t\treturn globalResult;\n\t}\n\n\t// Acquire per-company token if provided\n\tif (companyId) {\n\t\tconst companyLimiter = getCompanyLimiter(companyId);\n\t\tconst companyResult = await companyLimiter.acquire(endpoint, config, maxWaitMs);\n\n\t\tif (!companyResult.allowed) {\n\t\t\treturn companyResult;\n\t\t}\n\n\t\t// Return the longer wait time\n\t\treturn {\n\t\t\t...companyResult,\n\t\t\twaitTime: Math.max(globalResult.waitTime || 0, companyResult.waitTime || 0),\n\t\t};\n\t}\n\n\treturn globalResult;\n}\n\n/**\n * Decorator function to rate limit async operations\n */\nexport function withRateLimit<T>(\n\tfn: () => Promise<T>,\n\toptions: {\n\t\tendpoint?: RateLimitEndpoint;\n\t\tcompanyId?: string;\n\t\tmaxWaitMs?: number;\n\t\tcorrelationId?: string;\n\t} = {}\n): Promise<T> {\n\tconst { endpoint = \"default\", companyId, maxWaitMs = 30000, correlationId } = options;\n\n\treturn new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tconst result = await acquireRateLimit(endpoint, companyId, maxWaitMs);\n\n\t\t\tif (!result.allowed) {\n\t\t\t\tconst error = new Error(\n\t\t\t\t\t`Rate limit exceeded. Retry after ${result.retryAfterMs}ms`\n\t\t\t\t);\n\t\t\t\t(error as any).code = \"RATE_LIMIT_EXCEEDED\";\n\t\t\t\t(error as any).retryAfterMs = result.retryAfterMs;\n\t\t\t\treject(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (result.waitTime && result.waitTime > 100) {\n\t\t\t\ttelnyxLogger.debug(\"Request waited for rate limit\", {\n\t\t\t\t\tendpoint,\n\t\t\t\t\tcompanyId,\n\t\t\t\t\twaitTime: result.waitTime,\n\t\t\t\t\tcorrelationId,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst response = await fn();\n\t\t\tresolve(response);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\n/**\n * Get rate limit status for monitoring\n */\nexport function getRateLimitStatus(\n\tendpoint?: RateLimitEndpoint,\n\tcompanyId?: string\n): {\n\tglobal: Record<string, ReturnType<TokenBucketLimiter[\"getStatus\"]>>;\n\tcompany?: Record<string, ReturnType<TokenBucketLimiter[\"getStatus\"]>>;\n} {\n\tconst endpoints = endpoint\n\t\t? [endpoint]\n\t\t: (Object.keys(RATE_LIMIT_CONFIGS) as RateLimitEndpoint[]);\n\n\tconst global: Record<string, ReturnType<TokenBucketLimiter[\"getStatus\"]>> = {};\n\n\tfor (const ep of endpoints) {\n\t\tconst config = RATE_LIMIT_CONFIGS[ep];\n\t\tglobal[ep] = globalLimiter.getStatus(`global:${ep}`, config);\n\t}\n\n\tlet company: Record<string, ReturnType<TokenBucketLimiter[\"getStatus\"]>> | undefined;\n\n\tif (companyId) {\n\t\tconst limiter = companyLimiters.get(companyId);\n\t\tif (limiter) {\n\t\t\tcompany = {};\n\t\t\tfor (const ep of endpoints) {\n\t\t\t\tconst config = RATE_LIMIT_CONFIGS[ep];\n\t\t\t\tcompany[ep] = limiter.getStatus(ep, config);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { global, company };\n}\n\n/**\n * Reset rate limits (for testing)\n */\nexport function resetRateLimits(companyId?: string): void {\n\tif (companyId) {\n\t\tcompanyLimiters.delete(companyId);\n\t} else {\n\t\tglobalLimiter.resetAll();\n\t\tcompanyLimiters.clear();\n\t}\n}\n\n// =============================================================================\n// BULK OPERATION HELPER\n// =============================================================================\n\nexport interface BulkRateLimitOptions {\n\tendpoint: RateLimitEndpoint;\n\tcompanyId?: string;\n\tbatchSize?: number;\n\tbatchDelayMs?: number;\n}\n\n/**\n * Process items in rate-limited batches\n */\nexport async function processBatchWithRateLimit<T, R>(\n\titems: T[],\n\tprocessor: (item: T) => Promise<R>,\n\toptions: BulkRateLimitOptions\n): Promise<Array<{ item: T; result?: R; error?: Error }>> {\n\tconst { endpoint, companyId, batchSize = 10, batchDelayMs = 1000 } = options;\n\n\tconst results: Array<{ item: T; result?: R; error?: Error }> = [];\n\n\tfor (let i = 0; i < items.length; i += batchSize) {\n\t\tconst batch = items.slice(i, i + batchSize);\n\n\t\t// Process batch with rate limiting\n\t\tconst batchResults = await Promise.all(\n\t\t\tbatch.map(async (item) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await withRateLimit(\n\t\t\t\t\t\t() => processor(item),\n\t\t\t\t\t\t{ endpoint, companyId }\n\t\t\t\t\t);\n\t\t\t\t\treturn { item, result };\n\t\t\t\t} catch (error) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\titem,\n\t\t\t\t\t\terror: error instanceof Error ? error : new Error(String(error)),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tresults.push(...batchResults);\n\n\t\t// Delay between batches\n\t\tif (i + batchSize < items.length) {\n\t\t\tawait sleep(batchDelayMs);\n\t\t}\n\t}\n\n\treturn results;\n}\n\n// =============================================================================\n// RATE LIMIT RESPONSE HANDLER\n// =============================================================================\n\n/**\n * Handle 429 response from Telnyx API\n */\nexport function handle429Response(response: Response): {\n\tretryAfterMs: number;\n\tshouldRetry: boolean;\n} {\n\tconst retryAfter = response.headers.get(\"Retry-After\");\n\n\tlet retryAfterMs = 60000; // Default 60 seconds\n\n\tif (retryAfter) {\n\t\t// Check if it's a number (seconds)\n\t\tconst seconds = parseInt(retryAfter, 10);\n\t\tif (!isNaN(seconds)) {\n\t\t\tretryAfterMs = seconds * 1000;\n\t\t} else {\n\t\t\t// Try parsing as a date\n\t\t\tconst date = Date.parse(retryAfter);\n\t\t\tif (!isNaN(date)) {\n\t\t\t\tretryAfterMs = Math.max(0, date - Date.now());\n\t\t\t}\n\t\t}\n\t}\n\n\t// Don't retry if wait is too long (> 5 minutes)\n\tconst shouldRetry = retryAfterMs <= 300000;\n\n\ttelnyxLogger.warn(\"Rate limit response received\", {\n\t\tretryAfterMs,\n\t\tshouldRetry,\n\t});\n\n\treturn { retryAfterMs, shouldRetry };\n}\n","import \"server-only\";\nimport { telnyxRequest } from \"./api\";\n\nexport type TenDlcBrandPayload = {\n\tentityType: \"PRIVATE_PROFIT\" | \"PUBLIC_PROFIT\" | \"NON_PROFIT\";\n\tdisplayName: string;\n\tcompanyName: string;\n\tfirstName: string;\n\tlastName: string;\n\tein: string;\n\tphone: string;\n\tstreet: string;\n\tcity: string;\n\tstate: string;\n\tpostalCode: string;\n\tcountry: string;\n\temail: string;\n\twebsite?: string;\n\tvertical: string;\n\tisReseller?: boolean;\n\tmock?: boolean;\n\tmobilePhone?: string;\n\tbusinessContactEmail?: string;\n\tstockSymbol?: string;\n\tstockExchange?: string;\n\tipAddress?: string;\n\twebhookURL?: string;\n\twebhookFailoverURL?: string;\n};\n\nexport async function createTenDlcBrand(payload: TenDlcBrandPayload) {\n\treturn telnyxRequest<{ brandId: string; status: string }>(\"/10dlc/brand\", {\n\t\tmethod: \"POST\",\n\t\tbody: payload,\n\t});\n}\n\nexport async function getTenDlcBrand(brandId: string) {\n\treturn telnyxRequest<{ brandId: string; status: string }>(\n\t\t`/10dlc/brand/${brandId}`,\n\t);\n}\n\nexport type TenDlcCampaignPayload = {\n\tbrandId: string;\n\tusecase: string;\n\tdescription: string;\n\tmessageFlow: string;\n\thelpMessage: string;\n\thelpKeywords?: string;\n\toptinKeywords?: string;\n\toptinMessage?: string;\n\toptoutKeywords?: string;\n\toptoutMessage?: string;\n\tsample1: string;\n\tsample2?: string;\n\tsample3?: string;\n\tsample4?: string;\n\tsample5?: string;\n\tautoRenewal: boolean;\n\tsubUsecases?: string[];\n\ttermsAndConditions?: boolean;\n\tprivacyPolicyLink?: string;\n\ttermsAndConditionsLink?: string;\n\taffiliateMarketing?: boolean;\n\tageGated?: boolean;\n\tdirectLending?: boolean;\n\tembeddedLink?: boolean;\n\tembeddedPhone?: boolean;\n\tnumberPool?: boolean;\n\tsubscriberHelp?: boolean;\n\tsubscriberOptin?: boolean;\n\tsubscriberOptout?: boolean;\n\treferenceId?: string;\n\tmnoIds?: number[];\n\ttag?: string[];\n};\n\nexport async function createTenDlcCampaign(payload: TenDlcCampaignPayload) {\n\treturn telnyxRequest<{ campaignId: string }>(\"/10dlc/campaignBuilder\", {\n\t\tmethod: \"POST\",\n\t\tbody: payload,\n\t});\n}\n\nexport async function getTenDlcCampaign(campaignId: string) {\n\treturn telnyxRequest<{ id: string; status: string; usecase: string }>(\n\t\t`/10dlc/campaign/${campaignId}`,\n\t);\n}\n\nexport async function attachNumberToCampaign(\n\tcampaignId: string,\n\tphoneNumber: string,\n) {\n\treturn telnyxRequest<{ id: string }>(\n\t\t`/10dlc/campaigns/${campaignId}/phone_numbers`,\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\tbody: {\n\t\t\t\tphone_numbers: [{ phone_number: phoneNumber }],\n\t\t\t},\n\t\t},\n\t);\n}\n"],"names":[],"mappings":"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"}