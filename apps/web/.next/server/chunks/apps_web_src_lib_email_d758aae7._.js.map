{"version":3,"sources":["../../../../../apps/web/src/lib/email/email-types.ts","../../../../../apps/web/src/lib/email/rate-limiter.ts","../../../../../apps/web/src/lib/email/email-provider.ts","../../../../../apps/web/src/lib/email/email-sender.ts"],"sourcesContent":["/**\n * Email Types - Type definitions for email templates\n *\n * Features:\n * - Type-safe email data\n * - Template props interfaces\n * - Email send result types\n * - Validation schemas\n */\n\nimport { z } from \"zod\";\n\n// Email send result type\nexport type EmailSendResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tdata?: {\n\t\tid?: string;\n\t\tmessage?: string;\n\t};\n};\n\n// Company branding for tenant emails\nexport type CompanyBranding = {\n\tcompanyName: string;\n\tlogoUrl?: string;\n\tprimaryColor?: string;\n\tsupportEmail?: string;\n\tsupportPhone?: string;\n\twebsiteUrl?: string;\n\taddress?: string;\n};\n\n// Base email template props\nexport type BaseEmailProps = {\n\tpreviewText?: string;\n\tcompanyName?: string; // Deprecated - use company.companyName\n\tcompany?: CompanyBranding; // For company-branded emails\n};\n\n// Authentication Email Props\nexport interface WelcomeEmailProps extends BaseEmailProps {\n\tname: string;\n\tloginUrl: string;\n}\n\nexport interface EmailVerificationProps extends BaseEmailProps {\n\tname: string;\n\tverificationUrl: string;\n}\n\nexport interface PasswordResetProps extends BaseEmailProps {\n\tname?: string;\n\tresetUrl: string;\n\texpiresInMinutes?: number;\n}\n\nexport interface PasswordChangedProps extends BaseEmailProps {\n\tname: string;\n\tchangedAt: Date;\n}\n\nexport interface MagicLinkProps extends BaseEmailProps {\n\tloginUrl: string;\n\texpiresInMinutes?: number;\n}\n\n// Job Lifecycle Email Props\nexport interface JobConfirmationProps extends BaseEmailProps {\n\tcustomerName: string;\n\tjobDate: string;\n\tjobTime: string;\n\ttechnicianName: string;\n\tjobType: string;\n\taddress: string;\n\tjobNumber: string;\n\tviewJobUrl: string;\n}\n\nexport interface AppointmentReminderProps extends BaseEmailProps {\n\tcustomerName: string;\n\tappointmentDate: string;\n\tappointmentTime: string;\n\ttechnicianName: string;\n\taddress: string;\n\trescheduleUrl: string;\n}\n\nexport interface TechEnRouteProps extends BaseEmailProps {\n\tcustomerName: string;\n\ttechnicianName: string;\n\testimatedArrival: string;\n\ttechnicianPhoto?: string;\n\ttrackingUrl?: string;\n}\n\nexport interface JobCompleteProps extends BaseEmailProps {\n\tcustomerName: string;\n\tjobNumber: string;\n\tcompletedDate: string;\n\ttotalAmount: string;\n\tinvoiceUrl: string;\n\treviewUrl: string;\n}\n\n// Billing Email Props\nexport interface InvoiceSentProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\ttotalAmount: string;\n\tdueDate: string;\n\titems: Array<{\n\t\tdescription: string;\n\t\tquantity: number;\n\t\tamount: string;\n\t}>;\n\tpaymentUrl: string;\n\tdownloadUrl: string;\n}\n\nexport interface InvoiceNotificationProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\tinvoiceDate: string;\n\tdueDate?: string;\n\ttotalAmount: number; // in cents\n\tinvoiceUrl: string;\n\tcurrency?: string;\n\titems?: Array<{\n\t\tdescription: string;\n\t\tquantity: number;\n\t\tamount: number; // in cents\n\t}>;\n\tnotes?: string;\n\tpaymentLink?: string; // Secure payment portal link\n\tcustomBody?: string; // Custom email body from template\n\tcustomFooter?: string; // Custom email footer from template\n}\n\nexport interface EstimateNotificationProps extends BaseEmailProps {\n\tcustomerName: string;\n\testimateNumber: string;\n\testimateDate: string;\n\tvalidUntil?: string;\n\ttotalAmount: number; // in cents\n\testimateUrl: string;\n\tcurrency?: string;\n\titems?: Array<{\n\t\tdescription: string;\n\t\tquantity: number;\n\t\tamount: number; // in cents\n\t}>;\n\tnotes?: string;\n}\n\nexport interface PaymentReceivedProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\tpaymentAmount: string;\n\tpaymentMethod: string;\n\tpaymentDate: string;\n\treceiptUrl: string;\n}\n\nexport interface PaymentReminderProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\ttotalAmount: string;\n\tdueDate: string;\n\tdaysOverdue: number;\n\tpaymentUrl: string;\n}\n\nexport interface EstimateSentProps extends BaseEmailProps {\n\tcustomerName: string;\n\testimateNumber: string;\n\ttotalAmount: string;\n\tvalidUntil: string;\n\titems: Array<{\n\t\tdescription: string;\n\t\tamount: string;\n\t}>;\n\tacceptUrl: string;\n\tviewUrl: string;\n}\n\n// Customer Engagement Email Props\nexport interface ReviewRequestProps extends BaseEmailProps {\n\tcustomerName: string;\n\tjobNumber: string;\n\ttechnicianName: string;\n\tcompletedDate: string;\n\treviewUrl: string;\n}\n\nexport interface ServiceReminderProps extends BaseEmailProps {\n\tcustomerName: string;\n\tserviceName: string;\n\tlastServiceDate: string;\n\tscheduleUrl: string;\n}\n\nexport interface WelcomeCustomerProps extends BaseEmailProps {\n\tcustomerName: string;\n\taccountUrl: string;\n\tsupportEmail: string;\n\tsupportPhone: string;\n}\n\nexport interface PortalInvitationProps extends BaseEmailProps {\n\tcustomerName: string;\n\tportalUrl: string;\n\texpiresInHours?: number;\n\tcompanyName?: string;\n\tsupportEmail?: string;\n\tsupportPhone?: string;\n}\n\n// Verification Email Props\nexport interface VerificationSubmittedProps extends BaseEmailProps {\n\tcompanyName: string;\n\tcontactName: string;\n\thasTollFreeNumbers: boolean;\n\thas10DLCNumbers: boolean;\n\ttollFreeCount?: number;\n\tdlcCount?: number;\n\tdashboardUrl: string;\n}\n\nexport interface VerificationCompleteProps extends BaseEmailProps {\n\tcompanyName: string;\n\tcontactName: string;\n\tverificationTypes: string[]; // [\"toll-free\", \"10dlc\"]\n\tdashboardUrl: string;\n\tmessagingUrl: string;\n}\n\n// Waitlist Email Props\nexport interface WaitlistSubscriptionProps extends BaseEmailProps {\n\tname: string;\n}\n\n// Validation Schemas\nconst emailAddressSchema = z\n\t.string()\n\t.email(\"Invalid email address\")\n\t.min(1, \"Email is required\");\n\nexport const emailSendSchema = z.object({\n\tto: z.union([emailAddressSchema, z.array(emailAddressSchema)]),\n\tsubject: z.string().min(1, \"Subject is required\").max(200),\n\treplyTo: emailAddressSchema.optional(),\n});\n\n// Template types enum\nexport enum EmailTemplate {\n\t// Auth\n\tWELCOME = \"welcome\",\n\tEMAIL_VERIFICATION = \"email-verification\",\n\tPASSWORD_RESET = \"password-reset\",\n\tPASSWORD_CHANGED = \"password-changed\",\n\tMAGIC_LINK = \"magic-link\",\n\n\t// Jobs\n\tJOB_CONFIRMATION = \"job-confirmation\",\n\tAPPOINTMENT_REMINDER = \"appointment-reminder\",\n\tTECH_EN_ROUTE = \"tech-en-route\",\n\tJOB_COMPLETE = \"job-complete\",\n\n\t// Billing\n\tINVOICE = \"invoice\",\n\tESTIMATE = \"estimate\",\n\tINVOICE_SENT = \"invoice-sent\",\n\tPAYMENT_RECEIVED = \"payment-received\",\n\tPAYMENT_REMINDER = \"payment-reminder\",\n\tESTIMATE_SENT = \"estimate-sent\",\n\n\t// Customer\n\tREVIEW_REQUEST = \"review-request\",\n\tSERVICE_REMINDER = \"service-reminder\",\n\tWELCOME_CUSTOMER = \"welcome-customer\",\n\tPORTAL_INVITATION = \"portal-invitation\",\n\n\t// Team\n\tTEAM_INVITATION = \"team-invitation\",\n\n\t// Onboarding & Verification\n\tVERIFICATION_SUBMITTED = \"verification-submitted\",\n\tVERIFICATION_COMPLETE = \"verification-complete\",\n\n\t// Waitlist\n\tWAITLIST_SUBSCRIPTION = \"waitlist-subscription\",\n\tWAITLIST_ADMIN_NOTIFICATION = \"waitlist-admin-notification\",\n\n\t// Generic\n\tGENERIC = \"generic\",\n}\n\n","/**\n * Email Rate Limiter\n *\n * Implements per-domain rate limiting for email sending to:\n * - Prevent spam/abuse\n * - Protect domain reputation\n * - Enforce plan-based limits\n * - Track daily/hourly email quotas\n */\n\n\"use server\";\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface RateLimitResult {\n\tallowed: boolean;\n\treason?: string;\n\tremaining?: number;\n\tresetAt?: string;\n}\n\nexport interface ActiveDomainInfo {\n\tdomainId: string;\n\tdomain: string;\n\treplyToEmail: string | null;\n\tdailyLimit: number;\n\thourlyLimit: number;\n\temailsSentToday: number;\n\temailsSentThisHour: number;\n}\n\n// =============================================================================\n// RATE LIMIT CONFIGURATION\n// =============================================================================\n\n// Default rate limits (can be overridden per domain/plan)\nconst DEFAULT_LIMITS = {\n\tdaily: 1000, // 1000 emails per day per domain\n\thourly: 100, // 100 emails per hour per domain\n\tperMinute: 10, // 10 emails per minute per domain\n};\n\n// In-memory cache for rate limit tracking (resets on server restart)\n// For production, use Redis or database counters\nconst rateLimitCache = new Map<\n\tstring,\n\t{\n\t\tcount: number;\n\t\twindowStart: number;\n\t}\n>();\n\n// =============================================================================\n// PUBLIC API\n// =============================================================================\n\n/**\n * Get the active email domain for a company\n *\n * Returns the verified, sending-enabled domain for the company,\n * prioritizing custom domains over platform subdomains.\n */\nexport async function getCompanyActiveDomain(\n\tcompanyId: string\n): Promise<ActiveDomainInfo | null> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Query for the active sending domain\n\tconst { data: domain, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tdomain_name,\n\t\t\treply_to_email,\n\t\t\tdaily_limit,\n\t\t\thourly_limit,\n\t\t\temails_sent_today,\n\t\t\temails_sent_this_hour,\n\t\t\tis_platform_subdomain\n\t\t`\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"verified\")\n\t\t.eq(\"sending_enabled\", true)\n\t\t.eq(\"is_suspended\", false)\n\t\t.order(\"is_platform_subdomain\", { ascending: true }) // Custom domains first\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.maybeSingle();\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching company email domain:\", error);\n\t\treturn null;\n\t}\n\n\tif (!domain) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tdomainId: domain.id,\n\t\tdomain: domain.domain_name,\n\t\treplyToEmail: domain.reply_to_email,\n\t\tdailyLimit: domain.daily_limit || DEFAULT_LIMITS.daily,\n\t\thourlyLimit: domain.hourly_limit || DEFAULT_LIMITS.hourly,\n\t\temailsSentToday: domain.emails_sent_today || 0,\n\t\temailsSentThisHour: domain.emails_sent_this_hour || 0,\n\t};\n}\n\n/**\n * Check if a domain has exceeded its rate limit\n *\n * This is a non-blocking check that doesn't increment counters.\n * Use incrementEmailCounter after successfully sending.\n */\nexport async function checkRateLimit(domainId: string): Promise<RateLimitResult> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Get current domain stats\n\tconst { data: domain, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t`\n\t\t\tdaily_limit,\n\t\t\thourly_limit,\n\t\t\temails_sent_today,\n\t\t\temails_sent_this_hour,\n\t\t\tis_suspended,\n\t\t\tdaily_limit_reset_at,\n\t\t\thourly_limit_reset_at\n\t\t`\n\t\t)\n\t\t.eq(\"id\", domainId)\n\t\t.single();\n\n\tif (error || !domain) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Domain not found or error fetching limits\",\n\t\t};\n\t}\n\n\t// Check if domain is suspended\n\tif (domain.is_suspended) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Domain is suspended due to reputation issues\",\n\t\t};\n\t}\n\n\tconst dailyLimit = domain.daily_limit || DEFAULT_LIMITS.daily;\n\tconst hourlyLimit = domain.hourly_limit || DEFAULT_LIMITS.hourly;\n\tconst emailsSentToday = domain.emails_sent_today || 0;\n\tconst emailsSentThisHour = domain.emails_sent_this_hour || 0;\n\n\t// Check daily limit\n\tif (emailsSentToday >= dailyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: `Daily email limit reached (${dailyLimit} emails/day)`,\n\t\t\tremaining: 0,\n\t\t\tresetAt: domain.daily_limit_reset_at || getNextMidnightUTC(),\n\t\t};\n\t}\n\n\t// Check hourly limit\n\tif (emailsSentThisHour >= hourlyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: `Hourly email limit reached (${hourlyLimit} emails/hour)`,\n\t\t\tremaining: 0,\n\t\t\tresetAt: domain.hourly_limit_reset_at || getNextHourUTC(),\n\t\t};\n\t}\n\n\t// Check per-minute limit (in-memory)\n\tconst minuteKey = `${domainId}:minute`;\n\tconst minuteWindow = getMinuteWindow();\n\tconst minuteCache = rateLimitCache.get(minuteKey);\n\n\tif (minuteCache && minuteCache.windowStart === minuteWindow) {\n\t\tif (minuteCache.count >= DEFAULT_LIMITS.perMinute) {\n\t\t\treturn {\n\t\t\t\tallowed: false,\n\t\t\t\treason: `Rate limit: Too many emails per minute (${DEFAULT_LIMITS.perMinute}/min)`,\n\t\t\t\tremaining: 0,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tallowed: true,\n\t\tremaining: Math.min(dailyLimit - emailsSentToday, hourlyLimit - emailsSentThisHour),\n\t};\n}\n\n/**\n * Increment the email counter after successfully sending\n *\n * This atomically increments the counters and validates limits.\n * Should be called after checkRateLimit and before actually sending.\n */\nexport async function incrementEmailCounter(\n\tdomainId: string\n): Promise<RateLimitResult> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Use a database function for atomic increment and validation\n\t// This prevents race conditions in high-concurrency scenarios\n\tconst { data, error } = await supabase.rpc(\"increment_email_counter\", {\n\t\tp_domain_id: domainId,\n\t});\n\n\tif (error) {\n\t\t// If the RPC doesn't exist, fall back to manual increment\n\t\tif (error.code === \"PGRST202\" || error.message.includes(\"function\")) {\n\t\t\treturn await incrementEmailCounterFallback(domainId);\n\t\t}\n\n\t\tconsole.error(\"Error incrementing email counter:\", error);\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: error.message,\n\t\t};\n\t}\n\n\t// Handle RPC result\n\tif (data && typeof data === \"object\") {\n\t\tconst result = data as { allowed: boolean; reason?: string; remaining?: number };\n\t\treturn {\n\t\t\tallowed: result.allowed,\n\t\t\treason: result.reason,\n\t\t\tremaining: result.remaining,\n\t\t};\n\t}\n\n\t// Default: allowed if no error\n\treturn { allowed: true };\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n/**\n * Fallback increment method when RPC function doesn't exist\n */\nasync function incrementEmailCounterFallback(\n\tdomainId: string\n): Promise<RateLimitResult> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Get current counts\n\tconst { data: domain, error: fetchError } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"emails_sent_today, emails_sent_this_hour, daily_limit, hourly_limit\")\n\t\t.eq(\"id\", domainId)\n\t\t.single();\n\n\tif (fetchError || !domain) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Domain not found\",\n\t\t};\n\t}\n\n\tconst dailyLimit = domain.daily_limit || DEFAULT_LIMITS.daily;\n\tconst hourlyLimit = domain.hourly_limit || DEFAULT_LIMITS.hourly;\n\n\t// Check limits before incrementing\n\tif ((domain.emails_sent_today || 0) >= dailyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Daily limit reached\",\n\t\t};\n\t}\n\n\tif ((domain.emails_sent_this_hour || 0) >= hourlyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Hourly limit reached\",\n\t\t};\n\t}\n\n\t// Increment counters\n\tconst { error: updateError } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.update({\n\t\t\temails_sent_today: (domain.emails_sent_today || 0) + 1,\n\t\t\temails_sent_this_hour: (domain.emails_sent_this_hour || 0) + 1,\n\t\t})\n\t\t.eq(\"id\", domainId);\n\n\tif (updateError) {\n\t\tconsole.error(\"Error updating email counters:\", updateError);\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: updateError.message,\n\t\t};\n\t}\n\n\t// Update in-memory per-minute counter\n\tconst minuteKey = `${domainId}:minute`;\n\tconst minuteWindow = getMinuteWindow();\n\tconst minuteCache = rateLimitCache.get(minuteKey);\n\n\tif (minuteCache && minuteCache.windowStart === minuteWindow) {\n\t\tminuteCache.count++;\n\t} else {\n\t\trateLimitCache.set(minuteKey, {\n\t\t\tcount: 1,\n\t\t\twindowStart: minuteWindow,\n\t\t});\n\t}\n\n\treturn {\n\t\tallowed: true,\n\t\tremaining: Math.min(\n\t\t\tdailyLimit - (domain.emails_sent_today || 0) - 1,\n\t\t\thourlyLimit - (domain.emails_sent_this_hour || 0) - 1\n\t\t),\n\t};\n}\n\n/**\n * Get the current minute window (for per-minute rate limiting)\n */\nfunction getMinuteWindow(): number {\n\treturn Math.floor(Date.now() / 60000);\n}\n\n/**\n * Get the next midnight UTC timestamp\n */\nfunction getNextMidnightUTC(): string {\n\tconst now = new Date();\n\tconst tomorrow = new Date(now);\n\ttomorrow.setUTCDate(tomorrow.getUTCDate() + 1);\n\ttomorrow.setUTCHours(0, 0, 0, 0);\n\treturn tomorrow.toISOString();\n}\n\n/**\n * Get the next hour UTC timestamp\n */\nfunction getNextHourUTC(): string {\n\tconst now = new Date();\n\tconst nextHour = new Date(now);\n\tnextHour.setUTCHours(nextHour.getUTCHours() + 1, 0, 0, 0);\n\treturn nextHour.toISOString();\n}\n\n// =============================================================================\n// RESET FUNCTIONS (for cron jobs)\n// =============================================================================\n\n/**\n * Reset daily email counters (should be called by cron at midnight UTC)\n */\nexport async function resetDailyCounters(): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.update({\n\t\t\temails_sent_today: 0,\n\t\t\tdaily_limit_reset_at: getNextMidnightUTC(),\n\t\t})\n\t\t.neq(\"id\", \"\"); // Update all rows\n\n\tif (error) {\n\t\tconsole.error(\"Error resetting daily counters:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true };\n}\n\n/**\n * Reset hourly email counters (should be called by cron every hour)\n */\nexport async function resetHourlyCounters(): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.update({\n\t\t\temails_sent_this_hour: 0,\n\t\t\thourly_limit_reset_at: getNextHourUTC(),\n\t\t})\n\t\t.neq(\"id\", \"\"); // Update all rows\n\n\tif (error) {\n\t\tconsole.error(\"Error resetting hourly counters:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true };\n}\n","/**\n * Email Provider Abstraction Layer\n *\n * This module provides a unified interface for sending emails through multiple\n * providers (Resend and Postmark) with automatic fallback support.\n *\n * Architecture:\n * ┌─────────────────────────────────────────────────────────────────┐\n * │                    Email Provider Layer                         │\n * ├─────────────────────────────────────────────────────────────────┤\n * │  1. Try Primary Provider (Resend)                               │\n * │     ├─ Success → Return result, log to monitor                  │\n * │     └─ Failure → Try Fallback                                   │\n * │  2. Try Fallback Provider (Postmark)                            │\n * │     ├─ Success → Return result, log to monitor                  │\n * │     └─ Failure → Return error with both provider failures       │\n * └─────────────────────────────────────────────────────────────────┘\n *\n * Features:\n * - Automatic fallback when primary provider fails\n * - Health monitoring for both providers\n * - Unified response format\n * - Comprehensive logging for debugging\n * - Provider-agnostic interface for email operations\n *\n * Usage:\n * ```typescript\n * import { sendEmailWithFallback } from \"@/lib/email/email-provider\";\n *\n * const result = await sendEmailWithFallback({\n *   to: \"user@example.com\",\n *   subject: \"Welcome!\",\n *   html: \"<h1>Hello</h1>\",\n * });\n * ```\n */\n\nimport { emailConfig, isResendConfigured, resend } from \"./resend-client\";\nimport {\n\tpostmarkConfig,\n\tisPostmarkConfigured,\n\tsendPostmarkEmail,\n\tcheckPostmarkHealth,\n\ttype PostmarkResponse,\n} from \"./postmark-client\";\nimport {\n\tsendCompanyGmailEmail,\n\tgetCompanyGmailTokens,\n\tgetCompanyEmailProvider,\n\tcheckCompanyGmailHealth,\n\tisGmailIntegrationEnabled,\n\ttype CompanyEmailProvider,\n\ttype GmailSendResult,\n} from \"./gmail-client\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Supported email providers\n * - resend: Primary managed provider (high deliverability, company branding)\n * - postmark: Fallback managed provider (automatic failover)\n * - gmail: User's personal Gmail account (requires OAuth connection)\n */\nexport type EmailProvider = \"resend\" | \"postmark\" | \"gmail\";\n\n/**\n * Email send options - provider-agnostic interface\n */\n/** Attachment type for email */\nexport interface EmailAttachment {\n\tfilename: string;\n\tcontent: string; // Base64 encoded content\n\tcontentType?: string;\n}\n\nexport interface EmailSendOptions {\n\t/** Recipient email address(es) */\n\tto: string | string[];\n\t/** Email subject line */\n\tsubject: string;\n\t/** HTML body content */\n\thtml: string;\n\t/** Plain text body (optional, auto-generated if not provided) */\n\ttext?: string;\n\t/** From address (uses provider default if not specified) */\n\tfrom?: string;\n\t/** Reply-to address */\n\treplyTo?: string;\n\t/** Tags for categorization and tracking */\n\ttags?: Record<string, string>;\n\t/** Communication ID for internal tracking */\n\tcommunicationId?: string;\n\t/** Company ID - required for checking company email provider preference */\n\tcompanyId?: string;\n\t/** CC recipients */\n\tcc?: string | string[];\n\t/** BCC recipients */\n\tbcc?: string | string[];\n\t/** Email attachments */\n\tattachments?: EmailAttachment[];\n}\n\n/**\n * Result of sending an email through the provider layer\n */\nexport interface EmailProviderResult {\n\t/** Whether the email was sent successfully */\n\tsuccess: boolean;\n\t/** The provider that successfully sent the email */\n\tprovider?: EmailProvider;\n\t/** Message ID from the provider */\n\tmessageId?: string;\n\t/** Error message if failed */\n\terror?: string;\n\t/** Whether fallback was used */\n\tusedFallback?: boolean;\n\t/** Detailed results from each provider attempt */\n\tattempts: Array<{\n\t\tprovider: EmailProvider;\n\t\tsuccess: boolean;\n\t\tmessageId?: string;\n\t\terror?: string;\n\t\tlatencyMs: number;\n\t}>;\n}\n\n/**\n * Provider health status\n */\nexport interface ProviderHealthStatus {\n\tprovider: EmailProvider;\n\thealthy: boolean;\n\tlatencyMs: number;\n\tlastChecked: Date;\n\terror?: string;\n}\n\n/**\n * Combined health status for all providers\n */\nexport interface AllProvidersHealth {\n\tprimary: ProviderHealthStatus | null;\n\tfallback: ProviderHealthStatus | null;\n\trecommendedProvider: EmailProvider | null;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\n/**\n * Provider configuration\n * Determines which provider is primary and which is fallback\n */\nexport const providerConfig = {\n\t/** Primary provider - tried first */\n\tprimary: \"resend\" as EmailProvider,\n\t/** Fallback provider - used if primary fails */\n\tfallback: \"postmark\" as EmailProvider,\n\t/** Enable automatic fallback on failure */\n\tenableFallback: true,\n\t/** Log all provider operations for monitoring */\n\tenableLogging: true,\n\t/** Retry count before falling back (0 = immediate fallback) */\n\tprimaryRetries: 0,\n};\n\n// =============================================================================\n// PROVIDER AVAILABILITY\n// =============================================================================\n\n/**\n * Check if a specific provider is configured and available\n *\n * @param provider - Provider to check\n * @returns Whether the provider is available\n */\nexport function isProviderConfigured(provider: EmailProvider): boolean {\n\tswitch (provider) {\n\t\tcase \"resend\":\n\t\t\treturn isResendConfigured();\n\t\tcase \"postmark\":\n\t\t\treturn isPostmarkConfigured();\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Get list of all configured providers\n *\n * @returns Array of configured provider names\n */\nexport function getConfiguredProviders(): EmailProvider[] {\n\tconst providers: EmailProvider[] = [];\n\n\tif (isResendConfigured()) {\n\t\tproviders.push(\"resend\");\n\t}\n\n\tif (isPostmarkConfigured()) {\n\t\tproviders.push(\"postmark\");\n\t}\n\n\treturn providers;\n}\n\n/**\n * Get the best available provider\n * Returns primary if configured, otherwise fallback\n *\n * @returns Best available provider or null if none configured\n */\nexport function getBestAvailableProvider(): EmailProvider | null {\n\tif (isProviderConfigured(providerConfig.primary)) {\n\t\treturn providerConfig.primary;\n\t}\n\n\tif (providerConfig.enableFallback && isProviderConfigured(providerConfig.fallback)) {\n\t\treturn providerConfig.fallback;\n\t}\n\n\treturn null;\n}\n\n// =============================================================================\n// EMAIL SENDING\n// =============================================================================\n\n/**\n * Send email via Resend\n *\n * @param options - Email options\n * @returns Send result\n */\nasync function sendViaResend(\n\toptions: EmailSendOptions\n): Promise<{ success: boolean; messageId?: string; error?: string }> {\n\tif (!isResendConfigured() || !resend) {\n\t\treturn { success: false, error: \"Resend is not configured\" };\n\t}\n\n\ttry {\n\t\t// Build tags array for Resend\n\t\tconst tags: Array<{ name: string; value: string }> = [];\n\t\tif (options.tags) {\n\t\t\tfor (const [name, value] of Object.entries(options.tags)) {\n\t\t\t\ttags.push({ name, value });\n\t\t\t}\n\t\t}\n\t\tif (options.communicationId) {\n\t\t\ttags.push({ name: \"communication_id\", value: options.communicationId });\n\t\t}\n\n\t\t// Send via Resend\n\t\tconst { data, error } = await resend.emails.send({\n\t\t\tfrom: options.from || emailConfig.from,\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml: options.html,\n\t\t\ttext: options.text,\n\t\t\treplyTo: options.replyTo,\n\t\t\ttags: tags.length > 0 ? tags : undefined,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message || \"Resend send failed\" };\n\t\t}\n\n\t\treturn { success: true, messageId: data?.id };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Resend send failed\",\n\t\t};\n\t}\n}\n\n/**\n * Send email via Postmark\n *\n * @param options - Email options\n * @returns Send result\n */\nasync function sendViaPostmark(\n\toptions: EmailSendOptions\n): Promise<{ success: boolean; messageId?: string; error?: string }> {\n\tif (!isPostmarkConfigured()) {\n\t\treturn { success: false, error: \"Postmark is not configured\" };\n\t}\n\n\ttry {\n\t\t// Convert tags to Postmark metadata format\n\t\tconst metadata: Record<string, string> = { ...options.tags };\n\t\tif (options.communicationId) {\n\t\t\tmetadata.communication_id = options.communicationId;\n\t\t}\n\t\tif (options.companyId) {\n\t\t\tmetadata.company_id = options.companyId;\n\t\t}\n\n\t\t// Determine tag (Postmark only supports one tag per email)\n\t\tconst tag = options.tags?.template || options.tags?.type || \"transactional\";\n\n\t\t// Send via Postmark\n\t\tconst result = await sendPostmarkEmail({\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml: options.html,\n\t\t\ttext: options.text,\n\t\t\tfrom: options.from || postmarkConfig.from,\n\t\t\treplyTo: options.replyTo,\n\t\t\ttag,\n\t\t\tmetadata,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: result.error };\n\t\t}\n\n\t\treturn { success: true, messageId: result.data.MessageID };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Postmark send failed\",\n\t\t};\n\t}\n}\n\n/**\n * Send email via Gmail (company's connected Gmail account)\n *\n * @param companyId - Company ID with connected Gmail\n * @param options - Email options\n * @returns Send result\n */\nasync function sendViaGmail(\n\tcompanyId: string,\n\toptions: EmailSendOptions\n): Promise<{ success: boolean; messageId?: string; error?: string }> {\n\ttry {\n\t\tconst result = await sendCompanyGmailEmail(companyId, {\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml: options.html,\n\t\t\ttext: options.text,\n\t\t\treplyTo: options.replyTo,\n\t\t\tcc: options.cc,\n\t\t\tbcc: options.bcc,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: result.error };\n\t\t}\n\n\t\treturn { success: true, messageId: result.messageId };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Gmail send failed\",\n\t\t};\n\t}\n}\n\n/**\n * Check if Gmail is available for a company\n *\n * @param companyId - Company ID to check\n * @returns Whether Gmail is available and configured\n */\nasync function isCompanyGmailAvailable(companyId: string): Promise<boolean> {\n\ttry {\n\t\t// Check if Gmail integration is enabled globally\n\t\tif (!(await isGmailIntegrationEnabled())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\t\treturn tokens !== null && tokens.isValid;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Send email with automatic fallback\n *\n * This is the main function for sending emails. It:\n * 1. Checks company's email provider preference (managed vs gmail vs disabled)\n * 2. If disabled, returns error immediately\n * 3. If Gmail preferred and available, sends via Gmail\n * 4. Otherwise, tries the primary provider (Resend)\n * 5. If primary fails and fallback is enabled, tries Postmark\n * 6. Returns detailed results including all attempts\n *\n * Provider Selection Logic (Multi-Tenant):\n * - If company preference = \"disabled\" → Return error (company has email disabled)\n * - If company preference = \"gmail\" AND valid Gmail tokens exist → Gmail\n * - If company preference = \"managed\" OR Gmail unavailable → Resend → Postmark\n *\n * @param options - Email send options\n * @returns Result with success status and attempt details\n *\n * @example\n * const result = await sendEmailWithFallback({\n *   to: \"user@example.com\",\n *   subject: \"Welcome!\",\n *   html: \"<h1>Hello</h1>\",\n *   tags: { template: \"welcome\" },\n *   companyId: \"company-123\", // Required for multi-tenant provider selection\n * });\n *\n * if (result.success) {\n *   console.log(`Sent via ${result.provider}, ID: ${result.messageId}`);\n * } else {\n *   console.error(`Failed: ${result.error}`);\n * }\n */\nexport async function sendEmailWithFallback(\n\toptions: EmailSendOptions\n): Promise<EmailProviderResult> {\n\tconst attempts: EmailProviderResult[\"attempts\"] = [];\n\tconst recipient = Array.isArray(options.to) ? options.to.join(\", \") : options.to;\n\n\t// Log the send attempt\n\tif (providerConfig.enableLogging) {\n\t\tconsole.log(`[EmailProvider] Sending email to ${recipient}, subject: \"${options.subject}\"`);\n\t}\n\n\t// ==========================================================================\n\t// COMPANY EMAIL PROVIDER CHECK (Multi-Tenant)\n\t// ==========================================================================\n\t// Each company (tenant) can choose:\n\t// - 'managed': Use our Resend/Postmark providers\n\t// - 'gmail': Use their connected Gmail account\n\t// - 'disabled': Email is disabled for this company\n\tif (options.companyId) {\n\t\tconst companyPreference = await getCompanyEmailProvider(options.companyId);\n\n\t\t// Handle disabled - company has turned off email\n\t\tif (companyPreference === \"disabled\") {\n\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\tconsole.log(`[EmailProvider] Company ${options.companyId} has email disabled`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Email is disabled for this company\",\n\t\t\t\tusedFallback: false,\n\t\t\t\tattempts: [],\n\t\t\t};\n\t\t}\n\n\t\t// Handle Gmail preference\n\t\tif (companyPreference === \"gmail\") {\n\t\t\tconst gmailAvailable = await isCompanyGmailAvailable(options.companyId);\n\n\t\t\tif (gmailAvailable) {\n\t\t\t\tconst startTime = Date.now();\n\n\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\tconsole.log(`[EmailProvider] Company ${options.companyId} prefers Gmail, attempting Gmail send...`);\n\t\t\t\t}\n\n\t\t\t\tconst result = await sendViaGmail(options.companyId, options);\n\t\t\t\tconst latencyMs = Date.now() - startTime;\n\n\t\t\t\tattempts.push({\n\t\t\t\t\tprovider: \"gmail\",\n\t\t\t\t\tsuccess: result.success,\n\t\t\t\t\tmessageId: result.messageId,\n\t\t\t\t\terror: result.error,\n\t\t\t\t\tlatencyMs,\n\t\t\t\t});\n\n\t\t\t\tif (result.success) {\n\t\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[EmailProvider] ✓ Gmail send succeeded in ${latencyMs}ms, messageId: ${result.messageId}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tprovider: \"gmail\",\n\t\t\t\t\t\tmessageId: result.messageId,\n\t\t\t\t\t\tusedFallback: false,\n\t\t\t\t\t\tattempts,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Gmail failed - fall through to managed providers\n\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[EmailProvider] ✗ Gmail send failed in ${latencyMs}ms: ${result.error}`\n\t\t\t\t\t);\n\t\t\t\t\tconsole.log(\"[EmailProvider] Falling back to managed providers...\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\tconsole.log(`[EmailProvider] Company ${options.companyId} prefers Gmail but no valid tokens, using managed providers`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ==========================================================================\n\t// MANAGED PROVIDERS: Primary (Resend) → Fallback (Postmark)\n\t// ==========================================================================\n\n\t// ==========================================================================\n\t// ATTEMPT 1: Primary Provider (Resend)\n\t// ==========================================================================\n\tif (isProviderConfigured(providerConfig.primary)) {\n\t\tconst startTime = Date.now();\n\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.log(`[EmailProvider] Trying primary provider: ${providerConfig.primary}`);\n\t\t}\n\n\t\tconst result =\n\t\t\tproviderConfig.primary === \"resend\"\n\t\t\t\t? await sendViaResend(options)\n\t\t\t\t: await sendViaPostmark(options);\n\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tattempts.push({\n\t\t\tprovider: providerConfig.primary,\n\t\t\tsuccess: result.success,\n\t\t\tmessageId: result.messageId,\n\t\t\terror: result.error,\n\t\t\tlatencyMs,\n\t\t});\n\n\t\t// If primary succeeded, return immediately\n\t\tif (result.success) {\n\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[EmailProvider] ✓ Primary provider succeeded in ${latencyMs}ms, messageId: ${result.messageId}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tprovider: providerConfig.primary,\n\t\t\t\tmessageId: result.messageId,\n\t\t\t\tusedFallback: false,\n\t\t\t\tattempts,\n\t\t\t};\n\t\t}\n\n\t\t// Primary failed\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.warn(\n\t\t\t\t`[EmailProvider] ✗ Primary provider failed in ${latencyMs}ms: ${result.error}`\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.warn(`[EmailProvider] Primary provider (${providerConfig.primary}) not configured`);\n\t\t}\n\t}\n\n\t// ==========================================================================\n\t// ATTEMPT 2: Fallback Provider (Postmark)\n\t// ==========================================================================\n\tif (providerConfig.enableFallback && isProviderConfigured(providerConfig.fallback)) {\n\t\tconst startTime = Date.now();\n\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.log(`[EmailProvider] Trying fallback provider: ${providerConfig.fallback}`);\n\t\t}\n\n\t\tconst result =\n\t\t\tproviderConfig.fallback === \"postmark\"\n\t\t\t\t? await sendViaPostmark(options)\n\t\t\t\t: await sendViaResend(options);\n\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tattempts.push({\n\t\t\tprovider: providerConfig.fallback,\n\t\t\tsuccess: result.success,\n\t\t\tmessageId: result.messageId,\n\t\t\terror: result.error,\n\t\t\tlatencyMs,\n\t\t});\n\n\t\t// If fallback succeeded, return\n\t\tif (result.success) {\n\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[EmailProvider] ✓ Fallback provider succeeded in ${latencyMs}ms, messageId: ${result.messageId}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tprovider: providerConfig.fallback,\n\t\t\t\tmessageId: result.messageId,\n\t\t\t\tusedFallback: true,\n\t\t\t\tattempts,\n\t\t\t};\n\t\t}\n\n\t\t// Fallback also failed\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.error(\n\t\t\t\t`[EmailProvider] ✗ Fallback provider also failed in ${latencyMs}ms: ${result.error}`\n\t\t\t);\n\t\t}\n\t} else if (providerConfig.enableFallback) {\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.warn(\n\t\t\t\t`[EmailProvider] Fallback provider (${providerConfig.fallback}) not configured`\n\t\t\t);\n\t\t}\n\t}\n\n\t// ==========================================================================\n\t// ALL PROVIDERS FAILED\n\t// ==========================================================================\n\tconst errors = attempts.map((a) => `${a.provider}: ${a.error}`).join(\"; \");\n\n\tif (providerConfig.enableLogging) {\n\t\tconsole.error(`[EmailProvider] ✗ All providers failed: ${errors}`);\n\t}\n\n\treturn {\n\t\tsuccess: false,\n\t\terror: `All email providers failed. ${errors}`,\n\t\tusedFallback: attempts.length > 1,\n\t\tattempts,\n\t};\n}\n\n// =============================================================================\n// HEALTH CHECKS\n// =============================================================================\n\n/**\n * Check health of Resend provider\n *\n * @returns Health status\n */\nasync function checkResendHealth(): Promise<ProviderHealthStatus> {\n\tconst startTime = Date.now();\n\n\tif (!isResendConfigured() || !resend) {\n\t\treturn {\n\t\t\tprovider: \"resend\",\n\t\t\thealthy: false,\n\t\t\tlatencyMs: 0,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: \"Resend is not configured\",\n\t\t};\n\t}\n\n\ttry {\n\t\t// Resend doesn't have a dedicated health endpoint\n\t\t// We'll list domains as a health check (lightweight operation)\n\t\tconst response = await fetch(\"https://api.resend.com/domains\", {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${process.env.RESEND_API_KEY}`,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t});\n\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tif (response.ok) {\n\t\t\tconsole.log(`[EmailProvider] Resend health check passed in ${latencyMs}ms`);\n\t\t\treturn {\n\t\t\t\tprovider: \"resend\",\n\t\t\t\thealthy: true,\n\t\t\t\tlatencyMs,\n\t\t\t\tlastChecked: new Date(),\n\t\t\t};\n\t\t}\n\n\t\tconst error = await response.text();\n\t\tconsole.error(`[EmailProvider] Resend health check failed: ${error}`);\n\t\treturn {\n\t\t\tprovider: \"resend\",\n\t\t\thealthy: false,\n\t\t\tlatencyMs,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: `HTTP ${response.status}: ${error}`,\n\t\t};\n\t} catch (error) {\n\t\tconst latencyMs = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\n\t\tconsole.error(`[EmailProvider] Resend health check error: ${errorMessage}`);\n\t\treturn {\n\t\t\tprovider: \"resend\",\n\t\t\thealthy: false,\n\t\t\tlatencyMs,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: errorMessage,\n\t\t};\n\t}\n}\n\n/**\n * Check health of all configured providers\n *\n * @returns Health status for all providers\n */\nexport async function checkAllProvidersHealth(): Promise<AllProvidersHealth> {\n\tconsole.log(\"[EmailProvider] Checking health of all providers...\");\n\n\tconst results: AllProvidersHealth = {\n\t\tprimary: null,\n\t\tfallback: null,\n\t\trecommendedProvider: null,\n\t};\n\n\t// Check primary (Resend)\n\tif (isProviderConfigured(\"resend\")) {\n\t\tresults.primary = await checkResendHealth();\n\t}\n\n\t// Check fallback (Postmark)\n\tif (isProviderConfigured(\"postmark\")) {\n\t\tconst postmarkHealth = await checkPostmarkHealth();\n\t\tresults.fallback = {\n\t\t\tprovider: \"postmark\",\n\t\t\thealthy: postmarkHealth.healthy,\n\t\t\tlatencyMs: postmarkHealth.latencyMs,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: postmarkHealth.error,\n\t\t};\n\t}\n\n\t// Determine recommended provider based on health\n\tif (results.primary?.healthy) {\n\t\tresults.recommendedProvider = \"resend\";\n\t} else if (results.fallback?.healthy) {\n\t\tresults.recommendedProvider = \"postmark\";\n\t}\n\n\tconsole.log(\n\t\t`[EmailProvider] Health check complete. Primary: ${results.primary?.healthy ? \"healthy\" : \"unhealthy\"}, Fallback: ${results.fallback?.healthy ? \"healthy\" : \"unhealthy\"}, Recommended: ${results.recommendedProvider || \"none\"}`\n\t);\n\n\treturn results;\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Get display information about the email provider setup\n *\n * @returns Provider setup summary\n */\nexport function getProviderSetupInfo(): {\n\tprimaryConfigured: boolean;\n\tfallbackConfigured: boolean;\n\tfallbackEnabled: boolean;\n\tconfiguredProviders: EmailProvider[];\n\tstatus: \"fully_configured\" | \"primary_only\" | \"fallback_only\" | \"not_configured\";\n} {\n\tconst primaryConfigured = isProviderConfigured(providerConfig.primary);\n\tconst fallbackConfigured = isProviderConfigured(providerConfig.fallback);\n\tconst configuredProviders = getConfiguredProviders();\n\n\tlet status: \"fully_configured\" | \"primary_only\" | \"fallback_only\" | \"not_configured\";\n\n\tif (primaryConfigured && fallbackConfigured) {\n\t\tstatus = \"fully_configured\";\n\t} else if (primaryConfigured) {\n\t\tstatus = \"primary_only\";\n\t} else if (fallbackConfigured) {\n\t\tstatus = \"fallback_only\";\n\t} else {\n\t\tstatus = \"not_configured\";\n\t}\n\n\treturn {\n\t\tprimaryConfigured,\n\t\tfallbackConfigured,\n\t\tfallbackEnabled: providerConfig.enableFallback,\n\t\tconfiguredProviders,\n\t\tstatus,\n\t};\n}\n\n/**\n * Log a summary of the current provider configuration\n * Useful for debugging and startup diagnostics\n */\nexport function logProviderConfiguration(): void {\n\tconst info = getProviderSetupInfo();\n\n\tconsole.log(\"=\".repeat(60));\n\tconsole.log(\"[EmailProvider] Configuration Summary\");\n\tconsole.log(\"=\".repeat(60));\n\tconsole.log(`Primary Provider: ${providerConfig.primary} (${info.primaryConfigured ? \"✓ configured\" : \"✗ not configured\"})`);\n\tconsole.log(`Fallback Provider: ${providerConfig.fallback} (${info.fallbackConfigured ? \"✓ configured\" : \"✗ not configured\"})`);\n\tconsole.log(`Fallback Enabled: ${info.fallbackEnabled ? \"Yes\" : \"No\"}`);\n\tconsole.log(`Status: ${info.status}`);\n\tconsole.log(`Configured Providers: ${info.configuredProviders.join(\", \") || \"none\"}`);\n\tconsole.log(\"=\".repeat(60));\n}\n","/**\n * Email Sender - Type-safe email sending utilities\n *\n * CRITICAL RULE - Reply-To Addresses:\n * ====================================\n * Reply-to ALWAYS uses the company's platform subdomain (mail.thorbis.com),\n * regardless of which email provider or sending method is used.\n *\n * Examples:\n * - FROM: notifications@acme.mail.thorbis.com → REPLY-TO: support@acme.mail.thorbis.com\n * - FROM: notifications@acme-plumbing.com (custom) → REPLY-TO: support@acme.mail.thorbis.com\n * - FROM: john@gmail.com (personal) → REPLY-TO: support@acme.mail.thorbis.com\n *\n * See: /docs/email/REPLY_TO_ARCHITECTURE.md for full details\n *\n * Features:\n * - Type-safe email sending with validation\n * - Development mode logging\n * - Error handling and logging\n * - Email logging to database\n * - Retry logic for failed sends\n * - Per-company rate limiting\n * - Deliverability monitoring\n */\n\n\"use server\";\n\nimport { render } from \"@react-email/components\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { ReactElement } from \"react\";\nimport { z } from \"zod\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport type { Database } from \"@/types/supabase\";\nimport { recordDeliveryEvent } from \"./deliverability-monitor\";\nimport type {\n\tEmailSendResult,\n\tEmailTemplate as EmailTemplateEnum,\n} from \"./email-types\";\nimport { emailSendSchema } from \"./email-types\";\nimport {\n\taddToSuppressionList,\n\tcheckSuppressionList,\n\trunPreSendChecks,\n} from \"./pre-send-checks\";\nimport {\n\tcheckRateLimit,\n\tgetCompanyActiveDomain,\n\tincrementEmailCounter,\n} from \"./rate-limiter\";\nimport { emailConfig, isResendConfigured, resend } from \"./resend-client\";\n\n// =============================================================================\n// MULTI-PROVIDER SUPPORT (Resend primary, Postmark fallback)\n// =============================================================================\n// Provider abstraction layer - handles automatic fallback when primary fails\nimport {\n\tsendEmailWithFallback,\n\tgetProviderSetupInfo,\n} from \"./email-provider\";\n\n// Provider monitoring - tracks success rates, latency for both providers\nimport {\n\trecordSendSuccess,\n\trecordSendFailure,\n\trecordFallbackTriggered,\n} from \"./provider-monitor\";\n\n// Attachment type for email\ntype EmailAttachment = {\n\tfilename: string;\n\tcontent: string; // Base64 encoded content\n\tcontentType?: string;\n};\n\n// Email send options\ntype SendEmailOptions = {\n\tto: string | string[];\n\tsubject: string;\n\ttemplate: ReactElement;\n\ttemplateType: EmailTemplateEnum;\n\t/** Reply-to address. Optional override.\n\t * If not provided, uses company's configured reply_to_email from company_email_domains table.\n\t * If company hasn't configured one, defaults to support@{company-subdomain}.mail.thorbis.com\n\t * This ensures replies always go to the same branded subdomain as FROM address (never custom domains) */\n\treplyTo?: string;\n\ttags?: { name: string; value: string }[];\n\tcompanyId?: string;\n\tcommunicationId?: string;\n\tfromOverride?: string;\n\t// CC/BCC recipients\n\tcc?: string | string[];\n\tbcc?: string | string[];\n\t// Attachments\n\tattachments?: EmailAttachment[];\n\t// Deliverability options\n\tisMarketingEmail?: boolean;\n\tskipPreSendChecks?: boolean; // For system emails that must go out\n\ttextContent?: string; // Plain text version for spam scoring\n\tunsubscribeUrl?: string;\n\tlistId?: string; // For List-Unsubscribe header\n};\n\n/**\n * Send email with React Email template\n *\n * Features:\n * - Validates email addresses\n * - Renders React Email template to HTML\n * - Sends via Resend\n * - Logs to database\n * - Development mode logging\n * - Rate limiting per company/domain\n * - Deliverability tracking\n */\nexport async function sendEmail({\n\tto,\n\tsubject,\n\ttemplate,\n\ttemplateType,\n\treplyTo,\n\ttags = [],\n\tcompanyId,\n\tcommunicationId,\n\tfromOverride,\n\tcc,\n\tbcc,\n\tattachments,\n\tisMarketingEmail = false,\n\tskipPreSendChecks = false,\n\ttextContent = \"\",\n\tunsubscribeUrl,\n\tlistId,\n}: SendEmailOptions): Promise<EmailSendResult> {\n\tlet activeDomainId: string | null = null;\n\tlet companyReplyTo: string | null = null;\n\tlet activeDomain: Awaited<ReturnType<typeof getCompanyActiveDomain>> = null;\n\n\ttry {\n\n\t\t// In development, log email instead of sending\n\t\tif (emailConfig.isDevelopment) {\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tid: `dev-mode-${Date.now()}`,\n\t\t\t\t\tmessage: \"Email logged in development mode (not actually sent)\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Check if at least one email provider is configured\n\t\t// We support Resend (primary) and Postmark (fallback)\n\t\tconst providerInfo = getProviderSetupInfo();\n\t\tif (providerInfo.status === \"not_configured\") {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Email service not configured. Please add RESEND_API_KEY or POSTMARK_API_KEY to environment variables.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\n\t\t\t`[EmailSender] Providers available: ${providerInfo.configuredProviders.join(\", \")} (status: ${providerInfo.status})`\n\t\t);\n\n\t\tconst supabase = await createClient();\n\n\t\t// Fetch company email domain to get reply-to configuration\n\t\tif (companyId) {\n\t\t\tactiveDomain = await getCompanyActiveDomain(companyId);\n\t\t\tif (!activeDomain) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"No active email domain configured for this company. Please set up email in settings.\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tactiveDomainId = activeDomain.domainId;\n\n\t\t\t// Set reply-to from company's domain configuration\n\t\t\t// If not set, construct default using the company's domain (e.g., support@acme.mail.thorbis.com)\n\t\t\t// This ensures all replies go to the same branded subdomain as the FROM address\n\t\t\tif (activeDomain.replyToEmail) {\n\t\t\t\tcompanyReplyTo = activeDomain.replyToEmail;\n\t\t\t} else {\n\t\t\t\t// Default to support@{company-domain}\n\t\t\t\tcompanyReplyTo = `support@${activeDomain.domain}`;\n\t\t\t}\n\t\t}\n\n\t\t// Determine final reply-to address\n\t\t// Priority: 1) Explicit replyTo parameter, 2) Company's configured reply-to, 3) None\n\t\tconst finalReplyTo = replyTo || companyReplyTo || undefined;\n\n\t\t// Validate email data (now with proper reply-to)\n\t\tconst validatedData = emailSendSchema.parse({\n\t\t\tto,\n\t\t\tsubject,\n\t\t\treplyTo: finalReplyTo,\n\t\t});\n\n\t\t// Normalize recipient list\n\t\tconst recipientEmails = Array.isArray(validatedData.to)\n\t\t\t? validatedData.to\n\t\t\t: [validatedData.to];\n\n\t\t// Check rate limits and run pre-send checks if companyId is provided\n\t\tif (companyId && activeDomainId) {\n\n\t\t\t// Check rate limit before incrementing\n\t\t\tconst rateLimitCheck = await checkRateLimit(activeDomain.domainId);\n\t\t\tif (!rateLimitCheck.allowed) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitCheck.reason || \"Rate limit exceeded\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Run pre-send deliverability checks (unless skipped for system emails)\n\t\t\tif (!skipPreSendChecks) {\n\t\t\t\t// Render template early to get HTML for spam check\n\t\t\t\tconst preCheckHtml = await render(template);\n\t\t\t\tconst plainText = textContent || extractTextFromHtml(preCheckHtml);\n\n\t\t\t\tconst preSendResult = await runPreSendChecks(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tactiveDomain.domainId,\n\t\t\t\t\trecipientEmails,\n\t\t\t\t\tsubject,\n\t\t\t\t\tpreCheckHtml,\n\t\t\t\t\tplainText,\n\t\t\t\t\tisMarketingEmail\n\t\t\t\t);\n\n\t\t\t\t// Block if there are critical errors\n\t\t\t\tif (!preSendResult.allowed) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: `Deliverability check failed: ${preSendResult.errors.join(\"; \")}`,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tspamScore: preSendResult.spamScore,\n\t\t\t\t\t\t\twarnings: preSendResult.warnings,\n\t\t\t\t\t\t\tsuggestions: preSendResult.suggestions,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Filter out suppressed recipients\n\t\t\t\tconst activeRecipients = recipientEmails.filter((email) => {\n\t\t\t\t\tconst status = preSendResult.recipientStatus?.find(\n\t\t\t\t\t\t(r) => r.email.toLowerCase() === email.toLowerCase()\n\t\t\t\t\t);\n\t\t\t\t\treturn !status?.suppressed;\n\t\t\t\t});\n\n\t\t\t\tif (activeRecipients.length === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: \"All recipients are on suppression list - no emails sent\",\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Update validated data with filtered recipients\n\t\t\t\tif (activeRecipients.length < recipientEmails.length) {\n\t\t\t\t\tvalidatedData.to = activeRecipients.length === 1\n\t\t\t\t\t\t? activeRecipients[0]\n\t\t\t\t\t\t: activeRecipients;\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if any (but still send)\n\t\t\t\tif (preSendResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"[Email Deliverability Warnings]\", preSendResult.warnings);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Even for system emails, check suppression list\n\t\t\t\tconst suppressions = await checkSuppressionList(companyId, recipientEmails);\n\t\t\t\tconst activeRecipients = recipientEmails.filter((email) => {\n\t\t\t\t\tconst status = suppressions.get(email.toLowerCase());\n\t\t\t\t\treturn !status?.suppressed;\n\t\t\t\t});\n\n\t\t\t\tif (activeRecipients.length === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: \"All recipients are on suppression list\",\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (activeRecipients.length < recipientEmails.length) {\n\t\t\t\t\tvalidatedData.to = activeRecipients.length === 1\n\t\t\t\t\t\t? activeRecipients[0]\n\t\t\t\t\t\t: activeRecipients;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increment the counter (this also validates limits atomically)\n\t\t\tconst incrementResult = await incrementEmailCounter(activeDomain.domainId);\n\t\t\tif (!incrementResult.allowed) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: incrementResult.reason || \"Rate limit exceeded\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Determine from identity\n\t\tlet fromAddress = fromOverride || emailConfig.from;\n\t\tif (companyId && supabase) {\n\t\t\tconst override = await getCompanyEmailIdentity(supabase, companyId);\n\t\t\tif (override) {\n\t\t\t\tfromAddress = override;\n\t\t\t}\n\t\t}\n\n\t\t// Render template to HTML\n\t\tlet html = await render(template);\n\n\t\t// Add email tracking if communicationId is provided\n\t\tif (communicationId) {\n\t\t\tconst { addEmailTracking } = await import(\"./email-tracking\");\n\t\t\thtml = addEmailTracking(html, communicationId);\n\t\t}\n\n\t\tconst sendTags = [\n\t\t\t...tags,\n\t\t\t{ name: \"template\", value: templateType },\n\t\t\t{ name: \"environment\", value: process.env.NODE_ENV || \"development\" },\n\t\t];\n\n\t\tif (communicationId) {\n\t\t\tsendTags.push({ name: \"communication_id\", value: communicationId });\n\t\t}\n\n\t\t// Add company_id tag for webhook suppression list tracking\n\t\tif (companyId) {\n\t\t\tsendTags.push({ name: \"company_id\", value: companyId });\n\t\t}\n\n\t\t// Build enhanced headers for better deliverability\n\t\tconst emailHeaders: Record<string, string> = {\n\t\t\t// Precedence helps identify transactional vs marketing\n\t\t\t\"X-Priority\": \"3\", // Normal priority (1=High, 3=Normal, 5=Low)\n\t\t\t\"X-Mailer\": \"Stratos Email System\",\n\t\t};\n\n\t\t// Add List-Unsubscribe header for marketing emails (RFC 2369 compliance)\n\t\tif (isMarketingEmail && unsubscribeUrl) {\n\t\t\temailHeaders[\"List-Unsubscribe\"] = `<${unsubscribeUrl}>`;\n\t\t\temailHeaders[\"List-Unsubscribe-Post\"] = \"List-Unsubscribe=One-Click\";\n\t\t}\n\n\t\t// Add List-Id for mailing lists (helps with filtering)\n\t\tif (listId) {\n\t\t\temailHeaders[\"List-Id\"] = listId;\n\t\t}\n\n\t\t// Auto-Submitted header for transactional/automated emails\n\t\tif (!isMarketingEmail) {\n\t\t\temailHeaders[\"Auto-Submitted\"] = \"auto-generated\";\n\t\t\temailHeaders[\"Precedence\"] = \"bulk\"; // Prevents auto-replies\n\t\t}\n\n\t\t// =======================================================================\n\t\t// SEND EMAIL VIA PROVIDER LAYER (Resend → Postmark fallback)\n\t\t// =======================================================================\n\t\t// Convert tags to Record format for provider layer\n\t\tconst tagsRecord: Record<string, string> = {};\n\t\tfor (const tag of sendTags) {\n\t\t\ttagsRecord[tag.name] = tag.value;\n\t\t}\n\n\t\t// Track timing for monitoring\n\t\tconst sendStartTime = Date.now();\n\n\t\t// Send via provider layer (tries Resend first, then Postmark if Resend fails)\n\t\tconst providerResult = await sendEmailWithFallback({\n\t\t\tto: validatedData.to,\n\t\t\tsubject: validatedData.subject,\n\t\t\thtml,\n\t\t\ttext: textContent || extractTextFromHtml(html),\n\t\t\tfrom: fromAddress,\n\t\t\treplyTo: validatedData.replyTo,\n\t\t\ttags: tagsRecord,\n\t\t\tcommunicationId,\n\t\t\tcompanyId,\n\t\t\tcc,\n\t\t\tbcc,\n\t\t\tattachments,\n\t\t});\n\n\t\tconst sendLatencyMs = Date.now() - sendStartTime;\n\n\t\t// =======================================================================\n\t\t// RECORD PROVIDER MONITORING EVENTS\n\t\t// =======================================================================\n\t\t// Track success/failure for each provider attempt (for health dashboard)\n\t\tfor (const attempt of providerResult.attempts) {\n\t\t\tif (attempt.success) {\n\t\t\t\tawait recordSendSuccess(\n\t\t\t\t\tattempt.provider,\n\t\t\t\t\tattempt.messageId || \"\",\n\t\t\t\t\tattempt.latencyMs,\n\t\t\t\t\t{\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t\tdomainId: activeDomainId || undefined,\n\t\t\t\t\t\tmetadata: { template: templateType },\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tawait recordSendFailure(\n\t\t\t\t\tattempt.provider,\n\t\t\t\t\tattempt.error || \"Unknown error\",\n\t\t\t\t\tattempt.latencyMs,\n\t\t\t\t\t{\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t\tdomainId: activeDomainId || undefined,\n\t\t\t\t\t\tmetadata: { template: templateType },\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Record if fallback was triggered\n\t\tif (providerResult.usedFallback && providerResult.success) {\n\t\t\tconst primaryAttempt = providerResult.attempts.find((a) => a.provider === \"resend\");\n\t\t\tawait recordFallbackTriggered(\n\t\t\t\t\"resend\",\n\t\t\t\t\"postmark\",\n\t\t\t\tprimaryAttempt?.error || \"Primary failed\",\n\t\t\t\t{ companyId, metadata: { template: templateType } }\n\t\t\t);\n\t\t\tconsole.log(`[EmailSender] Used Postmark fallback after Resend failed: ${primaryAttempt?.error}`);\n\t\t}\n\n\t\t// =======================================================================\n\t\t// HANDLE RESULT\n\t\t// =======================================================================\n\t\tif (providerResult.success) {\n\t\t\t// SUCCESS: Email sent via one of the providers\n\t\t\tconsole.log(\n\t\t\t\t`[EmailSender] ✓ Email sent via ${providerResult.provider}${providerResult.usedFallback ? \" (fallback)\" : \"\"} in ${sendLatencyMs}ms`\n\t\t\t);\n\n\t\t\t// Log successful email to database\n\t\t\ttry {\n\t\t\t\tif (supabase) {\n\t\t\t\t\tawait supabase.from(\"email_logs\").insert({\n\t\t\t\t\t\tto: Array.isArray(validatedData.to)\n\t\t\t\t\t\t\t? validatedData.to.join(\", \")\n\t\t\t\t\t\t\t: validatedData.to,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\tsubject: validatedData.subject,\n\t\t\t\t\t\thtml_body: html,\n\t\t\t\t\t\tstatus: \"sent\",\n\t\t\t\t\t\tmessage_id: providerResult.messageId,\n\t\t\t\t\t\tcompany_id: companyId || null,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\ttags: sendTags,\n\t\t\t\t\t\t\tprovider: providerResult.provider,\n\t\t\t\t\t\t\tusedFallback: providerResult.usedFallback,\n\t\t\t\t\t\t\tlatencyMs: sendLatencyMs,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsent_at: new Date().toISOString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (_logError) {\n\t\t\t\t// Don't throw - email was sent successfully even if logging failed\n\t\t\t}\n\n\t\t\t// Record delivered event for deliverability tracking\n\t\t\t// Note: This is an optimistic record; actual delivery confirmation comes via webhook\n\t\t\tif (activeDomainId) {\n\t\t\t\ttry {\n\t\t\t\t\tawait recordDeliveryEvent({\n\t\t\t\t\t\tdomainId: activeDomainId,\n\t\t\t\t\t\teventType: \"delivered\",\n\t\t\t\t\t\temailId: providerResult.messageId,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\tprovider: providerResult.provider,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} catch (_deliverabilityError) {\n\t\t\t\t\t// Don't fail the overall operation\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tid: providerResult.messageId,\n\t\t\t\t\tmessage: `Email sent successfully via ${providerResult.provider}${providerResult.usedFallback ? \" (fallback)\" : \"\"}`,\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\t// FAILURE: All providers failed\n\t\t\tconsole.error(`[EmailSender] ✗ All providers failed: ${providerResult.error}`);\n\n\t\t\t// Log failed email to database for retry queue\n\t\t\ttry {\n\t\t\t\tif (supabase) {\n\t\t\t\t\tawait supabase.from(\"email_logs\").insert({\n\t\t\t\t\t\tto: Array.isArray(validatedData.to)\n\t\t\t\t\t\t\t? validatedData.to.join(\", \")\n\t\t\t\t\t\t\t: validatedData.to,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\tsubject: validatedData.subject,\n\t\t\t\t\t\thtml_body: html,\n\t\t\t\t\t\tstatus: \"failed\",\n\t\t\t\t\t\terror_message: providerResult.error || \"All providers failed\",\n\t\t\t\t\t\tcompany_id: companyId || null,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\ttags: sendTags,\n\t\t\t\t\t\t\tattempts: providerResult.attempts,\n\t\t\t\t\t\t\tlatencyMs: sendLatencyMs,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tretry_count: 0,\n\t\t\t\t\t\tmax_retries: 3,\n\t\t\t\t\t\tnext_retry_at: new Date(Date.now() + 5 * 60 * 1000).toISOString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (_logError) {}\n\n\t\t\t// Record bounce event for deliverability tracking\n\t\t\tif (activeDomainId) {\n\t\t\t\ttry {\n\t\t\t\t\tawait recordDeliveryEvent({\n\t\t\t\t\t\tdomainId: activeDomainId,\n\t\t\t\t\t\teventType: \"bounced\",\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\terror: providerResult.error,\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\tattempts: providerResult.attempts.length,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} catch (_deliverabilityError) {\n\t\t\t\t\t// Don't fail the overall operation\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: providerResult.error || \"Failed to send email (all providers failed)\",\n\t\t\t};\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Invalid email data\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to send email\",\n\t\t};\n\t}\n}\n\n/**\n * Send batch emails (up to 100 at once per Resend limits)\n *\n * Features:\n * - Validates batch size\n * - Sends multiple emails\n * - Returns results for each email\n */\nasync function sendBatchEmails(\n\temails: SendEmailOptions[],\n): Promise<EmailSendResult[]> {\n\tif (emails.length > 100) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Cannot send more than 100 emails at once\",\n\t\t\t},\n\t\t];\n\t}\n\n\tconst results = await Promise.all(emails.map((email) => sendEmail(email)));\n\n\treturn results;\n}\n\n/**\n * Test email configuration by sending a test email\n *\n * Features:\n * - Validates Resend configuration\n * - Sends test email to specified address\n * - Returns detailed error information\n */\nasync function testEmailConfiguration(\n\ttestEmailAddress: string,\n): Promise<EmailSendResult> {\n\ttry {\n\t\tconst validatedEmail = emailSendSchema.shape.to.parse(testEmailAddress);\n\n\t\tif (!isResendConfigured()) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Resend API key is not configured\",\n\t\t\t};\n\t\t}\n\n\t\t// Create a simple test template\n\t\tconst testTemplate = {\n\t\t\ttype: \"div\",\n\t\t\tprops: {\n\t\t\t\tchildren: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"h1\",\n\t\t\t\t\t\tprops: { children: \"Email Configuration Test\" },\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"p\",\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tchildren: \"This is a test email from your Thorbis application.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"p\",\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tchildren:\n\t\t\t\t\t\t\t\t\"If you received this, your email configuration is working correctly!\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t} as any;\n\n\t\treturn await sendEmail({\n\t\t\tto: validatedEmail,\n\t\t\tsubject: \"Test Email - Thorbis Email Configuration\",\n\t\t\ttemplate: testTemplate,\n\t\t\ttemplateType: \"welcome\" as EmailTemplateEnum,\n\t\t\ttags: [{ name: \"type\", value: \"test\" }],\n\t\t});\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Invalid email address\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Configuration test failed\",\n\t\t};\n\t}\n}\n\nasync function getCompanyEmailIdentity(\n\tsupabase: SupabaseClient<Database>,\n\tcompanyId: string,\n) {\n\t// Get company name first\n\tconst { data: company } = await supabase\n\t\t.from(\"companies\")\n\t\t.select(\"name\")\n\t\t.eq(\"id\", companyId)\n\t\t.single();\n\n\tconst companyName = company?.name || \"Notification\";\n\n\t// Check company_email_domains table for active sending domain\n\t// Prioritizes custom domains over platform subdomains\n\tconst { data: domain } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"domain_name, is_platform_subdomain\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"verified\")\n\t\t.eq(\"sending_enabled\", true)\n\t\t.eq(\"is_suspended\", false)\n\t\t.order(\"is_platform_subdomain\", { ascending: true }) // Custom domains first\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.maybeSingle();\n\n\tif (domain?.domain_name) {\n\t\t// domain_name contains the full domain (e.g., company.mail.stratos.app or mail.custom.com)\n\t\treturn formatFromAddress(companyName, `notifications@${domain.domain_name}`);\n\t}\n\n\t// Fallback: Check old communication_email_settings (legacy)\n\tconst { data: settings } = await supabase\n\t\t.from(\"communication_email_settings\")\n\t\t.select(\"smtp_from_email, smtp_from_name\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.maybeSingle();\n\n\tif (settings?.smtp_from_email) {\n\t\treturn formatFromAddress(settings.smtp_from_name, settings.smtp_from_email);\n\t}\n\n\treturn null;\n}\n\nfunction formatFromAddress(name: string | null | undefined, email: string) {\n\tif (name?.trim()) {\n\t\treturn `${name} <${email}>`;\n\t}\n\treturn email;\n}\n\n/**\n * Extract plain text from HTML for spam scoring and multipart emails\n */\nfunction extractTextFromHtml(html: string): string {\n\t// Remove script and style tags with their content\n\tlet text = html.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n\ttext = text.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\");\n\n\t// Replace block elements with newlines\n\ttext = text.replace(/<\\/(p|div|h[1-6]|li|br|tr)>/gi, \"\\n\");\n\ttext = text.replace(/<(br|hr)\\s*\\/?>/gi, \"\\n\");\n\n\t// Remove all remaining HTML tags\n\ttext = text.replace(/<[^>]+>/g, \" \");\n\n\t// Decode common HTML entities\n\ttext = text\n\t\t.replace(/&nbsp;/gi, \" \")\n\t\t.replace(/&amp;/gi, \"&\")\n\t\t.replace(/&lt;/gi, \"<\")\n\t\t.replace(/&gt;/gi, \">\")\n\t\t.replace(/&quot;/gi, '\"')\n\t\t.replace(/&#39;/gi, \"'\")\n\t\t.replace(/&mdash;/gi, \"—\")\n\t\t.replace(/&ndash;/gi, \"–\");\n\n\t// Clean up whitespace\n\ttext = text.replace(/\\s+/g, \" \").trim();\n\ttext = text.replace(/\\n\\s*\\n/g, \"\\n\\n\"); // Multiple newlines to double\n\n\treturn text;\n}\n\n/**\n * Handle bounce webhook and add to suppression list\n */\nexport async function handleBounceWebhook(\n\tcompanyId: string,\n\temail: string,\n\tbounceType: \"hard\" | \"soft\",\n\tbounceReason?: string\n): Promise<void> {\n\t// Import here to avoid circular dependency\n\tconst { addToSuppressionList, addToGlobalBounceList } = await import(\"./pre-send-checks\");\n\n\t// Add to company suppression list for hard bounces\n\tif (bounceType === \"hard\") {\n\t\tawait addToSuppressionList(companyId, email, \"bounce\", bounceReason);\n\t}\n\n\t// Add to global bounce list (hard bounces only)\n\tawait addToGlobalBounceList(email, bounceType, bounceReason);\n}\n\n/**\n * Handle complaint webhook (spam report) and add to suppression list\n */\nexport async function handleComplaintWebhook(\n\tcompanyId: string,\n\temail: string\n): Promise<void> {\n\tconst { addToSuppressionList } = await import(\"./pre-send-checks\");\n\n\t// Always suppress on complaint - user marked as spam\n\tawait addToSuppressionList(\n\t\tcompanyId,\n\t\temail,\n\t\t\"complaint\",\n\t\t\"User reported email as spam\"\n\t);\n}\n"],"names":[],"mappings":"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"}