{"version":3,"sources":["../../../../../apps/web/src/lib/ai/memory-service.ts"],"sourcesContent":["/**\n * AI Memory Service - Semantic memory with embeddings (Mem0-style)\n * Based on Mem0 architecture and industry best practices for AI memory systems\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport crypto from \"crypto\";\n\nexport type MemoryType =\n  | \"fact\"\n  | \"preference\"\n  | \"interaction\"\n  | \"context\"\n  | \"entity\"\n  | \"procedure\"\n  | \"feedback\";\n\nexport type MemoryScope = \"user\" | \"company\" | \"global\";\n\nexport interface MemoryEntry {\n  content: string;\n  memoryType: MemoryType;\n  scope: MemoryScope;\n  entityType?: string;\n  entityId?: string;\n  sourceMessageId?: string;\n  sourceChatId?: string;\n  importance?: number;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\nexport interface MemorySearchResult {\n  id: string;\n  content: string;\n  memoryType: string;\n  similarity: number;\n  importance: number;\n  createdAt: string;\n  accessCount: number;\n}\n\n/**\n * Generate embeddings using OpenAI API (or other provider)\n * This is a placeholder - replace with actual embedding generation\n */\nasync function generateEmbedding(text: string): Promise<number[]> {\n  // In production, call OpenAI or another embedding provider\n  // For now, we'll use a simple hash-based approach for testing\n  // This should be replaced with actual embedding generation\n\n  // Check if we have OpenAI API key configured\n  const openaiKey = process.env.OPENAI_API_KEY;\n\n  if (openaiKey) {\n    try {\n      const response = await fetch(\"https://api.openai.com/v1/embeddings\", {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          model: \"text-embedding-3-small\",\n          input: text,\n          dimensions: 1536,\n        }),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.data[0].embedding;\n      }\n    } catch (error) {\n      console.error(\"Failed to generate OpenAI embedding:\", error);\n    }\n  }\n\n  // Fallback: generate a deterministic pseudo-embedding for testing\n  // This allows the system to work without an API key for development\n  const hash = crypto.createHash(\"sha256\").update(text).digest(\"hex\");\n  const embedding: number[] = [];\n\n  for (let i = 0; i < 1536; i++) {\n    // Generate a value between -1 and 1 based on hash\n    const charCode = hash.charCodeAt(i % hash.length);\n    embedding.push((charCode / 128 - 1) * Math.sin(i));\n  }\n\n  // Normalize the vector\n  const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\n  return embedding.map((val) => val / magnitude);\n}\n\n/**\n * Store a new memory with embedding\n */\nexport async function storeMemory(\n  companyId: string,\n  userId: string | undefined,\n  memory: MemoryEntry\n): Promise<string> {\n  const supabase = createServiceSupabaseClient();\n  const memoryId = crypto.randomUUID();\n\n  // Generate embedding for the content\n  const embedding = await generateEmbedding(memory.content);\n\n  // Calculate content hash for deduplication\n  const contentHash = crypto.createHash(\"sha256\").update(memory.content).digest(\"hex\");\n\n  // Check for duplicate content\n  const { data: existing } = await supabase\n    .from(\"ai_memory\")\n    .select(\"id\")\n    .eq(\"company_id\", companyId)\n    .eq(\"content_hash\", contentHash)\n    .maybeSingle();\n\n  if (existing) {\n    // Update access count instead of creating duplicate\n    await supabase\n      .from(\"ai_memory\")\n      .update({\n        access_count: supabase.rpc(\"increment\", { x: 1 }),\n        last_accessed_at: new Date().toISOString(),\n      })\n      .eq(\"id\", existing.id);\n\n    return existing.id;\n  }\n\n  const { error } = await supabase.from(\"ai_memory\").insert({\n    id: memoryId,\n    company_id: companyId,\n    user_id: userId,\n    content: memory.content,\n    content_hash: contentHash,\n    memory_type: memory.memoryType,\n    scope: memory.scope,\n    entity_type: memory.entityType,\n    entity_id: memory.entityId,\n    source_message_id: memory.sourceMessageId,\n    source_chat_id: memory.sourceChatId,\n    embedding,\n    importance: memory.importance || 0.5,\n    access_count: 0,\n    tags: memory.tags || [],\n    metadata: memory.metadata || {},\n    created_at: new Date().toISOString(),\n  });\n\n  if (error) {\n    console.error(\"Failed to store memory:\", error);\n    throw error;\n  }\n\n  return memoryId;\n}\n\n/**\n * Store multiple memories efficiently\n */\nexport async function storeMemories(\n  companyId: string,\n  userId: string | undefined,\n  memories: MemoryEntry[]\n): Promise<string[]> {\n  const memoryIds: string[] = [];\n\n  for (const memory of memories) {\n    try {\n      const id = await storeMemory(companyId, userId, memory);\n      memoryIds.push(id);\n    } catch (error) {\n      console.error(\"Failed to store memory:\", error);\n    }\n  }\n\n  return memoryIds;\n}\n\n/**\n * Search memories by semantic similarity\n */\nexport async function searchMemories(\n  companyId: string,\n  query: string,\n  options?: {\n    userId?: string;\n    scope?: MemoryScope;\n    memoryTypes?: MemoryType[];\n    entityType?: string;\n    entityId?: string;\n    limit?: number;\n    minSimilarity?: number;\n  }\n): Promise<MemorySearchResult[]> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 10;\n  const minSimilarity = options?.minSimilarity || 0.5;\n\n  // Generate embedding for the query\n  const queryEmbedding = await generateEmbedding(query);\n\n  // Use Supabase's vector similarity search\n  // This requires a custom RPC function in Supabase\n  const { data, error } = await supabase.rpc(\"vector_memory_search\", {\n    p_company_id: companyId,\n    p_query_embedding: queryEmbedding,\n    p_user_id: options?.userId || null,\n    p_scope: options?.scope || null,\n    p_memory_types: options?.memoryTypes || null,\n    p_entity_type: options?.entityType || null,\n    p_entity_id: options?.entityId || null,\n    p_limit: limit,\n    p_min_similarity: minSimilarity,\n  });\n\n  if (error) {\n    console.error(\"Failed to search memories:\", error);\n\n    // Fallback to non-vector search if RPC doesn't exist\n    return fallbackSearch(companyId, query, options);\n  }\n\n  // Update access counts for retrieved memories\n  if (data && data.length > 0) {\n    const memoryIds = data.map((m: { id: string }) => m.id);\n    await updateAccessCounts(companyId, memoryIds);\n  }\n\n  return (data || []).map((m: {\n    id: string;\n    content: string;\n    memory_type: string;\n    similarity: number;\n    importance: number;\n    created_at: string;\n    access_count: number;\n  }) => ({\n    id: m.id,\n    content: m.content,\n    memoryType: m.memory_type,\n    similarity: m.similarity,\n    importance: m.importance,\n    createdAt: m.created_at,\n    accessCount: m.access_count,\n  }));\n}\n\n/**\n * Fallback search when vector search RPC is not available\n */\nasync function fallbackSearch(\n  companyId: string,\n  query: string,\n  options?: {\n    userId?: string;\n    scope?: MemoryScope;\n    memoryTypes?: MemoryType[];\n    entityType?: string;\n    entityId?: string;\n    limit?: number;\n  }\n): Promise<MemorySearchResult[]> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 10;\n\n  let dbQuery = supabase\n    .from(\"ai_memory\")\n    .select(\"id, content, memory_type, importance, created_at, access_count\")\n    .eq(\"company_id\", companyId)\n    .is(\"deleted_at\", null)\n    .order(\"importance\", { ascending: false })\n    .limit(limit);\n\n  if (options?.userId) {\n    dbQuery = dbQuery.eq(\"user_id\", options.userId);\n  }\n\n  if (options?.scope) {\n    dbQuery = dbQuery.eq(\"scope\", options.scope);\n  }\n\n  if (options?.memoryTypes && options.memoryTypes.length > 0) {\n    dbQuery = dbQuery.in(\"memory_type\", options.memoryTypes);\n  }\n\n  if (options?.entityType) {\n    dbQuery = dbQuery.eq(\"entity_type\", options.entityType);\n  }\n\n  if (options?.entityId) {\n    dbQuery = dbQuery.eq(\"entity_id\", options.entityId);\n  }\n\n  // Text search fallback\n  dbQuery = dbQuery.ilike(\"content\", `%${query}%`);\n\n  const { data, error } = await dbQuery;\n\n  if (error) {\n    console.error(\"Fallback search failed:\", error);\n    return [];\n  }\n\n  return (data || []).map((m) => ({\n    id: m.id,\n    content: m.content,\n    memoryType: m.memory_type,\n    similarity: 0.5, // No real similarity score in fallback\n    importance: m.importance,\n    createdAt: m.created_at,\n    accessCount: m.access_count,\n  }));\n}\n\n/**\n * Update access counts for retrieved memories\n */\nasync function updateAccessCounts(companyId: string, memoryIds: string[]): Promise<void> {\n  const supabase = createServiceSupabaseClient();\n\n  // Update in batches to avoid long-running transactions\n  for (const id of memoryIds) {\n    await supabase\n      .from(\"ai_memory\")\n      .update({\n        access_count: supabase.sql`access_count + 1`,\n        last_accessed_at: new Date().toISOString(),\n      })\n      .eq(\"id\", id)\n      .eq(\"company_id\", companyId);\n  }\n}\n\n/**\n * Get memories for a specific entity\n */\nexport async function getEntityMemories(\n  companyId: string,\n  entityType: string,\n  entityId: string,\n  options?: { limit?: number; memoryTypes?: MemoryType[] }\n): Promise<\n  Array<{\n    id: string;\n    content: string;\n    memoryType: string;\n    importance: number;\n    createdAt: string;\n  }>\n> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 20;\n\n  let query = supabase\n    .from(\"ai_memory\")\n    .select(\"id, content, memory_type, importance, created_at\")\n    .eq(\"company_id\", companyId)\n    .eq(\"entity_type\", entityType)\n    .eq(\"entity_id\", entityId)\n    .is(\"deleted_at\", null)\n    .order(\"importance\", { ascending: false })\n    .limit(limit);\n\n  if (options?.memoryTypes && options.memoryTypes.length > 0) {\n    query = query.in(\"memory_type\", options.memoryTypes);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error(\"Failed to get entity memories:\", error);\n    return [];\n  }\n\n  return (data || []).map((m) => ({\n    id: m.id,\n    content: m.content,\n    memoryType: m.memory_type,\n    importance: m.importance,\n    createdAt: m.created_at,\n  }));\n}\n\n/**\n * Update memory importance based on usage patterns\n */\nexport async function updateMemoryImportance(\n  companyId: string,\n  memoryId: string,\n  importance: number\n): Promise<void> {\n  const supabase = createServiceSupabaseClient();\n\n  const { error } = await supabase\n    .from(\"ai_memory\")\n    .update({ importance: Math.max(0, Math.min(1, importance)) })\n    .eq(\"id\", memoryId)\n    .eq(\"company_id\", companyId);\n\n  if (error) {\n    console.error(\"Failed to update memory importance:\", error);\n  }\n}\n\n/**\n * Soft delete a memory\n */\nexport async function deleteMemory(companyId: string, memoryId: string): Promise<boolean> {\n  const supabase = createServiceSupabaseClient();\n\n  const { error } = await supabase\n    .from(\"ai_memory\")\n    .update({ deleted_at: new Date().toISOString() })\n    .eq(\"id\", memoryId)\n    .eq(\"company_id\", companyId);\n\n  if (error) {\n    console.error(\"Failed to delete memory:\", error);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Extract and store memories from a conversation\n */\nexport async function extractMemoriesFromConversation(\n  companyId: string,\n  userId: string | undefined,\n  chatId: string,\n  messageId: string,\n  content: string,\n  role: \"user\" | \"assistant\"\n): Promise<string[]> {\n  // This is a simplified extraction - in production, you might use\n  // an LLM to extract structured memories from the conversation\n\n  const memories: MemoryEntry[] = [];\n\n  // Store the interaction itself\n  memories.push({\n    content: content.substring(0, 500), // Limit content length\n    memoryType: \"interaction\",\n    scope: userId ? \"user\" : \"company\",\n    sourceMessageId: messageId,\n    sourceChatId: chatId,\n    importance: 0.5,\n    metadata: { role },\n  });\n\n  // Extract potential facts (very basic - use LLM in production)\n  const factPatterns = [\n    /(?:remember|note|important)[:\\s]+(.+?)(?:\\.|$)/gi,\n    /(?:always|never|usually)[:\\s]+(.+?)(?:\\.|$)/gi,\n  ];\n\n  for (const pattern of factPatterns) {\n    const matches = content.matchAll(pattern);\n    for (const match of matches) {\n      if (match[1] && match[1].length > 10) {\n        memories.push({\n          content: match[1].trim(),\n          memoryType: \"fact\",\n          scope: userId ? \"user\" : \"company\",\n          sourceMessageId: messageId,\n          sourceChatId: chatId,\n          importance: 0.7,\n        });\n      }\n    }\n  }\n\n  return storeMemories(companyId, userId, memories);\n}\n\n/**\n * Get memory statistics for monitoring\n */\nexport async function getMemoryStatistics(\n  companyId: string\n): Promise<{\n  totalMemories: number;\n  byType: Record<string, number>;\n  byScope: Record<string, number>;\n  averageImportance: number;\n  totalAccessCount: number;\n  memoriesLast7Days: number;\n}> {\n  const supabase = createServiceSupabaseClient();\n\n  const { data, error } = await supabase\n    .from(\"ai_memory\")\n    .select(\"memory_type, scope, importance, access_count, created_at\")\n    .eq(\"company_id\", companyId)\n    .is(\"deleted_at\", null);\n\n  if (error || !data) {\n    return {\n      totalMemories: 0,\n      byType: {},\n      byScope: {},\n      averageImportance: 0,\n      totalAccessCount: 0,\n      memoriesLast7Days: 0,\n    };\n  }\n\n  const byType: Record<string, number> = {};\n  const byScope: Record<string, number> = {};\n  let totalImportance = 0;\n  let totalAccessCount = 0;\n  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n  let memoriesLast7Days = 0;\n\n  for (const memory of data) {\n    byType[memory.memory_type] = (byType[memory.memory_type] || 0) + 1;\n    byScope[memory.scope] = (byScope[memory.scope] || 0) + 1;\n    totalImportance += memory.importance;\n    totalAccessCount += memory.access_count;\n\n    if (new Date(memory.created_at as string) > sevenDaysAgo) {\n      memoriesLast7Days++;\n    }\n  }\n\n  return {\n    totalMemories: data.length,\n    byType,\n    byScope,\n    averageImportance: data.length > 0 ? totalImportance / data.length : 0,\n    totalAccessCount,\n    memoriesLast7Days,\n  };\n}\n\n/**\n * Consolidate similar memories to reduce redundancy\n */\nexport async function consolidateMemories(companyId: string): Promise<{\n  consolidated: number;\n  deleted: number;\n}> {\n  // This would use vector similarity to find and merge similar memories\n  // For now, we'll just return zeros - implement with actual consolidation logic\n  console.log(\"Memory consolidation for company:\", companyId);\n\n  return { consolidated: 0, deleted: 0 };\n}\n\n/**\n * Decay old, unused memories to free up space\n */\nexport async function decayOldMemories(\n  companyId: string,\n  options?: {\n    maxAge?: number; // days\n    minAccessCount?: number;\n    dryRun?: boolean;\n  }\n): Promise<{\n  affected: number;\n  deleted: number;\n}> {\n  const supabase = createServiceSupabaseClient();\n  const maxAge = options?.maxAge || 90; // 90 days default\n  const minAccessCount = options?.minAccessCount || 1;\n  const cutoffDate = new Date(Date.now() - maxAge * 24 * 60 * 60 * 1000);\n\n  // Find old, unused memories\n  const { data, error } = await supabase\n    .from(\"ai_memory\")\n    .select(\"id\")\n    .eq(\"company_id\", companyId)\n    .is(\"deleted_at\", null)\n    .lt(\"created_at\", cutoffDate.toISOString())\n    .lte(\"access_count\", minAccessCount);\n\n  if (error || !data) {\n    return { affected: 0, deleted: 0 };\n  }\n\n  if (options?.dryRun) {\n    return { affected: data.length, deleted: 0 };\n  }\n\n  // Soft delete old memories\n  const ids = data.map((m) => m.id);\n  if (ids.length > 0) {\n    await supabase\n      .from(\"ai_memory\")\n      .update({ deleted_at: new Date().toISOString() })\n      .in(\"id\", ids)\n      .eq(\"company_id\", companyId);\n  }\n\n  return { affected: data.length, deleted: data.length };\n}\n"],"names":[],"mappings":"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"}