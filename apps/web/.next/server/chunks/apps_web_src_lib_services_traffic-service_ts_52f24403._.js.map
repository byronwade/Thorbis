{"version":3,"sources":["../../../../../apps/web/src/lib/services/traffic-service.ts"],"sourcesContent":["/**\n * Traffic Service\n *\n * Fetches real-time traffic incidents using Google Maps APIs\n * Includes: crashes, construction, road closures, police activity\n */\n\nimport { z } from \"zod\";\n\n// ============================================================================\n// Types and Schemas\n// ============================================================================\n\nconst TrafficIncidentSchema = z.object({\n\ttype: z.enum([\n\t\t\"crash\",\n\t\t\"construction\",\n\t\t\"road_closed\",\n\t\t\"police\",\n\t\t\"congestion\",\n\t\t\"other\",\n\t]),\n\tseverity: z.enum([\"minor\", \"moderate\", \"major\"]),\n\tdescription: z.string(),\n\tlocation: z.object({\n\t\tlat: z.number(),\n\t\tlon: z.number(),\n\t\taddress: z.string().optional(),\n\t}),\n\tdistance: z.number(), // Distance from job location in miles\n\taffectsRoute: z.boolean(), // Whether this affects the route to the job\n\tstartTime: z.string().optional(), // ISO timestamp\n\tendTime: z.string().optional(), // ISO timestamp (for construction)\n\tenrichedAt: z.string(), // ISO timestamp\n});\n\nconst TrafficDataSchema = z.object({\n\tincidents: z.array(TrafficIncidentSchema),\n\ttotalIncidents: z.number(),\n\tnearbyIncidents: z.number(), // Within 5 miles\n\trouteAffectingIncidents: z.number(),\n\tdataSource: z.string(),\n\tenrichedAt: z.string(),\n});\n\nexport type TrafficIncident = z.infer<typeof TrafficIncidentSchema>;\nexport type TrafficData = z.infer<typeof TrafficDataSchema>;\n\n// ============================================================================\n// Traffic Service\n// ============================================================================\n\nclass TrafficService {\n\t/**\n\t * Get traffic incidents near a location\n\t */\n\tasync getTrafficIncidents(\n\t\tlat: number,\n\t\tlon: number,\n\t\tshopLat?: number,\n\t\tshopLon?: number,\n\t): Promise<TrafficData | null> {\n\t\ttry {\n\t\t\t// For now, we'll use Google Maps Directions API with traffic model\n\t\t\t// to detect incidents along the route\n\t\t\tconst apiKey =\n\t\t\t\tprocess.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY ||\n\t\t\t\tprocess.env.NEXT_PUBLIC_GOOGLE_PLACES_API_KEY;\n\n\t\t\tif (!apiKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst incidents: TrafficIncident[] = [];\n\n\t\t\t// If we have shop coordinates, check for incidents on the route\n\t\t\tif (shopLat && shopLon) {\n\t\t\t\tconst routeIncidents = await this.getRouteIncidents(\n\t\t\t\t\tshopLat,\n\t\t\t\t\tshopLon,\n\t\t\t\t\tlat,\n\t\t\t\t\tlon,\n\t\t\t\t\tapiKey,\n\t\t\t\t);\n\t\t\t\tincidents.push(...routeIncidents);\n\t\t\t}\n\n\t\t\t// Get nearby incidents using Google Maps Places API\n\t\t\tconst nearbyIncidents = await this.getNearbyIncidents(lat, lon, apiKey);\n\t\t\tincidents.push(...nearbyIncidents);\n\n\t\t\tconst nearbyCount = incidents.filter((i) => i.distance <= 5).length;\n\t\t\tconst routeAffectingCount = incidents.filter(\n\t\t\t\t(i) => i.affectsRoute,\n\t\t\t).length;\n\n\t\t\tconst trafficData: TrafficData = {\n\t\t\t\tincidents,\n\t\t\t\ttotalIncidents: incidents.length,\n\t\t\t\tnearbyIncidents: nearbyCount,\n\t\t\t\trouteAffectingIncidents: routeAffectingCount,\n\t\t\t\tdataSource: \"google-maps\",\n\t\t\t\tenrichedAt: new Date().toISOString(),\n\t\t\t};\n\n\t\t\treturn TrafficDataSchema.parse(trafficData);\n\t\t} catch (_error) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get incidents along the route from shop to job\n\t */\n\tprivate async getRouteIncidents(\n\t\toriginLat: number,\n\t\toriginLon: number,\n\t\tdestLat: number,\n\t\tdestLon: number,\n\t\tapiKey: string,\n\t): Promise<TrafficIncident[]> {\n\t\ttry {\n\t\t\tconst url = new URL(\n\t\t\t\t\"https://maps.googleapis.com/maps/api/directions/json\",\n\t\t\t);\n\t\t\turl.searchParams.set(\"origin\", `${originLat},${originLon}`);\n\t\t\turl.searchParams.set(\"destination\", `${destLat},${destLon}`);\n\t\t\turl.searchParams.set(\"departure_time\", \"now\");\n\t\t\turl.searchParams.set(\"traffic_model\", \"best_guess\");\n\t\t\turl.searchParams.set(\"key\", apiKey);\n\n\t\t\tconst response = await fetch(url.toString());\n\t\t\tif (!response.ok) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst data = await response.json();\n\n\t\t\tif (data.status !== \"OK\" || !data.routes?.[0]) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst route = data.routes[0];\n\t\t\tconst incidents: TrafficIncident[] = [];\n\n\t\t\t// Check for warnings (construction, closures, etc.)\n\t\t\tif (route.warnings) {\n\t\t\t\tfor (const warning of route.warnings) {\n\t\t\t\t\tincidents.push({\n\t\t\t\t\t\ttype: this.categorizeWarning(warning),\n\t\t\t\t\t\tseverity: \"moderate\",\n\t\t\t\t\t\tdescription: warning,\n\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\tlat: destLat,\n\t\t\t\t\t\t\tlon: destLon,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdistance: 0, // On route\n\t\t\t\t\t\taffectsRoute: true,\n\t\t\t\t\t\tenrichedAt: new Date().toISOString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Analyze traffic conditions\n\t\t\tconst leg = route.legs[0];\n\t\t\tif (leg.duration_in_traffic && leg.duration) {\n\t\t\t\tconst trafficDelay = leg.duration_in_traffic.value - leg.duration.value;\n\t\t\t\tconst delayMinutes = Math.floor(trafficDelay / 60);\n\n\t\t\t\tif (delayMinutes > 10) {\n\t\t\t\t\tincidents.push({\n\t\t\t\t\t\ttype: \"congestion\",\n\t\t\t\t\t\tseverity: delayMinutes > 30 ? \"major\" : \"moderate\",\n\t\t\t\t\t\tdescription: `Heavy traffic causing ${delayMinutes} minute delay`,\n\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\tlat: destLat,\n\t\t\t\t\t\t\tlon: destLon,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\taffectsRoute: true,\n\t\t\t\t\t\tenrichedAt: new Date().toISOString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn incidents;\n\t\t} catch (_error) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Search for incidents using Google Places API\n\t */\n\tprivate async getNearbyIncidents(\n\t\t_lat: number,\n\t\t_lon: number,\n\t\t_apiKey: string,\n\t): Promise<TrafficIncident[]> {\n\t\t// Note: Google Places API doesn't directly provide traffic incidents\n\t\t// In production, you'd want to use a dedicated traffic API like:\n\t\t// - TomTom Traffic API\n\t\t// - HERE Traffic API\n\t\t// - Waze Traffic API\n\t\t// For now, we'll return empty array\n\t\treturn [];\n\t}\n\n\t/**\n\t * Categorize a warning string into incident type\n\t */\n\tprivate categorizeWarning(warning: string): TrafficIncident[\"type\"] {\n\t\tconst lower = warning.toLowerCase();\n\t\tif (lower.includes(\"construction\") || lower.includes(\"work\")) {\n\t\t\treturn \"construction\";\n\t\t}\n\t\tif (lower.includes(\"closed\") || lower.includes(\"closure\")) {\n\t\t\treturn \"road_closed\";\n\t\t}\n\t\tif (lower.includes(\"accident\") || lower.includes(\"crash\")) {\n\t\t\treturn \"crash\";\n\t\t}\n\t\treturn \"other\";\n\t}\n}\n\nexport const trafficService = new TrafficService();\n"],"names":[],"mappings":"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"}