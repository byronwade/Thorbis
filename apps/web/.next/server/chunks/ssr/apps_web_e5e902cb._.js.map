{"version":3,"sources":["../../../../../../apps/web/src/actions/notifications.ts","../../../../../../apps/web/src/lib/notifications/types.ts","../../../../../../apps/web/src/actions/company-context.ts","../../../../../../apps/web/src/actions/user-status.ts","../../../../../../apps/web/src/lib/email/email-service.ts","../../../../../../apps/web/src/actions/email-actions.ts","../../../../../../apps/web/src/lib/ai/action-approval.ts","../../../../../../node_modules/.pnpm/%40ai-sdk%2Bprovider%402.0.0/node_modules/%40ai-sdk/provider/dist/index.mjs","../../../../../../node_modules/.pnpm/%40ai-sdk%2Bprovider-utils%403.0.17_zod%404.1.12/node_modules/%40ai-sdk/provider-utils/dist/index.mjs","../../../../../../node_modules/.pnpm/eventsource-parser%403.0.6/node_modules/eventsource-parser/src/errors.ts","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/helpers/util.js","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/helpers/errorUtil.js","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/errors.js","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/ZodError.js","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/locales/en.js","../../../../../../node_modules/.pnpm/eventsource-parser%403.0.6/node_modules/eventsource-parser/src/stream.ts","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/helpers/parseUtil.js","../../../../../../node_modules/.pnpm/%40ai-sdk%2Bprovider%402.0.0/node_modules/%40ai-sdk/provider/src/errors/ai-sdk-error.ts","../../../../../../node_modules/.pnpm/zod%404.1.12/node_modules/zod/v3/types.js","../../../../../../node_modules/.pnpm/eventsource-parser%403.0.6/node_modules/eventsource-parser/src/parse.ts","../../../../../../apps/web/src/lib/ai/agent-tools.ts","../../../../../../apps/web/src/actions/ai-approval.ts","../../../../../../apps/web/src/lib/services/google-custom-search-service.ts","../../../../../../apps/web/emails/templates/customer/portal-invitation.tsx","../../../../../../apps/web/src/actions/customers.ts","../../../../../../apps/web/src/actions/support-sessions.ts"],"sourcesContent":["\"use server\";\n\n/**\n * Notifications Server Actions\n *\n * Server-side operations for the notifications system including:\n * - Fetching notifications with filtering and pagination\n * - Creating new notifications\n * - Marking notifications as read/unread\n * - Deleting notifications\n * - Managing notification preferences\n *\n * Performance optimizations:\n * - Server-side data fetching and validation\n * - Efficient database queries with proper indexes\n * - RLS policies for security\n * - Zod validation for all inputs\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\ttype CreateNotificationInput,\n\tCreateNotificationSchema,\n\ttype GetNotificationsInput,\n\tGetNotificationsSchema,\n\ttype NotificationPreference,\n\tNotificationPreferenceSchema,\n} from \"@/lib/notifications/types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// NOTE: Type re-exports removed to comply with Next.js 16 \"use server\" restrictions\n// Import types directly from @/lib/notifications/types instead\n\nconst UpdateNotificationPreferencesSchema = z.array(\n\tNotificationPreferenceSchema,\n);\n\n// =====================================================================================\n// Helper Functions\n// =====================================================================================\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext(): Promise<{\n\tuserId: string;\n\tcompanyId: string;\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>;\n}> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.maybeSingle();\n\n\tif (teamError) {\n\t\tthrow new Error(\"Failed to fetch user company\");\n\t}\n\n\tif (!teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase,\n\t};\n}\n\n// =====================================================================================\n// Notification CRUD Operations\n// =====================================================================================\n\n/**\n * Get notifications for the current user\n *\n * @param options - Filtering and pagination options\n * @returns Array of notifications and total count\n */\nexport async function getNotifications(\n\toptions?: Partial<GetNotificationsInput>,\n) {\n\ttry {\n\t\t// Notifications are user-specific, not company-specific\n\t\t// So we don't need the full auth context with company\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Validate input\n\t\tconst validatedOptions = GetNotificationsSchema.parse(options || {});\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (validatedOptions.unreadOnly) {\n\t\t\tquery = query.eq(\"read\", false);\n\t\t}\n\n\t\tif (validatedOptions.type) {\n\t\t\tquery = query.eq(\"type\", validatedOptions.type);\n\t\t}\n\n\t\tif (validatedOptions.priority) {\n\t\t\tquery = query.eq(\"priority\", validatedOptions.priority);\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(\n\t\t\tvalidatedOptions.offset,\n\t\t\tvalidatedOptions.offset + validatedOptions.limit - 1,\n\t\t);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notifications\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: data || [],\n\t\t\tcount: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t\tdata: [],\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Get unread notification count for the current user\n *\n * @returns Number of unread notifications\n */\nasync function getUnreadCount() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for optimized counting\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"get_unread_notification_count\",\n\t\t\t{\n\t\t\t\tp_user_id: userId,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch unread count\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Create a new notification\n *\n * @param input - Notification data\n * @returns Created notification\n */\nasync function createNotification(input: CreateNotificationInput) {\n\ttry {\n\t\tconst { supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedData = CreateNotificationSchema.parse(input);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.insert({\n\t\t\t\tuser_id: validatedData.userId,\n\t\t\t\tcompany_id: validatedData.companyId,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tmessage: validatedData.message,\n\t\t\t\taction_url: validatedData.actionUrl,\n\t\t\t\taction_label: validatedData.actionLabel,\n\t\t\t\tmetadata: validatedData.metadata || {},\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to create notification\" };\n\t\t}\n\n\t\t// Revalidate paths where notifications appear\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, data };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as read\n *\n * @param notificationId - ID of the notification to mark as read\n * @returns Success status\n */\nexport async function markAsRead(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: true })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as read\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Mark all notifications as read for the current user\n *\n * @returns Number of notifications marked as read\n */\nexport async function markAllAsRead() {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Use the database function for bulk operation\n\t\tconst { data, error } = await supabase.rpc(\"mark_all_notifications_read\", {\n\t\t\tp_user_id: userId,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to mark all notifications as read\",\n\t\t\t\tcount: 0,\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true, count: data || 0 };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tcount: 0,\n\t\t};\n\t}\n}\n\n/**\n * Mark a notification as unread\n *\n * @param notificationId - ID of the notification to mark as unread\n * @returns Success status\n */\nasync function markAsUnread(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.update({ read: false })\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to mark notification as unread\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a notification\n *\n * @param notificationId - ID of the notification to delete\n * @returns Success status\n */\nexport async function deleteNotification(notificationId: string) {\n\ttry {\n\t\tconst { userId, supabase } = await getAuthContext();\n\n\t\t// Validate UUID\n\t\tconst idSchema = z.string().uuid(\"Invalid notification ID\");\n\t\tconst validatedId = idSchema.parse(notificationId);\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notifications\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", validatedId)\n\t\t\t.eq(\"user_id\", userId); // Ensure user owns the notification\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: \"Failed to delete notification\" };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard\");\n\t\trevalidatePath(\"/dashboard/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n\n// =====================================================================================\n// Notification Preferences Operations\n// =====================================================================================\n\n/**\n * Get notification preferences for the current user\n *\n * @returns Array of notification preferences\n */\nasync function getNotificationPreferences() {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch notification preferences\",\n\t\t\t\tdata: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: data || [] };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t\tdata: [],\n\t\t};\n\t}\n}\n\n/**\n * Update notification preferences for the current user\n *\n * @param preferences - Array of notification preference settings\n * @returns Success status\n */\nasync function updateNotificationPreferences(\n\tpreferences: NotificationPreference[],\n) {\n\ttry {\n\t\tconst { userId, companyId, supabase } = await getAuthContext();\n\n\t\t// Validate input\n\t\tconst validatedPreferences =\n\t\t\tUpdateNotificationPreferencesSchema.parse(preferences);\n\n\t\t// Delete existing preferences\n\t\tawait supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.delete()\n\t\t\t.eq(\"user_id\", userId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\t// Insert new preferences\n\t\tconst preferencesToInsert = validatedPreferences.map((pref) => ({\n\t\t\tuser_id: userId,\n\t\t\tcompany_id: companyId,\n\t\t\tchannel: pref.channel,\n\t\t\tevent_type: pref.eventType,\n\t\t\tenabled: pref.enabled,\n\t\t}));\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"notification_preferences\")\n\t\t\t.insert(preferencesToInsert);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update notification preferences\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/profile/notifications\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"An error occurred\",\n\t\t};\n\t}\n}\n","/**\n * Notification Types and Schemas\n *\n * Zod schemas and TypeScript types for the notifications system.\n * Separated from server actions to comply with Next.js \"use server\" restrictions.\n */\n\nimport { z } from \"zod\";\n\n// ============================================================================\n// SCHEMAS\n// ============================================================================\n\nconst NotificationTypeSchema = z.enum([\n\t\"message\",\n\t\"alert\",\n\t\"payment\",\n\t\"job\",\n\t\"team\",\n\t\"system\",\n]);\n\nconst NotificationPrioritySchema = z.enum([\n\t\"low\",\n\t\"medium\",\n\t\"high\",\n\t\"urgent\",\n]);\n\nexport const CreateNotificationSchema = z.object({\n\tuserId: z.string().uuid(\"Invalid user ID\"),\n\tcompanyId: z.string().uuid(\"Invalid company ID\"),\n\ttype: NotificationTypeSchema,\n\tpriority: NotificationPrioritySchema.default(\"medium\"),\n\ttitle: z.string().min(1, \"Title is required\").max(200),\n\tmessage: z.string().min(1, \"Message is required\").max(500),\n\tactionUrl: z.string().url().optional().or(z.literal(\"\")),\n\tactionLabel: z.string().max(50).optional(),\n\tmetadata: z.record(z.string(), z.any()).optional(),\n});\n\nexport const GetNotificationsSchema = z.object({\n\tlimit: z.number().int().min(1).max(100).default(50),\n\toffset: z.number().int().min(0).default(0),\n\tunreadOnly: z.boolean().default(false),\n\ttype: NotificationTypeSchema.optional(),\n\tpriority: NotificationPrioritySchema.optional(),\n});\n\nexport const NotificationPreferenceSchema = z.object({\n\tchannel: z.enum([\"in_app\", \"email\", \"sms\", \"push\"]),\n\teventType: z.string(),\n\tenabled: z.boolean(),\n});\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type NotificationType = z.infer<typeof NotificationTypeSchema>;\nexport type NotificationPriority = z.infer<typeof NotificationPrioritySchema>;\nexport type CreateNotificationInput = z.infer<typeof CreateNotificationSchema>;\nexport type GetNotificationsInput = z.infer<typeof GetNotificationsSchema>;\nexport type NotificationPreference = z.infer<\n\ttypeof NotificationPreferenceSchema\n>;\n","\"use server\";\n\n/**\n * Company Context Server Actions\n *\n * Server Actions for managing active company context.\n * Used by company switcher UI components.\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport {\n\tclearActiveCompany,\n\tgetActiveCompany,\n\tgetUserCompanies,\n\tsetActiveCompany,\n} from \"@/lib/auth/company-context\";\n\n/**\n * Action Result Type\n */\ntype ActionResult<T = void> =\n\t| {\n\t\t\tsuccess: true;\n\t\t\tdata?: T;\n\t\t\tmessage?: string;\n\t  }\n\t| {\n\t\t\tsuccess: false;\n\t\t\terror: string;\n\t  };\n\n/**\n * Switch Company\n *\n * Changes the user's active company context.\n * Revalidates the entire layout to update company-scoped data.\n *\n * @param companyId - Company ID to switch to\n * @returns ActionResult indicating success or failure\n */\nexport async function switchCompany(\n\tcompanyId: string,\n): Promise<ActionResult<void>> {\n\ttry {\n\t\tawait setActiveCompany(companyId);\n\n\t\t// Revalidate everything to ensure all company-scoped data is refreshed\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Company switched successfully\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to switch company\",\n\t\t};\n\t}\n}\n\n/**\n * Clear Active Company\n *\n * Removes the active company context.\n * Useful for logout or company removal flows.\n *\n * @returns ActionResult indicating success or failure\n */\nasync function clearCompany(): Promise<ActionResult<void>> {\n\ttry {\n\t\tawait clearActiveCompany();\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Company context cleared\",\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to clear company context\",\n\t\t};\n\t}\n}\n\n/**\n * Get User's Companies\n *\n * Returns all companies the user has access to.\n * Useful for populating company switcher dropdowns.\n *\n * @returns ActionResult with array of companies\n */\nasync function getCompanies(): Promise<\n\tActionResult<Array<{ id: string; name: string; logo?: string | null }>>\n> {\n\ttry {\n\t\tconst companies = await getUserCompanies();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: companies,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to get companies\",\n\t\t};\n\t}\n}\n\n/**\n * Get Active Company Details\n *\n * Returns details about the currently active company.\n *\n * @returns ActionResult with company details or null\n */\nasync function getActiveCompanyDetails(): Promise<\n\tActionResult<{ id: string; name: string; logo?: string | null } | null>\n> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: company,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get active company\",\n\t\t};\n\t}\n}\n","\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\n/**\n * Update user status action\n * Allows users to change their availability status (online, available, busy)\n */\n\nexport type UserStatus = \"online\" | \"available\" | \"busy\" | \"offline\";\n\nexport async function updateUserStatus(status: UserStatus) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Database connection failed\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unauthorized\",\n\t\t\t};\n\t\t}\n\n\t\t// Update user status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", user.id);\n\n\t\tif (updateError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to update status\",\n\t\t\t};\n\t\t}\n\n\t\t// Revalidate all pages to reflect the new status\n\t\trevalidatePath(\"/\", \"layout\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tstatus,\n\t\t};\n\t} catch (_error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"An unexpected error occurred\",\n\t\t};\n\t}\n}\n","\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\n\nexport type CompanyEmail = {\n\tid: string;\n\tfrom_address: string | null;\n\tfrom_name: string | null;\n\tto_address: string | null;\n\tsubject: string | null;\n\tbody: string | null;\n\tbody_html: string | null;\n\tcreated_at: string;\n\tread_at: string | null;\n\tdirection: \"inbound\" | \"outbound\";\n\tcustomer_id: string | null;\n\tcustomer?: {\n\t\tid: string;\n\t\tfirst_name: string | null;\n\t\tlast_name: string | null;\n\t\tdisplay_name: string | null;\n\t\temail: string | null;\n\t\tphone: string | null;\n\t\tcompany_name: string | null;\n\t} | null;\n\tsent_at: string | null;\n\tdelivered_at: string | null;\n\topened_at: string | null;\n\tclicked_at: string | null;\n\topen_count: number | null;\n\tclick_count: number | null;\n\tstatus: string;\n\ttags?: string[] | null;\n\tcategory?: string | null;\n\tprovider_metadata?: Record<string, unknown> | null;\n};\n\nexport type EmailFolder = \n\t| \"inbox\" \n\t| \"drafts\" \n\t| \"sent\" \n\t| \"archive\" \n\t| \"snoozed\" \n\t| \"spam\" \n\t| \"trash\" \n\t| \"bin\"\n\t| \"starred\"\n\t| string; // For labels\n\ntype GetCompanyEmailsInput = {\n\tlimit?: number;\n\toffset?: number;\n\ttype?: \"sent\" | \"received\" | \"all\";\n\tfolder?: EmailFolder;\n\tlabel?: string; // For label filtering\n\tsearch?: string;\n\tsortBy?: \"created_at\" | \"sent_at\" | \"subject\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\nexport type GetCompanyEmailsResult = {\n\temails: CompanyEmail[];\n\ttotal: number;\n\thasMore: boolean;\n};\n\nexport async function getCompanyEmails(\n\tcompanyId: string,\n\tinput: GetCompanyEmailsInput = {},\n): Promise<GetCompanyEmailsResult> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { emails: [], total: 0, hasMore: false };\n\t}\n\n\tconst {\n\t\tlimit = 50,\n\t\toffset = 0,\n\t\ttype = \"all\",\n\t\tfolder,\n\t\tlabel,\n\t\tsearch,\n\t\tsortBy = \"created_at\",\n\t\tsortOrder = \"desc\",\n\t} = input;\n\n\t// Build the query - get all emails, we'll filter by channel in memory\n\t// Note: Using left join for customer to avoid filtering out emails without customers\n\tlet query = supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tsubject,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\topened_at,\n\t\t\tclicked_at,\n\t\t\topen_count,\n\t\t\tclick_count,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags\n\t\t`,\n\t\t\t{ count: \"exact\" },\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"email\");\n\n\t// Apply folder filtering\n\tif (folder) {\n\t\tswitch (folder) {\n\t\t\tcase \"inbox\":\n\t\t\t\t// Inbox: inbound, not archived, not deleted, not draft, not spam, not snoozed (or snooze expired)\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"inbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.neq(\"status\", \"draft\")\n\t\t\t\t\t.or(\"category.is.null,category.neq.spam\")\n\t\t\t\t\t.or(\"snoozed_until.is.null,snoozed_until.lt.now()\");\n\t\t\t\tbreak;\n\t\t\tcase \"drafts\":\n\t\t\t\t// Drafts: status is draft, not deleted\n\t\t\t\tquery = query.eq(\"status\", \"draft\").is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"sent\":\n\t\t\t\t// Sent: outbound, not archived, not deleted\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"outbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.neq(\"status\", \"draft\");\n\t\t\t\tbreak;\n\t\t\tcase \"archive\":\n\t\t\t\t// Archive: is_archived = true, not deleted\n\t\t\t\tquery = query.eq(\"is_archived\", true).is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"snoozed\":\n\t\t\t\t// Snoozed: snoozed_until is not null and in the future, not deleted\n\t\t\t\tquery = query\n\t\t\t\t\t.not(\"snoozed_until\", \"is\", null)\n\t\t\t\t\t.gt(\"snoozed_until\", new Date().toISOString())\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"spam\":\n\t\t\t\t// Spam: category = 'spam' or tags contains 'spam', not deleted\n\t\t\t\t// Use separate queries and combine in memory, or use OR with proper syntax\n\t\t\t\tquery = query\n\t\t\t\t\t.or(\"category.eq.spam\")\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\t// Note: Tags filtering for spam will be done in memory after fetch\n\t\t\t\tbreak;\n\t\t\tcase \"trash\":\n\t\t\tcase \"bin\":\n\t\t\t\t// Trash/Bin: deleted_at is not null\n\t\t\t\tquery = query.not(\"deleted_at\", \"is\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"starred\":\n\t\t\t\t// Starred: tags contains 'starred', not deleted\n\t\t\t\t// Note: We'll filter by tags in memory after fetch due to JSONB query limitations\n\t\t\t\tquery = query\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Custom folder or label filtering - will be done in memory after fetch\n\t\t\t\t// (JSONB array containment not supported by PostgREST cs operator)\n\t\t\t\tquery = query.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t// Default: exclude deleted emails\n\t\tquery = query.is(\"deleted_at\", null);\n\t}\n\n\t// Filter by direction (if not already filtered by folder)\n\tif (!folder || (folder !== \"inbox\" && folder !== \"sent\" && folder !== \"drafts\")) {\n\t\tif (type === \"sent\") {\n\t\t\tquery = query.eq(\"direction\", \"outbound\");\n\t\t} else if (type === \"received\") {\n\t\t\tquery = query.eq(\"direction\", \"inbound\");\n\t\t}\n\t\t// Note: type === \"all\" doesn't filter by direction\n\t}\n\n\t// Search filter\n\tif (search) {\n\t\tquery = query.or(\n\t\t\t`subject.ilike.%${search}%,body.ilike.%${search}%,from_address.ilike.%${search}%,to_address.ilike.%${search}%`,\n\t\t);\n\t}\n\n\t// Sort\n\tquery = query.order(sortBy, { ascending: sortOrder === \"asc\" });\n\n\t// Pagination\n\tquery = query.range(offset, offset + limit - 1);\n\n\tconst { data, error, count } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"❌ Error fetching emails:\", error);\n\t\tconsole.error(\"   Company ID:\", companyId);\n\t\tconsole.error(\"   Query filters:\", { type: \"email\", direction: type });\n\t\tconsole.error(\"   Full error details:\", JSON.stringify(error, null, 2));\n\t\treturn { emails: [], total: 0, hasMore: false };\n\t}\n\n\t// Normalize customer data and filter out channel field\n\tlet emails: CompanyEmail[] = (data || []).map((email: any) => {\n\t\tconst customer = Array.isArray(email.customer)\n\t\t\t? email.customer[0] ?? null\n\t\t\t: email.customer ?? null;\n\n\t\t// Remove channel from the returned object as it's not part of CompanyEmail type\n\t\tconst { channel, ...emailData } = email;\n\n\t\treturn {\n\t\t\t...emailData,\n\t\t\tcustomer,\n\t\t};\n\t});\n\n\t// Post-process spam filtering\n\tif (folder === \"spam\") {\n\t\t// Show only spam emails\n\t\temails = emails.filter((email: any) => {\n\t\t\tconst tags = (email.tags as string[]) || [];\n\t\t\treturn email.category === \"spam\" || tags.includes(\"spam\");\n\t\t});\n\t\t// Update count for spam after filtering\n\t\tconst spamCount = emails.length;\n\t\treturn {\n\t\t\temails,\n\t\t\ttotal: spamCount,\n\t\t\thasMore: spamCount >= limit,\n\t\t};\n\t} else if (folder !== \"archive\") {\n\t\t// Exclude spam emails from all folders EXCEPT spam and archive\n\t\t// Archive should show ALL archived emails regardless of spam status\n\t\temails = emails.filter((email: any) => {\n\t\t\tconst tags = (email.tags as string[]) || [];\n\t\t\tconst isSpam = email.category === \"spam\" || tags.includes(\"spam\");\n\t\t\treturn !isSpam; // Exclude spam from non-spam, non-archive folders\n\t\t});\n\t}\n\n\t// Post-process starred filtering (if folder is starred)\n\tif (folder === \"starred\") {\n\t\temails = emails.filter((email: any) => {\n\t\t\tconst tags = (email.tags as string[]) || [];\n\t\t\treturn tags.includes(\"starred\");\n\t\t});\n\t\t// Update count for starred after filtering\n\t\tconst starredCount = emails.length;\n\t\treturn {\n\t\t\temails,\n\t\t\ttotal: starredCount,\n\t\t\thasMore: starredCount >= limit,\n\t\t};\n\t}\n\n\t// Post-process custom folder/label filtering (JSONB array containment not supported by PostgREST)\n\tconst standardFolders = [\"inbox\", \"spam\", \"starred\", \"sent\", \"drafts\", \"archive\", \"snoozed\", \"trash\", \"bin\"];\n\tconst folderName = label || folder;\n\tif (folderName && !standardFolders.includes(folderName)) {\n\t\temails = emails.filter((email: any) => {\n\t\t\tconst tags = (email.tags as string[]) || [];\n\t\t\treturn tags.includes(folderName);\n\t\t});\n\t\tconst customCount = emails.length;\n\t\treturn {\n\t\t\temails,\n\t\t\ttotal: customCount,\n\t\t\thasMore: customCount >= limit,\n\t\t};\n\t}\n\n\treturn {\n\t\temails,\n\t\ttotal: count || 0,\n\t\thasMore: (count || 0) > offset + limit,\n\t};\n}\n\nexport async function getEmailThreads(\n\tcompanyId: string,\n\tinput: {\n\t\tlimit?: number;\n\t\toffset?: number;\n\t\tsearch?: string;\n\t} = {},\n): Promise<{ threads: CompanyEmail[]; total: number; hasMore: boolean }> {\n\t// For now, return emails grouped by thread\n\t// This is a simplified implementation\n\tconst result = await getCompanyEmails(companyId, {\n\t\t...input,\n\t\ttype: \"all\",\n\t\tsortBy: \"created_at\",\n\t\tsortOrder: \"desc\",\n\t});\n\n\treturn {\n\t\tthreads: result.emails,\n\t\ttotal: result.total,\n\t\thasMore: result.hasMore,\n\t};\n}\n\nexport async function getEmailById(\n\tcompanyId: string,\n\temailId: string,\n): Promise<CompanyEmail | null> {\n\tconst supabase = await createClient();\n\n\tif (!supabase || !companyId) {\n\t\treturn null;\n\t}\n\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tsubject,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus\n\t\t`,\n\t\t)\n\t\t.eq(\"id\", emailId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"channel\", \"resend\")\n\t\t.eq(\"type\", \"email\")\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\tconst customer = Array.isArray(data.customer)\n\t\t? data.customer[0] ?? null\n\t\t: data.customer ?? null;\n\n\treturn {\n\t\t...data,\n\t\tcustomer,\n\t};\n}\n\nexport async function markEmailAsRead(\n\tcompanyId: string,\n\temailId: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase || !companyId) {\n\t\tconsole.error(\"❌ markEmailAsRead: Missing supabase or companyId\");\n\t\treturn false;\n\t}\n\n\t// First, check if the email exists and get its current state\n\tconst { data: existingEmail, error: checkError } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"id, company_id, type, read_at\")\n\t\t.eq(\"id\", emailId)\n\t\t.single();\n\n\tif (checkError) {\n\t\tconsole.error(\"❌ markEmailAsRead: Email not found:\", { emailId, error: checkError });\n\t\treturn false;\n\t}\n\n\tif (!existingEmail) {\n\t\tconsole.error(\"❌ markEmailAsRead: Email not found:\", emailId);\n\t\treturn false;\n\t}\n\n\t// Verify company_id matches\n\tif (existingEmail.company_id !== companyId) {\n\t\tconsole.error(\"❌ markEmailAsRead: Company ID mismatch:\", { \n\t\t\temailId, \n\t\t\temailCompanyId: existingEmail.company_id, \n\t\t\trequestedCompanyId: companyId \n\t\t});\n\t\treturn false;\n\t}\n\n\t// Verify type is email\n\tif (existingEmail.type !== \"email\") {\n\t\tconsole.error(\"❌ markEmailAsRead: Type mismatch:\", { \n\t\t\temailId, \n\t\t\ttype: existingEmail.type \n\t\t});\n\t\treturn false;\n\t}\n\n\t// If already read, return success\n\tif (existingEmail.read_at) {\n\t\treturn true;\n\t}\n\n\tconst readAt = new Date().toISOString();\n\t\n\t// Try update without .single() first to see if it affects any rows\n\tconst { data: updateData, error: updateError, count } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"id\", emailId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"email\")\n\t\t.select(\"id, read_at\");\n\n\tif (updateError) {\n\t\tconsole.error(\"❌ markEmailAsRead update error:\", { \n\t\t\temailId, \n\t\t\tcompanyId,\n\t\t\terror: updateError, \n\t\t\terrorCode: updateError.code, \n\t\t\terrorMessage: updateError.message,\n\t\t\terrorDetails: updateError.details,\n\t\t\terrorHint: updateError.hint\n\t\t});\n\t\treturn false;\n\t}\n\n\tif (!updateData || updateData.length === 0) {\n\t\tconsole.error(\"❌ markEmailAsRead: No rows updated\", { \n\t\t\temailId, \n\t\t\tcompanyId,\n\t\t\tcount,\n\t\t\texistingEmail: existingEmail \n\t\t});\n\t\t// This could mean RLS policy blocked it or the filters didn't match\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport async function getEmailStats(): Promise<{\n\ttotalEmails: number;\n\tsentEmails: number;\n\treceivedEmails: number;\n\tunreadEmails: number;\n\tthreadsCount: number;\n}> {\n\tconst supabase = await createClient();\n\tconst companyId = await getActiveCompanyId();\n\n\tif (!supabase || !companyId) {\n\t\treturn {\n\t\t\ttotalEmails: 0,\n\t\t\tsentEmails: 0,\n\t\t\treceivedEmails: 0,\n\t\t\tunreadEmails: 0,\n\t\t\tthreadsCount: 0,\n\t\t};\n\t}\n\n\t// Get total emails\n\tconst { count: totalCount } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"*\", { count: \"exact\", head: true })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"channel\", \"resend\")\n\t\t.eq(\"type\", \"email\")\n\t\t.is(\"deleted_at\", null);\n\n\t// Get sent emails\n\tconst { count: sentCount } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"*\", { count: \"exact\", head: true })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"channel\", \"resend\")\n\t\t.eq(\"type\", \"email\")\n\t\t.eq(\"direction\", \"outbound\")\n\t\t.is(\"deleted_at\", null);\n\n\t// Get received emails\n\tconst { count: receivedCount } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"*\", { count: \"exact\", head: true })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"channel\", \"resend\")\n\t\t.eq(\"type\", \"email\")\n\t\t.eq(\"direction\", \"inbound\")\n\t\t.is(\"deleted_at\", null);\n\n\t// Get unread emails\n\tconst { count: unreadCount } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\"*\", { count: \"exact\", head: true })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"channel\", \"resend\")\n\t\t.eq(\"type\", \"email\")\n\t\t.eq(\"direction\", \"inbound\")\n\t\t.is(\"read_at\", null)\n\t\t.is(\"deleted_at\", null);\n\n\t// For threads, we'll use a simple count of unique subjects\n\t// This is a simplified implementation\n\tconst threadsCount = totalCount || 0;\n\n\treturn {\n\t\ttotalEmails: totalCount || 0,\n\t\tsentEmails: sentCount || 0,\n\t\treceivedEmails: receivedCount || 0,\n\t\tunreadEmails: unreadCount || 0,\n\t\tthreadsCount,\n\t};\n}\n\nexport type ArchiveAllEmailsResult = {\n\tsuccess: boolean;\n\tcount: number;\n\terror?: string;\n};\n\nexport async function archiveAllEmails(\n\tcompanyId: string,\n\tfolder?: EmailFolder,\n): Promise<ArchiveAllEmailsResult> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { success: false, count: 0, error: \"Database connection failed\" };\n\t}\n\n\tif (!companyId) {\n\t\treturn { success: false, count: 0, error: \"Missing company ID\" };\n\t}\n\n\tconst buildArchiveQuery = () =>\n\t\tsupabase\n\t\t\t.from(\"communications\")\n\t\t\t.update({ is_archived: true })\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"type\", \"email\");\n\n\ttype ArchiveQuery = ReturnType<typeof buildArchiveQuery>;\n\n\tconst runArchive = async (queryBuilder: ArchiveQuery) => {\n\t\tconst { data, error, count } = await queryBuilder.select(\"id\", { count: \"exact\" });\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn data?.length ?? count ?? 0;\n\t};\n\n\tconst folderName = folder?.trim();\n\tconst normalizedFolder = folderName?.toLowerCase();\n\n\ttry {\n\t\tswitch (normalizedFolder || \"inbox\") {\n\t\t\tcase \"inbox\": {\n\t\t\t\t// Inbox: inbound, not archived, not draft, not spam, not snoozed (or snooze expired)\n\t\t\t\tconst archived = await runArchive(\n\t\t\t\t\tbuildArchiveQuery()\n\t\t\t\t\t\t.eq(\"direction\", \"inbound\")\n\t\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t\t.neq(\"status\", \"draft\")\n\t\t\t\t\t\t.or(\"category.is.null,category.neq.spam\")\n\t\t\t\t\t\t.or(`snoozed_until.is.null,snoozed_until.lt.${new Date().toISOString()}`)\n\t\t\t\t\t\t.is(\"deleted_at\", null),\n\t\t\t\t);\n\t\t\t\treturn { success: true, count: archived };\n\t\t\t}\n\t\t\tcase \"drafts\": {\n\t\t\t\tconst archived = await runArchive(\n\t\t\t\t\tbuildArchiveQuery().eq(\"status\", \"draft\").is(\"deleted_at\", null),\n\t\t\t\t);\n\t\t\t\treturn { success: true, count: archived };\n\t\t\t}\n\t\t\tcase \"sent\": {\n\t\t\t\tconst archived = await runArchive(\n\t\t\t\t\tbuildArchiveQuery()\n\t\t\t\t\t\t.eq(\"direction\", \"outbound\")\n\t\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t\t.neq(\"status\", \"draft\"),\n\t\t\t\t);\n\t\t\t\treturn { success: true, count: archived };\n\t\t\t}\n\t\t\tcase \"archive\": {\n\t\t\t\tconst archived = await runArchive(\n\t\t\t\t\tbuildArchiveQuery().eq(\"is_archived\", true).is(\"deleted_at\", null),\n\t\t\t\t);\n\t\t\t\treturn { success: true, count: archived };\n\t\t\t}\n\t\t\tcase \"snoozed\": {\n\t\t\t\tconst archived = await runArchive(\n\t\t\t\t\tbuildArchiveQuery()\n\t\t\t\t\t\t.not(\"snoozed_until\", \"is\", null)\n\t\t\t\t\t\t.gt(\"snoozed_until\", new Date().toISOString())\n\t\t\t\t\t\t.is(\"deleted_at\", null),\n\t\t\t\t);\n\t\t\t\treturn { success: true, count: archived };\n\t\t\t}\n\t\t\tcase \"spam\": {\n\t\t\t\tconst categorized = await runArchive(\n\t\t\t\t\tbuildArchiveQuery().eq(\"category\", \"spam\").is(\"deleted_at\", null),\n\t\t\t\t);\n\t\t\t\t// For spam tagged emails, fetch IDs first then update (JSONB filtering not supported)\n\t\t\t\tconst { data: spamTaggedEmails } = await supabase\n\t\t\t\t\t.from(\"communications\")\n\t\t\t\t\t.select(\"id, tags\")\n\t\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t\t.eq(\"type\", \"email\")\n\t\t\t\t\t.neq(\"category\", \"spam\")\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tconst spamTaggedIds = (spamTaggedEmails ?? [])\n\t\t\t\t\t.filter(e => Array.isArray(e.tags) && (e.tags as string[]).includes(\"spam\"))\n\t\t\t\t\t.map(e => e.id);\n\t\t\t\tlet taggedCount = 0;\n\t\t\t\tif (spamTaggedIds.length > 0) {\n\t\t\t\t\tconst { data } = await supabase\n\t\t\t\t\t\t.from(\"communications\")\n\t\t\t\t\t\t.update({ is_archived: true })\n\t\t\t\t\t\t.in(\"id\", spamTaggedIds)\n\t\t\t\t\t\t.select(\"id\");\n\t\t\t\t\ttaggedCount = data?.length ?? 0;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tcount: categorized + taggedCount,\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"trash\":\n\t\t\tcase \"bin\": {\n\t\t\t\tconst archived = await runArchive(buildArchiveQuery().not(\"deleted_at\", \"is\", null));\n\t\t\t\treturn { success: true, count: archived };\n\t\t\t}\n\t\t\tcase \"starred\": {\n\t\t\t\t// Fetch starred email IDs first then update (JSONB filtering not supported)\n\t\t\t\tconst { data: starredEmails } = await supabase\n\t\t\t\t\t.from(\"communications\")\n\t\t\t\t\t.select(\"id, tags\")\n\t\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t\t.eq(\"type\", \"email\")\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tconst starredIds = (starredEmails ?? [])\n\t\t\t\t\t.filter(e => Array.isArray(e.tags) && (e.tags as string[]).includes(\"starred\"))\n\t\t\t\t\t.map(e => e.id);\n\t\t\t\tlet starredCount = 0;\n\t\t\t\tif (starredIds.length > 0) {\n\t\t\t\t\tconst { data } = await supabase\n\t\t\t\t\t\t.from(\"communications\")\n\t\t\t\t\t\t.update({ is_archived: true })\n\t\t\t\t\t\t.in(\"id\", starredIds)\n\t\t\t\t\t\t.select(\"id\");\n\t\t\t\t\tstarredCount = data?.length ?? 0;\n\t\t\t\t}\n\t\t\t\treturn { success: true, count: starredCount };\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t// Custom folder - fetch IDs first then update (JSONB filtering not supported)\n\t\t\t\tconst { data: customEmails } = await supabase\n\t\t\t\t\t.from(\"communications\")\n\t\t\t\t\t.select(\"id, tags\")\n\t\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t\t.eq(\"type\", \"email\")\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tconst customIds = (customEmails ?? [])\n\t\t\t\t\t.filter(e => Array.isArray(e.tags) && folderName && (e.tags as string[]).includes(folderName))\n\t\t\t\t\t.map(e => e.id);\n\t\t\t\tlet customCount = 0;\n\t\t\t\tif (customIds.length > 0) {\n\t\t\t\t\tconst { data } = await supabase\n\t\t\t\t\t\t.from(\"communications\")\n\t\t\t\t\t\t.update({ is_archived: true })\n\t\t\t\t\t\t.in(\"id\", customIds)\n\t\t\t\t\t\t.select(\"id\");\n\t\t\t\t\tcustomCount = data?.length ?? 0;\n\t\t\t\t}\n\t\t\t\treturn { success: true, count: customCount };\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(\"❌ archiveAllEmails error:\", { companyId, folder, error });\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tcount: 0,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n","\"use server\";\n\nimport {\n    archiveAllEmails,\n    getCompanyEmails,\n    getEmailById,\n    getEmailStats,\n    getEmailThreads,\n    markEmailAsRead,\n    type CompanyEmail,\n} from \"@/lib/email/email-service\";\nimport { z } from \"zod\";\n\nconst getEmailsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  inboxType: z.enum([\"personal\", \"company\"]).optional(),\n  folder: z.enum([\"inbox\", \"drafts\", \"sent\", \"archive\", \"snoozed\", \"spam\", \"trash\", \"bin\", \"starred\", \"all\"]).optional(),\n  category: z.enum([\"support\", \"sales\", \"billing\", \"general\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\", \"subject\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst getEmailThreadsSchema = z.object({\n  limit: z.number().min(1).max(50).optional().default(20),\n  offset: z.number().min(0).optional().default(0),\n  search: z.string().optional(),\n});\n\nconst markEmailReadSchema = z.object({\n  emailId: z.string().min(1),\n});\n\nexport type GetEmailsInput = z.infer<typeof getEmailsSchema>;\nexport type GetEmailThreadsInput = z.infer<typeof getEmailThreadsSchema>;\nexport type MarkEmailReadInput = z.infer<typeof markEmailReadSchema>;\n\n// Re-export email types from email-service\nexport type { CompanyEmail };\n\nexport type GetEmailsResult = Awaited<ReturnType<typeof getCompanyEmails>>;\nexport type GetEmailThreadsResult = Awaited<ReturnType<typeof getEmailThreads>>;\nexport type GetEmailStatsResult = Awaited<ReturnType<typeof getEmailStats>>;\n\n/**\n * Get emails for the active company\n */\nexport async function getEmailsAction(\n  input: GetEmailsInput\n): Promise<GetEmailsResult> {\n  try {\n    const parseResult = getEmailsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      console.error(\"❌ Zod validation error:\", parseResult.error.issues);\n      throw new Error(`Invalid input parameters: ${parseResult.error.issues.map((e) => `${e.path.map(String).join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    // Convert null to undefined for search field\n    const sanitizedInput = {\n      ...validatedInput,\n      search: validatedInput.search ?? undefined,\n    };\n    return await getCompanyEmails(companyId, sanitizedInput);\n  } catch (error) {\n    console.error(\"❌ getEmailsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get email threads for the active company\n */\nasync function getEmailThreadsAction(\n  input: GetEmailThreadsInput\n): Promise<GetEmailThreadsResult> {\n  try {\n    const validatedInput = getEmailThreadsSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailThreads(companyId, validatedInput);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Get a specific email by ID\n */\nexport async function getEmailByIdAction(emailId: string): Promise<{\n  success: boolean;\n  email?: CompanyEmail;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const email = await getEmailById(companyId, emailId);\n    \n    if (!email) {\n      return { success: false, error: \"Email not found\" };\n    }\n\n    return { success: true, email };\n  } catch (error) {\n    console.error(\"Error getting email by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an email as read\n */\nexport async function markEmailAsReadAction(\n  input: MarkEmailReadInput\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const validatedInput = markEmailReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const result = await markEmailAsRead(companyId, validatedInput.emailId);\n    if (!result) {\n      return { success: false, error: \"Failed to mark email as read - check server logs for details\" };\n    }\n    return { success: true };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, error: `Invalid input: ${error.issues.map((e: { message: string }) => e.message).join(\", \")}` };\n    }\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    console.error(\"Error marking email as read:\", error);\n    return { success: false, error: errorMessage };\n  }\n}\n\n/**\n * Get email statistics for the active company\n */\nasync function getEmailStatsAction(): Promise<GetEmailStatsResult> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getEmailStats();\n  } catch (error) {\n    console.error(\"Error getting email stats:\", error);\n    return {\n      totalEmails: 0,\n      sentEmails: 0,\n      receivedEmails: 0,\n      unreadEmails: 0,\n      threadsCount: 0,\n    };\n  }\n}\n\n/**\n * Get total unread email count for the active company\n * Used for displaying notification badges in the header\n */\nexport async function getTotalUnreadCountAction(): Promise<{\n  success: boolean;\n  count?: number;\n  error?: string\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const stats = await getEmailStats();\n    return { success: true, count: stats.unreadEmails };\n  } catch (error) {\n    console.error(\"Error getting unread count:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Fetch email content from Resend API or update with provided content\n */\nexport async function fetchEmailContentAction(\n  emailId: string,\n  _resendEmailId?: string,\n  providedContent?: { html?: string | null; text?: string | null }\n): Promise<{\n  success: boolean;\n  html?: string | null;\n  text?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    let html: string | null = null;\n    let text: string | null = null;\n\n    // If content is provided directly, use it\n    if (providedContent) {\n      html = providedContent.html || null;\n      text = providedContent.text || null;\n    } else {\n      // First, try to get email from database to check for content in metadata\n      const { data: email, error: emailError } = await supabase\n        .from(\"communications\")\n        .select(\"provider_message_id, provider_metadata, body, body_html\")\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId)\n        .single();\n\n      if (emailError) {\n        // Don't return error for PGRST errors that might be expected\n        if (emailError.code === 'PGRST116') {\n          return { success: false, error: \"Email not found in database\" };\n        }\n        return { success: false, error: `Database error: ${emailError.message}` };\n      }\n\n      if (!email) {\n        return { success: false, error: \"Email not found in database\" };\n      }\n\n      // Check if email already has content stored\n      if (email.body_html || email.body) {\n        html = email.body_html || null;\n        text = email.body || null;\n      } else if (email.provider_metadata) {\n        // Try to extract content from provider_metadata\n        const metadata = email.provider_metadata as Record<string, unknown>;\n        \n        // PRIORITY 1: Check webhook_content first (webhook payload - most reliable source)\n        const webhookContent = metadata.webhook_content as Record<string, unknown> | undefined;\n        if (webhookContent) {\n          const htmlValue = webhookContent.html || webhookContent.body_html;\n          const textValue = webhookContent.text || webhookContent.body;\n          \n          if (htmlValue && typeof htmlValue === \"string\") {\n            const content = htmlValue.trim();\n            if (content.length > 0) {\n              html = content;\n            }\n          }\n          if (!html && textValue && typeof textValue === \"string\") {\n            const content = textValue.trim();\n            if (content.length > 0) {\n              text = content;\n            }\n          }\n        }\n\n        // PRIORITY 2: Check full_content (API response) if webhook didn't have content\n        if (!html && !text) {\n          const fullContent = metadata.full_content as Record<string, unknown> | undefined;\n          if (fullContent) {\n            const htmlFields = [\"html\", \"body_html\", \"bodyHtml\"];\n            const textFields = [\"text\", \"body\", \"plain_text\", \"plainText\"];\n\n            // Try HTML fields first\n            for (const field of htmlFields) {\n              if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                const content = (fullContent[field] as string).trim();\n                if (content.length > 0) {\n                  html = content;\n                  break;\n                }\n              }\n            }\n\n            // If no HTML, try text fields\n            if (!html) {\n              for (const field of textFields) {\n                if (fullContent[field] && typeof fullContent[field] === \"string\") {\n                  const content = (fullContent[field] as string).trim();\n                  if (content.length > 0) {\n                    text = content;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // PRIORITY 3: Check top-level metadata.data for content (webhook payload structure)\n        if (!html && !text) {\n          const webhookData = metadata.data as Record<string, unknown> | undefined;\n          if (webhookData) {\n            const htmlValue = webhookData.html || webhookData.body_html;\n            const textValue = webhookData.text || webhookData.body;\n            \n            if (htmlValue && typeof htmlValue === \"string\") {\n              const content = htmlValue.trim();\n              if (content.length > 0) {\n                html = content;\n              }\n            }\n            if (!html && textValue && typeof textValue === \"string\") {\n              const content = textValue.trim();\n              if (content.length > 0) {\n                text = content;\n              }\n            }\n          }\n        }\n\n        // PRIORITY 4: Check top-level metadata fields directly\n        if (!html && !text) {\n          const htmlFields = [\"html\", \"body_html\"];\n          const textFields = [\"text\", \"body\"];\n          \n          for (const field of htmlFields) {\n            if (metadata[field] && typeof metadata[field] === \"string\") {\n              const content = (metadata[field] as string).trim();\n              if (content.length > 0) {\n                html = content;\n                break;\n              }\n            }\n          }\n          \n          if (!html) {\n            for (const field of textFields) {\n              if (metadata[field] && typeof metadata[field] === \"string\") {\n                const content = (metadata[field] as string).trim();\n                if (content.length > 0) {\n                  text = content;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        // If we found content in metadata, use it and return early\n        if (html || text) {\n          // Update database with extracted content\n          if ((html || text) && supabase) {\n            const { error: updateError } = await supabase\n              .from(\"communications\")\n              .update({\n                body: text || \"\",\n                body_html: html,\n              })\n              .eq(\"id\", emailId)\n              .eq(\"company_id\", companyId);\n\n            if (updateError) {\n              console.warn(\"⚠️  Failed to update email content in database:\", updateError.message);\n            }\n          }\n          return { success: true, html, text };\n        } else {\n          // No content found in metadata\n          return {\n            success: false,\n            error: \"No email content available in metadata\"\n          };\n        }\n      } else {\n        // No metadata at all, can't fetch content\n        return { success: false, error: \"No email metadata available\" };\n      }\n    }\n\n    // Update the database with the content\n    // Try to update, but don't fail if the email doesn't exist - we still return the content\n    if (supabase) {\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update({\n          body: text || \"\",\n          body_html: html,\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      if (updateError) {\n        console.warn(\"⚠️  Failed to update email content in database (this is OK, content still returned):\", updateError.message);\n      }\n    }\n\n    return { success: true, html, text };\n  } catch (error) {\n    console.error(\"Error fetching email content:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Sync inbound email routes from database to Resend\n * Creates routes in Resend that don't have a resend_route_id\n */\nexport async function syncInboundRoutesToResendAction(): Promise<{\n  success: boolean;\n  synced: number;\n  errors: string[];\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { createInboundRoute } = await import(\"@/lib/email/resend-domains\");\n    const { createServiceSupabaseClient } = await import(\"@/lib/supabase/service-client\");\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, synced: 0, errors: [\"Database connection failed\"] };\n    }\n\n    const serviceSupabase = await createServiceSupabaseClient();\n    if (!serviceSupabase) {\n      return { success: false, synced: 0, errors: [\"Service database connection failed\"] };\n    }\n\n    // Get all routes that don't have a resend_route_id\n    // Note: This table may not be in the type definitions, so we use type assertion\n    const { data: routes, error } = await (serviceSupabase\n      .from(\"communication_email_inbound_routes\" as any)\n      .select(\"id, company_id, route_address, name, enabled\")\n      .is(\"resend_route_id\", null)\n      .eq(\"enabled\", true) as any);\n\n    if (error) {\n      console.error(\"Failed to fetch routes:\", error);\n      return { success: false, synced: 0, errors: [error.message] };\n    }\n\n    if (!routes || routes.length === 0) {\n      return { success: true, synced: 0, errors: [] };\n    }\n\n    // Construct webhook URL\n    let webhookUrl = process.env.NEXT_PUBLIC_SITE_URL;\n    if (!webhookUrl && process.env.VERCEL_URL) {\n      webhookUrl = `https://${process.env.VERCEL_URL}`;\n    }\n    if (!webhookUrl) {\n      return { success: false, synced: 0, errors: [\"Webhook URL not configured. Set NEXT_PUBLIC_SITE_URL or VERCEL_URL\"] };\n    }\n    webhookUrl = `${webhookUrl}/api/webhooks/resend`;\n\n    const errors: string[] = [];\n    let synced = 0;\n\n    for (const route of (routes || []) as Array<{ id: string; company_id: string; route_address: string; name: string | null; enabled: boolean }>) {\n      try {\n        // Handle catch-all routes (e.g., @biezru.resend.app)\n        // Resend doesn't support true catch-all, so we'll create a route for the domain\n        // For now, we'll skip catch-all routes and handle them differently\n        if (route.route_address.startsWith(\"@\")) {\n          errors.push(`Catch-all routes (${route.route_address}) need to be configured manually in Resend dashboard`);\n          continue;\n        }\n\n        // Create route in Resend\n        const result = await createInboundRoute({\n          name: route.name || `Route for ${route.route_address}`,\n          recipients: [route.route_address],\n          url: webhookUrl,\n        });\n\n        if (!result.success) {\n          console.error(`❌ Failed to create Resend route for ${route.route_address}:`, result.error);\n          errors.push(`${route.route_address}: ${result.error}`);\n          continue;\n        }\n\n        // Update database with resend_route_id\n        const { error: updateError } = await (serviceSupabase\n          .from(\"communication_email_inbound_routes\" as any)\n          .update({\n            resend_route_id: result.data.id,\n            signing_secret: result.data.secret || null,\n            last_synced_at: new Date().toISOString(),\n          })\n          .eq(\"id\", route.id) as any);\n\n        if (updateError) {\n          console.error(`❌ Failed to update route ${route.route_address}:`, updateError);\n          errors.push(`${route.route_address}: Database update failed`);\n          continue;\n        }\n\n        synced++;\n      } catch (error) {\n        console.error(`❌ Error syncing route ${route.route_address}:`, error);\n        errors.push(`${route.route_address}: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      synced,\n      errors,\n    };\n  } catch (error) {\n    console.error(\"Error syncing inbound routes:\", error);\n    return {\n      success: false,\n      synced: 0,\n      errors: [error instanceof Error ? error.message : \"Unknown error\"],\n    };\n  }\n}\n\n/**\n * Archive an email\n */\nexport async function archiveEmailAction(emailId: string): Promise<{ success: boolean; error?: string }> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const { error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n    \n    if (error) {\n      return { success: false, error: error.message };\n    }\n    \n    return { success: true };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk archive multiple emails by their IDs\n */\nexport async function bulkArchiveEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  archived: number;\n  error?: string\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, archived: 0, error: \"No email IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, archived: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ is_archived: true })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, archived: 0, error: error.message };\n    }\n\n    const archivedCount = data?.length ?? 0;\n    return { success: true, archived: archivedCount };\n  } catch (error) {\n    return { success: false, archived: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Archive all emails in a folder\n */\nexport async function archiveAllEmailsAction(folder?: string): Promise<{ \n  success: boolean; \n  archived: number;\n  error?: string \n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, archived: 0, error: \"No active company found\" };\n    }\n    \n    const result = await archiveAllEmails(companyId, folder);\n    \n    if (!result.success) {\n      return { success: false, archived: 0, error: result.error };\n    }\n    \n    return { success: true, archived: result.count };\n  } catch (error) {\n    return {\n      success: false,\n      archived: 0,\n      error: error instanceof Error ? error.message : \"Unknown error\"\n    };\n  }\n}\n\n/**\n * Get email folder counts for the active company\n * Returns count of emails in each folder (inbox, sent, drafts, etc.)\n */\nexport async function getEmailFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    all: number;\n    inbox: number;\n    drafts: number;\n    sent: number;\n    archive: number;\n    snoozed: number;\n    spam: number;\n    trash: number;\n    starred: number;\n    [key: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get counts for each folder type using parallel queries\n    // All counts show UNREAD emails only (read_at IS NULL)\n    const [\n      allResult,\n      inboxResult,\n      draftsResult,\n      sentResult,\n      archiveResult,\n      snoozedResult,\n      spamResult,\n      trashResult,\n      starredResult\n    ] = await Promise.all([\n      // All Mail: all non-deleted, unread emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Inbox: inbound, not archived, not deleted, not draft, not spam, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\")\n        .or(\"category.is.null,category.neq.spam\")\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n\n      // Drafts - always count all drafts (read_at not relevant for drafts)\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"status\", \"draft\")\n        .is(\"deleted_at\", null),\n\n      // Sent: outbound, not archived, not deleted, unread\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null)\n        .neq(\"status\", \"draft\"),\n\n      // Archive - unread archived emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .eq(\"is_archived\", true)\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Snoozed - unread snoozed emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"snoozed_until\", \"is\", null)\n        .gt(\"snoozed_until\", new Date().toISOString())\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Spam - fetch category, tags, and read_at to count unread spam\n      supabase\n        .from(\"communications\")\n        .select(\"category, tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n\n      // Trash - unread deleted emails\n      supabase\n        .from(\"communications\")\n        .select(\"*\", { count: \"exact\", head: true })\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .not(\"deleted_at\", \"is\", null)\n        .is(\"read_at\", null),\n\n      // Starred - fetch tags and read_at, count unread starred in memory\n      supabase\n        .from(\"communications\")\n        .select(\"tags, read_at\")\n        .eq(\"company_id\", companyId)\n        .eq(\"type\", \"email\")\n        .is(\"deleted_at\", null)\n        .is(\"read_at\", null),\n    ]);\n\n    // Count spam emails in memory (category=spam OR spam tag)\n    const spamCount = (spamResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      const hasSpamTag = Array.isArray(tags) && tags.includes(\"spam\");\n      return email.category === \"spam\" || hasSpamTag;\n    }).length;\n\n    // Count starred emails in memory\n    const starredCount = (starredResult.data ?? []).filter(email => {\n      const tags = email.tags as string[] | null;\n      return Array.isArray(tags) && tags.includes(\"starred\");\n    }).length;\n\n    return {\n      success: true,\n      counts: {\n        all: allResult.count ?? 0,\n        inbox: inboxResult.count ?? 0,\n        drafts: draftsResult.count ?? 0,\n        sent: sentResult.count ?? 0,\n        archive: archiveResult.count ?? 0,\n        snoozed: snoozedResult.count ?? 0,\n        spam: spamCount,\n        trash: trashResult.count ?? 0,\n        starred: starredCount,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting email folder counts:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Toggle star status on an email\n * Adds or removes \"starred\" tag from the email's tags array\n */\nexport async function toggleStarEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isStarred?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlyStarred = currentTags.includes(\"starred\");\n\n    // Toggle the starred tag\n    const newTags = isCurrentlyStarred\n      ? currentTags.filter(tag => tag !== \"starred\")\n      : [...currentTags, \"starred\"];\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ tags: newTags.length > 0 ? newTags : null })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isStarred: !isCurrentlyStarred };\n  } catch (error) {\n    console.error(\"Error toggling star on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Toggle spam status on an email\n * Adds or removes \"spam\" tag and updates category field\n */\nexport async function toggleSpamEmailAction(emailId: string): Promise<{\n  success: boolean;\n  isSpam?: boolean;\n  error?: string\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // First, get current tags and category\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"tags, category\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    const currentTags = (email?.tags as string[]) || [];\n    const isCurrentlySpam = currentTags.includes(\"spam\") || email?.category === \"spam\";\n\n    // Toggle the spam tag and category\n    const newTags = isCurrentlySpam\n      ? currentTags.filter(tag => tag !== \"spam\")\n      : [...currentTags, \"spam\"];\n\n    const newCategory = isCurrentlySpam ? null : \"spam\";\n\n    // Update the email\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        tags: newTags.length > 0 ? newTags : null,\n        category: newCategory\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, isSpam: !isCurrentlySpam };\n  } catch (error) {\n    console.error(\"Error toggling spam on email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Snooze an email until a specific time\n * The email will reappear in inbox after the snooze time\n */\nexport async function snoozeEmailAction(\n  emailId: string,\n  snoozeUntil: string | null\n): Promise<{\n  success: boolean;\n  snoozedUntil?: string | null;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Update the snoozed_until field\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({ snoozed_until: snoozeUntil })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\");\n\n    if (updateError) {\n      return { success: false, error: updateError.message };\n    }\n\n    return { success: true, snoozedUntil: snoozeUntil };\n  } catch (error) {\n    console.error(\"Error snoozing email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Unsnooze an email (remove snooze time)\n */\nexport async function unsnoozeEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  return snoozeEmailAction(emailId, null);\n}\n\n/**\n * Bulk mark emails as read or unread\n */\nexport async function bulkMarkReadUnreadAction(\n  emailIds: string[],\n  markAsRead: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ read_at: markAsRead ? new Date().toISOString() : null })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, updated: 0, error: error.message };\n    }\n\n    // Dispatch event to refresh counts\n    return { success: true, updated: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk marking emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk toggle star on emails\n */\nexport async function bulkStarEmailsAction(\n  emailIds: string[],\n  addStar: boolean\n): Promise<{\n  success: boolean;\n  updated: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, updated: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, updated: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, updated: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Group emails by what changes need to be made\n    const toUpdate: Array<{ id: string; newTags: string[] | null }> = [];\n\n    for (const email of emails) {\n      const currentTags = (email.tags as string[]) || [];\n      const hasStarred = currentTags.includes(\"starred\");\n\n      let newTags: string[];\n      if (addStar && !hasStarred) {\n        newTags = [...currentTags, \"starred\"];\n      } else if (!addStar && hasStarred) {\n        newTags = currentTags.filter((t) => t !== \"starred\");\n      } else {\n        continue; // No change needed\n      }\n\n      toUpdate.push({ id: email.id, newTags: newTags.length > 0 ? newTags : null });\n    }\n\n    if (toUpdate.length === 0) {\n      return { success: true, updated: 0 };\n    }\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      toUpdate.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const updatedCount = results.filter((r) => !r.error).length;\n    return { success: true, updated: updatedCount };\n  } catch (error) {\n    console.error(\"Error bulk starring emails:\", error);\n    return { success: false, updated: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk delete emails (move to trash)\n */\nexport async function bulkDeleteEmailsAction(emailIds: string[]): Promise<{\n  success: boolean;\n  deleted: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, deleted: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, deleted: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, deleted: 0, error: \"Database connection failed\" };\n    }\n\n    // Soft delete by setting deleted_at\n    const { data, error } = await supabase\n      .from(\"communications\")\n      .update({ deleted_at: new Date().toISOString() })\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .select(\"id\");\n\n    if (error) {\n      return { success: false, deleted: 0, error: error.message };\n    }\n\n    return { success: true, deleted: data?.length ?? 0 };\n  } catch (error) {\n    console.error(\"Error bulk deleting emails:\", error);\n    return { success: false, deleted: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Bulk move emails to spam\n */\nexport async function bulkMoveToSpamAction(emailIds: string[]): Promise<{\n  success: boolean;\n  moved: number;\n  error?: string;\n}> {\n  \"use server\";\n\n  if (!emailIds || emailIds.length === 0) {\n    return { success: false, moved: 0, error: \"No IDs provided\" };\n  }\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, moved: 0, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, moved: 0, error: \"Database connection failed\" };\n    }\n\n    // OPTIMIZED: Batch fetch all emails in ONE query (was N queries)\n    const { data: emails } = await supabase\n      .from(\"communications\")\n      .select(\"id, tags\")\n      .in(\"id\", emailIds)\n      .eq(\"company_id\", companyId);\n\n    if (!emails || emails.length === 0) {\n      return { success: true, moved: 0 };\n    }\n\n    // Prepare updates with new tags\n    const updates = emails.map((email) => {\n      const currentTags = (email.tags as string[]) || [];\n      const newTags = currentTags.includes(\"spam\")\n        ? currentTags\n        : [...currentTags, \"spam\"];\n      return { id: email.id, newTags };\n    });\n\n    // Batch update using Promise.all (parallel updates)\n    const results = await Promise.all(\n      updates.map(({ id, newTags }) =>\n        supabase\n          .from(\"communications\")\n          .update({ category: \"spam\", tags: newTags })\n          .eq(\"id\", id)\n          .eq(\"company_id\", companyId)\n      )\n    );\n\n    const movedCount = results.filter((r) => !r.error).length;\n    return { success: true, moved: movedCount };\n  } catch (error) {\n    console.error(\"Error moving emails to spam:\", error);\n    return { success: false, moved: 0, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// DRAFT ACTIONS\n// ============================================================================\n\nconst saveDraftSchema = z.object({\n  id: z.string().uuid().optional(), // If provided, update existing draft\n  to: z.array(z.string().email()).optional().default([]),\n  cc: z.array(z.string().email()).optional().default([]),\n  bcc: z.array(z.string().email()).optional().default([]),\n  subject: z.string().optional().default(\"\"),\n  body: z.string().optional().default(\"\"),\n  bodyHtml: z.string().optional(),\n  customerId: z.string().uuid().optional(),\n  attachments: z.array(z.object({\n    filename: z.string(),\n    content: z.string(),\n    contentType: z.string().optional(),\n  })).optional(),\n});\n\nexport type SaveDraftInput = z.infer<typeof saveDraftSchema>;\n\n/**\n * Save or update an email draft\n * If id is provided, updates existing draft; otherwise creates a new one\n */\nexport async function saveDraftAction(input: SaveDraftInput): Promise<{\n  success: boolean;\n  draftId?: string;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const parseResult = saveDraftSchema.safeParse(input);\n    if (!parseResult.success) {\n      return { success: false, error: `Invalid input: ${parseResult.error.message}` };\n    }\n\n    const { id, to, cc, bcc, subject, body, bodyHtml, customerId, attachments } = parseResult.data;\n\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the company's default email address for from_address\n    const { data: companySettings } = await supabase\n      .from(\"company_communication_settings\")\n      .select(\"email_from_address, email_from_name\")\n      .eq(\"company_id\", companyId)\n      .single();\n\n    const fromAddress = companySettings?.email_from_address || \"noreply@example.com\";\n    const fromName = companySettings?.email_from_name || \"Draft\";\n\n    const draftData = {\n      company_id: companyId,\n      customer_id: customerId || null,\n      type: \"email\" as const,\n      direction: \"outbound\" as const,\n      from_address: fromAddress,\n      from_name: fromName,\n      to_address: to.length > 0 ? to.join(\", \") : \"draft@placeholder.local\",\n      cc_address: cc.length > 0 ? cc.join(\", \") : null,\n      bcc_address: bcc.length > 0 ? bcc.join(\", \") : null,\n      subject: subject || \"(No subject)\",\n      body: body || \"\",\n      body_html: bodyHtml || null,\n      attachments: attachments && attachments.length > 0 ? attachments : null,\n      attachment_count: attachments?.length || 0,\n      status: \"draft\" as const,\n      is_automated: false,\n      is_internal: false,\n      is_archived: false,\n      is_thread_starter: true,\n      priority: \"normal\" as const,\n      updated_at: new Date().toISOString(),\n    };\n\n    if (id) {\n      // Update existing draft\n      const { error: updateError } = await supabase\n        .from(\"communications\")\n        .update(draftData)\n        .eq(\"id\", id)\n        .eq(\"company_id\", companyId)\n        .eq(\"status\", \"draft\");\n\n      if (updateError) {\n        console.error(\"Error updating draft:\", updateError);\n        return { success: false, error: updateError.message };\n      }\n\n      return { success: true, draftId: id };\n    } else {\n      // Create new draft\n      const { data: newDraft, error: insertError } = await supabase\n        .from(\"communications\")\n        .insert({\n          ...draftData,\n          created_at: new Date().toISOString(),\n        })\n        .select(\"id\")\n        .single();\n\n      if (insertError) {\n        console.error(\"Error creating draft:\", insertError);\n        return { success: false, error: insertError.message };\n      }\n\n      return { success: true, draftId: newDraft.id };\n    }\n  } catch (error) {\n    console.error(\"Error saving draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Get a draft by ID\n */\nexport async function getDraftAction(draftId: string): Promise<{\n  success: boolean;\n  draft?: {\n    id: string;\n    to: string[];\n    cc: string[];\n    bcc: string[];\n    subject: string;\n    body: string;\n    bodyHtml?: string | null;\n    customerId?: string | null;\n    attachments?: Array<{ filename: string; content: string; contentType?: string }> | null;\n    updatedAt: string;\n  };\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const { data: draft, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"id, to_address, cc_address, bcc_address, subject, body, body_html, customer_id, attachments, updated_at\")\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!draft) {\n      return { success: false, error: \"Draft not found\" };\n    }\n\n    // Parse addresses from comma-separated strings to arrays\n    const parseAddresses = (addr: string | null): string[] => {\n      if (!addr || addr === \"draft@placeholder.local\") return [];\n      return addr.split(\",\").map(a => a.trim()).filter(Boolean);\n    };\n\n    return {\n      success: true,\n      draft: {\n        id: draft.id,\n        to: parseAddresses(draft.to_address),\n        cc: parseAddresses(draft.cc_address),\n        bcc: parseAddresses(draft.bcc_address),\n        subject: draft.subject === \"(No subject)\" ? \"\" : (draft.subject || \"\"),\n        body: draft.body || \"\",\n        bodyHtml: draft.body_html,\n        customerId: draft.customer_id,\n        attachments: draft.attachments as Array<{ filename: string; content: string; contentType?: string }> | null,\n        updatedAt: draft.updated_at,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Delete a draft\n */\nexport async function deleteDraftAction(draftId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Hard delete drafts (they don't need to go to trash)\n    const { error: deleteError } = await supabase\n      .from(\"communications\")\n      .delete()\n      .eq(\"id\", draftId)\n      .eq(\"company_id\", companyId)\n      .eq(\"status\", \"draft\");\n\n    if (deleteError) {\n      return { success: false, error: deleteError.message };\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting draft:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n// ============================================================================\n// RETRY ACTIONS\n// ============================================================================\n\n/**\n * Retry sending a failed email\n * Fetches the failed email, resets its status, and attempts to resend\n */\nexport async function retryFailedEmailAction(emailId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const { sendEmail } = await import(\"@/lib/email/email-sender\");\n    const { PlainTextEmail } = await import(\"@/emails/plain-text-email\");\n\n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    // Get the failed email\n    const { data: email, error: fetchError } = await supabase\n      .from(\"communications\")\n      .select(\"*\")\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"email\")\n      .eq(\"status\", \"failed\")\n      .single();\n\n    if (fetchError) {\n      return { success: false, error: fetchError.message };\n    }\n\n    if (!email) {\n      return { success: false, error: \"Failed email not found\" };\n    }\n\n    // Reset status to queued\n    const { error: updateError } = await supabase\n      .from(\"communications\")\n      .update({\n        status: \"queued\",\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    if (updateError) {\n      return { success: false, error: `Failed to reset email status: ${updateError.message}` };\n    }\n\n    // Parse recipients\n    const parseAddresses = (addr: string | null): string | string[] => {\n      if (!addr) return [];\n      const addresses = addr.split(\",\").map(a => a.trim()).filter(Boolean);\n      return addresses.length === 1 ? addresses[0] : addresses;\n    };\n\n    const to = parseAddresses(email.to_address);\n    const cc = parseAddresses(email.cc_address);\n    const bcc = parseAddresses(email.bcc_address);\n\n    // Get attachments from metadata if stored (for scheduled emails)\n    const metadata = email.provider_metadata as Record<string, unknown> | null;\n    const attachments = metadata?.scheduled_attachments as Array<{\n      filename: string;\n      content: string;\n      contentType?: string;\n    }> | undefined;\n\n    // Attempt to resend\n    const sendResult = await sendEmail({\n      to,\n      subject: email.subject || \"(No subject)\",\n      template: PlainTextEmail({ message: email.body || \"\" }),\n      templateType: \"generic\" as any,\n      companyId,\n      communicationId: emailId,\n      cc: cc.length > 0 ? cc : undefined,\n      bcc: bcc.length > 0 ? bcc : undefined,\n      attachments,\n    });\n\n    if (!sendResult.success) {\n      // Update status back to failed\n      await supabase\n        .from(\"communications\")\n        .update({\n          status: \"failed\",\n          failure_reason: sendResult.error || \"Email send failed on retry\",\n        })\n        .eq(\"id\", emailId)\n        .eq(\"company_id\", companyId);\n\n      return {\n        success: false,\n        error: sendResult.error || \"Failed to send email on retry\",\n      };\n    }\n\n    // Update status to sent\n    await supabase\n      .from(\"communications\")\n      .update({\n        status: \"sent\",\n        sent_at: new Date().toISOString(),\n        provider_message_id: sendResult.data?.id || null,\n        failure_reason: null,\n      })\n      .eq(\"id\", emailId)\n      .eq(\"company_id\", companyId);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error retrying failed email:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}","/**\n * AI Action Approval Service\n *\n * Handles owner-only approval workflow for destructive AI actions.\n * Ensures no destructive action can execute without explicit owner permission.\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport {\n\tisDestructiveTool,\n\tgetDestructiveToolMetadata,\n\ttype DestructiveToolMetadata,\n\ttype DestructiveActionType,\n\ttype RiskLevel,\n} from \"./agent-tools\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface PendingAction {\n\tid: string;\n\tcompanyId: string;\n\tchatId: string;\n\tmessageId: string;\n\tuserId: string;\n\ttoolName: string;\n\ttoolArgs: Record<string, unknown>;\n\tactionType: DestructiveActionType;\n\taffectedEntityType: string;\n\taffectedEntityIds: string[];\n\taffectedCount: number;\n\triskLevel: RiskLevel;\n\tstatus: \"pending\" | \"approved\" | \"rejected\" | \"expired\" | \"executed\" | \"failed\";\n\tapprovedBy?: string;\n\tapprovedAt?: string;\n\trejectionReason?: string;\n\texecutedAt?: string;\n\texecutionResult?: Record<string, unknown>;\n\texecutionError?: string;\n\texpiresAt: string;\n\tcreatedAt: string;\n}\n\nexport interface CreatePendingActionInput {\n\tcompanyId: string;\n\tchatId: string;\n\tmessageId: string;\n\tuserId: string;\n\ttoolName: string;\n\ttoolArgs: Record<string, unknown>;\n\taffectedEntityIds?: string[];\n}\n\nexport interface ApprovalResult {\n\tsuccess: boolean;\n\terror?: string;\n\tactionId?: string;\n\ttoolName?: string;\n\ttoolArgs?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Owner Verification\n// ============================================================================\n\n/**\n * Check if a user is the owner of a company\n * Uses the database function for consistency with RLS\n */\nexport async function isCompanyOwner(\n\tcompanyId: string,\n\tuserId: string\n): Promise<boolean> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase.rpc(\"is_company_owner\", {\n\t\tp_company_id: companyId,\n\t\tp_user_id: userId,\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Error checking owner status:\", error);\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Get the owner(s) of a company\n */\nexport async function getCompanyOwners(companyId: string): Promise<Array<{\n\tuserId: string;\n\temail: string;\n\tfirstName: string;\n\tlastName: string;\n}>> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(`\n\t\t\tuser_id,\n\t\t\tusers!company_memberships_users_id_fkey (\n\t\t\t\temail,\n\t\t\t\tname\n\t\t\t)\n\t\t`)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"role\", \"owner\");\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching company owners:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((row) => {\n\t\tconst user = row.users as { email: string; name: string } | null;\n\t\tconst nameParts = (user?.name || \"\").split(\" \");\n\t\treturn {\n\t\t\tuserId: row.user_id,\n\t\t\temail: user?.email || \"\",\n\t\t\tfirstName: nameParts[0] || \"\",\n\t\t\tlastName: nameParts.slice(1).join(\" \") || \"\",\n\t\t};\n\t});\n}\n\n// ============================================================================\n// Pending Action Management\n// ============================================================================\n\n/**\n * Create a pending action that requires owner approval\n * Returns the pending action ID for tracking\n */\nexport async function createPendingAction(\n\tinput: CreatePendingActionInput\n): Promise<{ success: boolean; pendingActionId?: string; error?: string }> {\n\tconst supabase = createServiceSupabaseClient();\n\n\t// Get metadata about this destructive tool\n\tconst metadata = getDestructiveToolMetadata(input.toolName);\n\tif (!metadata) {\n\t\treturn { success: false, error: `Tool '${input.toolName}' is not registered as destructive` };\n\t}\n\n\t// Calculate expiration (24 hours from now)\n\tconst expiresAt = new Date();\n\texpiresAt.setHours(expiresAt.getHours() + 24);\n\n\t// Create the pending action record\n\tconst { data, error } = await supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.insert({\n\t\t\tcompany_id: input.companyId,\n\t\t\tchat_id: input.chatId,\n\t\t\tmessage_id: input.messageId,\n\t\t\tuser_id: input.userId,\n\t\t\ttool_name: input.toolName,\n\t\t\ttool_args: input.toolArgs,\n\t\t\taction_type: metadata.actionType,\n\t\t\taction_title: `AI wants to: ${metadata.description}`,\n\t\t\taction_summary: generateActionSummary(input.toolName, input.toolArgs, metadata),\n\t\t\taction_details: {\n\t\t\t\ttoolName: input.toolName,\n\t\t\t\ttoolArgs: input.toolArgs,\n\t\t\t\tmetadata,\n\t\t\t},\n\t\t\taffected_entity_type: metadata.affectedEntityType,\n\t\t\taffected_entity_ids: input.affectedEntityIds || [],\n\t\t\taffected_count: input.affectedEntityIds?.length || 1,\n\t\t\trisk_level: metadata.riskLevel,\n\t\t\tstatus: \"pending\",\n\t\t\turgency: metadata.riskLevel === \"critical\" ? \"high\" : metadata.riskLevel === \"high\" ? \"medium\" : \"low\",\n\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t// Required by existing schema\n\t\t\taction_log_id: crypto.randomUUID(),\n\t\t})\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (error) {\n\t\tconsole.error(\"Error creating pending action:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true, pendingActionId: data.id };\n}\n\n/**\n * Generate a human-readable summary of the action\n */\nfunction generateActionSummary(\n\ttoolName: string,\n\ttoolArgs: Record<string, unknown>,\n\tmetadata: DestructiveToolMetadata\n): string {\n\tconst parts: string[] = [metadata.description];\n\n\t// Add relevant details from toolArgs\n\tif (toolArgs.to || toolArgs.recipient) {\n\t\tparts.push(`Recipient: ${toolArgs.to || toolArgs.recipient}`);\n\t}\n\tif (toolArgs.subject) {\n\t\tparts.push(`Subject: \"${toolArgs.subject}\"`);\n\t}\n\tif (toolArgs.customerId) {\n\t\tparts.push(`Customer ID: ${toolArgs.customerId}`);\n\t}\n\tif (toolArgs.amount) {\n\t\tparts.push(`Amount: $${(toolArgs.amount as number) / 100}`);\n\t}\n\n\treturn parts.join(\" | \");\n}\n\n/**\n * Get all pending actions for a chat session\n */\nexport async function getPendingActionsForChat(\n\tcompanyId: string,\n\tchatId: string\n): Promise<PendingAction[]> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"chat_id\", chatId)\n\t\t.eq(\"status\", \"pending\")\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching pending actions:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map(mapDbToPendingAction);\n}\n\n/**\n * Get all pending actions for a company (for owner dashboard)\n */\nexport async function getPendingActionsForCompany(\n\tcompanyId: string,\n\toptions?: {\n\t\tstatus?: \"pending\" | \"approved\" | \"rejected\" | \"expired\";\n\t\tlimit?: number;\n\t}\n): Promise<PendingAction[]> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tlet query = supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (options?.status) {\n\t\tquery = query.eq(\"status\", options.status);\n\t}\n\n\tif (options?.limit) {\n\t\tquery = query.limit(options.limit);\n\t}\n\n\tconst { data, error } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching pending actions:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map(mapDbToPendingAction);\n}\n\n/**\n * Get a specific pending action by ID\n */\nexport async function getPendingAction(\n\tcompanyId: string,\n\tactionId: string\n): Promise<PendingAction | null> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"id\", actionId)\n\t\t.single();\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching pending action:\", error);\n\t\treturn null;\n\t}\n\n\treturn mapDbToPendingAction(data);\n}\n\n// ============================================================================\n// Approval/Rejection (Owner-Only)\n// ============================================================================\n\n/**\n * Approve a pending action - OWNER ONLY\n * Uses the database function which enforces owner check\n */\nexport async function approveAction(\n\tactionId: string,\n\tapproverId: string\n): Promise<ApprovalResult> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase.rpc(\"approve_pending_action\", {\n\t\tp_action_id: actionId,\n\t\tp_approver_id: approverId,\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Error approving action:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\tconst result = data as ApprovalResult;\n\treturn result;\n}\n\n/**\n * Reject a pending action - OWNER ONLY\n * Uses the database function which enforces owner check\n */\nexport async function rejectAction(\n\tactionId: string,\n\trejectorId: string,\n\treason?: string\n): Promise<ApprovalResult> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase.rpc(\"reject_pending_action\", {\n\t\tp_action_id: actionId,\n\t\tp_rejector_id: rejectorId,\n\t\tp_reason: reason || null,\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Error rejecting action:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\tconst result = data as ApprovalResult;\n\treturn result;\n}\n\n// ============================================================================\n// Execution After Approval\n// ============================================================================\n\n/**\n * Mark an approved action as executed\n */\nexport async function markActionExecuted(\n\tcompanyId: string,\n\tactionId: string,\n\tresult: Record<string, unknown>\n): Promise<boolean> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.update({\n\t\t\tstatus: \"executed\",\n\t\t\texecuted_at: new Date().toISOString(),\n\t\t\texecution_result: result,\n\t\t\tupdated_at: new Date().toISOString(),\n\t\t})\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"id\", actionId)\n\t\t.eq(\"status\", \"approved\"); // Can only execute approved actions\n\n\tif (error) {\n\t\tconsole.error(\"Error marking action as executed:\", error);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Mark an approved action as failed\n */\nexport async function markActionFailed(\n\tcompanyId: string,\n\tactionId: string,\n\terrorMessage: string\n): Promise<boolean> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.update({\n\t\t\tstatus: \"failed\",\n\t\t\texecution_error: errorMessage,\n\t\t\tupdated_at: new Date().toISOString(),\n\t\t})\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"id\", actionId)\n\t\t.eq(\"status\", \"approved\");\n\n\tif (error) {\n\t\tconsole.error(\"Error marking action as failed:\", error);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// ============================================================================\n// Expiration Handling\n// ============================================================================\n\n/**\n * Expire old pending actions (called by cron or on access)\n */\nexport async function expireOldActions(companyId: string): Promise<number> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"ai_pending_actions\")\n\t\t.update({\n\t\t\tstatus: \"expired\",\n\t\t\tupdated_at: new Date().toISOString(),\n\t\t})\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"pending\")\n\t\t.lt(\"expires_at\", new Date().toISOString())\n\t\t.select(\"id\");\n\n\tif (error) {\n\t\tconsole.error(\"Error expiring old actions:\", error);\n\t\treturn 0;\n\t}\n\n\treturn data?.length || 0;\n}\n\n// ============================================================================\n// Tool Interception Helper\n// ============================================================================\n\n/**\n * Check if a tool call should be intercepted for owner approval\n * Returns the pending action details if interception is needed\n */\nexport async function shouldInterceptTool(\n\ttoolName: string,\n\ttoolArgs: Record<string, unknown>,\n\tcontext: {\n\t\tcompanyId: string;\n\t\tchatId: string;\n\t\tmessageId: string;\n\t\tuserId: string;\n\t}\n): Promise<{\n\tintercept: boolean;\n\tpendingActionId?: string;\n\tmetadata?: DestructiveToolMetadata;\n\terror?: string;\n}> {\n\t// Check if tool is destructive\n\tif (!isDestructiveTool(toolName)) {\n\t\treturn { intercept: false };\n\t}\n\n\tconst metadata = getDestructiveToolMetadata(toolName);\n\tif (!metadata || !metadata.requiresOwnerApproval) {\n\t\treturn { intercept: false };\n\t}\n\n\t// Check if user is already an owner (owners can self-approve in UI)\n\tconst isOwner = await isCompanyOwner(context.companyId, context.userId);\n\n\t// Even owners need to see the dialog and explicitly approve\n\t// This ensures conscious decision-making for destructive actions\n\n\t// Create pending action\n\tconst result = await createPendingAction({\n\t\tcompanyId: context.companyId,\n\t\tchatId: context.chatId,\n\t\tmessageId: context.messageId,\n\t\tuserId: context.userId,\n\t\ttoolName,\n\t\ttoolArgs,\n\t});\n\n\tif (!result.success) {\n\t\treturn { intercept: true, error: result.error, metadata };\n\t}\n\n\treturn {\n\t\tintercept: true,\n\t\tpendingActionId: result.pendingActionId,\n\t\tmetadata,\n\t};\n}\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction mapDbToPendingAction(row: Record<string, unknown>): PendingAction {\n\treturn {\n\t\tid: row.id as string,\n\t\tcompanyId: row.company_id as string,\n\t\tchatId: row.chat_id as string,\n\t\tmessageId: row.message_id as string,\n\t\tuserId: row.user_id as string,\n\t\ttoolName: row.tool_name as string,\n\t\ttoolArgs: (row.tool_args as Record<string, unknown>) || {},\n\t\tactionType: row.action_type as DestructiveActionType,\n\t\taffectedEntityType: row.affected_entity_type as string,\n\t\taffectedEntityIds: (row.affected_entity_ids as string[]) || [],\n\t\taffectedCount: (row.affected_count as number) || 1,\n\t\triskLevel: (row.risk_level as RiskLevel) || \"medium\",\n\t\tstatus: row.status as PendingAction[\"status\"],\n\t\tapprovedBy: row.approved_by as string | undefined,\n\t\tapprovedAt: row.approved_at as string | undefined,\n\t\trejectionReason: row.rejection_reason as string | undefined,\n\t\texecutedAt: row.executed_at as string | undefined,\n\t\texecutionResult: row.execution_result as Record<string, unknown> | undefined,\n\t\texecutionError: row.execution_error as string | undefined,\n\t\texpiresAt: row.expires_at as string,\n\t\tcreatedAt: row.created_at as string,\n\t};\n}\n\n// ============================================================================\n// Exports for use in AI chat route and UI\n// ============================================================================\n\nexport {\n\tisDestructiveTool,\n\tgetDestructiveToolMetadata,\n\ttype DestructiveToolMetadata,\n\ttype DestructiveActionType,\n\ttype RiskLevel,\n} from \"./agent-tools\";\n","// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\nexport {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidArgumentError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  LoadSettingError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TooManyEmbeddingValuesForCallError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n  getErrorMessage,\n  isJSONArray,\n  isJSONObject,\n  isJSONValue\n};\n//# sourceMappingURL=index.mjs.map","// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  let cancelled = false;\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      if (cancelled) return;\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    async cancel(reason) {\n      cancelled = true;\n      if (iterator.return) {\n        try {\n          await iterator.return(reason);\n        } catch (e) {\n        }\n      }\n    }\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs, options) {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n  const signal = options == null ? void 0 : options.abortSignal;\n  return new Promise((resolve2, reject) => {\n    if (signal == null ? void 0 : signal.aborted) {\n      reject(createAbortError());\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve2();\n    }, delayInMs);\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal == null ? void 0 : signal.removeEventListener(\"abort\", onAbort);\n    };\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n    signal == null ? void 0 : signal.addEventListener(\"abort\", onAbort);\n  });\n}\nfunction createAbortError() {\n  return new DOMException(\"Delay was aborted\", \"AbortError\");\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\n\n// src/generate-id.ts\nimport { InvalidArgumentError } from \"@ai-sdk/provider\";\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\nimport { APICallError as APICallError2 } from \"@ai-sdk/provider\";\n\n// src/handle-fetch-error.ts\nimport { APICallError } from \"@ai-sdk/provider\";\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\n\n// src/handle-fetch-error.ts\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error;\n}\n\n// src/get-runtime-environment-user-agent.ts\nfunction getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {\n  var _a, _b, _c;\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n  if ((_a = globalThisAny.navigator) == null ? void 0 : _a.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n  return \"runtime/unknown\";\n}\n\n// src/normalize-headers.ts\nfunction normalizeHeaders(headers) {\n  if (headers == null) {\n    return {};\n  }\n  const normalized = {};\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      normalized[key.toLowerCase()] = value;\n    });\n  } else {\n    if (!Array.isArray(headers)) {\n      headers = Object.entries(headers);\n    }\n    for (const [key, value] of headers) {\n      if (value != null) {\n        normalized[key.toLowerCase()] = value;\n      }\n    }\n  }\n  return normalized;\n}\n\n// src/with-user-agent-suffix.ts\nfunction withUserAgentSuffix(headers, ...userAgentSuffixParts) {\n  const normalizedHeaders = new Headers(normalizeHeaders(headers));\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\n    \"user-agent\",\n    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \")\n  );\n  return Object.fromEntries(normalizedHeaders.entries());\n}\n\n// src/version.ts\nvar VERSION = true ? \"3.0.17\" : \"0.0.0-test\";\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError2({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError2({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: {} });\n  }\n};\n\n// src/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\nfunction injectJsonInstructionIntoMessages({\n  messages,\n  schema,\n  schemaPrefix,\n  schemaSuffix\n}) {\n  var _a, _b;\n  const systemMessage = ((_a = messages[0]) == null ? void 0 : _a.role) === \"system\" ? { ...messages[0] } : { role: \"system\", content: \"\" };\n  systemMessage.content = injectJsonInstruction({\n    prompt: systemMessage.content,\n    schema,\n    schemaPrefix,\n    schemaSuffix\n  });\n  return [\n    systemMessage,\n    ...((_b = messages[0]) == null ? void 0 : _b.role) === \"system\" ? messages.slice(1) : messages\n  ];\n}\n\n// src/is-url-supported.ts\nfunction isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls\n}) {\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n  return Object.entries(supportedUrls).map(([key, value]) => {\n    const mediaType2 = key.toLowerCase();\n    return mediaType2 === \"*\" || mediaType2 === \"*/*\" ? { mediaTypePrefix: \"\", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\\*/, \"\"), regexes: value };\n  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));\n}\n\n// src/load-api-key.ts\nimport { LoadAPIKeyError } from \"@ai-sdk/provider\";\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\nimport { LoadSettingError } from \"@ai-sdk/provider\";\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/media-type-to-extension.ts\nfunction mediaTypeToExtension(mediaType) {\n  var _a;\n  const [_type, subtype = \"\"] = mediaType.toLowerCase().split(\"/\");\n  return (_a = {\n    mpeg: \"mp3\",\n    \"x-wav\": \"wav\",\n    opus: \"ogg\",\n    mp4: \"m4a\",\n    \"x-m4a\": \"m4a\"\n  }[subtype]) != null ? _a : subtype;\n}\n\n// src/parse-json.ts\nimport {\n  JSONParseError,\n  TypeValidationError as TypeValidationError3\n} from \"@ai-sdk/provider\";\n\n// src/secure-json-parse.ts\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  try {\n    Error.stackTraceLimit = 0;\n  } catch (e) {\n    return _parse(text);\n  }\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n\n// src/validate-types.ts\nimport { TypeValidationError as TypeValidationError2 } from \"@ai-sdk/provider\";\n\n// src/validator.ts\nimport { TypeValidationError } from \"@ai-sdk/provider\";\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction lazyValidator(createValidator) {\n  let validator2;\n  return () => {\n    if (validator2 == null) {\n      validator2 = createValidator();\n    }\n    return validator2;\n  };\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : typeof value === \"function\" ? value() : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\n\n// src/validate-types.ts\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError2.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError2.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError2.wrap({ value, cause: error }),\n      rawValue: value\n    };\n  }\n}\n\n// src/parse-json.ts\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError3.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-json-event-stream.ts\nimport {\n  EventSourceParserStream\n} from \"eventsource-parser/stream\";\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\n\n// src/parse-provider-options.ts\nimport { InvalidArgumentError as InvalidArgumentError2 } from \"@ai-sdk/provider\";\nasync function parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = await safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError2({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\nimport { APICallError as APICallError3 } from \"@ai-sdk/provider\";\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError3.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError3({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError3.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError3({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\n\n// src/types/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\nfunction dynamicTool(tool2) {\n  return { ...tool2, type: \"dynamic\" };\n}\n\n// src/provider-defined-tool-factory.ts\nfunction createProviderDefinedToolFactory({\n  id,\n  name,\n  inputSchema\n}) {\n  return ({\n    execute,\n    outputSchema,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider-defined\",\n    id,\n    name,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\nfunction createProviderDefinedToolFactoryWithOutputSchema({\n  id,\n  name,\n  inputSchema,\n  outputSchema\n}) {\n  return ({\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider-defined\",\n    id,\n    name,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\nimport { APICallError as APICallError4, EmptyResponseBodyError } from \"@ai-sdk/provider\";\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        async transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              await safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError4({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new APICallError4({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new APICallError4({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new APICallError4({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/zod-schema.ts\nimport * as z4 from \"zod/v4\";\n\n// src/zod-to-json-schema/get-relative-path.ts\nvar getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n\n// src/zod-to-json-schema/options.ts\nvar ignoreOverride = Symbol(\n  \"Let zodToJsonSchema decide on which parser to use\"\n);\nvar defaultOptions = {\n  name: void 0,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\"\n};\nvar getDefaultOptions = (options) => typeof options === \"string\" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\n\n// src/zod-to-json-schema/select-parser.ts\nimport { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind3 } from \"zod/v3\";\n\n// src/zod-to-json-schema/parsers/any.ts\nfunction parseAnyDef() {\n  return {};\n}\n\n// src/zod-to-json-schema/parsers/array.ts\nimport { ZodFirstPartyTypeKind } from \"zod/v3\";\nfunction parseArrayDef(def, refs) {\n  var _a, _b, _c;\n  const res = {\n    type: \"array\"\n  };\n  if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\n\n// src/zod-to-json-schema/parsers/bigint.ts\nfunction parseBigintDef(def) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/zod-to-json-schema/parsers/boolean.ts\nfunction parseBooleanDef() {\n  return { type: \"boolean\" };\n}\n\n// src/zod-to-json-schema/parsers/branded.ts\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\n\n// src/zod-to-json-schema/parsers/catch.ts\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/zod-to-json-schema/parsers/date.ts\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser(def);\n  }\n}\nvar integerDateParser = (def) => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        res.minimum = check.value;\n        break;\n      case \"max\":\n        res.maximum = check.value;\n        break;\n    }\n  }\n  return res;\n};\n\n// src/zod-to-json-schema/parsers/default.ts\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\n\n// src/zod-to-json-schema/parsers/effects.ts\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef(_def.schema._def, refs) : parseAnyDef();\n}\n\n// src/zod-to-json-schema/parsers/enum.ts\nfunction parseEnumDef(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\n\n// src/zod-to-json-schema/parsers/intersection.ts\nvar isJsonSchema7AllOfType = (type) => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n    })\n  ].filter((x) => !!x);\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;\n}\n\n// src/zod-to-json-schema/parsers/literal.ts\nfunction parseLiteralDef(def) {\n  const parsedType = typeof def.value;\n  if (parsedType !== \"bigint\" && parsedType !== \"number\" && parsedType !== \"boolean\" && parsedType !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  return {\n    type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n    const: def.value\n  };\n}\n\n// src/zod-to-json-schema/parsers/record.ts\nimport {\n  ZodFirstPartyTypeKind as ZodFirstPartyTypeKind2\n} from \"zod/v3\";\n\n// src/zod-to-json-schema/parsers/string.ts\nvar emojiRegex = void 0;\nvar zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === void 0) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          break;\n        case \"max\":\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\", check.message, refs);\n              break;\n            }\n            case \"contentEncoding:base64\": {\n              res.contentEncoding = \"base64\";\n              break;\n            }\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* @__PURE__ */ ((_) => {\n          })(check);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal) : literal;\n}\nvar ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  var _a;\n  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  var _a;\n  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  var _a;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    // Case-insensitive\n    m: regex.flags.includes(\"m\"),\n    // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\")\n    // `.` matches newlines\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e) {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n  return pattern;\n}\n\n// src/zod-to-json-schema/parsers/record.ts\nfunction parseRecordDef(def, refs) {\n  var _a, _b, _c, _d, _e, _f;\n  const schema = {\n    type: \"object\",\n    additionalProperties: (_a = parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    })) != null ? _a : refs.allowedAdditionalProperties\n  };\n  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind2.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind2.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs\n    );\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\n\n// src/zod-to-json-schema/parsers/map.ts\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || parseAnyDef();\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || parseAnyDef();\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\n\n// src/zod-to-json-schema/parsers/native-enum.ts\nfunction parseNativeEnumDef(def) {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object[object[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map((key) => object[key]);\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values) => typeof values))\n  );\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\n\n// src/zod-to-json-schema/parsers/never.ts\nfunction parseNeverDef() {\n  return { not: parseAnyDef() };\n}\n\n// src/zod-to-json-schema/parsers/null.ts\nfunction parseNullDef() {\n  return {\n    type: \"null\"\n  };\n}\n\n// src/zod-to-json-schema/parsers/union.ts\nvar primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every(\n    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)\n  )) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types = options.reduce(\n      (acc, x) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"boolean\":\n            return [...acc, type];\n          case \"bigint\":\n            return [...acc, \"integer\"];\n          case \"object\":\n            if (x._def.value === null) return [...acc, \"null\"];\n          case \"symbol\":\n          case \"undefined\":\n          case \"function\":\n          default:\n            return acc;\n        }\n      },\n      []\n    );\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          []\n        )\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce(\n        (acc, x) => [\n          ...acc,\n          ...x._def.values.filter((x2) => !acc.includes(x2))\n        ],\n        []\n      )\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(\n    (x, i) => parseDef(x._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n    })\n  ).filter(\n    (x) => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0)\n  );\n  return anyOf.length ? { anyOf } : void 0;\n};\n\n// src/zod-to-json-schema/parsers/nullable.ts\nfunction parseNullableDef(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(\n    def.innerType._def.typeName\n  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        \"null\"\n      ]\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && { anyOf: [base, { type: \"null\" }] };\n}\n\n// src/zod-to-json-schema/parsers/number.ts\nfunction parseNumberDef(def) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        break;\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/zod-to-json-schema/parsers/object.ts\nfunction parseObjectDef(def, refs) {\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === void 0 || propDef._def === void 0) {\n      continue;\n    }\n    const propOptional = safeIsOptional(propDef);\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === void 0) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n  if (required.length) {\n    result.required = required;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== void 0) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e) {\n    return true;\n  }\n}\n\n// src/zod-to-json-schema/parsers/optional.ts\nvar parseOptionalDef = (def, refs) => {\n  var _a;\n  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();\n};\n\n// src/zod-to-json-schema/parsers/pipeline.ts\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter((x) => x !== void 0)\n  };\n};\n\n// src/zod-to-json-schema/parsers/promise.ts\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\n\n// src/zod-to-json-schema/parsers/set.ts\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\n\n// src/zod-to-json-schema/parsers/tuple.ts\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      )\n    };\n  }\n}\n\n// src/zod-to-json-schema/parsers/undefined.ts\nfunction parseUndefinedDef() {\n  return {\n    not: parseAnyDef()\n  };\n}\n\n// src/zod-to-json-schema/parsers/unknown.ts\nfunction parseUnknownDef() {\n  return parseAnyDef();\n}\n\n// src/zod-to-json-schema/parsers/readonly.ts\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/zod-to-json-schema/select-parser.ts\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind3.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodNumber:\n      return parseNumberDef(def);\n    case ZodFirstPartyTypeKind3.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodBigInt:\n      return parseBigintDef(def);\n    case ZodFirstPartyTypeKind3.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind3.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind3.ZodNull:\n      return parseNullDef();\n    case ZodFirstPartyTypeKind3.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodUnion:\n    case ZodFirstPartyTypeKind3.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodLiteral:\n      return parseLiteralDef(def);\n    case ZodFirstPartyTypeKind3.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind3.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind3.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind3.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodNaN:\n    case ZodFirstPartyTypeKind3.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind3.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind3.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind3.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodFunction:\n    case ZodFirstPartyTypeKind3.ZodVoid:\n    case ZodFirstPartyTypeKind3.ZodSymbol:\n      return void 0;\n    default:\n      return /* @__PURE__ */ ((_) => void 0)(typeName);\n  }\n};\n\n// src/zod-to-json-schema/parse-def.ts\nfunction parseDef(def, refs, forceResolution = false) {\n  var _a;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(\n      refs,\n      def,\n      refs,\n      seenItem,\n      forceResolution\n    );\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== void 0) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            \"/\"\n          )}! Defaulting to any`\n        );\n        return parseAnyDef();\n      }\n      return refs.$refStrategy === \"seen\" ? parseAnyDef() : void 0;\n    }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\n\n// src/zod-to-json-schema/refs.ts\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: void 0,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: void 0\n        }\n      ])\n    )\n  };\n};\n\n// src/zod-to-json-schema/zod-to-json-schema.ts\nvar zodToJsonSchema = (schema, options) => {\n  var _a;\n  const refs = getRefs(options);\n  let definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce(\n    (acc, [name2, schema2]) => {\n      var _a2;\n      return {\n        ...acc,\n        [name2]: (_a2 = parseDef(\n          schema2._def,\n          {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name2]\n          },\n          true\n        )) != null ? _a2 : parseAnyDef()\n      };\n    },\n    {}\n  ) : void 0;\n  const name = typeof options === \"string\" ? options : (options == null ? void 0 : options.nameStrategy) === \"title\" ? void 0 : options == null ? void 0 : options.name;\n  const main = (_a = parseDef(\n    schema._def,\n    name === void 0 ? refs : {\n      ...refs,\n      currentPath: [...refs.basePath, refs.definitionPath, name]\n    },\n    false\n  )) != null ? _a : parseAnyDef();\n  const title = typeof options === \"object\" && options.name !== void 0 && options.nameStrategy === \"title\" ? options.name : void 0;\n  if (title !== void 0) {\n    main.title = title;\n  }\n  const combined = name === void 0 ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === \"relative\" ? [] : refs.basePath,\n      refs.definitionPath,\n      name\n    ].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name]: main\n    }\n  };\n  combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  return combined;\n};\n\n// src/zod-to-json-schema/index.ts\nvar zod_to_json_schema_default = zodToJsonSchema;\n\n// src/zod-schema.ts\nfunction zod3Schema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => zod_to_json_schema_default(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\"\n    }),\n    {\n      validate: async (value) => {\n        const result = await zodSchema2.safeParseAsync(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => z4.toJSONSchema(zodSchema2, {\n      target: \"draft-7\",\n      io: \"output\",\n      reused: useReferences ? \"ref\" : \"inline\"\n    }),\n    {\n      validate: async (value) => {\n        const result = await z4.safeParseAsync(zodSchema2, value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction isZod4Schema(zodSchema2) {\n  return \"_zod\" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction lazySchema(createSchema) {\n  let schema;\n  return () => {\n    if (schema == null) {\n      schema = createSchema();\n    }\n    return schema;\n  };\n}\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [validatorSymbol]: true,\n    get jsonSchema() {\n      if (typeof jsonSchema2 === \"function\") {\n        jsonSchema2 = jsonSchema2();\n      }\n      return jsonSchema2;\n    },\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({\n    properties: {},\n    additionalProperties: false\n  }) : isSchema(schema) ? schema : typeof schema === \"function\" ? schema() : zodSchema(schema);\n}\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction convertToBase64(value) {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/is-async-iterable.ts\nfunction isAsyncIterable(obj) {\n  return obj != null && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n// src/types/execute-tool.ts\nasync function* executeTool({\n  execute,\n  input,\n  options\n}) {\n  const result = execute(input, options);\n  if (isAsyncIterable(result)) {\n    let lastOutput;\n    for await (const output of result) {\n      lastOutput = output;\n      yield { type: \"preliminary\", output };\n    }\n    yield { type: \"final\", output: lastOutput };\n  } else {\n    yield { type: \"final\", output: await result };\n  }\n}\n\n// src/index.ts\nexport * from \"@standard-schema/spec\";\nimport {\n  EventSourceParserStream as EventSourceParserStream2\n} from \"eventsource-parser/stream\";\nexport {\n  EventSourceParserStream2 as EventSourceParserStream,\n  VERSION,\n  asSchema,\n  asValidator,\n  combineHeaders,\n  convertAsyncIteratorToReadableStream,\n  convertBase64ToUint8Array,\n  convertToBase64,\n  convertUint8ArrayToBase64,\n  createBinaryResponseHandler,\n  createEventSourceResponseHandler,\n  createIdGenerator,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  createJsonStreamResponseHandler,\n  createProviderDefinedToolFactory,\n  createProviderDefinedToolFactoryWithOutputSchema,\n  createStatusCodeErrorResponseHandler,\n  delay,\n  dynamicTool,\n  executeTool,\n  extractResponseHeaders,\n  generateId,\n  getErrorMessage,\n  getFromApi,\n  getRuntimeEnvironmentUserAgent,\n  injectJsonInstructionIntoMessages,\n  isAbortError,\n  isParsableJson,\n  isUrlSupported,\n  isValidator,\n  jsonSchema,\n  lazySchema,\n  lazyValidator,\n  loadApiKey,\n  loadOptionalSetting,\n  loadSetting,\n  mediaTypeToExtension,\n  normalizeHeaders,\n  parseJSON,\n  parseJsonEventStream,\n  parseProviderOptions,\n  postFormDataToApi,\n  postJsonToApi,\n  postToApi,\n  removeUndefinedEntries,\n  resolve,\n  safeParseJSON,\n  safeValidateTypes,\n  standardSchemaValidator,\n  tool,\n  validateTypes,\n  validator,\n  withUserAgentSuffix,\n  withoutTrailingSlash,\n  zodSchema\n};\n//# sourceMappingURL=index.mjs.map","/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string | undefined\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string | undefined\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string | undefined\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n","export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n","export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n","import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n","import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = Object.create(null);\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n","import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n","import {createParser} from './parse.ts'\nimport type {EventSourceMessage, EventSourceParser} from './types.ts'\n\n/**\n * Options for the EventSourceParserStream.\n *\n * @public\n */\nexport interface StreamOptions {\n  /**\n   * Behavior when a parsing error occurs.\n   *\n   * - A custom function can be provided to handle the error.\n   * - `'terminate'` will error the stream and stop parsing.\n   * - Any other value will ignore the error and continue parsing.\n   *\n   * @defaultValue `undefined`\n   */\n  onError?: ('terminate' | ((error: Error) => void)) | undefined\n\n  /**\n   * Callback for when a reconnection interval is sent from the server.\n   *\n   * @param retry - The number of milliseconds to wait before reconnecting.\n   */\n  onRetry?: ((retry: number) => void) | undefined\n\n  /**\n   * Callback for when a comment is encountered in the stream.\n   *\n   * @param comment - The comment encountered in the stream.\n   */\n  onComment?: ((comment: string) => void) | undefined\n}\n\n/**\n * A TransformStream that ingests a stream of strings and produces a stream of `EventSourceMessage`.\n *\n * @example Basic usage\n * ```\n * const eventStream =\n *   response.body\n *     .pipeThrough(new TextDecoderStream())\n *     .pipeThrough(new EventSourceParserStream())\n * ```\n *\n * @example Terminate stream on parsing errors\n * ```\n * const eventStream =\n *  response.body\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new EventSourceParserStream({terminateOnError: true}))\n * ```\n *\n * @public\n */\nexport class EventSourceParserStream extends TransformStream<string, EventSourceMessage> {\n  constructor({onError, onRetry, onComment}: StreamOptions = {}) {\n    let parser!: EventSourceParser\n\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event)\n          },\n          onError(error) {\n            if (onError === 'terminate') {\n              controller.error(error)\n            } else if (typeof onError === 'function') {\n              onError(error)\n            }\n\n            // Ignore by default\n          },\n          onRetry,\n          onComment,\n        })\n      },\n      transform(chunk) {\n        parser.feed(chunk)\n      },\n    })\n  }\n}\n\nexport {type ErrorType, ParseError} from './errors.ts'\nexport type {EventSourceMessage} from './types.ts'\n","import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        // @ts-ignore\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    // @ts-ignore\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n","/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // 👆 This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}…` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      // CR at the end of a chunk might be part of a CRLF sequence that spans chunks,\n      // so we shouldn't treat it as a line terminator (yet)\n      if (crIndex === chunk.length - 1) {\n        lineEnd = -1\n      } else {\n        lineEnd = crIndex\n      }\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n","/**\n * AI Agent Tools - Comprehensive tool definitions for the AI Manager\n * Integrates with database, Resend, Telnyx, and financial systems\n */\n\nimport { tool } from \"ai\";\nimport { z } from \"zod\";\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport {\n\tsearchCustomersFullText,\n\tsearchJobsFullText,\n\tsearchAllEntities,\n} from \"@/lib/search/full-text-search\";\nimport { googleCustomSearchService } from \"@/lib/services/google-custom-search-service\";\n\n// Tool categories for permission checking\nexport type ToolCategory = \"communication\" | \"financial\" | \"scheduling\" | \"customer\" | \"reporting\" | \"system\" | \"team\" | \"vendor\" | \"notification\" | \"property\" | \"equipment\";\n\n// ============================================================================\n// UNIVERSAL DATABASE ACCESS TOOLS\n// ============================================================================\n\nexport const listDatabaseTablesTool = tool({\n\tdescription: \"List all available database tables and their purposes. Use this to understand what data is available.\",\n\tparameters: z.object({}),\n\texecute: async () => {\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttables: [\n\t\t\t\t{ name: \"customers\", description: \"Customer records with contact info, revenue, and status\" },\n\t\t\t\t{ name: \"team_members\", description: \"Employee/staff records with roles, contact info, and assignments\" },\n\t\t\t\t{ name: \"vendors\", description: \"Supplier/vendor records with contact and payment info\" },\n\t\t\t\t{ name: \"jobs\", description: \"Work orders and service jobs with status, scheduling, and costs\" },\n\t\t\t\t{ name: \"appointments\", description: \"Scheduled appointments and service calls\" },\n\t\t\t\t{ name: \"invoices\", description: \"Customer invoices with line items and payment status\" },\n\t\t\t\t{ name: \"estimates\", description: \"Price estimates/quotes for customers\" },\n\t\t\t\t{ name: \"contracts\", description: \"Service contracts and agreements\" },\n\t\t\t\t{ name: \"payments\", description: \"Payment records and transactions\" },\n\t\t\t\t{ name: \"properties\", description: \"Customer properties/service locations\" },\n\t\t\t\t{ name: \"equipment\", description: \"Equipment and assets at properties\" },\n\t\t\t\t{ name: \"communications\", description: \"Email, SMS, and call history\" },\n\t\t\t\t{ name: \"price_book_items\", description: \"Service and product pricing catalog\" },\n\t\t\t\t{ name: \"materials\", description: \"Materials and parts inventory\" },\n\t\t\t\t{ name: \"purchase_orders\", description: \"Orders placed with vendors\" },\n\t\t\t\t{ name: \"time_entries\", description: \"Time tracking for jobs and employees\" },\n\t\t\t\t{ name: \"expenses\", description: \"Business expenses and costs\" },\n\t\t\t\t{ name: \"service_agreements\", description: \"Recurring service agreements\" },\n\t\t\t\t{ name: \"maintenance_plans\", description: \"Equipment maintenance schedules\" },\n\t\t\t\t{ name: \"notes\", description: \"Notes attached to various records\" },\n\t\t\t\t{ name: \"tags\", description: \"Tags/labels for organizing records\" },\n\t\t\t\t{ name: \"finance_virtual_buckets\", description: \"Financial savings goals and allocations\" },\n\t\t\t\t{ name: \"scheduled_notifications\", description: \"Scheduled reminders and notifications\" },\n\t\t\t],\n\t\t};\n\t},\n});\n\nexport const queryDatabaseTool = tool({\n\tdescription: \"Query any database table to retrieve records. Use this for flexible data access when specific tools don't cover your needs.\",\n\tparameters: z.object({\n\t\ttable: z.string().describe(\"Table name to query (e.g., 'customers', 'jobs', 'invoices')\"),\n\t\tselect: z.string().optional().default(\"*\").describe(\"Columns to select (comma-separated or * for all)\"),\n\t\tfilters: z.array(z.object({\n\t\t\tcolumn: z.string(),\n\t\t\toperator: z.enum([\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"like\", \"ilike\", \"in\", \"is\"]),\n\t\t\tvalue: z.union([z.string(), z.number(), z.boolean(), z.null(), z.array(z.string())]),\n\t\t})).optional().describe(\"Filters to apply\"),\n\t\torderBy: z.object({\n\t\t\tcolumn: z.string(),\n\t\t\tascending: z.boolean().default(false),\n\t\t}).optional().describe(\"Sort order\"),\n\t\tlimit: z.number().optional().default(50).describe(\"Max records to return\"),\n\t\toffset: z.number().optional().default(0).describe(\"Records to skip for pagination\"),\n\t}),\n\texecute: async ({ table, select, filters, orderBy, limit, offset }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Security: Only allow access to business tables\n\t\tconst allowedTables = [\n\t\t\t\"customers\", \"team_members\", \"vendors\", \"jobs\", \"appointments\", \"invoices\",\n\t\t\t\"estimates\", \"contracts\", \"payments\", \"properties\", \"equipment\", \"communications\",\n\t\t\t\"price_book_items\", \"materials\", \"purchase_orders\", \"time_entries\", \"expenses\",\n\t\t\t\"service_agreements\", \"maintenance_plans\", \"notes\", \"tags\", \"finance_virtual_buckets\",\n\t\t\t\"scheduled_notifications\", \"job_line_items\", \"invoice_line_items\", \"estimate_line_items\",\n\t\t];\n\n\t\tif (!allowedTables.includes(table)) {\n\t\t\treturn { success: false, error: `Table '${table}' is not accessible. Available: ${allowedTables.join(\", \")}` };\n\t\t}\n\n\t\tlet query = supabase.from(table).select(select);\n\n\t\t// Always filter by company_id for security\n\t\tquery = query.eq(\"company_id\", companyId);\n\n\t\t// Apply filters\n\t\tif (filters) {\n\t\t\tfor (const filter of filters) {\n\t\t\t\tswitch (filter.operator) {\n\t\t\t\t\tcase \"eq\": query = query.eq(filter.column, filter.value); break;\n\t\t\t\t\tcase \"neq\": query = query.neq(filter.column, filter.value); break;\n\t\t\t\t\tcase \"gt\": query = query.gt(filter.column, filter.value); break;\n\t\t\t\t\tcase \"gte\": query = query.gte(filter.column, filter.value); break;\n\t\t\t\t\tcase \"lt\": query = query.lt(filter.column, filter.value); break;\n\t\t\t\t\tcase \"lte\": query = query.lte(filter.column, filter.value); break;\n\t\t\t\t\tcase \"like\": query = query.like(filter.column, filter.value as string); break;\n\t\t\t\t\tcase \"ilike\": query = query.ilike(filter.column, filter.value as string); break;\n\t\t\t\t\tcase \"in\": query = query.in(filter.column, filter.value as string[]); break;\n\t\t\t\t\tcase \"is\": query = query.is(filter.column, filter.value); break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Apply ordering\n\t\tif (orderBy) {\n\t\t\tquery = query.order(orderBy.column, { ascending: orderBy.ascending });\n\t\t}\n\n\t\t// Apply pagination\n\t\tquery = query.range(offset, offset + limit - 1);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, data, count: data?.length || 0, table };\n\t},\n});\n\nexport const getRecordByIdTool = tool({\n\tdescription: \"Get a specific record by its ID from any table. Use when you need full details of a known record.\",\n\tparameters: z.object({\n\t\ttable: z.string().describe(\"Table name\"),\n\t\tid: z.string().uuid().describe(\"Record UUID\"),\n\t\tselect: z.string().optional().default(\"*\").describe(\"Columns to select\"),\n\t}),\n\texecute: async ({ table, id, select }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst allowedTables = [\n\t\t\t\"customers\", \"team_members\", \"vendors\", \"jobs\", \"appointments\", \"invoices\",\n\t\t\t\"estimates\", \"contracts\", \"payments\", \"properties\", \"equipment\", \"communications\",\n\t\t\t\"price_book_items\", \"materials\", \"purchase_orders\", \"time_entries\", \"expenses\",\n\t\t\t\"service_agreements\", \"maintenance_plans\", \"notes\", \"finance_virtual_buckets\",\n\t\t];\n\n\t\tif (!allowedTables.includes(table)) {\n\t\t\treturn { success: false, error: `Table '${table}' is not accessible` };\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(table)\n\t\t\t.select(select)\n\t\t\t.eq(\"id\", id)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, record: data, table };\n\t},\n});\n\nexport const getRelatedRecordsTool = tool({\n\tdescription: \"Get records related to a specific entity (e.g., all jobs for a customer, all invoices for a job).\",\n\tparameters: z.object({\n\t\tparentTable: z.string().describe(\"Parent table (e.g., 'customers')\"),\n\t\tparentId: z.string().uuid().describe(\"Parent record ID\"),\n\t\tchildTable: z.string().describe(\"Related table to query (e.g., 'jobs')\"),\n\t\tforeignKey: z.string().describe(\"Foreign key column in child table (e.g., 'customer_id')\"),\n\t\tselect: z.string().optional().default(\"*\"),\n\t\tlimit: z.number().optional().default(50),\n\t}),\n\texecute: async ({ parentTable, parentId, childTable, foreignKey, select, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(childTable)\n\t\t\t.select(select)\n\t\t\t.eq(foreignKey, parentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, data, count: data?.length || 0, parentTable, childTable };\n\t},\n});\n\nexport const getCompanyOverviewTool = tool({\n\tdescription: \"Get a comprehensive overview of the entire company including counts and summaries from all major tables.\",\n\tparameters: z.object({}),\n\texecute: async (_params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst [\n\t\t\tcustomersResult,\n\t\t\tteamResult,\n\t\t\tvendorsResult,\n\t\t\tjobsResult,\n\t\t\tinvoicesResult,\n\t\t\testimatesResult,\n\t\t\tcontractsResult,\n\t\t\tpropertiesResult,\n\t\t\tequipmentResult,\n\t\t\tappointmentsResult,\n\t\t] = await Promise.all([\n\t\t\tsupabase.from(\"customers\").select(\"id, status\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"team_members\").select(\"id, status, role\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"vendors\").select(\"id, status\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"jobs\").select(\"id, status, total_amount\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"invoices\").select(\"id, status, total_amount, balance_amount\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"estimates\").select(\"id, status, total_amount\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"contracts\").select(\"id, status, total_value\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"properties\").select(\"id\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"equipment\").select(\"id\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t\tsupabase.from(\"appointments\").select(\"id, status\", { count: \"exact\" }).eq(\"company_id\", companyId),\n\t\t]);\n\n\t\t// Calculate summaries\n\t\tconst activeCustomers = customersResult.data?.filter(c => c.status === \"active\").length || 0;\n\t\tconst activeTeam = teamResult.data?.filter(t => t.status === \"active\").length || 0;\n\t\tconst openJobs = jobsResult.data?.filter(j => [\"pending\", \"scheduled\", \"in_progress\"].includes(j.status)).length || 0;\n\t\tconst completedJobs = jobsResult.data?.filter(j => j.status === \"completed\").length || 0;\n\t\tconst pendingInvoices = invoicesResult.data?.filter(i => [\"sent\", \"viewed\"].includes(i.status)).length || 0;\n\t\tconst overdueBalance = invoicesResult.data?.filter(i => i.balance_amount > 0).reduce((s, i) => s + i.balance_amount, 0) || 0;\n\t\tconst pendingEstimates = estimatesResult.data?.filter(e => [\"sent\", \"viewed\"].includes(e.status)).length || 0;\n\t\tconst activeContracts = contractsResult.data?.filter(c => c.status === \"active\").length || 0;\n\n\t\t// Team role breakdown\n\t\tconst roleBreakdown: Record<string, number> = {};\n\t\tteamResult.data?.forEach(t => {\n\t\t\troleBreakdown[t.role || \"unassigned\"] = (roleBreakdown[t.role || \"unassigned\"] || 0) + 1;\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\toverview: {\n\t\t\t\tcustomers: {\n\t\t\t\t\ttotal: customersResult.count || 0,\n\t\t\t\t\tactive: activeCustomers,\n\t\t\t\t},\n\t\t\t\tteam: {\n\t\t\t\t\ttotal: teamResult.count || 0,\n\t\t\t\t\tactive: activeTeam,\n\t\t\t\t\tbyRole: roleBreakdown,\n\t\t\t\t},\n\t\t\t\tvendors: {\n\t\t\t\t\ttotal: vendorsResult.count || 0,\n\t\t\t\t},\n\t\t\t\tjobs: {\n\t\t\t\t\ttotal: jobsResult.count || 0,\n\t\t\t\t\topen: openJobs,\n\t\t\t\t\tcompleted: completedJobs,\n\t\t\t\t},\n\t\t\t\tinvoices: {\n\t\t\t\t\ttotal: invoicesResult.count || 0,\n\t\t\t\t\tpending: pendingInvoices,\n\t\t\t\t\toutstandingBalance: overdueBalance / 100,\n\t\t\t\t},\n\t\t\t\testimates: {\n\t\t\t\t\ttotal: estimatesResult.count || 0,\n\t\t\t\t\tpending: pendingEstimates,\n\t\t\t\t},\n\t\t\t\tcontracts: {\n\t\t\t\t\ttotal: contractsResult.count || 0,\n\t\t\t\t\tactive: activeContracts,\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\ttotal: propertiesResult.count || 0,\n\t\t\t\t},\n\t\t\t\tequipment: {\n\t\t\t\t\ttotal: equipmentResult.count || 0,\n\t\t\t\t},\n\t\t\t\tappointments: {\n\t\t\t\t\ttotal: appointmentsResult.count || 0,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n});\n\nexport const searchAllEntitesTool = tool({\n\tdescription: \"Search across multiple tables simultaneously using full-text search with relevance ranking. Use for broad searches when you don't know which entity type contains the information.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"Search term - supports multi-word queries and typo tolerance\"),\n\t\tlimit: z.number().optional().default(10).describe(\"Results per table\"),\n\t}),\n\texecute: async ({ query, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Use unified full-text search for better performance and relevance\n\t\tconst searchResults = await searchAllEntities(supabase, companyId, query, { limit });\n\n\t\t// Format results for AI consumption\n\t\tconst results: Record<string, unknown[]> = {};\n\t\tif (searchResults.customers.length > 0) results.customers = searchResults.customers;\n\t\tif (searchResults.jobs.length > 0) results.jobs = searchResults.jobs;\n\t\tif (searchResults.properties.length > 0) results.properties = searchResults.properties;\n\t\tif (searchResults.equipment.length > 0) results.equipment = searchResults.equipment;\n\t\tif (searchResults.priceBookItems.length > 0) results.priceBookItems = searchResults.priceBookItems;\n\n\t\tconst totalResults = Object.values(results).reduce((sum, arr) => sum + arr.length, 0);\n\n\t\treturn { success: true, results, totalResults, query };\n\t},\n});\n\n// ============================================================================\n// CUSTOMER TOOLS\n// ============================================================================\n\nexport const searchCustomersTool = tool({\n\tdescription: \"Search for customers by name, email, phone, or address using full-text search with relevance ranking. Supports multi-word queries and typo tolerance.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"Search query - can be name, email, phone, or address\"),\n\t\tlimit: z.number().optional().default(10).describe(\"Maximum results to return\"),\n\t}),\n\texecute: async ({ query, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Use full-text search for better performance and relevance\n\t\tconst customers = await searchCustomersFullText(supabase, companyId, query, { limit });\n\n\t\treturn { success: true, customers, count: customers.length };\n\t},\n});\n\nexport const getCustomerDetailsTool = tool({\n\tdescription: \"Get detailed information about a specific customer including their jobs, invoices, and communication history\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().describe(\"The UUID of the customer\"),\n\t}),\n\texecute: async ({ customerId }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst [customerResult, jobsResult, invoicesResult] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"*\")\n\t\t\t\t.eq(\"id\", customerId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single(),\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, status, total_amount, scheduled_start\")\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t\t.limit(5),\n\t\t\tsupabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.select(\"id, invoice_number, status, total_amount, balance_amount, due_date\")\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t\t.limit(5),\n\t\t]);\n\n\t\tif (customerResult.error) return { success: false, error: customerResult.error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcustomer: customerResult.data,\n\t\t\trecentJobs: jobsResult.data || [],\n\t\t\trecentInvoices: invoicesResult.data || [],\n\t\t};\n\t},\n});\n\nexport const createCustomerTool = tool({\n\tdescription: \"Create a new customer in the system. Use this when a new customer contacts the business.\",\n\tparameters: z.object({\n\t\tfirstName: z.string().describe(\"Customer's first name\"),\n\t\tlastName: z.string().describe(\"Customer's last name\"),\n\t\temail: z.string().email().describe(\"Customer's email address\"),\n\t\tphone: z.string().describe(\"Customer's phone number\"),\n\t\taddress: z.string().optional().describe(\"Street address\"),\n\t\tcity: z.string().optional().describe(\"City\"),\n\t\tstate: z.string().optional().describe(\"State\"),\n\t\tzipCode: z.string().optional().describe(\"ZIP code\"),\n\t\tsource: z.string().optional().describe(\"How the customer found us (referral, google, etc.)\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tfirst_name: params.firstName,\n\t\t\t\tlast_name: params.lastName,\n\t\t\t\tdisplay_name: `${params.firstName} ${params.lastName}`,\n\t\t\t\temail: params.email,\n\t\t\t\tphone: params.phone,\n\t\t\t\taddress: params.address,\n\t\t\t\tcity: params.city,\n\t\t\t\tstate: params.state,\n\t\t\t\tzip_code: params.zipCode,\n\t\t\t\tsource: params.source,\n\t\t\t\tstatus: \"active\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, customer: data, message: `Created customer ${data.display_name}` };\n\t},\n});\n\nexport const updateCustomerTool = tool({\n\tdescription: \"Update customer information\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().describe(\"Customer ID to update\"),\n\t\tupdates: z.object({\n\t\t\tfirstName: z.string().optional(),\n\t\t\tlastName: z.string().optional(),\n\t\t\temail: z.string().email().optional(),\n\t\t\tphone: z.string().optional(),\n\t\t\taddress: z.string().optional(),\n\t\t\tcity: z.string().optional(),\n\t\t\tstate: z.string().optional(),\n\t\t\tzipCode: z.string().optional(),\n\t\t\tnotes: z.string().optional(),\n\t\t}).describe(\"Fields to update\"),\n\t}),\n\texecute: async ({ customerId, updates }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst updateData: Record<string, unknown> = {};\n\t\tif (updates.firstName) updateData.first_name = updates.firstName;\n\t\tif (updates.lastName) updateData.last_name = updates.lastName;\n\t\tif (updates.email) updateData.email = updates.email;\n\t\tif (updates.phone) updateData.phone = updates.phone;\n\t\tif (updates.address) updateData.address = updates.address;\n\t\tif (updates.city) updateData.city = updates.city;\n\t\tif (updates.state) updateData.state = updates.state;\n\t\tif (updates.zipCode) updateData.zip_code = updates.zipCode;\n\t\tif (updates.notes) updateData.notes = updates.notes;\n\n\t\tif (updates.firstName || updates.lastName) {\n\t\t\tupdateData.display_name = `${updates.firstName || \"\"} ${updates.lastName || \"\"}`.trim();\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, customer: data };\n\t},\n});\n\n// ============================================================================\n// TEAM MEMBER TOOLS\n// ============================================================================\n\nexport const searchTeamMembersTool = tool({\n\tdescription: \"Search for team members by name, role, or department. Use this to find employees to assign or contact.\",\n\tparameters: z.object({\n\t\tquery: z.string().optional().describe(\"Search query - name or email\"),\n\t\trole: z.string().optional().describe(\"Filter by role (technician, admin, manager, etc.)\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ query, role, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"team_members\")\n\t\t\t.select(\"id, first_name, last_name, email, phone, role, department, status, hire_date, avatar_url\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (query) {\n\t\t\tqueryBuilder = queryBuilder.or(`first_name.ilike.%${query}%,last_name.ilike.%${query}%,email.ilike.%${query}%`);\n\t\t}\n\t\tif (role) queryBuilder = queryBuilder.eq(\"role\", role);\n\n\t\tconst { data, error } = await queryBuilder.limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, teamMembers: data, count: data?.length || 0 };\n\t},\n});\n\nexport const getTeamMemberDetailsTool = tool({\n\tdescription: \"Get detailed information about a team member including their schedule and performance\",\n\tparameters: z.object({\n\t\tteamMemberId: z.string().uuid().describe(\"The team member's ID\"),\n\t}),\n\texecute: async ({ teamMemberId }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst [memberResult, jobsResult] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"team_members\")\n\t\t\t\t.select(\"*\")\n\t\t\t\t.eq(\"id\", teamMemberId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single(),\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, status, scheduled_start, total_amount\")\n\t\t\t\t.eq(\"assigned_to\", teamMemberId)\n\t\t\t\t.order(\"scheduled_start\", { ascending: false })\n\t\t\t\t.limit(10),\n\t\t]);\n\n\t\tif (memberResult.error) return { success: false, error: memberResult.error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tteamMember: memberResult.data,\n\t\t\trecentJobs: jobsResult.data || [],\n\t\t};\n\t},\n});\n\nexport const sendTeamEmailTool = tool({\n\tdescription: \"Send an email to a team member for internal communication, assignments, or updates.\",\n\tparameters: z.object({\n\t\tteamMemberId: z.string().uuid().describe(\"Team member ID to send email to\"),\n\t\tsubject: z.string().describe(\"Email subject\"),\n\t\tbody: z.string().describe(\"Email body (HTML supported)\"),\n\t}),\n\texecute: async ({ teamMemberId, subject, body }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Get team member email\n\t\tconst { data: member } = await supabase\n\t\t\t.from(\"team_members\")\n\t\t\t.select(\"email, first_name, last_name\")\n\t\t\t.eq(\"id\", teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!member?.email) return { success: false, error: \"Team member email not found\" };\n\n\t\tconst { resend } = await import(\"@/lib/email/resend-client\");\n\t\tif (!resend) return { success: false, error: \"Email service not configured\" };\n\n\t\tconst { data, error } = await resend.emails.send({\n\t\t\tfrom: process.env.RESEND_FROM_EMAIL || \"noreply@thorbis.com\",\n\t\t\tto: member.email,\n\t\t\tsubject,\n\t\t\thtml: body,\n\t\t});\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\treturn { success: true, messageId: data?.id, message: `Email sent to ${member.first_name} ${member.last_name}` };\n\t},\n});\n\nexport const sendTeamSmsTool = tool({\n\tdescription: \"Send an SMS to a team member for urgent updates or assignments.\",\n\tparameters: z.object({\n\t\tteamMemberId: z.string().uuid().describe(\"Team member ID\"),\n\t\tmessage: z.string().max(160).describe(\"SMS message (max 160 chars)\"),\n\t}),\n\texecute: async ({ teamMemberId, message }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst { data: member } = await supabase\n\t\t\t.from(\"team_members\")\n\t\t\t.select(\"phone, first_name, last_name\")\n\t\t\t.eq(\"id\", teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!member?.phone) return { success: false, error: \"Team member phone not found\" };\n\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"is_primary\", true)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) return { success: false, error: \"No company phone configured\" };\n\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tfrom: phoneNumber.phone_number,\n\t\t\tto: member.phone,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) return { success: false, error: result.error };\n\n\t\treturn { success: true, messageId: result.messageId, message: `SMS sent to ${member.first_name} ${member.last_name}` };\n\t},\n});\n\n// ============================================================================\n// VENDOR TOOLS\n// ============================================================================\n\nexport const searchVendorsTool = tool({\n\tdescription: \"Search for vendors/suppliers by name, category, or status\",\n\tparameters: z.object({\n\t\tquery: z.string().optional().describe(\"Search query - name or contact\"),\n\t\tcategory: z.string().optional().describe(\"Vendor category (supplies, equipment, parts, etc.)\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ query, category, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"id, name, contact_name, email, phone, category, status, account_number, payment_terms\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (query) queryBuilder = queryBuilder.or(`name.ilike.%${query}%,contact_name.ilike.%${query}%`);\n\t\tif (category) queryBuilder = queryBuilder.eq(\"category\", category);\n\n\t\tconst { data, error } = await queryBuilder.limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, vendors: data, count: data?.length || 0 };\n\t},\n});\n\nexport const getVendorDetailsTool = tool({\n\tdescription: \"Get detailed information about a vendor including purchase history\",\n\tparameters: z.object({\n\t\tvendorId: z.string().uuid().describe(\"Vendor ID\"),\n\t}),\n\texecute: async ({ vendorId }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst [vendorResult, purchasesResult] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"vendors\")\n\t\t\t\t.select(\"*\")\n\t\t\t\t.eq(\"id\", vendorId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single(),\n\t\t\tsupabase\n\t\t\t\t.from(\"purchase_orders\")\n\t\t\t\t.select(\"id, po_number, status, total_amount, order_date\")\n\t\t\t\t.eq(\"vendor_id\", vendorId)\n\t\t\t\t.order(\"order_date\", { ascending: false })\n\t\t\t\t.limit(10),\n\t\t]);\n\n\t\tif (vendorResult.error) return { success: false, error: vendorResult.error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tvendor: vendorResult.data,\n\t\t\trecentPurchases: purchasesResult.data || [],\n\t\t};\n\t},\n});\n\nexport const sendVendorEmailTool = tool({\n\tdescription: \"Send an email to a vendor for orders, inquiries, or communication.\",\n\tparameters: z.object({\n\t\tvendorId: z.string().uuid().describe(\"Vendor ID\"),\n\t\tsubject: z.string().describe(\"Email subject\"),\n\t\tbody: z.string().describe(\"Email body\"),\n\t}),\n\texecute: async ({ vendorId, subject, body }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst { data: vendor } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"email, name, contact_name\")\n\t\t\t.eq(\"id\", vendorId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!vendor?.email) return { success: false, error: \"Vendor email not found\" };\n\n\t\tconst { resend } = await import(\"@/lib/email/resend-client\");\n\t\tif (!resend) return { success: false, error: \"Email service not configured\" };\n\n\t\tconst { data, error } = await resend.emails.send({\n\t\t\tfrom: process.env.RESEND_FROM_EMAIL || \"noreply@thorbis.com\",\n\t\t\tto: vendor.email,\n\t\t\tsubject,\n\t\t\thtml: body,\n\t\t});\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\treturn { success: true, messageId: data?.id, message: `Email sent to ${vendor.name}` };\n\t},\n});\n\nexport const sendVendorSmsTool = tool({\n\tdescription: \"Send an SMS to a vendor contact for urgent communication.\",\n\tparameters: z.object({\n\t\tvendorId: z.string().uuid().describe(\"Vendor ID\"),\n\t\tmessage: z.string().max(160).describe(\"SMS message\"),\n\t}),\n\texecute: async ({ vendorId, message }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst { data: vendor } = await supabase\n\t\t\t.from(\"vendors\")\n\t\t\t.select(\"phone, name\")\n\t\t\t.eq(\"id\", vendorId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!vendor?.phone) return { success: false, error: \"Vendor phone not found\" };\n\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"is_primary\", true)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) return { success: false, error: \"No company phone configured\" };\n\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tfrom: phoneNumber.phone_number,\n\t\t\tto: vendor.phone,\n\t\t\ttext: message,\n\t\t});\n\n\t\tif (!result.success) return { success: false, error: result.error };\n\n\t\treturn { success: true, messageId: result.messageId, message: `SMS sent to ${vendor.name}` };\n\t},\n});\n\n// ============================================================================\n// PROPERTY & EQUIPMENT TOOLS\n// ============================================================================\n\nexport const searchPropertiesTool = tool({\n\tdescription: \"Search for service properties by address, customer, or type\",\n\tparameters: z.object({\n\t\tquery: z.string().optional().describe(\"Address or property name search\"),\n\t\tcustomerId: z.string().uuid().optional().describe(\"Filter by customer\"),\n\t\tpropertyType: z.string().optional().describe(\"Property type (residential, commercial, etc.)\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ query, customerId, propertyType, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"id, name, address, city, state, zip_code, property_type, customer:customers(display_name)\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (query) queryBuilder = queryBuilder.or(`address.ilike.%${query}%,name.ilike.%${query}%`);\n\t\tif (customerId) queryBuilder = queryBuilder.eq(\"customer_id\", customerId);\n\t\tif (propertyType) queryBuilder = queryBuilder.eq(\"property_type\", propertyType);\n\n\t\tconst { data, error } = await queryBuilder.limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, properties: data, count: data?.length || 0 };\n\t},\n});\n\nexport const getPropertyDetailsTool = tool({\n\tdescription: \"Get detailed property information including equipment and service history\",\n\tparameters: z.object({\n\t\tpropertyId: z.string().uuid().describe(\"Property ID\"),\n\t}),\n\texecute: async ({ propertyId }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst [propertyResult, equipmentResult, jobsResult] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"*, customer:customers(display_name, phone, email)\")\n\t\t\t\t.eq(\"id\", propertyId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single(),\n\t\t\tsupabase\n\t\t\t\t.from(\"equipment\")\n\t\t\t\t.select(\"id, name, model, serial_number, install_date, warranty_expiry, last_service_date\")\n\t\t\t\t.eq(\"property_id\", propertyId)\n\t\t\t\t.limit(20),\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, status, scheduled_start, completed_at\")\n\t\t\t\t.eq(\"property_id\", propertyId)\n\t\t\t\t.order(\"scheduled_start\", { ascending: false })\n\t\t\t\t.limit(10),\n\t\t]);\n\n\t\tif (propertyResult.error) return { success: false, error: propertyResult.error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tproperty: propertyResult.data,\n\t\t\tequipment: equipmentResult.data || [],\n\t\t\tserviceHistory: jobsResult.data || [],\n\t\t};\n\t},\n});\n\nexport const searchEquipmentTool = tool({\n\tdescription: \"Search for equipment/assets by type, customer, or model\",\n\tparameters: z.object({\n\t\tquery: z.string().optional().describe(\"Equipment name, model, or serial number\"),\n\t\tcustomerId: z.string().uuid().optional(),\n\t\tequipmentType: z.string().optional().describe(\"Equipment type (HVAC, plumbing, electrical, etc.)\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ query, customerId, equipmentType, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"equipment\")\n\t\t\t.select(\"id, name, model, serial_number, equipment_type, install_date, warranty_expiry, last_service_date, property:properties(address, customer:customers(display_name))\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (query) queryBuilder = queryBuilder.or(`name.ilike.%${query}%,model.ilike.%${query}%,serial_number.ilike.%${query}%`);\n\t\tif (equipmentType) queryBuilder = queryBuilder.eq(\"equipment_type\", equipmentType);\n\n\t\tconst { data, error } = await queryBuilder.limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, equipment: data, count: data?.length || 0 };\n\t},\n});\n\nexport const getMaintenanceDueTool = tool({\n\tdescription: \"Get equipment that is due or overdue for maintenance service\",\n\tparameters: z.object({\n\t\tdaysAhead: z.number().optional().default(30).describe(\"Look ahead days for upcoming maintenance\"),\n\t}),\n\texecute: async ({ daysAhead }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst futureDate = new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"equipment\")\n\t\t\t.select(\"id, name, model, last_service_date, next_service_date, property:properties(address, customer:customers(display_name, phone, email))\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.lte(\"next_service_date\", futureDate.toISOString())\n\t\t\t.order(\"next_service_date\", { ascending: true })\n\t\t\t.limit(50);\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\tconst overdue = data?.filter((e) => new Date(e.next_service_date) < new Date()) || [];\n\t\tconst upcoming = data?.filter((e) => new Date(e.next_service_date) >= new Date()) || [];\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\toverdue,\n\t\t\tupcoming,\n\t\t\toverdueCount: overdue.length,\n\t\t\tupcomingCount: upcoming.length,\n\t\t};\n\t},\n});\n\n// ============================================================================\n// JOB/SCHEDULING TOOLS\n// ============================================================================\n\nexport const searchJobsTool = tool({\n\tdescription: \"Search for jobs by title, job number, description, or status using full-text search with relevance ranking. Supports multi-word queries and typo tolerance.\",\n\tparameters: z.object({\n\t\tquery: z.string().optional().describe(\"Search query - searches job number, title, description\"),\n\t\tstatus: z.enum([\"pending\", \"scheduled\", \"in_progress\", \"completed\", \"cancelled\"]).optional(),\n\t\tcustomerId: z.string().uuid().optional(),\n\t\tlimit: z.number().optional().default(10),\n\t}),\n\texecute: async ({ query, status, customerId, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Use full-text search if there's a query\n\t\tif (query && !status && !customerId) {\n\t\t\tconst jobs = await searchJobsFullText(supabase, companyId, query, { limit });\n\t\t\treturn { success: true, jobs, count: jobs.length };\n\t\t}\n\n\t\t// Fall back to filtered query when status/customerId filters are used\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, job_number, title, status, total_amount, scheduled_start, scheduled_end, customer:customers(display_name, phone)\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\tif (query) queryBuilder = queryBuilder.or(`title.ilike.%${query}%,job_number.ilike.%${query}%`);\n\t\tif (status) queryBuilder = queryBuilder.eq(\"status\", status);\n\t\tif (customerId) queryBuilder = queryBuilder.eq(\"customer_id\", customerId);\n\n\t\tconst { data, error } = await queryBuilder.order(\"scheduled_start\", { ascending: false }).limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, jobs: data, count: data?.length || 0 };\n\t},\n});\n\nexport const createAppointmentTool = tool({\n\tdescription: \"Schedule a new appointment for a customer. Use this to book service calls or consultations.\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().describe(\"Customer to schedule for\"),\n\t\tpropertyId: z.string().uuid().describe(\"Property where service will be performed\"),\n\t\ttitle: z.string().describe(\"Appointment title/description\"),\n\t\tstartTime: z.string().describe(\"Start time in ISO format (YYYY-MM-DDTHH:mm:ss)\"),\n\t\tduration: z.number().describe(\"Duration in minutes\"),\n\t\ttype: z.enum([\"service\", \"consultation\", \"estimate\", \"follow_up\"]).default(\"service\"),\n\t\tnotes: z.string().optional().describe(\"Additional notes for the technician\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst startDate = new Date(params.startTime);\n\t\tconst endDate = new Date(startDate.getTime() + params.duration * 60000);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tproperty_id: params.propertyId,\n\t\t\t\ttitle: params.title,\n\t\t\t\tstart_time: startDate.toISOString(),\n\t\t\t\tend_time: endDate.toISOString(),\n\t\t\t\tduration: params.duration,\n\t\t\t\ttype: params.type,\n\t\t\t\tnotes: params.notes,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, appointment: data, message: `Scheduled appointment for ${startDate.toLocaleString()}` };\n\t},\n});\n\nexport const getAvailableSlotsTool = tool({\n\tdescription: \"Find available appointment slots for scheduling. Returns available time windows.\",\n\tparameters: z.object({\n\t\tdate: z.string().describe(\"Date to check (YYYY-MM-DD)\"),\n\t\tduration: z.number().default(60).describe(\"Required duration in minutes\"),\n\t}),\n\texecute: async ({ date, duration }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst targetDate = new Date(date);\n\t\tconst dayStart = new Date(targetDate.setHours(8, 0, 0, 0));\n\t\tconst dayEnd = new Date(targetDate.setHours(18, 0, 0, 0));\n\n\t\t// Get existing appointments for that day\n\t\tconst { data: appointments } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"start_time, end_time\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.gte(\"start_time\", dayStart.toISOString())\n\t\t\t.lte(\"start_time\", dayEnd.toISOString())\n\t\t\t.neq(\"status\", \"cancelled\");\n\n\t\t// Calculate available slots (simplified)\n\t\tconst availableSlots = [];\n\t\tlet currentTime = dayStart;\n\n\t\twhile (currentTime < dayEnd) {\n\t\t\tconst slotEnd = new Date(currentTime.getTime() + duration * 60000);\n\t\t\tconst hasConflict = appointments?.some((apt) => {\n\t\t\t\tconst aptStart = new Date(apt.start_time);\n\t\t\t\tconst aptEnd = new Date(apt.end_time);\n\t\t\t\treturn currentTime < aptEnd && slotEnd > aptStart;\n\t\t\t});\n\n\t\t\tif (!hasConflict && slotEnd <= dayEnd) {\n\t\t\t\tavailableSlots.push({\n\t\t\t\t\tstart: currentTime.toISOString(),\n\t\t\t\t\tend: slotEnd.toISOString(),\n\t\t\t\t});\n\t\t\t}\n\t\t\tcurrentTime = new Date(currentTime.getTime() + 30 * 60000); // 30-minute increments\n\t\t}\n\n\t\treturn { success: true, availableSlots, date };\n\t},\n});\n\n// ============================================================================\n// INVOICE/FINANCIAL TOOLS\n// ============================================================================\n\nexport const searchInvoicesTool = tool({\n\tdescription: \"Search for invoices by number, customer, or status\",\n\tparameters: z.object({\n\t\tquery: z.string().optional(),\n\t\tstatus: z.enum([\"draft\", \"sent\", \"viewed\", \"paid\", \"overdue\", \"cancelled\"]).optional(),\n\t\tcustomerId: z.string().uuid().optional(),\n\t\tlimit: z.number().optional().default(10),\n\t}),\n\texecute: async ({ query, status, customerId, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"id, invoice_number, title, status, total_amount, balance_amount, due_date, customer:customers(display_name)\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (query) queryBuilder = queryBuilder.ilike(\"invoice_number\", `%${query}%`);\n\t\tif (status) queryBuilder = queryBuilder.eq(\"status\", status);\n\t\tif (customerId) queryBuilder = queryBuilder.eq(\"customer_id\", customerId);\n\n\t\tconst { data, error } = await queryBuilder.order(\"created_at\", { ascending: false }).limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, invoices: data, count: data?.length || 0 };\n\t},\n});\n\nexport const createInvoiceTool = tool({\n\tdescription: \"Create a new invoice for a customer\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().describe(\"Customer to invoice\"),\n\t\ttitle: z.string().describe(\"Invoice title/description\"),\n\t\tlineItems: z.array(z.object({\n\t\t\tdescription: z.string(),\n\t\t\tquantity: z.number(),\n\t\t\tunitPrice: z.number().describe(\"Price in cents\"),\n\t\t})).describe(\"Line items for the invoice\"),\n\t\tdueDate: z.string().optional().describe(\"Due date (YYYY-MM-DD)\"),\n\t\tnotes: z.string().optional(),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Calculate totals\n\t\tconst subtotal = params.lineItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);\n\t\tconst taxAmount = Math.round(subtotal * 0.08); // 8% tax example\n\t\tconst totalAmount = subtotal + taxAmount;\n\n\t\t// Generate invoice number\n\t\tconst invoiceNumber = `INV-${Date.now().toString(36).toUpperCase()}`;\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: params.customerId,\n\t\t\t\tinvoice_number: invoiceNumber,\n\t\t\t\ttitle: params.title,\n\t\t\t\tline_items: params.lineItems,\n\t\t\t\tsubtotal,\n\t\t\t\ttax_amount: taxAmount,\n\t\t\t\ttotal_amount: totalAmount,\n\t\t\t\tbalance_amount: totalAmount,\n\t\t\t\tdue_date: params.dueDate ? new Date(params.dueDate).toISOString() : null,\n\t\t\t\tnotes: params.notes,\n\t\t\t\tstatus: \"draft\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tinvoice: data,\n\t\t\tmessage: `Created invoice ${invoiceNumber} for $${(totalAmount / 100).toFixed(2)}`,\n\t\t};\n\t},\n});\n\nexport const getFinancialSummaryTool = tool({\n\tdescription: \"Get a financial summary including revenue, outstanding balances, and trends. Use this to provide business advice.\",\n\tparameters: z.object({\n\t\tperiod: z.enum([\"today\", \"week\", \"month\", \"quarter\", \"year\"]).default(\"month\"),\n\t}),\n\texecute: async ({ period }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst now = new Date();\n\t\tlet startDate: Date;\n\n\t\tswitch (period) {\n\t\t\tcase \"today\":\n\t\t\t\tstartDate = new Date(now.setHours(0, 0, 0, 0));\n\t\t\t\tbreak;\n\t\t\tcase \"week\":\n\t\t\t\tstartDate = new Date(now.setDate(now.getDate() - 7));\n\t\t\t\tbreak;\n\t\t\tcase \"month\":\n\t\t\t\tstartDate = new Date(now.setMonth(now.getMonth() - 1));\n\t\t\t\tbreak;\n\t\t\tcase \"quarter\":\n\t\t\t\tstartDate = new Date(now.setMonth(now.getMonth() - 3));\n\t\t\t\tbreak;\n\t\t\tcase \"year\":\n\t\t\t\tstartDate = new Date(now.setFullYear(now.getFullYear() - 1));\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst [invoicesResult, paymentsResult, overdueResult] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.select(\"total_amount, paid_amount, balance_amount, status\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.gte(\"created_at\", startDate.toISOString()),\n\t\t\tsupabase\n\t\t\t\t.from(\"payments\")\n\t\t\t\t.select(\"amount\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"status\", \"completed\")\n\t\t\t\t.gte(\"created_at\", startDate.toISOString()),\n\t\t\tsupabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.select(\"id, invoice_number, balance_amount, due_date, customer:customers(display_name)\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"status\", \"sent\")\n\t\t\t\t.lt(\"due_date\", new Date().toISOString())\n\t\t\t\t.gt(\"balance_amount\", 0),\n\t\t]);\n\n\t\tconst totalInvoiced = invoicesResult.data?.reduce((sum, inv) => sum + inv.total_amount, 0) || 0;\n\t\tconst totalCollected = paymentsResult.data?.reduce((sum, pay) => sum + pay.amount, 0) || 0;\n\t\tconst totalOutstanding = invoicesResult.data?.reduce((sum, inv) => sum + inv.balance_amount, 0) || 0;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tperiod,\n\t\t\tsummary: {\n\t\t\t\ttotalInvoiced: totalInvoiced / 100,\n\t\t\t\ttotalCollected: totalCollected / 100,\n\t\t\t\ttotalOutstanding: totalOutstanding / 100,\n\t\t\t\tinvoiceCount: invoicesResult.data?.length || 0,\n\t\t\t\tcollectionRate: totalInvoiced > 0 ? ((totalCollected / totalInvoiced) * 100).toFixed(1) : 0,\n\t\t\t},\n\t\t\toverdueInvoices: overdueResult.data || [],\n\t\t};\n\t},\n});\n\nexport const getVirtualBucketsTool = tool({\n\tdescription: \"Get virtual financial buckets for the company. These are savings goals and fund allocations.\",\n\tparameters: z.object({}),\n\texecute: async (_params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"finance_virtual_buckets\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"is_active\", true);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, buckets: data };\n\t},\n});\n\nexport const transferToBucketTool = tool({\n\tdescription: \"Transfer funds to a virtual bucket for savings goals. This is for financial planning.\",\n\tparameters: z.object({\n\t\tbucketId: z.string().uuid().describe(\"Target bucket ID\"),\n\t\tamount: z.number().describe(\"Amount to transfer in cents\"),\n\t\tnote: z.string().optional().describe(\"Note for the transfer\"),\n\t}),\n\texecute: async ({ bucketId, amount, note }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Update bucket balance\n\t\tconst { data: bucket, error: fetchError } = await supabase\n\t\t\t.from(\"finance_virtual_buckets\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", bucketId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !bucket) return { success: false, error: \"Bucket not found\" };\n\n\t\tconst newBalance = (bucket.current_balance || 0) + amount;\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"finance_virtual_buckets\")\n\t\t\t.update({\n\t\t\t\tcurrent_balance: newBalance,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", bucketId);\n\n\t\tif (updateError) return { success: false, error: updateError.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Transferred $${(amount / 100).toFixed(2)} to ${bucket.name}. New balance: $${(newBalance / 100).toFixed(2)}`,\n\t\t\tbucket: { ...bucket, current_balance: newBalance },\n\t\t};\n\t},\n});\n\n// ============================================================================\n// COMMUNICATION TOOLS\n// ============================================================================\n\nexport const sendEmailTool = tool({\n\tdescription: \"Send an email to a customer. Use this for follow-ups, reminders, or responding to inquiries.\",\n\tparameters: z.object({\n\t\tto: z.string().email().describe(\"Recipient email address\"),\n\t\tsubject: z.string().describe(\"Email subject line\"),\n\t\tbody: z.string().describe(\"Email body content (HTML supported)\"),\n\t\tcustomerId: z.string().uuid().optional().describe(\"Associated customer ID for tracking\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\t// Import Resend dynamically to avoid issues\n\t\tconst { resend } = await import(\"@/lib/email/resend-client\");\n\n\t\tif (!resend) {\n\t\t\treturn { success: false, error: \"Email service not configured\" };\n\t\t}\n\n\t\tconst { data, error } = await resend.emails.send({\n\t\t\tfrom: process.env.RESEND_FROM_EMAIL || \"noreply@thorbis.com\",\n\t\t\tto: params.to,\n\t\t\tsubject: params.subject,\n\t\t\thtml: params.body,\n\t\t});\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\t// Log communication\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tawait supabase.from(\"communications\").insert({\n\t\t\tcompany_id: companyId,\n\t\t\tcustomer_id: params.customerId,\n\t\t\ttype: \"email\",\n\t\t\tdirection: \"outbound\",\n\t\t\tto_address: params.to,\n\t\t\tsubject: params.subject,\n\t\t\tbody: params.body,\n\t\t\tbody_html: params.body,\n\t\t\tstatus: \"sent\",\n\t\t\tsent_at: new Date().toISOString(),\n\t\t\tprovider_message_id: data?.id,\n\t\t});\n\n\t\treturn { success: true, messageId: data?.id, message: `Email sent to ${params.to}` };\n\t},\n});\n\nexport const sendSmsTool = tool({\n\tdescription: \"Send an SMS text message to a customer. Use for appointment reminders or quick updates.\",\n\tparameters: z.object({\n\t\tto: z.string().describe(\"Phone number (format: +1XXXXXXXXXX)\"),\n\t\tmessage: z.string().max(160).describe(\"Message content (max 160 characters)\"),\n\t\tcustomerId: z.string().uuid().optional().describe(\"Associated customer ID\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\t// Get company phone number\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number, telnyx_connection_id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"is_primary\", true)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) {\n\t\t\treturn { success: false, error: \"No phone number configured for company\" };\n\t\t}\n\n\t\t// Send via Telnyx\n\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\tconst result = await sendSMS({\n\t\t\tfrom: phoneNumber.phone_number,\n\t\t\tto: params.to,\n\t\t\ttext: params.message,\n\t\t});\n\n\t\tif (!result.success) return { success: false, error: result.error };\n\n\t\t// Log communication\n\t\tawait supabase.from(\"communications\").insert({\n\t\t\tcompany_id: companyId,\n\t\t\tcustomer_id: params.customerId,\n\t\t\ttype: \"sms\",\n\t\t\tdirection: \"outbound\",\n\t\t\tto_address: params.to,\n\t\t\tbody: params.message,\n\t\t\tstatus: \"sent\",\n\t\t\tsent_at: new Date().toISOString(),\n\t\t\ttelnyx_message_id: result.messageId,\n\t\t});\n\n\t\treturn { success: true, messageId: result.messageId, message: `SMS sent to ${params.to}` };\n\t},\n});\n\nexport const initiateCallTool = tool({\n\tdescription: \"Initiate a phone call to a customer. The call will be connected through the business phone system.\",\n\tparameters: z.object({\n\t\tto: z.string().describe(\"Phone number to call (format: +1XXXXXXXXXX)\"),\n\t\tcustomerId: z.string().uuid().optional().describe(\"Associated customer ID\"),\n\t\treason: z.string().optional().describe(\"Reason for the call (for logging)\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Get company phone configuration\n\t\tconst { data: phoneNumber } = await supabase\n\t\t\t.from(\"phone_numbers\")\n\t\t\t.select(\"phone_number, telnyx_connection_id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"is_primary\", true)\n\t\t\t.single();\n\n\t\tif (!phoneNumber) {\n\t\t\treturn { success: false, error: \"No phone number configured\" };\n\t\t}\n\n\t\t// Initiate call via Telnyx\n\t\tconst { initiateCall } = await import(\"@/lib/telnyx/calls\");\n\t\tconst result = await initiateCall({\n\t\t\tconnectionId: phoneNumber.telnyx_connection_id,\n\t\t\tfrom: phoneNumber.phone_number,\n\t\t\tto: params.to,\n\t\t});\n\n\t\tif (!result.success) return { success: false, error: result.error };\n\n\t\t// Log communication\n\t\tawait supabase.from(\"communications\").insert({\n\t\t\tcompany_id: companyId,\n\t\t\tcustomer_id: params.customerId,\n\t\t\ttype: \"call\",\n\t\t\tdirection: \"outbound\",\n\t\t\tto_address: params.to,\n\t\t\tfrom_address: phoneNumber.phone_number,\n\t\t\tbody: params.reason || \"Outbound call\",\n\t\t\tstatus: \"pending\",\n\t\t\ttelnyx_call_control_id: result.callControlId,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcallControlId: result.callControlId,\n\t\t\tmessage: `Call initiated to ${params.to}`,\n\t\t};\n\t},\n});\n\nexport const getCommunicationHistoryTool = tool({\n\tdescription: \"Get communication history with a customer (calls, texts, emails)\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().describe(\"Customer ID to get history for\"),\n\t\ttype: z.enum([\"all\", \"email\", \"sms\", \"call\"]).optional().default(\"all\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ customerId, type, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"customer_id\", customerId);\n\n\t\tif (type !== \"all\") queryBuilder = queryBuilder.eq(\"type\", type);\n\n\t\tconst { data, error } = await queryBuilder\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, communications: data };\n\t},\n});\n\n// ============================================================================\n// REPORTING/ANALYTICS TOOLS\n// ============================================================================\n\nexport const getDashboardMetricsTool = tool({\n\tdescription: \"Get key business metrics for the dashboard. Use this to provide business insights and recommendations.\",\n\tparameters: z.object({}),\n\texecute: async (_params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst now = new Date();\n\t\tconst thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));\n\n\t\tconst [customersResult, jobsResult, invoicesResult] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\", { count: \"exact\", head: true })\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"status\", \"active\"),\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, status, total_amount\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.gte(\"created_at\", thirtyDaysAgo.toISOString()),\n\t\t\tsupabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.select(\"id, total_amount, balance_amount, status\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.gte(\"created_at\", thirtyDaysAgo.toISOString()),\n\t\t]);\n\n\t\tconst completedJobs = jobsResult.data?.filter((j) => j.status === \"completed\") || [];\n\t\tconst overdueInvoices = invoicesResult.data?.filter((i) => i.status === \"sent\" && i.balance_amount > 0) || [];\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmetrics: {\n\t\t\t\tactiveCustomers: customersResult.count || 0,\n\t\t\t\tjobsLast30Days: jobsResult.data?.length || 0,\n\t\t\t\tcompletedJobsLast30Days: completedJobs.length,\n\t\t\t\tjobCompletionRate: jobsResult.data?.length\n\t\t\t\t\t? ((completedJobs.length / jobsResult.data.length) * 100).toFixed(1)\n\t\t\t\t\t: 0,\n\t\t\t\tinvoicesLast30Days: invoicesResult.data?.length || 0,\n\t\t\t\toverdueInvoiceCount: overdueInvoices.length,\n\t\t\t\ttotalOutstanding: overdueInvoices.reduce((sum, i) => sum + i.balance_amount, 0) / 100,\n\t\t\t},\n\t\t};\n\t},\n});\n\nexport const getProactiveInsightsTool = tool({\n\tdescription: \"Get proactive business insights and recommendations. Use this to help owners make decisions.\",\n\tparameters: z.object({}),\n\texecute: async (_params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Get various insights\n\t\tconst [overdueResult, inactiveCustomersResult, upcomingAppointmentsResult] = await Promise.all([\n\t\t\t// Overdue invoices\n\t\t\tsupabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.select(\"id, invoice_number, balance_amount, due_date, customer:customers(display_name, phone, email)\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"status\", \"sent\")\n\t\t\t\t.lt(\"due_date\", new Date().toISOString())\n\t\t\t\t.gt(\"balance_amount\", 0)\n\t\t\t\t.limit(5),\n\t\t\t// Customers inactive for 90+ days\n\t\t\tsupabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id, display_name, phone, email, last_job_date\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"status\", \"active\")\n\t\t\t\t.lt(\"last_job_date\", new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString())\n\t\t\t\t.limit(5),\n\t\t\t// Tomorrow's appointments\n\t\t\tsupabase\n\t\t\t\t.from(\"appointments\")\n\t\t\t\t.select(\"id, title, start_time, customer:customers(display_name, phone)\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"status\", \"scheduled\")\n\t\t\t\t.gte(\"start_time\", new Date().toISOString())\n\t\t\t\t.lt(\"start_time\", new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString())\n\t\t\t\t.limit(10),\n\t\t]);\n\n\t\tconst insights = [];\n\n\t\tif (overdueResult.data && overdueResult.data.length > 0) {\n\t\t\tconst totalOverdue = overdueResult.data.reduce((sum, inv) => sum + inv.balance_amount, 0);\n\t\t\tinsights.push({\n\t\t\t\ttype: \"overdue_invoices\",\n\t\t\t\tseverity: \"high\",\n\t\t\t\ttitle: `${overdueResult.data.length} overdue invoices totaling $${(totalOverdue / 100).toFixed(2)}`,\n\t\t\t\trecommendation: \"Consider sending payment reminders or initiating collection calls\",\n\t\t\t\tdata: overdueResult.data,\n\t\t\t});\n\t\t}\n\n\t\tif (inactiveCustomersResult.data && inactiveCustomersResult.data.length > 0) {\n\t\t\tinsights.push({\n\t\t\t\ttype: \"inactive_customers\",\n\t\t\t\tseverity: \"medium\",\n\t\t\t\ttitle: `${inactiveCustomersResult.data.length} customers haven't had service in 90+ days`,\n\t\t\t\trecommendation: \"Send re-engagement emails or offer maintenance service promotions\",\n\t\t\t\tdata: inactiveCustomersResult.data,\n\t\t\t});\n\t\t}\n\n\t\tif (upcomingAppointmentsResult.data && upcomingAppointmentsResult.data.length > 0) {\n\t\t\tinsights.push({\n\t\t\t\ttype: \"upcoming_appointments\",\n\t\t\t\tseverity: \"info\",\n\t\t\t\ttitle: `${upcomingAppointmentsResult.data.length} appointments scheduled for tomorrow`,\n\t\t\t\trecommendation: \"Consider sending reminder messages to customers\",\n\t\t\t\tdata: upcomingAppointmentsResult.data,\n\t\t\t});\n\t\t}\n\n\t\treturn { success: true, insights };\n\t},\n});\n\n// ============================================================================\n// REMINDER/NOTIFICATION TOOLS\n// ============================================================================\n\nexport const scheduleReminderTool = tool({\n\tdescription: \"Schedule a reminder email or SMS to be sent at a specific time. Use for appointment reminders, payment reminders, or follow-ups.\",\n\tparameters: z.object({\n\t\trecipientType: z.enum([\"customer\", \"team_member\", \"vendor\"]).describe(\"Type of recipient\"),\n\t\trecipientId: z.string().uuid().describe(\"ID of the recipient\"),\n\t\tchannel: z.enum([\"email\", \"sms\", \"both\"]).describe(\"Communication channel\"),\n\t\tsubject: z.string().optional().describe(\"Email subject (for email channel)\"),\n\t\tmessage: z.string().describe(\"Message content\"),\n\t\tsendAt: z.string().describe(\"When to send (ISO format)\"),\n\t\trelatedTo: z.object({\n\t\t\ttype: z.enum([\"job\", \"invoice\", \"appointment\", \"estimate\"]).optional(),\n\t\t\tid: z.string().uuid().optional(),\n\t\t}).optional().describe(\"Related entity\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Get recipient details based on type\n\t\tlet recipientEmail: string | null = null;\n\t\tlet recipientPhone: string | null = null;\n\t\tlet recipientName = \"\";\n\n\t\tif (params.recipientType === \"customer\") {\n\t\t\tconst { data } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"email, phone, display_name\")\n\t\t\t\t.eq(\"id\", params.recipientId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single();\n\t\t\tif (data) {\n\t\t\t\trecipientEmail = data.email;\n\t\t\t\trecipientPhone = data.phone;\n\t\t\t\trecipientName = data.display_name;\n\t\t\t}\n\t\t} else if (params.recipientType === \"team_member\") {\n\t\t\tconst { data } = await supabase\n\t\t\t\t.from(\"team_members\")\n\t\t\t\t.select(\"email, phone, first_name, last_name\")\n\t\t\t\t.eq(\"id\", params.recipientId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single();\n\t\t\tif (data) {\n\t\t\t\trecipientEmail = data.email;\n\t\t\t\trecipientPhone = data.phone;\n\t\t\t\trecipientName = `${data.first_name} ${data.last_name}`;\n\t\t\t}\n\t\t} else if (params.recipientType === \"vendor\") {\n\t\t\tconst { data } = await supabase\n\t\t\t\t.from(\"vendors\")\n\t\t\t\t.select(\"email, phone, name\")\n\t\t\t\t.eq(\"id\", params.recipientId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single();\n\t\t\tif (data) {\n\t\t\t\trecipientEmail = data.email;\n\t\t\t\trecipientPhone = data.phone;\n\t\t\t\trecipientName = data.name;\n\t\t\t}\n\t\t}\n\n\t\tif (!recipientEmail && !recipientPhone) {\n\t\t\treturn { success: false, error: \"Recipient contact information not found\" };\n\t\t}\n\n\t\t// Create scheduled notification\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"scheduled_notifications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\trecipient_type: params.recipientType,\n\t\t\t\trecipient_id: params.recipientId,\n\t\t\t\trecipient_name: recipientName,\n\t\t\t\trecipient_email: recipientEmail,\n\t\t\t\trecipient_phone: recipientPhone,\n\t\t\t\tchannel: params.channel,\n\t\t\t\tsubject: params.subject,\n\t\t\t\tmessage: params.message,\n\t\t\t\tscheduled_at: params.sendAt,\n\t\t\t\trelated_type: params.relatedTo?.type,\n\t\t\t\trelated_id: params.relatedTo?.id,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\treminder: data,\n\t\t\tmessage: `Reminder scheduled for ${recipientName} at ${new Date(params.sendAt).toLocaleString()}`,\n\t\t};\n\t},\n});\n\nexport const cancelReminderTool = tool({\n\tdescription: \"Cancel a scheduled reminder\",\n\tparameters: z.object({\n\t\treminderId: z.string().uuid().describe(\"ID of the reminder to cancel\"),\n\t}),\n\texecute: async ({ reminderId }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"scheduled_notifications\")\n\t\t\t.update({ status: \"cancelled\" })\n\t\t\t.eq(\"id\", reminderId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, message: \"Reminder cancelled successfully\" };\n\t},\n});\n\nexport const getScheduledRemindersTool = tool({\n\tdescription: \"Get list of scheduled reminders for a customer, job, or entity\",\n\tparameters: z.object({\n\t\trecipientType: z.enum([\"customer\", \"team_member\", \"vendor\"]).optional(),\n\t\trecipientId: z.string().uuid().optional(),\n\t\trelatedType: z.enum([\"job\", \"invoice\", \"appointment\", \"estimate\"]).optional(),\n\t\trelatedId: z.string().uuid().optional(),\n\t\tstatus: z.enum([\"scheduled\", \"sent\", \"cancelled\", \"failed\"]).optional().default(\"scheduled\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"scheduled_notifications\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (params.recipientType) queryBuilder = queryBuilder.eq(\"recipient_type\", params.recipientType);\n\t\tif (params.recipientId) queryBuilder = queryBuilder.eq(\"recipient_id\", params.recipientId);\n\t\tif (params.relatedType) queryBuilder = queryBuilder.eq(\"related_type\", params.relatedType);\n\t\tif (params.relatedId) queryBuilder = queryBuilder.eq(\"related_id\", params.relatedId);\n\t\tif (params.status) queryBuilder = queryBuilder.eq(\"status\", params.status);\n\n\t\tconst { data, error } = await queryBuilder.order(\"scheduled_at\", { ascending: true });\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, reminders: data, count: data?.length || 0 };\n\t},\n});\n\nexport const sendImmediateNotificationTool = tool({\n\tdescription: \"Send an immediate notification to a customer, team member, or vendor. Use for urgent updates.\",\n\tparameters: z.object({\n\t\trecipientType: z.enum([\"customer\", \"team_member\", \"vendor\"]).describe(\"Type of recipient\"),\n\t\trecipientId: z.string().uuid().describe(\"ID of the recipient\"),\n\t\tchannel: z.enum([\"email\", \"sms\", \"both\"]).describe(\"Communication channel\"),\n\t\tsubject: z.string().optional().describe(\"Email subject\"),\n\t\tmessage: z.string().describe(\"Message content\"),\n\t\tpriority: z.enum([\"normal\", \"high\", \"urgent\"]).optional().default(\"normal\"),\n\t}),\n\texecute: async (params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst results: { email?: { success: boolean; messageId?: string; error?: string }; sms?: { success: boolean; messageId?: string; error?: string } } = {};\n\n\t\t// Get recipient details\n\t\tlet recipientEmail: string | null = null;\n\t\tlet recipientPhone: string | null = null;\n\t\tlet recipientName = \"\";\n\n\t\tif (params.recipientType === \"customer\") {\n\t\t\tconst { data } = await supabase.from(\"customers\").select(\"email, phone, display_name\").eq(\"id\", params.recipientId).single();\n\t\t\tif (data) { recipientEmail = data.email; recipientPhone = data.phone; recipientName = data.display_name; }\n\t\t} else if (params.recipientType === \"team_member\") {\n\t\t\tconst { data } = await supabase.from(\"team_members\").select(\"email, phone, first_name, last_name\").eq(\"id\", params.recipientId).single();\n\t\t\tif (data) { recipientEmail = data.email; recipientPhone = data.phone; recipientName = `${data.first_name} ${data.last_name}`; }\n\t\t} else if (params.recipientType === \"vendor\") {\n\t\t\tconst { data } = await supabase.from(\"vendors\").select(\"email, phone, name\").eq(\"id\", params.recipientId).single();\n\t\t\tif (data) { recipientEmail = data.email; recipientPhone = data.phone; recipientName = data.name; }\n\t\t}\n\n\t\t// Send email if requested\n\t\tif ((params.channel === \"email\" || params.channel === \"both\") && recipientEmail) {\n\t\t\tconst { resend } = await import(\"@/lib/email/resend-client\");\n\t\t\tif (resend) {\n\t\t\t\tconst { data, error } = await resend.emails.send({\n\t\t\t\t\tfrom: process.env.RESEND_FROM_EMAIL || \"noreply@thorbis.com\",\n\t\t\t\t\tto: recipientEmail,\n\t\t\t\t\tsubject: params.subject || \"Notification\",\n\t\t\t\t\thtml: params.message,\n\t\t\t\t});\n\t\t\t\tresults.email = error ? { success: false, error: error.message } : { success: true, messageId: data?.id };\n\t\t\t}\n\t\t}\n\n\t\t// Send SMS if requested\n\t\tif ((params.channel === \"sms\" || params.channel === \"both\") && recipientPhone) {\n\t\t\tconst { data: phoneNumber } = await supabase.from(\"phone_numbers\").select(\"phone_number\").eq(\"company_id\", companyId).eq(\"is_primary\", true).single();\n\t\t\tif (phoneNumber) {\n\t\t\t\tconst { sendSMS } = await import(\"@/lib/telnyx/messaging\");\n\t\t\t\tconst result = await sendSMS({ from: phoneNumber.phone_number, to: recipientPhone, text: params.message.slice(0, 160) });\n\t\t\t\tresults.sms = result.success ? { success: true, messageId: result.messageId } : { success: false, error: result.error };\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true, results, message: `Notification sent to ${recipientName}` };\n\t},\n});\n\n// ============================================================================\n// ENHANCED REPORTING TOOLS\n// ============================================================================\n\nexport const getJobCostingReportTool = tool({\n\tdescription: \"Get detailed job costing report including labor, materials, and profit margins\",\n\tparameters: z.object({\n\t\tjobId: z.string().uuid().optional().describe(\"Specific job ID, or omit for summary\"),\n\t\tperiod: z.enum([\"week\", \"month\", \"quarter\", \"year\"]).optional().default(\"month\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ jobId, period, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tif (jobId) {\n\t\t\t// Single job costing\n\t\t\tconst { data: job, error } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"*, customer:customers(display_name), line_items, labor_cost, material_cost, total_amount\")\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single();\n\n\t\t\tif (error) return { success: false, error: error.message };\n\n\t\t\tconst laborCost = job?.labor_cost || 0;\n\t\t\tconst materialCost = job?.material_cost || 0;\n\t\t\tconst totalRevenue = job?.total_amount || 0;\n\t\t\tconst profit = totalRevenue - laborCost - materialCost;\n\t\t\tconst margin = totalRevenue > 0 ? (profit / totalRevenue) * 100 : 0;\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tjob: {\n\t\t\t\t\t...job,\n\t\t\t\t\tcosting: {\n\t\t\t\t\t\tlaborCost: laborCost / 100,\n\t\t\t\t\t\tmaterialCost: materialCost / 100,\n\t\t\t\t\t\ttotalCost: (laborCost + materialCost) / 100,\n\t\t\t\t\t\trevenue: totalRevenue / 100,\n\t\t\t\t\t\tprofit: profit / 100,\n\t\t\t\t\t\tmarginPercent: margin.toFixed(1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Period summary\n\t\tconst now = new Date();\n\t\tlet startDate: Date;\n\t\tswitch (period) {\n\t\t\tcase \"week\": startDate = new Date(now.setDate(now.getDate() - 7)); break;\n\t\t\tcase \"month\": startDate = new Date(now.setMonth(now.getMonth() - 1)); break;\n\t\t\tcase \"quarter\": startDate = new Date(now.setMonth(now.getMonth() - 3)); break;\n\t\t\tcase \"year\": startDate = new Date(now.setFullYear(now.getFullYear() - 1)); break;\n\t\t}\n\n\t\tconst { data: jobs } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, title, labor_cost, material_cost, total_amount, status, completed_at, customer:customers(display_name)\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"completed\")\n\t\t\t.gte(\"completed_at\", startDate.toISOString())\n\t\t\t.order(\"completed_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tconst summary = {\n\t\t\ttotalJobs: jobs?.length || 0,\n\t\t\ttotalRevenue: (jobs?.reduce((s, j) => s + (j.total_amount || 0), 0) || 0) / 100,\n\t\t\ttotalLaborCost: (jobs?.reduce((s, j) => s + (j.labor_cost || 0), 0) || 0) / 100,\n\t\t\ttotalMaterialCost: (jobs?.reduce((s, j) => s + (j.material_cost || 0), 0) || 0) / 100,\n\t\t\ttotalProfit: 0,\n\t\t\taverageMargin: 0,\n\t\t};\n\t\tsummary.totalProfit = summary.totalRevenue - summary.totalLaborCost - summary.totalMaterialCost;\n\t\tsummary.averageMargin = summary.totalRevenue > 0 ? (summary.totalProfit / summary.totalRevenue) * 100 : 0;\n\n\t\treturn { success: true, period, summary, jobs };\n\t},\n});\n\nexport const getRevenueBreakdownTool = tool({\n\tdescription: \"Get revenue breakdown by customer, service type, or time period\",\n\tparameters: z.object({\n\t\tgroupBy: z.enum([\"customer\", \"service_type\", \"month\", \"week\"]).default(\"month\"),\n\t\tperiod: z.enum([\"month\", \"quarter\", \"year\"]).default(\"quarter\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ groupBy, period, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst now = new Date();\n\t\tlet startDate: Date;\n\t\tswitch (period) {\n\t\t\tcase \"month\": startDate = new Date(now.setMonth(now.getMonth() - 1)); break;\n\t\t\tcase \"quarter\": startDate = new Date(now.setMonth(now.getMonth() - 3)); break;\n\t\t\tcase \"year\": startDate = new Date(now.setFullYear(now.getFullYear() - 1)); break;\n\t\t}\n\n\t\tconst { data: invoices } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"id, total_amount, paid_amount, created_at, customer:customers(id, display_name), job:jobs(service_type)\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"paid\")\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\t// Group data\n\t\tconst breakdown: Record<string, { label: string; revenue: number; count: number }> = {};\n\n\t\tinvoices?.forEach((inv) => {\n\t\t\tlet key = \"\";\n\t\t\tlet label = \"\";\n\n\t\t\tif (groupBy === \"customer\") {\n\t\t\t\tkey = inv.customer?.id || \"unknown\";\n\t\t\t\tlabel = inv.customer?.display_name || \"Unknown\";\n\t\t\t} else if (groupBy === \"service_type\") {\n\t\t\t\tkey = inv.job?.service_type || \"general\";\n\t\t\t\tlabel = inv.job?.service_type || \"General\";\n\t\t\t} else if (groupBy === \"month\") {\n\t\t\t\tconst date = new Date(inv.created_at);\n\t\t\t\tkey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, \"0\")}`;\n\t\t\t\tlabel = date.toLocaleDateString(\"en-US\", { year: \"numeric\", month: \"short\" });\n\t\t\t} else if (groupBy === \"week\") {\n\t\t\t\tconst date = new Date(inv.created_at);\n\t\t\t\tconst weekStart = new Date(date.setDate(date.getDate() - date.getDay()));\n\t\t\t\tkey = weekStart.toISOString().split(\"T\")[0];\n\t\t\t\tlabel = `Week of ${weekStart.toLocaleDateString()}`;\n\t\t\t}\n\n\t\t\tif (!breakdown[key]) breakdown[key] = { label, revenue: 0, count: 0 };\n\t\t\tbreakdown[key].revenue += (inv.paid_amount || 0) / 100;\n\t\t\tbreakdown[key].count += 1;\n\t\t});\n\n\t\tconst results = Object.values(breakdown).sort((a, b) => b.revenue - a.revenue).slice(0, limit);\n\t\tconst totalRevenue = results.reduce((s, r) => s + r.revenue, 0);\n\n\t\treturn { success: true, groupBy, period, breakdown: results, totalRevenue };\n\t},\n});\n\nexport const getARAgingReportTool = tool({\n\tdescription: \"Get accounts receivable aging report showing outstanding invoices by age (30/60/90+ days)\",\n\tparameters: z.object({}),\n\texecute: async (_params, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst now = new Date();\n\n\t\tconst { data: invoices } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"id, invoice_number, balance_amount, due_date, created_at, customer:customers(display_name, phone, email)\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.in(\"status\", [\"sent\", \"viewed\"])\n\t\t\t.gt(\"balance_amount\", 0);\n\n\t\tconst aging = {\n\t\t\tcurrent: { amount: 0, count: 0, invoices: [] as typeof invoices },\n\t\t\tdays30: { amount: 0, count: 0, invoices: [] as typeof invoices },\n\t\t\tdays60: { amount: 0, count: 0, invoices: [] as typeof invoices },\n\t\t\tdays90Plus: { amount: 0, count: 0, invoices: [] as typeof invoices },\n\t\t};\n\n\t\tinvoices?.forEach((inv) => {\n\t\t\tconst dueDate = new Date(inv.due_date);\n\t\t\tconst daysOverdue = Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));\n\n\t\t\tif (daysOverdue <= 0) {\n\t\t\t\taging.current.amount += inv.balance_amount;\n\t\t\t\taging.current.count += 1;\n\t\t\t\taging.current.invoices?.push(inv);\n\t\t\t} else if (daysOverdue <= 30) {\n\t\t\t\taging.days30.amount += inv.balance_amount;\n\t\t\t\taging.days30.count += 1;\n\t\t\t\taging.days30.invoices?.push(inv);\n\t\t\t} else if (daysOverdue <= 60) {\n\t\t\t\taging.days60.amount += inv.balance_amount;\n\t\t\t\taging.days60.count += 1;\n\t\t\t\taging.days60.invoices?.push(inv);\n\t\t\t} else {\n\t\t\t\taging.days90Plus.amount += inv.balance_amount;\n\t\t\t\taging.days90Plus.count += 1;\n\t\t\t\taging.days90Plus.invoices?.push(inv);\n\t\t\t}\n\t\t});\n\n\t\t// Convert to dollars\n\t\tObject.keys(aging).forEach((key) => {\n\t\t\taging[key as keyof typeof aging].amount = aging[key as keyof typeof aging].amount / 100;\n\t\t});\n\n\t\tconst totalOutstanding = aging.current.amount + aging.days30.amount + aging.days60.amount + aging.days90Plus.amount;\n\n\t\treturn { success: true, aging, totalOutstanding, totalInvoices: invoices?.length || 0 };\n\t},\n});\n\nexport const getTeamPerformanceReportTool = tool({\n\tdescription: \"Get team member performance metrics including jobs completed, revenue generated, and ratings\",\n\tparameters: z.object({\n\t\tteamMemberId: z.string().uuid().optional().describe(\"Specific team member, or omit for all\"),\n\t\tperiod: z.enum([\"week\", \"month\", \"quarter\", \"year\"]).default(\"month\"),\n\t}),\n\texecute: async ({ teamMemberId, period }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst now = new Date();\n\t\tlet startDate: Date;\n\t\tswitch (period) {\n\t\t\tcase \"week\": startDate = new Date(now.setDate(now.getDate() - 7)); break;\n\t\t\tcase \"month\": startDate = new Date(now.setMonth(now.getMonth() - 1)); break;\n\t\t\tcase \"quarter\": startDate = new Date(now.setMonth(now.getMonth() - 3)); break;\n\t\t\tcase \"year\": startDate = new Date(now.setFullYear(now.getFullYear() - 1)); break;\n\t\t}\n\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"id, assigned_to, status, total_amount, completed_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.gte(\"created_at\", startDate.toISOString());\n\n\t\tif (teamMemberId) queryBuilder = queryBuilder.eq(\"assigned_to\", teamMemberId);\n\n\t\tconst { data: jobs } = await queryBuilder;\n\t\tconst { data: teamMembers } = await supabase\n\t\t\t.from(\"team_members\")\n\t\t\t.select(\"id, first_name, last_name, role\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\t// Aggregate by team member\n\t\tconst performance: Record<string, {\n\t\t\tname: string;\n\t\t\trole: string;\n\t\t\tjobsAssigned: number;\n\t\t\tjobsCompleted: number;\n\t\t\tcompletionRate: number;\n\t\t\trevenue: number;\n\t\t}> = {};\n\n\t\tteamMembers?.forEach((tm) => {\n\t\t\tperformance[tm.id] = {\n\t\t\t\tname: `${tm.first_name} ${tm.last_name}`,\n\t\t\t\trole: tm.role,\n\t\t\t\tjobsAssigned: 0,\n\t\t\t\tjobsCompleted: 0,\n\t\t\t\tcompletionRate: 0,\n\t\t\t\trevenue: 0,\n\t\t\t};\n\t\t});\n\n\t\tjobs?.forEach((job) => {\n\t\t\tif (job.assigned_to && performance[job.assigned_to]) {\n\t\t\t\tperformance[job.assigned_to].jobsAssigned += 1;\n\t\t\t\tif (job.status === \"completed\") {\n\t\t\t\t\tperformance[job.assigned_to].jobsCompleted += 1;\n\t\t\t\t\tperformance[job.assigned_to].revenue += (job.total_amount || 0) / 100;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Calculate completion rates\n\t\tObject.values(performance).forEach((p) => {\n\t\t\tp.completionRate = p.jobsAssigned > 0 ? (p.jobsCompleted / p.jobsAssigned) * 100 : 0;\n\t\t});\n\n\t\tconst results = Object.values(performance).sort((a, b) => b.revenue - a.revenue);\n\n\t\treturn { success: true, period, performance: results };\n\t},\n});\n\nexport const getCustomerLifetimeValueTool = tool({\n\tdescription: \"Get customer lifetime value (CLV) analysis showing total revenue and engagement per customer\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().optional().describe(\"Specific customer, or omit for top customers\"),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ customerId, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tif (customerId) {\n\t\t\t// Single customer CLV\n\t\t\tconst [customerResult, invoicesResult, jobsResult] = await Promise.all([\n\t\t\t\tsupabase.from(\"customers\").select(\"*\").eq(\"id\", customerId).eq(\"company_id\", companyId).single(),\n\t\t\t\tsupabase.from(\"invoices\").select(\"total_amount, paid_amount, status, created_at\").eq(\"customer_id\", customerId),\n\t\t\t\tsupabase.from(\"jobs\").select(\"id, status, completed_at\").eq(\"customer_id\", customerId),\n\t\t\t]);\n\n\t\t\tif (customerResult.error) return { success: false, error: customerResult.error.message };\n\n\t\t\tconst totalRevenue = (invoicesResult.data?.filter((i) => i.status === \"paid\").reduce((s, i) => s + (i.paid_amount || 0), 0) || 0) / 100;\n\t\t\tconst jobCount = jobsResult.data?.length || 0;\n\t\t\tconst firstInvoice = invoicesResult.data?.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime())[0];\n\t\t\tconst customerSince = firstInvoice ? new Date(firstInvoice.created_at) : new Date(customerResult.data.created_at);\n\t\t\tconst monthsAsCustomer = Math.max(1, Math.floor((Date.now() - customerSince.getTime()) / (1000 * 60 * 60 * 24 * 30)));\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tcustomer: customerResult.data,\n\t\t\t\tclv: {\n\t\t\t\t\ttotalRevenue,\n\t\t\t\t\tjobCount,\n\t\t\t\t\taverageJobValue: jobCount > 0 ? totalRevenue / jobCount : 0,\n\t\t\t\t\tcustomerSince: customerSince.toISOString(),\n\t\t\t\t\tmonthsAsCustomer,\n\t\t\t\t\tmonthlyAverageRevenue: totalRevenue / monthsAsCustomer,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Top customers by CLV\n\t\tconst { data: customers } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, display_name, total_revenue, job_count, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tconst clvData = customers?.map((c) => ({\n\t\t\t...c,\n\t\t\ttotalRevenue: (c.total_revenue || 0) / 100,\n\t\t\taverageJobValue: c.job_count > 0 ? (c.total_revenue || 0) / 100 / c.job_count : 0,\n\t\t}));\n\n\t\treturn { success: true, topCustomers: clvData };\n\t},\n});\n\n// ============================================================================\n// ESTIMATE & CONTRACT TOOLS\n// ============================================================================\n\nexport const searchEstimatesTool = tool({\n\tdescription: \"Search for estimates by customer, status, or amount\",\n\tparameters: z.object({\n\t\tquery: z.string().optional(),\n\t\tstatus: z.enum([\"draft\", \"sent\", \"viewed\", \"approved\", \"rejected\", \"expired\"]).optional(),\n\t\tcustomerId: z.string().uuid().optional(),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ query, status, customerId, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"id, estimate_number, title, status, total_amount, valid_until, customer:customers(display_name)\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (query) queryBuilder = queryBuilder.ilike(\"estimate_number\", `%${query}%`);\n\t\tif (status) queryBuilder = queryBuilder.eq(\"status\", status);\n\t\tif (customerId) queryBuilder = queryBuilder.eq(\"customer_id\", customerId);\n\n\t\tconst { data, error } = await queryBuilder.order(\"created_at\", { ascending: false }).limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, estimates: data, count: data?.length || 0 };\n\t},\n});\n\nexport const searchContractsTool = tool({\n\tdescription: \"Search for contracts by customer, status, or type\",\n\tparameters: z.object({\n\t\tquery: z.string().optional(),\n\t\tstatus: z.enum([\"draft\", \"sent\", \"active\", \"expired\", \"cancelled\"]).optional(),\n\t\tcustomerId: z.string().uuid().optional(),\n\t\tlimit: z.number().optional().default(20),\n\t}),\n\texecute: async ({ query, status, customerId, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tlet queryBuilder = supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.select(\"id, contract_number, title, status, total_value, start_date, end_date, customer:customers(display_name)\")\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (query) queryBuilder = queryBuilder.ilike(\"contract_number\", `%${query}%`);\n\t\tif (status) queryBuilder = queryBuilder.eq(\"status\", status);\n\t\tif (customerId) queryBuilder = queryBuilder.eq(\"customer_id\", customerId);\n\n\t\tconst { data, error } = await queryBuilder.order(\"created_at\", { ascending: false }).limit(limit);\n\n\t\tif (error) return { success: false, error: error.message };\n\t\treturn { success: true, contracts: data, count: data?.length || 0 };\n\t},\n});\n\n// ============================================================================\n// EXPORT ALL TOOLS\n// ============================================================================\n\nexport const aiAgentTools = {\n\t// Universal Database Access tools\n\tlistDatabaseTables: listDatabaseTablesTool,\n\tqueryDatabase: queryDatabaseTool,\n\tgetRecordById: getRecordByIdTool,\n\tgetRelatedRecords: getRelatedRecordsTool,\n\tgetCompanyOverview: getCompanyOverviewTool,\n\tsearchAllEntities: searchAllEntitesTool,\n\n\t// Customer tools\n\tsearchCustomers: searchCustomersTool,\n\tgetCustomerDetails: getCustomerDetailsTool,\n\tcreateCustomer: createCustomerTool,\n\tupdateCustomer: updateCustomerTool,\n\n\t// Team Member tools\n\tsearchTeamMembers: searchTeamMembersTool,\n\tgetTeamMemberDetails: getTeamMemberDetailsTool,\n\tsendTeamEmail: sendTeamEmailTool,\n\tsendTeamSms: sendTeamSmsTool,\n\n\t// Vendor tools\n\tsearchVendors: searchVendorsTool,\n\tgetVendorDetails: getVendorDetailsTool,\n\tsendVendorEmail: sendVendorEmailTool,\n\tsendVendorSms: sendVendorSmsTool,\n\n\t// Property & Equipment tools\n\tsearchProperties: searchPropertiesTool,\n\tgetPropertyDetails: getPropertyDetailsTool,\n\tsearchEquipment: searchEquipmentTool,\n\tgetMaintenanceDue: getMaintenanceDueTool,\n\n\t// Job/Scheduling tools\n\tsearchJobs: searchJobsTool,\n\tcreateAppointment: createAppointmentTool,\n\tgetAvailableSlots: getAvailableSlotsTool,\n\n\t// Invoice/Financial tools\n\tsearchInvoices: searchInvoicesTool,\n\tcreateInvoice: createInvoiceTool,\n\tgetFinancialSummary: getFinancialSummaryTool,\n\tgetVirtualBuckets: getVirtualBucketsTool,\n\ttransferToBucket: transferToBucketTool,\n\n\t// Communication tools\n\tsendEmail: sendEmailTool,\n\tsendSms: sendSmsTool,\n\tinitiateCall: initiateCallTool,\n\tgetCommunicationHistory: getCommunicationHistoryTool,\n\n\t// Reminder/Notification tools\n\tscheduleReminder: scheduleReminderTool,\n\tcancelReminder: cancelReminderTool,\n\tgetScheduledReminders: getScheduledRemindersTool,\n\tsendImmediateNotification: sendImmediateNotificationTool,\n\n\t// Enhanced Reporting tools\n\tgetJobCostingReport: getJobCostingReportTool,\n\tgetRevenueBreakdown: getRevenueBreakdownTool,\n\tgetARAgingReport: getARAgingReportTool,\n\tgetTeamPerformanceReport: getTeamPerformanceReportTool,\n\tgetCustomerLifetimeValue: getCustomerLifetimeValueTool,\n\tgetDashboardMetrics: getDashboardMetricsTool,\n\tgetProactiveInsights: getProactiveInsightsTool,\n\n\t// Estimate & Contract tools\n\tsearchEstimates: searchEstimatesTool,\n\tsearchContracts: searchContractsTool,\n};\n\n// Tool category mapping for permission checking\nexport const toolCategories: Record<string, ToolCategory> = {\n\t// Universal Database Access (read-only, reporting category)\n\tlistDatabaseTables: \"reporting\",\n\tqueryDatabase: \"reporting\",\n\tgetRecordById: \"reporting\",\n\tgetRelatedRecords: \"reporting\",\n\tgetCompanyOverview: \"reporting\",\n\tsearchAllEntities: \"reporting\",\n\n\t// Customer\n\tsearchCustomers: \"customer\",\n\tgetCustomerDetails: \"customer\",\n\tcreateCustomer: \"customer\",\n\tupdateCustomer: \"customer\",\n\n\t// Team\n\tsearchTeamMembers: \"team\",\n\tgetTeamMemberDetails: \"team\",\n\tsendTeamEmail: \"team\",\n\tsendTeamSms: \"team\",\n\n\t// Vendor\n\tsearchVendors: \"vendor\",\n\tgetVendorDetails: \"vendor\",\n\tsendVendorEmail: \"vendor\",\n\tsendVendorSms: \"vendor\",\n\n\t// Property & Equipment\n\tsearchProperties: \"property\",\n\tgetPropertyDetails: \"property\",\n\tsearchEquipment: \"equipment\",\n\tgetMaintenanceDue: \"equipment\",\n\n\t// Scheduling\n\tsearchJobs: \"scheduling\",\n\tcreateAppointment: \"scheduling\",\n\tgetAvailableSlots: \"scheduling\",\n\n\t// Financial\n\tsearchInvoices: \"financial\",\n\tcreateInvoice: \"financial\",\n\tgetFinancialSummary: \"reporting\",\n\tgetVirtualBuckets: \"financial\",\n\ttransferToBucket: \"financial\",\n\n\t// Communication\n\tsendEmail: \"communication\",\n\tsendSms: \"communication\",\n\tinitiateCall: \"communication\",\n\tgetCommunicationHistory: \"communication\",\n\n\t// Notifications\n\tscheduleReminder: \"notification\",\n\tcancelReminder: \"notification\",\n\tgetScheduledReminders: \"notification\",\n\tsendImmediateNotification: \"notification\",\n\n\t// Reporting\n\tgetJobCostingReport: \"reporting\",\n\tgetRevenueBreakdown: \"reporting\",\n\tgetARAgingReport: \"reporting\",\n\tgetTeamPerformanceReport: \"reporting\",\n\tgetCustomerLifetimeValue: \"reporting\",\n\tgetDashboardMetrics: \"reporting\",\n\tgetProactiveInsights: \"reporting\",\n\n\t// Estimates & Contracts\n\tsearchEstimates: \"financial\",\n\tsearchContracts: \"financial\",\n};\n\n// ============================================================================\n// DESTRUCTIVE TOOLS - Require Owner Approval\n// These tools perform actions that cannot be easily undone or have significant impact\n// ============================================================================\n\nexport type DestructiveActionType =\n\t| \"delete\"\n\t| \"bulk_update\"\n\t| \"bulk_delete\"\n\t| \"archive\"\n\t| \"financial\"\n\t| \"send_communication\";\n\nexport type RiskLevel = \"low\" | \"medium\" | \"high\" | \"critical\";\n\nexport interface DestructiveToolMetadata {\n\tisDestructive: true;\n\tactionType: DestructiveActionType;\n\triskLevel: RiskLevel;\n\trequiresOwnerApproval: boolean;\n\tdescription: string;\n\taffectedEntityType: string;\n}\n\n// ============================================================================\n// SEMANTIC MEMORY TOOLS\n// ============================================================================\n\n/**\n * Store a fact or preference about an entity (customer, job, property, etc.)\n * This enables long-term semantic memory across conversations.\n */\nexport const storeMemoryTool = tool({\n\tdescription: \"Store a fact, preference, or important information about an entity (customer, job, property, etc.) for future reference. Use this to remember important details that should persist across conversations.\",\n\tparameters: z.object({\n\t\tcontent: z.string().describe(\"The fact or information to remember\"),\n\t\tmemoryType: z.enum([\"fact\", \"preference\", \"interaction\", \"context\", \"entity\", \"procedure\", \"feedback\"]).describe(\"Type of memory\"),\n\t\tentityType: z.enum([\"customer\", \"job\", \"property\", \"equipment\", \"invoice\", \"estimate\", \"team_member\"]).optional().describe(\"Type of entity this memory relates to\"),\n\t\tentityId: z.string().uuid().optional().describe(\"ID of the related entity\"),\n\t\timportance: z.enum([\"low\", \"medium\", \"high\"]).default(\"medium\").describe(\"How important is this memory\"),\n\t\ttags: z.array(z.string()).optional().describe(\"Tags to categorize the memory\"),\n\t}),\n\texecute: async ({ content, memoryType, entityType, entityId, importance, tags }, { companyId, userId }: { companyId: string; userId?: string }) => {\n\t\tconst { storeMemory } = await import(\"./memory-service\");\n\n\t\tconst importanceScore = { low: 0.3, medium: 0.6, high: 0.9 }[importance];\n\n\t\tconst memoryId = await storeMemory(companyId, userId || \"system\", {\n\t\t\tcontent,\n\t\t\tmemoryType,\n\t\t\tentityType,\n\t\t\tentityId,\n\t\t\timportance: importanceScore,\n\t\t\ttags,\n\t\t\tsourceType: \"agent\",\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Memory stored successfully`,\n\t\t\tmemoryId,\n\t\t\tsummary: `Remembered: \"${content.substring(0, 50)}...\"`,\n\t\t};\n\t},\n});\n\n/**\n * Search semantic memories using natural language\n */\nexport const searchMemoriesTool = tool({\n\tdescription: \"Search through stored memories using natural language. Use this to recall facts, preferences, or context about customers, jobs, or other entities.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"Natural language search query (e.g., 'customer preferences for Johnson family')\"),\n\t\tentityType: z.enum([\"customer\", \"job\", \"property\", \"equipment\", \"invoice\", \"estimate\", \"team_member\"]).optional().describe(\"Filter to specific entity type\"),\n\t\tentityId: z.string().uuid().optional().describe(\"Filter to specific entity\"),\n\t\tmemoryTypes: z.array(z.enum([\"fact\", \"preference\", \"interaction\", \"context\", \"entity\", \"procedure\", \"feedback\"])).optional().describe(\"Filter by memory types\"),\n\t\tlimit: z.number().optional().default(5).describe(\"Max memories to return\"),\n\t}),\n\texecute: async ({ query, entityType, entityId, memoryTypes, limit }, { companyId }: { companyId: string }) => {\n\t\tconst { searchMemories } = await import(\"./memory-service\");\n\n\t\tconst results = await searchMemories(companyId, query, {\n\t\t\tentityType,\n\t\t\tentityId,\n\t\t\tmemoryTypes,\n\t\t\tlimit,\n\t\t\tminSimilarity: 0.5,\n\t\t});\n\n\t\tif (results.length === 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"No relevant memories found\",\n\t\t\t\tmemories: [],\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Found ${results.length} relevant memories`,\n\t\t\tmemories: results.map(m => ({\n\t\t\t\tcontent: m.content,\n\t\t\t\ttype: m.memoryType,\n\t\t\t\trelevance: Math.round(m.similarity * 100) + \"%\",\n\t\t\t\tentityType: m.entityType,\n\t\t\t\tcreatedAt: m.createdAt,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Get all memories for a specific entity\n */\nexport const getEntityMemoriesTool = tool({\n\tdescription: \"Retrieve all stored memories about a specific entity (customer, job, property, etc.). Use this before interacting with a customer or job to get full context.\",\n\tparameters: z.object({\n\t\tentityType: z.enum([\"customer\", \"job\", \"property\", \"equipment\", \"invoice\", \"estimate\", \"team_member\"]).describe(\"Type of entity\"),\n\t\tentityId: z.string().uuid().describe(\"Entity ID\"),\n\t\tmemoryTypes: z.array(z.enum([\"fact\", \"preference\", \"interaction\", \"context\", \"entity\", \"procedure\", \"feedback\"])).optional().describe(\"Filter by memory types\"),\n\t\tlimit: z.number().optional().default(20).describe(\"Max memories to return\"),\n\t}),\n\texecute: async ({ entityType, entityId, memoryTypes, limit }, { companyId }: { companyId: string }) => {\n\t\tconst { getEntityMemories } = await import(\"./memory-service\");\n\n\t\tconst memories = await getEntityMemories(companyId, entityType, entityId, {\n\t\t\ttypes: memoryTypes,\n\t\t\tlimit,\n\t\t});\n\n\t\tif (memories.length === 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `No memories stored for this ${entityType}`,\n\t\t\t\tmemories: [],\n\t\t\t};\n\t\t}\n\n\t\t// Group by type for better presentation\n\t\tconst grouped: Record<string, Array<{ content: string; importance: number }>> = {};\n\t\tfor (const m of memories) {\n\t\t\tif (!grouped[m.memory_type]) grouped[m.memory_type] = [];\n\t\t\tgrouped[m.memory_type].push({\n\t\t\t\tcontent: m.content,\n\t\t\t\timportance: m.importance,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Found ${memories.length} memories for ${entityType}`,\n\t\t\tmemoriesByType: grouped,\n\t\t\ttotalCount: memories.length,\n\t\t};\n\t},\n});\n\n/**\n * Recall relevant context for current conversation\n */\nexport const recallContextTool = tool({\n\tdescription: \"Automatically recall relevant memories and context based on what's being discussed. Use this at the start of conversations or when switching topics to get background information.\",\n\tparameters: z.object({\n\t\ttopic: z.string().describe(\"The current topic or context (e.g., 'scheduling job for Smith residence', 'invoice payment issue')\"),\n\t\tcustomerName: z.string().optional().describe(\"Customer name if known\"),\n\t\tjobId: z.string().uuid().optional().describe(\"Job ID if discussing a specific job\"),\n\t}),\n\texecute: async ({ topic, customerName, jobId }, { companyId }: { companyId: string }) => {\n\t\tconst { searchMemories } = await import(\"./memory-service\");\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst context: {\n\t\t\tmemories: Array<{ content: string; type: string; relevance: string }>;\n\t\t\tcustomer?: { id: string; name: string; notes?: string };\n\t\t\tjob?: { id: string; title: string; status: string };\n\t\t} = {\n\t\t\tmemories: [],\n\t\t};\n\n\t\t// Search for relevant memories\n\t\tconst memories = await searchMemories(companyId, topic, {\n\t\t\tlimit: 5,\n\t\t\tminSimilarity: 0.4,\n\t\t});\n\n\t\tcontext.memories = memories.map(m => ({\n\t\t\tcontent: m.content,\n\t\t\ttype: m.memoryType,\n\t\t\trelevance: Math.round(m.similarity * 100) + \"%\",\n\t\t}));\n\n\t\t// If customer name provided, try to find them\n\t\tif (customerName) {\n\t\t\tconst { data: customer } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id, name, notes\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.ilike(\"name\", `%${customerName}%`)\n\t\t\t\t.limit(1)\n\t\t\t\t.single();\n\n\t\t\tif (customer) {\n\t\t\t\tcontext.customer = customer;\n\n\t\t\t\t// Get customer-specific memories\n\t\t\t\tconst customerMemories = await searchMemories(companyId, `${customerName} customer preferences`, {\n\t\t\t\t\tentityType: \"customer\",\n\t\t\t\t\tentityId: customer.id,\n\t\t\t\t\tlimit: 3,\n\t\t\t\t});\n\n\t\t\t\tfor (const m of customerMemories) {\n\t\t\t\t\tif (!context.memories.some(cm => cm.content === m.content)) {\n\t\t\t\t\t\tcontext.memories.push({\n\t\t\t\t\t\t\tcontent: m.content,\n\t\t\t\t\t\t\ttype: m.memoryType,\n\t\t\t\t\t\t\trelevance: Math.round(m.similarity * 100) + \"%\",\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If job ID provided, get job details\n\t\tif (jobId) {\n\t\t\tconst { data: job } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, status, description\")\n\t\t\t\t.eq(\"id\", jobId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single();\n\n\t\t\tif (job) {\n\t\t\t\tcontext.job = { id: job.id, title: job.title, status: job.status };\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttopic,\n\t\t\tcontext,\n\t\t\tsummary: context.memories.length > 0\n\t\t\t\t? `Found ${context.memories.length} relevant memories for context`\n\t\t\t\t: \"No specific memories found, but retrieved available entity info\",\n\t\t};\n\t},\n});\n\n// ============================================================================\n// COMMUNICATION LEARNING TOOLS\n// ============================================================================\n\n/**\n * Search across all communications (calls, emails, SMS) using full-text search\n */\nexport const searchCommunicationsFullTextTool = tool({\n\tdescription: \"Search across all customer communications (calls, emails, SMS) to find specific conversations, topics, or issues discussed. Great for finding 'what did the customer say about...'\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"Search query (e.g., 'water heater issue', 'preferred time morning')\"),\n\t\tchannel: z.enum([\"email\", \"sms\", \"call\", \"all\"]).optional().default(\"all\").describe(\"Filter by communication channel\"),\n\t\tcustomerId: z.string().uuid().optional().describe(\"Filter to specific customer\"),\n\t\tdirection: z.enum([\"inbound\", \"outbound\", \"all\"]).optional().default(\"all\").describe(\"Filter by direction\"),\n\t\tlimit: z.number().optional().default(10).describe(\"Max results\"),\n\t}),\n\texecute: async ({ query, channel, customerId, direction, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tlet dbQuery = supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(`\n\t\t\t\tid, type, channel, direction, subject, body_plain,\n\t\t\t\tcall_transcript, call_sentiment, from_name, to_name,\n\t\t\t\tcustomer_id, created_at,\n\t\t\t\tcustomer:customers(id, name)\n\t\t\t`)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\t// Apply filters\n\t\tif (channel !== \"all\") {\n\t\t\tdbQuery = dbQuery.eq(\"channel\", channel);\n\t\t}\n\t\tif (customerId) {\n\t\t\tdbQuery = dbQuery.eq(\"customer_id\", customerId);\n\t\t}\n\t\tif (direction !== \"all\") {\n\t\t\tdbQuery = dbQuery.eq(\"direction\", direction);\n\t\t}\n\n\t\t// Full-text search on body and transcript\n\t\tdbQuery = dbQuery.or(`body_plain.ilike.%${query}%,call_transcript.ilike.%${query}%,subject.ilike.%${query}%`);\n\n\t\tconst { data, error } = await dbQuery;\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Found ${data?.length || 0} communications matching \"${query}\"`,\n\t\t\tresults: data?.map(c => ({\n\t\t\t\tid: c.id,\n\t\t\t\tchannel: c.channel,\n\t\t\t\tdirection: c.direction,\n\t\t\t\tsubject: c.subject,\n\t\t\t\tpreview: (c.body_plain || c.call_transcript || \"\").substring(0, 200),\n\t\t\t\tsentiment: c.call_sentiment,\n\t\t\t\tcustomerName: c.customer?.name,\n\t\t\t\tdate: c.created_at,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Get call transcript with AI-extracted insights\n */\nexport const getCallTranscriptTool = tool({\n\tdescription: \"Get the full transcript of a phone call along with extracted insights. Use when you need to review what was discussed in a specific call.\",\n\tparameters: z.object({\n\t\tcommunicationId: z.string().uuid().describe(\"The communication ID of the call\"),\n\t}),\n\texecute: async ({ communicationId }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(`\n\t\t\t\tid, type, channel, direction, call_duration, call_transcript,\n\t\t\t\tcall_sentiment, call_recording_url, from_name, to_name,\n\t\t\t\tcustomer_id, created_at,\n\t\t\t\tcustomer:customers(id, name, email, phone)\n\t\t\t`)\n\t\t\t.eq(\"id\", communicationId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error) return { success: false, error: error.message };\n\t\tif (!data?.call_transcript) {\n\t\t\treturn { success: false, error: \"No transcript available for this communication\" };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcall: {\n\t\t\t\tid: data.id,\n\t\t\t\tdirection: data.direction,\n\t\t\t\tduration: data.call_duration ? `${Math.floor(data.call_duration / 60)}m ${data.call_duration % 60}s` : \"Unknown\",\n\t\t\t\tsentiment: data.call_sentiment,\n\t\t\t\tcustomerName: data.customer?.name,\n\t\t\t\tdate: data.created_at,\n\t\t\t\ttranscript: data.call_transcript,\n\t\t\t\thasRecording: !!data.call_recording_url,\n\t\t\t},\n\t\t};\n\t},\n});\n\n/**\n * Search voicemail transcriptions\n */\nexport const searchVoicemailTranscriptsTool = tool({\n\tdescription: \"Search through voicemail transcriptions to find messages about specific topics or from specific customers.\",\n\tparameters: z.object({\n\t\tquery: z.string().optional().describe(\"Search query for transcription content\"),\n\t\tcustomerId: z.string().uuid().optional().describe(\"Filter to specific customer\"),\n\t\turgentOnly: z.boolean().optional().default(false).describe(\"Only show urgent voicemails\"),\n\t\tunreadOnly: z.boolean().optional().default(false).describe(\"Only show unread voicemails\"),\n\t\tlimit: z.number().optional().default(10).describe(\"Max results\"),\n\t}),\n\texecute: async ({ query, customerId, urgentOnly, unreadOnly, limit }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tlet dbQuery = supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.select(`\n\t\t\t\tid, from_number, duration, transcription, transcription_confidence,\n\t\t\t\tis_read, is_urgent, received_at, customer_id,\n\t\t\t\tcustomer:customers(id, name)\n\t\t\t`)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"received_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (customerId) {\n\t\t\tdbQuery = dbQuery.eq(\"customer_id\", customerId);\n\t\t}\n\t\tif (urgentOnly) {\n\t\t\tdbQuery = dbQuery.eq(\"is_urgent\", true);\n\t\t}\n\t\tif (unreadOnly) {\n\t\t\tdbQuery = dbQuery.eq(\"is_read\", false);\n\t\t}\n\t\tif (query) {\n\t\t\tdbQuery = dbQuery.ilike(\"transcription\", `%${query}%`);\n\t\t}\n\n\t\tconst { data, error } = await dbQuery;\n\n\t\tif (error) return { success: false, error: error.message };\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Found ${data?.length || 0} voicemails`,\n\t\t\tvoicemails: data?.map(v => ({\n\t\t\t\tid: v.id,\n\t\t\t\tfrom: v.from_number,\n\t\t\t\tcustomerName: v.customer?.name,\n\t\t\t\tduration: v.duration ? `${Math.floor(v.duration / 60)}m ${v.duration % 60}s` : \"Unknown\",\n\t\t\t\ttranscription: v.transcription,\n\t\t\t\tconfidence: v.transcription_confidence,\n\t\t\t\tisUrgent: v.is_urgent,\n\t\t\t\tisRead: v.is_read,\n\t\t\t\treceivedAt: v.received_at,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Get all recent communications for a customer\n */\nexport const getCustomerCommunicationHistoryTool = tool({\n\tdescription: \"Get the complete communication history for a customer including calls, emails, SMS, and voicemails. Use this to understand the full context of a customer relationship.\",\n\tparameters: z.object({\n\t\tcustomerId: z.string().uuid().describe(\"Customer UUID\"),\n\t\tdays: z.number().optional().default(90).describe(\"Look back this many days\"),\n\t\tincludeTranscripts: z.boolean().optional().default(false).describe(\"Include full call transcripts\"),\n\t}),\n\texecute: async ({ customerId, days, includeTranscripts }, { companyId }: { companyId: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\t\tconst cutoffDate = new Date();\n\t\tcutoffDate.setDate(cutoffDate.getDate() - days);\n\n\t\t// Get communications\n\t\tconst { data: comms, error: commsError } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(`\n\t\t\t\tid, type, channel, direction, subject, body_plain,\n\t\t\t\tcall_transcript, call_sentiment, call_duration,\n\t\t\t\tfrom_name, to_name, created_at, status\n\t\t\t`)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gte(\"created_at\", cutoffDate.toISOString())\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Get voicemails\n\t\tconst { data: voicemails, error: vmError } = await supabase\n\t\t\t.from(\"voicemails\")\n\t\t\t.select(\"id, from_number, duration, transcription, is_urgent, received_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gte(\"received_at\", cutoffDate.toISOString())\n\t\t\t.order(\"received_at\", { ascending: false });\n\n\t\tif (commsError) return { success: false, error: commsError.message };\n\n\t\t// Summarize by channel\n\t\tconst summary = {\n\t\t\temails: comms?.filter(c => c.channel === \"email\").length || 0,\n\t\t\tcalls: comms?.filter(c => c.channel === \"call\").length || 0,\n\t\t\tsms: comms?.filter(c => c.channel === \"sms\").length || 0,\n\t\t\tvoicemails: voicemails?.length || 0,\n\t\t};\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcustomerId,\n\t\t\tperiod: `Last ${days} days`,\n\t\t\tsummary,\n\t\t\tcommunications: comms?.map(c => ({\n\t\t\t\tid: c.id,\n\t\t\t\tchannel: c.channel,\n\t\t\t\tdirection: c.direction,\n\t\t\t\tsubject: c.subject,\n\t\t\t\tpreview: includeTranscripts\n\t\t\t\t\t? (c.body_plain || c.call_transcript || \"\").substring(0, 500)\n\t\t\t\t\t: (c.body_plain || c.call_transcript || \"\").substring(0, 100),\n\t\t\t\tsentiment: c.call_sentiment,\n\t\t\t\tdate: c.created_at,\n\t\t\t})),\n\t\t\tvoicemails: voicemails?.map(v => ({\n\t\t\t\tid: v.id,\n\t\t\t\tduration: v.duration,\n\t\t\t\ttranscription: v.transcription?.substring(0, 200),\n\t\t\t\tisUrgent: v.is_urgent,\n\t\t\t\tdate: v.received_at,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Extract and store insights from a communication\n */\nexport const extractCommunicationInsightsTool = tool({\n\tdescription: \"Analyze a communication (call, email, SMS) and extract key insights like customer preferences, issues, sentiment. Automatically stores insights in memory for future reference.\",\n\tparameters: z.object({\n\t\tcommunicationId: z.string().uuid().describe(\"Communication ID to analyze\"),\n\t\tinsightTypes: z.array(z.enum([\"preference\", \"issue\", \"sentiment\", \"action_item\", \"feedback\"])).optional().describe(\"Types of insights to extract\"),\n\t}),\n\texecute: async ({ communicationId, insightTypes }, { companyId, userId }: { companyId: string; userId?: string }) => {\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Get the communication\n\t\tconst { data: comm, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(`\n\t\t\t\tid, channel, direction, subject, body_plain, call_transcript,\n\t\t\t\tcall_sentiment, customer_id,\n\t\t\t\tcustomer:customers(id, name)\n\t\t\t`)\n\t\t\t.eq(\"id\", communicationId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error || !comm) {\n\t\t\treturn { success: false, error: \"Communication not found\" };\n\t\t}\n\n\t\tconst content = comm.body_plain || comm.call_transcript || \"\";\n\t\tif (!content) {\n\t\t\treturn { success: false, error: \"No content to analyze\" };\n\t\t}\n\n\t\t// Extract insights using pattern matching (basic implementation)\n\t\tconst insights: Array<{ type: string; content: string; importance: string }> = [];\n\n\t\t// Look for preferences (morning, afternoon, specific days, etc.)\n\t\tconst preferencePatterns = [\n\t\t\t/prefer[s]?\\s+(morning|afternoon|evening|weekend|monday|tuesday|wednesday|thursday|friday)/gi,\n\t\t\t/best\\s+time[s]?\\s+(?:is|are|would be)\\s+([^.]+)/gi,\n\t\t\t/don'?t\\s+(?:like|want|prefer)\\s+([^.]+)/gi,\n\t\t];\n\n\t\tfor (const pattern of preferencePatterns) {\n\t\t\tconst matches = content.matchAll(pattern);\n\t\t\tfor (const match of matches) {\n\t\t\t\tinsights.push({\n\t\t\t\t\ttype: \"preference\",\n\t\t\t\t\tcontent: `Customer prefers: ${match[0]}`,\n\t\t\t\t\timportance: \"medium\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Look for issues/complaints\n\t\tconst issuePatterns = [\n\t\t\t/problem[s]?\\s+with\\s+([^.]+)/gi,\n\t\t\t/issue[s]?\\s+with\\s+([^.]+)/gi,\n\t\t\t/not\\s+working\\s+([^.]+)/gi,\n\t\t\t/broken\\s+([^.]+)/gi,\n\t\t];\n\n\t\tfor (const pattern of issuePatterns) {\n\t\t\tconst matches = content.matchAll(pattern);\n\t\t\tfor (const match of matches) {\n\t\t\t\tinsights.push({\n\t\t\t\t\ttype: \"issue\",\n\t\t\t\t\tcontent: `Reported issue: ${match[0]}`,\n\t\t\t\t\timportance: \"high\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Store insights in memory if customer is linked\n\t\tif (comm.customer_id && insights.length > 0) {\n\t\t\tconst { storeMemory } = await import(\"./memory-service\");\n\n\t\t\tfor (const insight of insights) {\n\t\t\t\tawait storeMemory(companyId, userId || \"system\", {\n\t\t\t\t\tcontent: insight.content,\n\t\t\t\t\tmemoryType: insight.type as \"preference\" | \"feedback\",\n\t\t\t\t\tentityType: \"customer\",\n\t\t\t\t\tentityId: comm.customer_id,\n\t\t\t\t\timportance: insight.importance === \"high\" ? 0.9 : 0.6,\n\t\t\t\t\tsourceType: \"communication\",\n\t\t\t\t\tsourceChatId: communicationId,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcommunicationId,\n\t\t\tchannel: comm.channel,\n\t\t\tcustomerName: comm.customer?.name,\n\t\t\textractedInsights: insights,\n\t\t\tstoredToMemory: insights.length > 0 && !!comm.customer_id,\n\t\t\tsentiment: comm.call_sentiment,\n\t\t};\n\t},\n});\n\n// =============================================================================\n// EXTERNAL DATA TOOLS - Weather, Traffic, GPS, Maps\n// =============================================================================\n\n/**\n * Get weather forecast and alerts for a location\n *\n * Uses the NWS (National Weather Service) API to get:\n * - 7-day forecast\n * - Hourly forecast\n * - Active weather alerts\n * - Severe weather warnings\n */\nexport const getWeatherForLocationTool = tool({\n\tdescription: `Get weather forecast and alerts for a specific location. Provides 7-day forecast, hourly conditions, and any active weather alerts. Use this when:\n- Scheduling outdoor jobs\n- Checking if weather is suitable for work\n- Planning technician routes\n- Informing customers about weather delays\n\nReturns forecast periods, temperature, wind, precipitation chances, and any severe weather alerts.`,\n\tparameters: z.object({\n\t\tlat: z.number().describe(\"Latitude of the location\"),\n\t\tlon: z.number().describe(\"Longitude of the location\"),\n\t\tincludeHourly: z\n\t\t\t.boolean()\n\t\t\t.optional()\n\t\t\t.default(true)\n\t\t\t.describe(\"Include hourly forecast for next 24 hours\"),\n\t}),\n\texecute: async ({ lat, lon, includeHourly }) => {\n\t\tconst { weatherService } = await import(\"../services/weather-service\");\n\n\t\tconst weather = await weatherService.getWeatherData(lat, lon);\n\n\t\tif (!weather) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to fetch weather data for this location\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tlocation: weather.location,\n\t\t\tcurrentConditions: weather.hourly?.periods?.[0] || null,\n\t\t\tforecast: weather.forecast?.periods?.slice(0, 7) || [],\n\t\t\thourly: includeHourly\n\t\t\t\t? weather.hourly?.periods?.slice(0, 12) || []\n\t\t\t\t: [],\n\t\t\talerts: weather.alerts,\n\t\t\thasActiveAlerts: weather.hasActiveAlerts,\n\t\t\thighestSeverity: weather.highestSeverity,\n\t\t\tenrichedAt: weather.enrichedAt,\n\t\t};\n\t},\n});\n\n/**\n * Check if weather is suitable for outdoor work\n *\n * Analyzes weather conditions and alerts to determine if\n * it's safe and practical to do outdoor work\n */\nexport const checkWeatherForJobTool = tool({\n\tdescription: `Check if weather conditions are suitable for outdoor field service work at a specific location. Considers:\n- Severe weather alerts\n- Precipitation (rain, snow, storms)\n- Extreme temperatures (freezing or excessive heat)\n- Wind conditions\n\nReturns a clear recommendation on whether to proceed with outdoor work.`,\n\tparameters: z.object({\n\t\tlat: z.number().describe(\"Latitude of the job location\"),\n\t\tlon: z.number().describe(\"Longitude of the job location\"),\n\t\tjobType: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\"Type of job (e.g., 'roofing', 'HVAC outdoor', 'landscaping')\"),\n\t}),\n\texecute: async ({ lat, lon, jobType }) => {\n\t\tconst { weatherService } = await import(\"../services/weather-service\");\n\n\t\tconst weather = await weatherService.getWeatherData(lat, lon);\n\n\t\tif (!weather) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tsuitable: null,\n\t\t\t\terror: \"Unable to fetch weather data\",\n\t\t\t};\n\t\t}\n\n\t\tconst suitability = weatherService.isSuitableForOutdoorWork(weather);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsuitable: suitability.suitable,\n\t\t\treason: suitability.reason || \"Weather conditions are acceptable for outdoor work\",\n\t\t\tcurrentConditions: weather.hourly?.periods?.[0]\n\t\t\t\t? {\n\t\t\t\t\t\ttemperature: weather.hourly.periods[0].temperature,\n\t\t\t\t\t\ttemperatureUnit: weather.hourly.periods[0].temperatureUnit,\n\t\t\t\t\t\tshortForecast: weather.hourly.periods[0].shortForecast,\n\t\t\t\t\t\twindSpeed: weather.hourly.periods[0].windSpeed,\n\t\t\t\t\t}\n\t\t\t\t: null,\n\t\t\talerts: weather.alerts.map((a) => ({\n\t\t\t\tevent: a.event,\n\t\t\t\tseverity: a.severity,\n\t\t\t\theadline: a.headline,\n\t\t\t})),\n\t\t\tjobType,\n\t\t\trecommendation: suitability.suitable\n\t\t\t\t? \"Proceed with outdoor work\"\n\t\t\t\t: `Consider rescheduling: ${suitability.reason}`,\n\t\t};\n\t},\n});\n\n/**\n * Get active weather alerts only (faster than full forecast)\n */\nexport const getWeatherAlertsTool = tool({\n\tdescription: `Quickly check for active weather alerts at a location without fetching the full forecast. Use this for:\n- Quick safety checks\n- Emergency notifications\n- Batch checking multiple job sites\n\nReturns only alert information (faster than full weather data).`,\n\tparameters: z.object({\n\t\tlat: z.number().describe(\"Latitude\"),\n\t\tlon: z.number().describe(\"Longitude\"),\n\t}),\n\texecute: async ({ lat, lon }) => {\n\t\tconst { weatherService } = await import(\"../services/weather-service\");\n\n\t\tconst alerts = await weatherService.getActiveAlerts(lat, lon);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\thasAlerts: alerts.length > 0,\n\t\t\talertCount: alerts.length,\n\t\t\talerts: alerts.map((a) => ({\n\t\t\t\tevent: a.event,\n\t\t\t\tseverity: a.severity,\n\t\t\t\turgency: a.urgency,\n\t\t\t\theadline: a.headline,\n\t\t\t\tinstruction: a.instruction,\n\t\t\t\texpires: a.expires,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Get traffic conditions and incidents along a route\n *\n * Uses Google Maps API to check for traffic incidents,\n * construction, accidents, and congestion\n */\nexport const getTrafficConditionsTool = tool({\n\tdescription: `Get real-time traffic conditions and incidents near a job location or along a route. Detects:\n- Traffic accidents/crashes\n- Road construction\n- Road closures\n- Police activity\n- Congestion levels\n\nUseful for:\n- Planning technician dispatch\n- Estimating arrival times\n- Routing around incidents\n- Notifying customers of delays`,\n\tparameters: z.object({\n\t\tdestinationLat: z.number().describe(\"Latitude of the destination/job site\"),\n\t\tdestinationLon: z.number().describe(\"Longitude of the destination/job site\"),\n\t\toriginLat: z\n\t\t\t.number()\n\t\t\t.optional()\n\t\t\t.describe(\"Latitude of origin (e.g., shop/office) to check route\"),\n\t\toriginLon: z\n\t\t\t.number()\n\t\t\t.optional()\n\t\t\t.describe(\"Longitude of origin to check route\"),\n\t}),\n\texecute: async ({ destinationLat, destinationLon, originLat, originLon }) => {\n\t\tconst { trafficService } = await import(\"../services/traffic-service\");\n\n\t\tconst traffic = await trafficService.getTrafficIncidents(\n\t\t\tdestinationLat,\n\t\t\tdestinationLon,\n\t\t\toriginLat,\n\t\t\toriginLon\n\t\t);\n\n\t\tif (!traffic) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to fetch traffic data. Check Google Maps API configuration.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttotalIncidents: traffic.totalIncidents,\n\t\t\tnearbyIncidents: traffic.nearbyIncidents,\n\t\t\trouteAffectingIncidents: traffic.routeAffectingIncidents,\n\t\t\tincidents: traffic.incidents.map((i) => ({\n\t\t\t\ttype: i.type,\n\t\t\t\tseverity: i.severity,\n\t\t\t\tdescription: i.description,\n\t\t\t\tdistance: i.distance,\n\t\t\t\taffectsRoute: i.affectsRoute,\n\t\t\t})),\n\t\t\trecommendation:\n\t\t\t\ttraffic.routeAffectingIncidents > 0\n\t\t\t\t\t? `${traffic.routeAffectingIncidents} incident(s) may affect travel time`\n\t\t\t\t\t: \"No significant traffic issues detected\",\n\t\t\tenrichedAt: traffic.enrichedAt,\n\t\t};\n\t},\n});\n\n/**\n * Geocode an address to GPS coordinates\n *\n * Converts a street address to latitude/longitude coordinates\n */\nexport const geocodeAddressTool = tool({\n\tdescription: `Convert a street address to GPS coordinates (latitude/longitude). Use this when:\n- You have an address but need coordinates for weather/traffic lookup\n- Verifying an address is valid\n- Getting standardized/formatted address\n\nReturns coordinates and Google's formatted version of the address.`,\n\tparameters: z.object({\n\t\taddress: z.string().describe(\"Street address (e.g., '123 Main St')\"),\n\t\tcity: z.string().describe(\"City name\"),\n\t\tstate: z.string().describe(\"State (e.g., 'CA' or 'California')\"),\n\t\tzipCode: z.string().describe(\"ZIP code\"),\n\t\tcountry: z.string().optional().default(\"USA\").describe(\"Country (defaults to USA)\"),\n\t}),\n\texecute: async ({ address, city, state, zipCode, country }) => {\n\t\tconst { geocodeAddressSilent } = await import(\"../services/geocoding\");\n\n\t\tconst result = await geocodeAddressSilent(address, city, state, zipCode, country);\n\n\t\tif (!result) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to geocode address. The address may be invalid or geocoding service unavailable.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcoordinates: {\n\t\t\t\tlat: result.lat,\n\t\t\t\tlon: result.lon,\n\t\t\t},\n\t\t\tformattedAddress: result.formattedAddress,\n\t\t};\n\t},\n});\n\n/**\n * Get property weather and conditions summary\n *\n * Combines multiple data sources to give a complete picture\n * of conditions at a property/job site\n */\nexport const getPropertyConditionsTool = tool({\n\tdescription: `Get a comprehensive conditions summary for a property/job site including weather, traffic, and alerts. This is the \"one-stop\" tool for checking all external conditions before dispatching or scheduling.\n\nCombines:\n- Current and forecast weather\n- Weather alerts\n- Traffic conditions (if shop coordinates provided)\n- Work suitability assessment`,\n\tparameters: z.object({\n\t\tpropertyLat: z.number().describe(\"Latitude of the property\"),\n\t\tpropertyLon: z.number().describe(\"Longitude of the property\"),\n\t\tshopLat: z.number().optional().describe(\"Shop/office latitude for traffic routing\"),\n\t\tshopLon: z.number().optional().describe(\"Shop/office longitude for traffic routing\"),\n\t\tjobType: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\"Type of job being performed (for work suitability)\"),\n\t}),\n\texecute: async ({ propertyLat, propertyLon, shopLat, shopLon, jobType }) => {\n\t\tconst { weatherService } = await import(\"../services/weather-service\");\n\t\tconst { trafficService } = await import(\"../services/traffic-service\");\n\n\t\t// Fetch weather and traffic in parallel\n\t\tconst [weather, traffic] = await Promise.all([\n\t\t\tweatherService.getWeatherData(propertyLat, propertyLon),\n\t\t\tshopLat && shopLon\n\t\t\t\t? trafficService.getTrafficIncidents(propertyLat, propertyLon, shopLat, shopLon)\n\t\t\t\t: Promise.resolve(null),\n\t\t]);\n\n\t\tconst result: Record<string, unknown> = {\n\t\t\tsuccess: true,\n\t\t\tpropertyLocation: { lat: propertyLat, lon: propertyLon },\n\t\t};\n\n\t\t// Weather conditions\n\t\tif (weather) {\n\t\t\tconst suitability = weatherService.isSuitableForOutdoorWork(weather);\n\t\t\tresult.weather = {\n\t\t\t\tcurrent: weather.hourly?.periods?.[0]\n\t\t\t\t\t? {\n\t\t\t\t\t\t\ttemperature: weather.hourly.periods[0].temperature,\n\t\t\t\t\t\t\ttemperatureUnit: weather.hourly.periods[0].temperatureUnit,\n\t\t\t\t\t\t\tconditions: weather.hourly.periods[0].shortForecast,\n\t\t\t\t\t\t\twind: weather.hourly.periods[0].windSpeed,\n\t\t\t\t\t\t}\n\t\t\t\t\t: null,\n\t\t\t\tforecast: weather.forecast?.periods?.slice(0, 3).map((p) => ({\n\t\t\t\t\tname: p.name,\n\t\t\t\t\ttemperature: p.temperature,\n\t\t\t\t\tshortForecast: p.shortForecast,\n\t\t\t\t})),\n\t\t\t\talerts: weather.alerts.map((a) => ({\n\t\t\t\t\tevent: a.event,\n\t\t\t\t\tseverity: a.severity,\n\t\t\t\t\theadline: a.headline,\n\t\t\t\t})),\n\t\t\t\thasAlerts: weather.hasActiveAlerts,\n\t\t\t\thighestAlertSeverity: weather.highestSeverity,\n\t\t\t};\n\t\t\tresult.workSuitability = {\n\t\t\t\tsuitable: suitability.suitable,\n\t\t\t\treason: suitability.reason || \"Conditions acceptable\",\n\t\t\t\tjobType,\n\t\t\t};\n\t\t} else {\n\t\t\tresult.weather = { error: \"Weather data unavailable\" };\n\t\t\tresult.workSuitability = { suitable: null, reason: \"Unable to assess\" };\n\t\t}\n\n\t\t// Traffic conditions\n\t\tif (traffic) {\n\t\t\tresult.traffic = {\n\t\t\t\ttotalIncidents: traffic.totalIncidents,\n\t\t\t\trouteAffecting: traffic.routeAffectingIncidents,\n\t\t\t\tincidents: traffic.incidents.slice(0, 5).map((i) => ({\n\t\t\t\t\ttype: i.type,\n\t\t\t\t\tseverity: i.severity,\n\t\t\t\t\tdescription: i.description,\n\t\t\t\t})),\n\t\t\t};\n\t\t} else if (shopLat && shopLon) {\n\t\t\tresult.traffic = { error: \"Traffic data unavailable\" };\n\t\t}\n\n\t\t// Overall recommendation\n\t\tconst issues: string[] = [];\n\t\tif (weather?.hasActiveAlerts) {\n\t\t\tissues.push(`Weather alert: ${weather.highestSeverity}`);\n\t\t}\n\t\tif (weather && !weatherService.isSuitableForOutdoorWork(weather).suitable) {\n\t\t\tissues.push(\"Weather not suitable for outdoor work\");\n\t\t}\n\t\tif (traffic && traffic.routeAffectingIncidents > 0) {\n\t\t\tissues.push(`${traffic.routeAffectingIncidents} traffic incident(s) on route`);\n\t\t}\n\n\t\tresult.overallStatus = issues.length === 0 ? \"good\" : \"caution\";\n\t\tresult.issues = issues;\n\t\tresult.recommendation =\n\t\t\tissues.length === 0\n\t\t\t\t? \"Conditions look good for this job\"\n\t\t\t\t: `Review before proceeding: ${issues.join(\"; \")}`;\n\n\t\treturn result;\n\t},\n});\n\n// =============================================================================\n// CODE SEARCH TOOLS - Building, Plumbing, Electrical Codes\n// =============================================================================\n\n/**\n * Common building code references by trade type\n * This is a knowledge base that can be enhanced with actual API integrations\n */\nconst codeReferences = {\n\tplumbing: {\n\t\tname: \"Uniform Plumbing Code (UPC) / International Plumbing Code (IPC)\",\n\t\tcommonRequirements: [\n\t\t\t\"Drain pipe slope: 1/4 inch per foot minimum\",\n\t\t\t\"Vent pipes must extend through roof\",\n\t\t\t\"P-traps required on all fixtures\",\n\t\t\t\"Water heater T&P relief valve required\",\n\t\t\t\"Backflow prevention on potable water\",\n\t\t\t\"Minimum fixture unit calculations for pipe sizing\",\n\t\t\t\"Air gap requirements for indirect waste\",\n\t\t],\n\t\tpermitTriggers: [\n\t\t\t\"New water heater installation\",\n\t\t\t\"Moving or adding fixtures\",\n\t\t\t\"New water/sewer line connections\",\n\t\t\t\"Gas line work\",\n\t\t\t\"Sewer line replacement\",\n\t\t],\n\t},\n\telectrical: {\n\t\tname: \"National Electrical Code (NEC)\",\n\t\tcommonRequirements: [\n\t\t\t\"GFCI required in kitchens, bathrooms, garages, outdoors\",\n\t\t\t\"AFCI required in bedrooms and living areas\",\n\t\t\t\"Smoke detectors on every floor and bedroom\",\n\t\t\t\"Panel accessibility clearance: 36 inches\",\n\t\t\t\"Wire sizing based on amperage load\",\n\t\t\t\"Grounding requirements for all circuits\",\n\t\t\t\"Box fill calculations for junction boxes\",\n\t\t],\n\t\tpermitTriggers: [\n\t\t\t\"New circuits or subpanels\",\n\t\t\t\"Service upgrade\",\n\t\t\t\"Adding outlets or switches\",\n\t\t\t\"Electric vehicle charger installation\",\n\t\t\t\"Generator installation\",\n\t\t],\n\t},\n\thvac: {\n\t\tname: \"International Mechanical Code (IMC)\",\n\t\tcommonRequirements: [\n\t\t\t\"Proper equipment sizing (Manual J calculation)\",\n\t\t\t\"Ductwork sizing (Manual D calculation)\",\n\t\t\t\"Combustion air requirements for gas appliances\",\n\t\t\t\"Clearances from combustible materials\",\n\t\t\t\"Condensate drain requirements\",\n\t\t\t\"Refrigerant line sizing and insulation\",\n\t\t\t\"Energy efficiency minimums (SEER ratings)\",\n\t\t],\n\t\tpermitTriggers: [\n\t\t\t\"New HVAC system installation\",\n\t\t\t\"Equipment replacement (like-for-like may be exempt)\",\n\t\t\t\"Ductwork modifications\",\n\t\t\t\"Gas line work\",\n\t\t\t\"Mini-split installation\",\n\t\t],\n\t},\n\tgeneral: {\n\t\tname: \"International Building Code (IBC) / International Residential Code (IRC)\",\n\t\tcommonRequirements: [\n\t\t\t\"Egress window requirements for bedrooms\",\n\t\t\t\"Stair rise/run specifications (7.75 in max rise, 10 in min run)\",\n\t\t\t\"Handrail requirements (34-38 inches height)\",\n\t\t\t\"Smoke and CO detector placement\",\n\t\t\t\"Fire-rated assemblies where required\",\n\t\t\t\"Structural load calculations\",\n\t\t],\n\t\tpermitTriggers: [\n\t\t\t\"Structural modifications\",\n\t\t\t\"Adding/removing walls\",\n\t\t\t\"Roof replacement (varies by jurisdiction)\",\n\t\t\t\"Window/door changes\",\n\t\t\t\"Additions or conversions\",\n\t\t],\n\t},\n\troofing: {\n\t\tname: \"International Building Code (IBC) - Roofing Section\",\n\t\tcommonRequirements: [\n\t\t\t\"Minimum roof slope requirements by material\",\n\t\t\t\"Underlayment requirements\",\n\t\t\t\"Ice and water shield in cold climates\",\n\t\t\t\"Flashing requirements at penetrations\",\n\t\t\t\"Ventilation requirements (1:150 or 1:300 ratio)\",\n\t\t\t\"Fire-rated materials in certain zones\",\n\t\t],\n\t\tpermitTriggers: [\n\t\t\t\"Complete re-roof (varies by jurisdiction)\",\n\t\t\t\"Structural repairs\",\n\t\t\t\"Adding skylights or vents\",\n\t\t\t\"Changing roofing material type\",\n\t\t],\n\t},\n};\n\n/**\n * Search building codes by trade type and work description\n */\nexport const searchBuildingCodesTool = tool({\n\tdescription: `Search for relevant building code requirements based on the type of work being performed. Returns common code requirements, permit triggers, and best practices for:\n- Plumbing (UPC/IPC)\n- Electrical (NEC)\n- HVAC (IMC)\n- General construction (IBC/IRC)\n- Roofing\n\nUse this to help technicians understand code requirements before starting work.`,\n\tparameters: z.object({\n\t\ttradeType: z\n\t\t\t.enum([\"plumbing\", \"electrical\", \"hvac\", \"general\", \"roofing\"])\n\t\t\t.describe(\"The trade or type of work\"),\n\t\tworkDescription: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\"Specific description of the work being performed\"),\n\t\tstate: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\"State abbreviation (codes vary by jurisdiction)\"),\n\t}),\n\texecute: async ({ tradeType, workDescription, state }) => {\n\t\tconst codeInfo = codeReferences[tradeType];\n\n\t\t// Build relevance context\n\t\tconst relevantRequirements: string[] = [];\n\t\tif (workDescription) {\n\t\t\tconst desc = workDescription.toLowerCase();\n\n\t\t\t// Filter requirements based on work description keywords\n\t\t\tfor (const req of codeInfo.commonRequirements) {\n\t\t\t\tconst reqLower = req.toLowerCase();\n\t\t\t\t// Simple relevance matching\n\t\t\t\tconst keywords = desc.split(/\\s+/);\n\t\t\t\tif (keywords.some((kw) => kw.length > 3 && reqLower.includes(kw))) {\n\t\t\t\t\trelevantRequirements.push(req);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttradeType,\n\t\t\tcodeName: codeInfo.name,\n\t\t\tcommonRequirements: codeInfo.commonRequirements,\n\t\t\trelevantToWork:\n\t\t\t\trelevantRequirements.length > 0 ? relevantRequirements : null,\n\t\t\tpermitTriggers: codeInfo.permitTriggers,\n\t\t\tjurisdictionNote: state\n\t\t\t\t? `Note: Requirements may vary in ${state}. Always verify with local building department.`\n\t\t\t\t: \"Requirements vary by jurisdiction. Always verify with local building department.\",\n\t\t\tdisclaimer:\n\t\t\t\t\"This is general guidance only. Consult actual code books and local jurisdiction for specific requirements.\",\n\t\t};\n\t},\n});\n\n/**\n * Get permit requirements for a specific type of work\n */\nexport const getPermitRequirementsTool = tool({\n\tdescription: `Determine if a permit is likely required for specific work and what type of permit. Helps field service companies understand when to pull permits and advise customers.\n\nReturns:\n- Whether permit is typically required\n- Type of permit needed\n- Common exceptions\n- Inspection requirements`,\n\tparameters: z.object({\n\t\tworkType: z.string().describe(\"Type of work being performed (e.g., 'water heater replacement', 'outlet installation')\"),\n\t\tpropertyType: z\n\t\t\t.enum([\"residential\", \"commercial\"])\n\t\t\t.optional()\n\t\t\t.default(\"residential\"),\n\t\tcity: z.string().optional().describe(\"City for jurisdiction-specific guidance\"),\n\t\tstate: z.string().optional().describe(\"State abbreviation\"),\n\t}),\n\texecute: async ({ workType, propertyType, city, state }) => {\n\t\tconst workLower = workType.toLowerCase();\n\n\t\t// Analyze work type to determine permit requirements\n\t\tlet permitRequired = false;\n\t\tlet permitType = \"unknown\";\n\t\tlet confidence = \"medium\";\n\t\tconst notes: string[] = [];\n\t\tconst inspections: string[] = [];\n\n\t\t// Electrical work\n\t\tif (\n\t\t\tworkLower.includes(\"outlet\") ||\n\t\t\tworkLower.includes(\"circuit\") ||\n\t\t\tworkLower.includes(\"panel\") ||\n\t\t\tworkLower.includes(\"electrical\") ||\n\t\t\tworkLower.includes(\"wire\") ||\n\t\t\tworkLower.includes(\"ev charger\")\n\t\t) {\n\t\t\tpermitRequired = true;\n\t\t\tpermitType = \"electrical\";\n\t\t\tinspections.push(\"Rough-in inspection\", \"Final inspection\");\n\t\t\tif (workLower.includes(\"panel\") || workLower.includes(\"service\")) {\n\t\t\t\tnotes.push(\"Service upgrades typically require utility coordination\");\n\t\t\t}\n\t\t}\n\n\t\t// Plumbing work\n\t\tif (\n\t\t\tworkLower.includes(\"water heater\") ||\n\t\t\tworkLower.includes(\"plumbing\") ||\n\t\t\tworkLower.includes(\"sewer\") ||\n\t\t\tworkLower.includes(\"drain\") ||\n\t\t\tworkLower.includes(\"fixture\")\n\t\t) {\n\t\t\tpermitRequired = true;\n\t\t\tpermitType = \"plumbing\";\n\t\t\tinspections.push(\"Rough-in inspection\", \"Final inspection\");\n\t\t\tif (workLower.includes(\"water heater\")) {\n\t\t\t\tnotes.push(\"Water heater permits often include gas and electrical inspections\");\n\t\t\t\tconfidence = \"high\";\n\t\t\t}\n\t\t}\n\n\t\t// HVAC work\n\t\tif (\n\t\t\tworkLower.includes(\"hvac\") ||\n\t\t\tworkLower.includes(\"furnace\") ||\n\t\t\tworkLower.includes(\"air condition\") ||\n\t\t\tworkLower.includes(\"ac \") ||\n\t\t\tworkLower.includes(\"heat pump\") ||\n\t\t\tworkLower.includes(\"mini-split\")\n\t\t) {\n\t\t\tpermitRequired = true;\n\t\t\tpermitType = \"mechanical\";\n\t\t\tinspections.push(\"Final inspection\");\n\t\t\tnotes.push(\"EPA certification required for refrigerant handling\");\n\t\t}\n\n\t\t// Roofing\n\t\tif (workLower.includes(\"roof\") || workLower.includes(\"re-roof\")) {\n\t\t\tpermitRequired = true;\n\t\t\tpermitType = \"building/roofing\";\n\t\t\tinspections.push(\"Final inspection\");\n\t\t\tnotes.push(\"Requirements vary significantly by jurisdiction - some exempt repairs under certain square footage\");\n\t\t\tconfidence = \"low\";\n\t\t}\n\n\t\t// Gas work\n\t\tif (\n\t\t\tworkLower.includes(\"gas line\") ||\n\t\t\tworkLower.includes(\"gas pipe\")\n\t\t) {\n\t\t\tpermitRequired = true;\n\t\t\tpermitType = \"gas/plumbing\";\n\t\t\tinspections.push(\"Pressure test inspection\", \"Final inspection\");\n\t\t\tnotes.push(\"Gas work requires licensed gas fitter in most jurisdictions\");\n\t\t\tconfidence = \"high\";\n\t\t}\n\n\t\t// Minor repairs generally don't require permits\n\t\tif (\n\t\t\tworkLower.includes(\"repair\") &&\n\t\t\t!workLower.includes(\"replace\") &&\n\t\t\t!workLower.includes(\"install\")\n\t\t) {\n\t\t\tpermitRequired = false;\n\t\t\tnotes.push(\"Minor repairs typically exempt, but verify with local jurisdiction\");\n\t\t\tconfidence = \"low\";\n\t\t}\n\n\t\t// Like-for-like replacements\n\t\tif (workLower.includes(\"like for like\") || workLower.includes(\"same location\")) {\n\t\t\tnotes.push(\"Like-for-like replacements may be exempt in some jurisdictions\");\n\t\t\tconfidence = \"low\";\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tworkType,\n\t\t\tpropertyType,\n\t\t\tlocation: city && state ? `${city}, ${state}` : state || \"Not specified\",\n\t\t\tpermitRequired,\n\t\t\tpermitType: permitRequired ? permitType : null,\n\t\t\tconfidence,\n\t\t\ttypicalInspections: permitRequired ? inspections : [],\n\t\t\tnotes,\n\t\t\trecommendations: permitRequired\n\t\t\t\t? [\n\t\t\t\t\t\t\"Contact local building department for specific requirements\",\n\t\t\t\t\t\t\"Have contractor license number ready\",\n\t\t\t\t\t\t\"Allow 1-3 business days for permit processing\",\n\t\t\t\t\t\t\"Schedule inspections in advance\",\n\t\t\t\t\t]\n\t\t\t\t: [\n\t\t\t\t\t\t\"Document work performed for records\",\n\t\t\t\t\t\t\"When in doubt, contact local building department\",\n\t\t\t\t\t],\n\t\t\tdisclaimer:\n\t\t\t\t\"Permit requirements vary by jurisdiction. Always verify with local building department.\",\n\t\t};\n\t},\n});\n\n/**\n * Get safety and code compliance checklist for a job type\n */\nexport const getCodeComplianceChecklistTool = tool({\n\tdescription: `Generate a code compliance and safety checklist for a specific type of job. Helps technicians ensure they're meeting code requirements during installation or repair.\n\nReturns a checklist of items to verify for code compliance.`,\n\tparameters: z.object({\n\t\tjobType: z.string().describe(\"Type of job (e.g., 'water heater installation', 'panel upgrade', 'AC replacement')\"),\n\t\tincludesSafety: z\n\t\t\t.boolean()\n\t\t\t.optional()\n\t\t\t.default(true)\n\t\t\t.describe(\"Include safety checklist items\"),\n\t}),\n\texecute: async ({ jobType, includesSafety }) => {\n\t\tconst jobLower = jobType.toLowerCase();\n\t\tconst checklist: Array<{ category: string; items: string[] }> = [];\n\n\t\t// Water heater specific\n\t\tif (\n\t\t\tjobLower.includes(\"water heater\") ||\n\t\t\tjobLower.includes(\"hot water\")\n\t\t) {\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Temperature & Pressure Relief\",\n\t\t\t\titems: [\n\t\t\t\t\t\"T&P relief valve installed in top 6 inches of tank\",\n\t\t\t\t\t\"Discharge pipe routes to within 6 inches of floor\",\n\t\t\t\t\t\"Discharge pipe same size as valve outlet\",\n\t\t\t\t\t\"No valves or restrictions in discharge line\",\n\t\t\t\t],\n\t\t\t});\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Seismic & Stability\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Seismic straps installed (required in seismic zones)\",\n\t\t\t\t\t\"Unit stable and level\",\n\t\t\t\t\t\"Proper clearances maintained\",\n\t\t\t\t],\n\t\t\t});\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Connections\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Proper venting for gas units (draft hood, flue)\",\n\t\t\t\t\t\"Gas shutoff valve accessible\",\n\t\t\t\t\t\"Sediment trap on gas line\",\n\t\t\t\t\t\"Dielectric unions on water connections\",\n\t\t\t\t\t\"Expansion tank installed if closed system\",\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\t// Electrical panel/service\n\t\tif (\n\t\t\tjobLower.includes(\"panel\") ||\n\t\t\tjobLower.includes(\"electrical\") ||\n\t\t\tjobLower.includes(\"breaker\")\n\t\t) {\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Panel Requirements\",\n\t\t\t\titems: [\n\t\t\t\t\t\"36-inch clearance in front of panel\",\n\t\t\t\t\t\"30-inch width clearance\",\n\t\t\t\t\t\"78-inch height clearance\",\n\t\t\t\t\t\"Panel cover intact and secured\",\n\t\t\t\t\t\"All breakers labeled\",\n\t\t\t\t\t\"No exposed conductors\",\n\t\t\t\t],\n\t\t\t});\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Grounding & Bonding\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Ground rod(s) installed\",\n\t\t\t\t\t\"Bonding jumper at water heater\",\n\t\t\t\t\t\"CSST gas line bonded (if applicable)\",\n\t\t\t\t\t\"Grounding electrode conductor sized properly\",\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\t// HVAC\n\t\tif (\n\t\t\tjobLower.includes(\"hvac\") ||\n\t\t\tjobLower.includes(\"furnace\") ||\n\t\t\tjobLower.includes(\"ac\") ||\n\t\t\tjobLower.includes(\"heat pump\")\n\t\t) {\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Equipment Installation\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Clearances from combustibles maintained\",\n\t\t\t\t\t\"Condensate drain properly routed\",\n\t\t\t\t\t\"Secondary drain pan with float switch (if in attic)\",\n\t\t\t\t\t\"Filter access provided\",\n\t\t\t\t\t\"Disconnect within sight of unit\",\n\t\t\t\t],\n\t\t\t});\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"Ductwork & Airflow\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Supply and return balanced\",\n\t\t\t\t\t\"Duct connections sealed\",\n\t\t\t\t\t\"No kinks in flex duct\",\n\t\t\t\t\t\"Adequate return air\",\n\t\t\t\t],\n\t\t\t});\n\t\t\tif (jobLower.includes(\"gas\") || jobLower.includes(\"furnace\")) {\n\t\t\t\tchecklist.push({\n\t\t\t\t\tcategory: \"Gas & Combustion\",\n\t\t\t\t\titems: [\n\t\t\t\t\t\t\"Combustion air adequate\",\n\t\t\t\t\t\t\"Gas pressure verified\",\n\t\t\t\t\t\t\"CO testing performed\",\n\t\t\t\t\t\t\"Heat exchanger inspected\",\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Safety checklist\n\t\tif (includesSafety) {\n\t\t\tchecklist.push({\n\t\t\t\tcategory: \"General Safety\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Work area secured and clean\",\n\t\t\t\t\t\"PPE used appropriately\",\n\t\t\t\t\t\"All utilities verified off before work\",\n\t\t\t\t\t\"Test equipment calibrated\",\n\t\t\t\t\t\"Customer informed of work\",\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\t// If no specific checklist matched, provide general\n\t\tif (checklist.length === (includesSafety ? 1 : 0)) {\n\t\t\tchecklist.unshift({\n\t\t\t\tcategory: \"General Code Compliance\",\n\t\t\t\titems: [\n\t\t\t\t\t\"Work matches permit scope (if applicable)\",\n\t\t\t\t\t\"Materials meet code requirements\",\n\t\t\t\t\t\"Manufacturer installation instructions followed\",\n\t\t\t\t\t\"All connections secure\",\n\t\t\t\t\t\"System tested and operational\",\n\t\t\t\t\t\"Area cleaned up\",\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tjobType,\n\t\t\tchecklist,\n\t\t\ttotalItems: checklist.reduce((sum, cat) => sum + cat.items.length, 0),\n\t\t\treminder:\n\t\t\t\t\"Document completion of each item. Photos recommended for permit inspections.\",\n\t\t\tdisclaimer:\n\t\t\t\t\"This checklist is general guidance. Refer to local codes and manufacturer instructions.\",\n\t\t};\n\t},\n});\n\n// =============================================================================\n// PROACTIVE LEARNING SYSTEM - Auto-learn from customer interactions\n// =============================================================================\n\n/**\n * Analyze recent communications to extract learnings\n *\n * Scans recent communications and extracts insights that can be stored\n * to memory for future reference\n */\nexport const analyzeRecentCommunicationsTool = tool({\n\tdescription: `Proactively analyze recent customer communications to extract insights and learnings. Scans the last N days of communications and identifies:\n- Customer preferences mentioned in calls/emails\n- Common issues or complaints\n- Positive feedback and compliments\n- Service requests patterns\n- Emergency situations or urgent needs\n\nUse this for periodic learning runs to build customer knowledge.`,\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company ID\"),\n\t\tdaysBack: z\n\t\t\t.number()\n\t\t\t.optional()\n\t\t\t.default(7)\n\t\t\t.describe(\"Number of days to look back\"),\n\t\tlimit: z\n\t\t\t.number()\n\t\t\t.optional()\n\t\t\t.default(50)\n\t\t\t.describe(\"Maximum communications to analyze\"),\n\t\tfocusArea: z\n\t\t\t.enum([\"all\", \"preferences\", \"issues\", \"feedback\", \"urgent\"])\n\t\t\t.optional()\n\t\t\t.default(\"all\")\n\t\t\t.describe(\"Focus on specific type of insights\"),\n\t}),\n\texecute: async ({ companyId, daysBack, limit, focusArea }) => {\n\t\tconst { createServiceSupabaseClient } = await import(\n\t\t\t\"@/lib/supabase/service-client\"\n\t\t);\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - daysBack);\n\n\t\t// Get recent communications with transcripts\n\t\tconst { data: comms, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\tchannel,\n\t\t\t\tdirection,\n\t\t\t\tcall_transcript,\n\t\t\t\tcall_sentiment,\n\t\t\t\tbody_plain,\n\t\t\t\tcustomer_id,\n\t\t\t\tcreated_at,\n\t\t\t\tcustomer:customers!customer_id(id, name)\n\t\t\t`\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.gte(\"created_at\", startDate.toISOString())\n\t\t\t.not(\"call_transcript\", \"is\", null)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error || !comms) {\n\t\t\treturn { success: false, error: error?.message || \"No communications found\" };\n\t\t}\n\n\t\tconst insights: Array<{\n\t\t\tcustomerId: string | null;\n\t\t\tcustomerName: string | null;\n\t\t\ttype: string;\n\t\t\tcontent: string;\n\t\t\tsource: string;\n\t\t\timportance: \"low\" | \"medium\" | \"high\";\n\t\t}> = [];\n\n\t\t// Pattern matching for different insight types\n\t\tconst patterns = {\n\t\t\tpreferences: [\n\t\t\t\t/prefer[s]?\\s+([^.]+)/gi,\n\t\t\t\t/like[s]?\\s+([^.]+)/gi,\n\t\t\t\t/want[s]?\\s+([^.]+)/gi,\n\t\t\t\t/always\\s+([^.]+)/gi,\n\t\t\t\t/please\\s+([^.]+)/gi,\n\t\t\t],\n\t\t\tissues: [\n\t\t\t\t/problem[s]?\\s+with\\s+([^.]+)/gi,\n\t\t\t\t/issue[s]?\\s+with\\s+([^.]+)/gi,\n\t\t\t\t/not\\s+working\\s+([^.]+)/gi,\n\t\t\t\t/broken\\s+([^.]+)/gi,\n\t\t\t\t/complaint[s]?\\s+about\\s+([^.]+)/gi,\n\t\t\t\t/frustrated\\s+([^.]+)/gi,\n\t\t\t],\n\t\t\tfeedback: [\n\t\t\t\t/great\\s+([^.]+)/gi,\n\t\t\t\t/excellent\\s+([^.]+)/gi,\n\t\t\t\t/thank\\s+you\\s+for\\s+([^.]+)/gi,\n\t\t\t\t/appreciate\\s+([^.]+)/gi,\n\t\t\t\t/happy\\s+with\\s+([^.]+)/gi,\n\t\t\t],\n\t\t\turgent: [\n\t\t\t\t/emergency\\s+([^.]+)/gi,\n\t\t\t\t/urgent\\s+([^.]+)/gi,\n\t\t\t\t/asap\\s+([^.]+)/gi,\n\t\t\t\t/right\\s+away\\s+([^.]+)/gi,\n\t\t\t\t/immediately\\s+([^.]+)/gi,\n\t\t\t],\n\t\t};\n\n\t\tfor (const comm of comms) {\n\t\t\tconst content = comm.call_transcript || comm.body_plain || \"\";\n\t\t\tif (!content) continue;\n\n\t\t\tconst customer = comm.customer as { id: string; name: string } | null;\n\n\t\t\t// Extract insights based on focus area\n\t\t\tconst areasToScan =\n\t\t\t\tfocusArea === \"all\"\n\t\t\t\t\t? (Object.keys(patterns) as Array<keyof typeof patterns>)\n\t\t\t\t\t: [focusArea as keyof typeof patterns];\n\n\t\t\tfor (const area of areasToScan) {\n\t\t\t\tfor (const pattern of patterns[area] || []) {\n\t\t\t\t\tconst matches = content.matchAll(pattern);\n\t\t\t\t\tfor (const match of matches) {\n\t\t\t\t\t\tinsights.push({\n\t\t\t\t\t\t\tcustomerId: comm.customer_id,\n\t\t\t\t\t\t\tcustomerName: customer?.name || null,\n\t\t\t\t\t\t\ttype: area,\n\t\t\t\t\t\t\tcontent: match[0],\n\t\t\t\t\t\t\tsource: `${comm.channel} on ${new Date(comm.created_at).toLocaleDateString()}`,\n\t\t\t\t\t\t\timportance: area === \"urgent\" || area === \"issues\" ? \"high\" : \"medium\",\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Also flag negative sentiment calls\n\t\t\tif (\n\t\t\t\tcomm.call_sentiment &&\n\t\t\t\t[\"negative\", \"very_negative\"].includes(comm.call_sentiment)\n\t\t\t) {\n\t\t\t\tinsights.push({\n\t\t\t\t\tcustomerId: comm.customer_id,\n\t\t\t\t\tcustomerName: customer?.name || null,\n\t\t\t\t\ttype: \"sentiment\",\n\t\t\t\t\tcontent: `Negative sentiment detected in ${comm.channel} communication`,\n\t\t\t\t\tsource: `${comm.channel} on ${new Date(comm.created_at).toLocaleDateString()}`,\n\t\t\t\t\timportance: \"high\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcommunicationsAnalyzed: comms.length,\n\t\t\tdaysBack,\n\t\t\tfocusArea,\n\t\t\tinsightsFound: insights.length,\n\t\t\tinsights: insights.slice(0, 100), // Limit response size\n\t\t\tsummary: {\n\t\t\t\tbyType: {\n\t\t\t\t\tpreferences: insights.filter((i) => i.type === \"preferences\").length,\n\t\t\t\t\tissues: insights.filter((i) => i.type === \"issues\").length,\n\t\t\t\t\tfeedback: insights.filter((i) => i.type === \"feedback\").length,\n\t\t\t\t\turgent: insights.filter((i) => i.type === \"urgent\").length,\n\t\t\t\t\tsentiment: insights.filter((i) => i.type === \"sentiment\").length,\n\t\t\t\t},\n\t\t\t\thighImportance: insights.filter((i) => i.importance === \"high\").length,\n\t\t\t},\n\t\t};\n\t},\n});\n\n/**\n * Learn from completed jobs to improve future recommendations\n */\nexport const learnFromCompletedJobsTool = tool({\n\tdescription: `Analyze completed jobs to learn patterns about:\n- Common job durations by type\n- Frequently used materials\n- Customer satisfaction indicators\n- Technician performance patterns\n- Seasonal job patterns\n\nHelps improve scheduling and resource allocation.`,\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company ID\"),\n\t\tdaysBack: z\n\t\t\t.number()\n\t\t\t.optional()\n\t\t\t.default(30)\n\t\t\t.describe(\"Days to look back\"),\n\t\tjobType: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\"Filter by job type\"),\n\t}),\n\texecute: async ({ companyId, daysBack, jobType }) => {\n\t\tconst { createServiceSupabaseClient } = await import(\n\t\t\t\"@/lib/supabase/service-client\"\n\t\t);\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\tconst startDate = new Date();\n\t\tstartDate.setDate(startDate.getDate() - daysBack);\n\n\t\tlet query = supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\n\t\t\t\t`\n\t\t\t\tid,\n\t\t\t\ttitle,\n\t\t\t\tjob_type,\n\t\t\t\tstatus,\n\t\t\t\tscheduled_start,\n\t\t\t\tscheduled_end,\n\t\t\t\tactual_start,\n\t\t\t\tactual_end,\n\t\t\t\ttotal_amount,\n\t\t\t\tcustomer:customers!customer_id(name),\n\t\t\t\tproperty:properties!property_id(address_line1, city)\n\t\t\t`\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"status\", \"completed\")\n\t\t\t.gte(\"created_at\", startDate.toISOString())\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (jobType) {\n\t\t\tquery = query.eq(\"job_type\", jobType);\n\t\t}\n\n\t\tconst { data: jobs, error } = await query;\n\n\t\tif (error || !jobs) {\n\t\t\treturn { success: false, error: error?.message || \"No jobs found\" };\n\t\t}\n\n\t\t// Analyze job patterns\n\t\tconst durationAnalysis: Record<string, number[]> = {};\n\t\tconst revenueAnalysis: Record<string, number[]> = {};\n\t\tconst accuracyAnalysis: Array<{\n\t\t\tjobType: string;\n\t\t\tscheduledMinutes: number;\n\t\t\tactualMinutes: number;\n\t\t\taccuracy: number;\n\t\t}> = [];\n\n\t\tfor (const job of jobs) {\n\t\t\tconst type = job.job_type || \"unknown\";\n\n\t\t\t// Duration analysis\n\t\t\tif (job.actual_start && job.actual_end) {\n\t\t\t\tconst actualMinutes =\n\t\t\t\t\t(new Date(job.actual_end).getTime() -\n\t\t\t\t\t\tnew Date(job.actual_start).getTime()) /\n\t\t\t\t\t60000;\n\t\t\t\tif (!durationAnalysis[type]) durationAnalysis[type] = [];\n\t\t\t\tdurationAnalysis[type].push(actualMinutes);\n\n\t\t\t\t// Scheduling accuracy\n\t\t\t\tif (job.scheduled_start && job.scheduled_end) {\n\t\t\t\t\tconst scheduledMinutes =\n\t\t\t\t\t\t(new Date(job.scheduled_end).getTime() -\n\t\t\t\t\t\t\tnew Date(job.scheduled_start).getTime()) /\n\t\t\t\t\t\t60000;\n\t\t\t\t\taccuracyAnalysis.push({\n\t\t\t\t\t\tjobType: type,\n\t\t\t\t\t\tscheduledMinutes,\n\t\t\t\t\t\tactualMinutes,\n\t\t\t\t\t\taccuracy: Math.min(scheduledMinutes / actualMinutes, actualMinutes / scheduledMinutes) * 100,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Revenue analysis\n\t\t\tif (job.total_amount) {\n\t\t\t\tif (!revenueAnalysis[type]) revenueAnalysis[type] = [];\n\t\t\t\trevenueAnalysis[type].push(job.total_amount);\n\t\t\t}\n\t\t}\n\n\t\t// Calculate averages\n\t\tconst durationSummary: Record<\n\t\t\tstring,\n\t\t\t{ avg: number; min: number; max: number; count: number }\n\t\t> = {};\n\t\tfor (const [type, durations] of Object.entries(durationAnalysis)) {\n\t\t\tconst avg = durations.reduce((a, b) => a + b, 0) / durations.length;\n\t\t\tdurationSummary[type] = {\n\t\t\t\tavg: Math.round(avg),\n\t\t\t\tmin: Math.round(Math.min(...durations)),\n\t\t\t\tmax: Math.round(Math.max(...durations)),\n\t\t\t\tcount: durations.length,\n\t\t\t};\n\t\t}\n\n\t\tconst revenueSummary: Record<\n\t\t\tstring,\n\t\t\t{ avg: number; min: number; max: number; count: number }\n\t\t> = {};\n\t\tfor (const [type, amounts] of Object.entries(revenueAnalysis)) {\n\t\t\tconst avg = amounts.reduce((a, b) => a + b, 0) / amounts.length;\n\t\t\trevenueSummary[type] = {\n\t\t\t\tavg: Math.round(avg * 100) / 100,\n\t\t\t\tmin: Math.min(...amounts),\n\t\t\t\tmax: Math.max(...amounts),\n\t\t\t\tcount: amounts.length,\n\t\t\t};\n\t\t}\n\n\t\t// Scheduling accuracy summary\n\t\tconst avgAccuracy =\n\t\t\taccuracyAnalysis.length > 0\n\t\t\t\t? accuracyAnalysis.reduce((sum, a) => sum + a.accuracy, 0) /\n\t\t\t\t\taccuracyAnalysis.length\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tjobsAnalyzed: jobs.length,\n\t\t\tdaysBack,\n\t\t\tinsights: {\n\t\t\t\tdurationByType: durationSummary,\n\t\t\t\trevenueByType: revenueSummary,\n\t\t\t\tschedulingAccuracy: avgAccuracy\n\t\t\t\t\t? `${Math.round(avgAccuracy)}% average accuracy`\n\t\t\t\t\t: \"Insufficient data\",\n\t\t\t},\n\t\t\trecommendations: Object.entries(durationSummary).map(([type, stats]) => ({\n\t\t\t\tjobType: type,\n\t\t\t\trecommendedDuration: stats.avg,\n\t\t\t\tnote:\n\t\t\t\t\tstats.max > stats.avg * 1.5\n\t\t\t\t\t\t? `Consider allocating buffer time - some ${type} jobs take up to ${stats.max} minutes`\n\t\t\t\t\t\t: null,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Build customer profile from all available data\n */\nexport const buildCustomerProfileTool = tool({\n\tdescription: `Build a comprehensive customer profile by aggregating all available data:\n- Communication history and sentiment\n- Job history and preferences\n- Payment history\n- Property information\n- Stored memories and notes\n\nUse this to prepare for customer interactions or to understand customer value.`,\n\tparameters: z.object({\n\t\tcustomerId: z.string().describe(\"Customer UUID\"),\n\t\tcompanyId: z.string().describe(\"Company ID\"),\n\t}),\n\texecute: async ({ customerId, companyId }) => {\n\t\tconst { createServiceSupabaseClient } = await import(\n\t\t\t\"@/lib/supabase/service-client\"\n\t\t);\n\t\tconst supabase = createServiceSupabaseClient();\n\n\t\t// Fetch all customer data in parallel\n\t\tconst [\n\t\t\tcustomerResult,\n\t\t\tjobsResult,\n\t\t\tcommsResult,\n\t\t\tinvoicesResult,\n\t\t\tmemoriesResult,\n\t\t] = await Promise.all([\n\t\t\tsupabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"*\")\n\t\t\t\t.eq(\"id\", customerId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single(),\n\t\t\tsupabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, job_type, status, total_amount, created_at\")\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t\t.limit(20),\n\t\t\tsupabase\n\t\t\t\t.from(\"communications\")\n\t\t\t\t.select(\"id, channel, direction, call_sentiment, created_at\")\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t\t.limit(50),\n\t\t\tsupabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.select(\"id, status, total, paid_amount, created_at\")\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t\t.limit(20),\n\t\t\tsupabase\n\t\t\t\t.from(\"ai_memory\")\n\t\t\t\t.select(\"content, memory_type, importance, created_at\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"entity_id\", customerId)\n\t\t\t\t.eq(\"entity_type\", \"customer\")\n\t\t\t\t.order(\"importance\", { ascending: false })\n\t\t\t\t.limit(20),\n\t\t]);\n\n\t\tconst customer = customerResult.data;\n\t\tconst jobs = jobsResult.data || [];\n\t\tconst comms = commsResult.data || [];\n\t\tconst invoices = invoicesResult.data || [];\n\t\tconst memories = memoriesResult.data || [];\n\n\t\tif (!customer) {\n\t\t\treturn { success: false, error: \"Customer not found\" };\n\t\t}\n\n\t\t// Analyze job history\n\t\tconst completedJobs = jobs.filter((j) => j.status === \"completed\");\n\t\tconst totalRevenue = jobs.reduce((sum, j) => sum + (j.total_amount || 0), 0);\n\t\tconst jobTypes = [...new Set(jobs.map((j) => j.job_type).filter(Boolean))];\n\n\t\t// Analyze communication sentiment\n\t\tconst sentiments = comms\n\t\t\t.map((c) => c.call_sentiment)\n\t\t\t.filter(Boolean);\n\t\tconst negativeSentiments = sentiments.filter(\n\t\t\t(s) => s === \"negative\" || s === \"very_negative\"\n\t\t).length;\n\t\tconst positiveSentiments = sentiments.filter(\n\t\t\t(s) => s === \"positive\" || s === \"very_positive\"\n\t\t).length;\n\n\t\t// Analyze payment behavior\n\t\tconst paidInvoices = invoices.filter((i) => i.status === \"paid\");\n\t\tconst overdueInvoices = invoices.filter((i) => i.status === \"overdue\");\n\t\tconst totalOwed = invoices\n\t\t\t.filter((i) => i.status !== \"paid\")\n\t\t\t.reduce((sum, i) => sum + ((i.total || 0) - (i.paid_amount || 0)), 0);\n\n\t\t// Customer tier based on revenue and history\n\t\tlet tier: \"new\" | \"regular\" | \"vip\" | \"at_risk\" = \"new\";\n\t\tif (completedJobs.length >= 5 && totalRevenue > 5000) {\n\t\t\ttier = \"vip\";\n\t\t} else if (completedJobs.length >= 2) {\n\t\t\ttier = \"regular\";\n\t\t}\n\t\tif (negativeSentiments > positiveSentiments || overdueInvoices.length > 2) {\n\t\t\ttier = \"at_risk\";\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcustomer: {\n\t\t\t\tid: customer.id,\n\t\t\t\tname: customer.name,\n\t\t\t\temail: customer.email,\n\t\t\t\tphone: customer.phone,\n\t\t\t\tcreatedAt: customer.created_at,\n\t\t\t},\n\t\t\ttier,\n\t\t\tjobHistory: {\n\t\t\t\ttotalJobs: jobs.length,\n\t\t\t\tcompletedJobs: completedJobs.length,\n\t\t\t\ttotalRevenue,\n\t\t\t\tcommonJobTypes: jobTypes,\n\t\t\t\trecentJobs: jobs.slice(0, 5).map((j) => ({\n\t\t\t\t\ttitle: j.title,\n\t\t\t\t\ttype: j.job_type,\n\t\t\t\t\tstatus: j.status,\n\t\t\t\t\tamount: j.total_amount,\n\t\t\t\t})),\n\t\t\t},\n\t\t\tcommunicationHistory: {\n\t\t\t\ttotalInteractions: comms.length,\n\t\t\t\tchannelBreakdown: {\n\t\t\t\t\tcalls: comms.filter((c) => c.channel === \"phone\").length,\n\t\t\t\t\temails: comms.filter((c) => c.channel === \"email\").length,\n\t\t\t\t\tsms: comms.filter((c) => c.channel === \"sms\").length,\n\t\t\t\t},\n\t\t\t\tsentimentSummary: {\n\t\t\t\t\tpositive: positiveSentiments,\n\t\t\t\t\tnegative: negativeSentiments,\n\t\t\t\t\tneutral: sentiments.length - positiveSentiments - negativeSentiments,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfinancials: {\n\t\t\t\ttotalInvoices: invoices.length,\n\t\t\t\tpaidInvoices: paidInvoices.length,\n\t\t\t\toverdueInvoices: overdueInvoices.length,\n\t\t\t\tcurrentBalance: totalOwed,\n\t\t\t\tpaymentHealth:\n\t\t\t\t\toverdueInvoices.length === 0\n\t\t\t\t\t\t? \"good\"\n\t\t\t\t\t\t: overdueInvoices.length < 3\n\t\t\t\t\t\t\t? \"fair\"\n\t\t\t\t\t\t\t: \"poor\",\n\t\t\t},\n\t\t\tmemories: memories.map((m) => ({\n\t\t\t\tcontent: m.content,\n\t\t\t\ttype: m.memory_type,\n\t\t\t\timportance: m.importance,\n\t\t\t})),\n\t\t\trecommendations:\n\t\t\t\ttier === \"at_risk\"\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t\"Review recent negative interactions\",\n\t\t\t\t\t\t\t\"Consider follow-up call to address concerns\",\n\t\t\t\t\t\t\t\"Check for outstanding payment issues\",\n\t\t\t\t\t\t]\n\t\t\t\t\t: tier === \"vip\"\n\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\"Prioritize this customer's requests\",\n\t\t\t\t\t\t\t\t\"Consider loyalty discount or perks\",\n\t\t\t\t\t\t\t\t\"Proactive maintenance reminders\",\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t: [\"Standard service approach\", \"Opportunity to build relationship\"],\n\t\t};\n\t},\n});\n\n// ============================================================================\n// ROUTE OPTIMIZATION TOOLS\n// Integration with routing-service.ts for directions and supplier finding\n// ============================================================================\n\n/**\n * Get driving route between two or more locations\n */\nexport const getRouteTool = tool({\n\tdescription:\n\t\t\"Calculate optimal driving route between locations with distance and duration\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\twaypoints: z\n\t\t\t.array(\n\t\t\t\tz.object({\n\t\t\t\t\taddress: z.string().describe(\"Full address\"),\n\t\t\t\t\tlat: z.number().optional().describe(\"Latitude if known\"),\n\t\t\t\t\tlng: z.number().optional().describe(\"Longitude if known\"),\n\t\t\t\t})\n\t\t\t)\n\t\t\t.min(2)\n\t\t\t.describe(\"Array of waypoints (minimum 2: origin and destination)\"),\n\t\toptimizeOrder: z\n\t\t\t.boolean()\n\t\t\t.optional()\n\t\t\t.default(false)\n\t\t\t.describe(\"Whether to optimize waypoint order for shortest route\"),\n\t}),\n\texecute: async ({ waypoints }) => {\n\t\t// Geocode any waypoints without coordinates\n\t\tconst geocodedWaypoints = await Promise.all(\n\t\t\twaypoints.map(async (wp) => {\n\t\t\t\tif (wp.lat && wp.lng) {\n\t\t\t\t\treturn { ...wp, coordinates: [wp.lng, wp.lat] as [number, number] };\n\t\t\t\t}\n\t\t\t\t// Use geocoding service (Nominatim requires User-Agent per ToS)\n\t\t\t\tconst geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(wp.address)}&limit=1`;\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(geocodeUrl, {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"User-Agent\": \"Stratos-FSM/1.0 (https://stratos.app; support@stratos.app)\",\n\t\t\t\t\t\t\t\"Accept\": \"application/json\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tif (!response.ok) {\n\t\t\t\t\t\tconsole.warn(`Geocoding failed for ${wp.address}: ${response.status}`);\n\t\t\t\t\t\treturn { ...wp, coordinates: null };\n\t\t\t\t\t}\n\t\t\t\t\tconst data = await response.json();\n\t\t\t\t\tif (data.length > 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...wp,\n\t\t\t\t\t\t\tcoordinates: [\n\t\t\t\t\t\t\t\tparseFloat(data[0].lon),\n\t\t\t\t\t\t\t\tparseFloat(data[0].lat),\n\t\t\t\t\t\t\t] as [number, number],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn(`Geocoding error for ${wp.address}:`, error);\n\t\t\t\t}\n\t\t\t\treturn { ...wp, coordinates: null };\n\t\t\t})\n\t\t);\n\n\t\tconst validWaypoints = geocodedWaypoints.filter((wp) => wp.coordinates);\n\t\tif (validWaypoints.length < 2) {\n\t\t\treturn { error: \"Could not geocode enough waypoints for routing\" };\n\t\t}\n\n\t\t// Get route from OpenRouteService (if API key available)\n\t\tconst apiKey = process.env.OPENROUTESERVICE_API_KEY;\n\t\tif (apiKey) {\n\t\t\ttry {\n\t\t\t\tconst coordinates = validWaypoints.map((wp) => wp.coordinates);\n\t\t\t\tconst response = await fetch(\n\t\t\t\t\t\"https://api.openrouteservice.org/v2/directions/driving-car/geojson\",\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tAuthorization: apiKey,\n\t\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbody: JSON.stringify({ coordinates, instructions: true }),\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tconst routeData = await response.json();\n\n\t\t\t\tif (routeData.features?.[0]) {\n\t\t\t\t\tconst feature = routeData.features[0];\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdistance_km: (feature.properties.summary.distance / 1000).toFixed(1),\n\t\t\t\t\t\tduration_minutes: Math.round(feature.properties.summary.duration / 60),\n\t\t\t\t\t\twaypoints: validWaypoints.map((wp) => wp.address),\n\t\t\t\t\t\tgeometry: feature.geometry,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Fall through to estimate\n\t\t\t}\n\t\t}\n\n\t\t// Fallback: Calculate straight-line distance estimate\n\t\tconst coords = validWaypoints.map((wp) => wp.coordinates!);\n\t\tlet totalDistance = 0;\n\t\tfor (let i = 0; i < coords.length - 1; i++) {\n\t\t\tconst [lon1, lat1] = coords[i];\n\t\t\tconst [lon2, lat2] = coords[i + 1];\n\t\t\tconst R = 6371;\n\t\t\tconst dLat = ((lat2 - lat1) * Math.PI) / 180;\n\t\t\tconst dLon = ((lon2 - lon1) * Math.PI) / 180;\n\t\t\tconst a =\n\t\t\t\tMath.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\t\tMath.cos((lat1 * Math.PI) / 180) *\n\t\t\t\t\tMath.cos((lat2 * Math.PI) / 180) *\n\t\t\t\t\tMath.sin(dLon / 2) *\n\t\t\t\t\tMath.sin(dLon / 2);\n\t\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\t\ttotalDistance += R * c;\n\t\t}\n\n\t\tconst drivingDistance = totalDistance * 1.3;\n\t\tconst durationMinutes = Math.round((drivingDistance / 50) * 60);\n\n\t\treturn {\n\t\t\tdistance_km: drivingDistance.toFixed(1),\n\t\t\tduration_minutes: durationMinutes,\n\t\t\twaypoints: validWaypoints.map((wp) => wp.address),\n\t\t\tnote: \"Estimated based on straight-line distance\",\n\t\t};\n\t},\n});\n\n/**\n * Find nearby suppliers (plumbing supply, electrical supply, etc.)\n */\nexport const findNearbySuppliersTool = tool({\n\tdescription: \"Find nearby supply stores for parts (plumbing, electrical, HVAC, hardware)\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tlocation: z.object({\n\t\t\tlat: z.number().describe(\"Latitude\"),\n\t\t\tlng: z.number().describe(\"Longitude\"),\n\t\t}),\n\t\tsupplyType: z\n\t\t\t.enum([\"plumbing\", \"electrical\", \"hvac\", \"hardware\", \"all\"])\n\t\t\t.default(\"all\"),\n\t\tradiusKm: z.number().optional().default(10),\n\t}),\n\texecute: async ({ location, supplyType, radiusKm }) => {\n\t\tconst typeFilters: Record<string, string> = {\n\t\t\tplumbing: '[\"shop\"=\"trade\"][\"trade\"~\"plumbing|bathroom\"]',\n\t\t\telectrical: '[\"shop\"=\"trade\"][\"trade\"~\"electrical\"]',\n\t\t\thvac: '[\"shop\"=\"trade\"][\"trade\"~\"hvac|air_conditioning\"]',\n\t\t\thardware: '[\"shop\"=\"doityourself\"]',\n\t\t\tall: '[\"shop\"~\"trade|doityourself|hardware\"]',\n\t\t};\n\n\t\tconst filter = typeFilters[supplyType];\n\t\tconst query = `[out:json][timeout:25];(node${filter}(around:${radiusKm * 1000},${location.lat},${location.lng});way${filter}(around:${radiusKm * 1000},${location.lat},${location.lng}););out center;`;\n\n\t\ttry {\n\t\t\tconst response = await fetch(\"https://overpass-api.de/api/interpreter\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: query,\n\t\t\t});\n\t\t\tconst data = await response.json();\n\n\t\t\tconst suppliers = data.elements\n\t\t\t\t.map((el: { tags?: { name?: string; phone?: string; website?: string }; lat?: number; lon?: number; center?: { lat: number; lon: number } }) => ({\n\t\t\t\t\tname: el.tags?.name || \"Unknown Supplier\",\n\t\t\t\t\tphone: el.tags?.phone,\n\t\t\t\t\twebsite: el.tags?.website,\n\t\t\t\t\tlat: el.lat || el.center?.lat,\n\t\t\t\t\tlng: el.lon || el.center?.lon,\n\t\t\t\t}))\n\t\t\t\t.filter((s: { name: string }) => s.name !== \"Unknown Supplier\")\n\t\t\t\t.slice(0, 10);\n\n\t\t\treturn { suppliers, searchRadius: radiusKm, supplyType };\n\t\t} catch {\n\t\t\treturn { error: \"Failed to search for suppliers\" };\n\t\t}\n\t},\n});\n\n// ============================================================================\n// INVENTORY & PARTS TOOLS\n// ============================================================================\n\n/**\n * Search inventory for parts\n */\nexport const searchInventoryTool = tool({\n\tdescription: \"Search company inventory for parts by name, SKU, or category\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tquery: z.string().describe(\"Search query\"),\n\t\tcategory: z.string().optional(),\n\t\tinStockOnly: z.boolean().optional().default(false),\n\t}),\n\texecute: async ({ companyId, query, category, inStockOnly }) => {\n\t\tconst supabase = await createClient();\n\n\t\tlet dbQuery = supabase\n\t\t\t.from(\"inventory\")\n\t\t\t.select(\"id, sku, name, description, category, quantity_on_hand, quantity_reserved, reorder_point, unit_cost, unit_price, location\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(`name.ilike.%${query}%,sku.ilike.%${query}%,description.ilike.%${query}%`);\n\n\t\tif (category) dbQuery = dbQuery.eq(\"category\", category);\n\t\tif (inStockOnly) dbQuery = dbQuery.gt(\"quantity_on_hand\", 0);\n\n\t\tconst { data, error } = await dbQuery.order(\"name\").limit(20);\n\t\tif (error) return { error: error.message };\n\n\t\treturn {\n\t\t\titems: data.map((item) => ({\n\t\t\t\t...item,\n\t\t\t\tavailable: item.quantity_on_hand - (item.quantity_reserved || 0),\n\t\t\t\tneedsReorder: item.quantity_on_hand <= (item.reorder_point || 0),\n\t\t\t})),\n\t\t\ttotal: data.length,\n\t\t};\n\t},\n});\n\n/**\n * Check parts availability for a job\n */\nexport const checkPartsAvailabilityTool = tool({\n\tdescription: \"Check if required parts are available in inventory for a job\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tparts: z.array(\n\t\t\tz.object({\n\t\t\t\titemId: z.string().optional(),\n\t\t\t\tsku: z.string().optional(),\n\t\t\t\tname: z.string().optional(),\n\t\t\t\tquantity: z.number(),\n\t\t\t})\n\t\t),\n\t}),\n\texecute: async ({ companyId, parts }) => {\n\t\tif (!parts.length) {\n\t\t\treturn { error: \"At least one part is required\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\t// Batch lookup: collect IDs and SKUs for a single query\n\t\tconst itemIds = parts.filter((p) => p.itemId).map((p) => p.itemId!);\n\t\tconst skus = parts.filter((p) => p.sku && !p.itemId).map((p) => p.sku!);\n\n\t\t// Fetch all matching inventory items in one query\n\t\tlet inventoryQuery = supabase\n\t\t\t.from(\"inventory\")\n\t\t\t.select(\"id, sku, name, quantity_on_hand, quantity_reserved, unit_cost, unit_price\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\t// Build OR conditions for batch lookup\n\t\tconst orConditions: string[] = [];\n\t\tif (itemIds.length > 0) {\n\t\t\torConditions.push(`id.in.(${itemIds.join(\",\")})`);\n\t\t}\n\t\tif (skus.length > 0) {\n\t\t\torConditions.push(`sku.in.(${skus.join(\",\")})`);\n\t\t}\n\n\t\tlet inventoryItems: { id: string; sku: string | null; name: string; quantity_on_hand: number; quantity_reserved: number | null; unit_cost: number | null; unit_price: number | null }[] = [];\n\n\t\tif (orConditions.length > 0) {\n\t\t\tconst { data } = await inventoryQuery.or(orConditions.join(\",\"));\n\t\t\tinventoryItems = data || [];\n\t\t}\n\n\t\t// For name-based lookups, we still need individual queries (fuzzy match)\n\t\tconst nameOnlyParts = parts.filter((p) => !p.itemId && !p.sku && p.name);\n\t\tif (nameOnlyParts.length > 0) {\n\t\t\tconst nameResults = await Promise.all(\n\t\t\t\tnameOnlyParts.map(async (part) => {\n\t\t\t\t\tconst { data } = await supabase\n\t\t\t\t\t\t.from(\"inventory\")\n\t\t\t\t\t\t.select(\"id, sku, name, quantity_on_hand, quantity_reserved, unit_cost, unit_price\")\n\t\t\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t\t.ilike(\"name\", `%${part.name}%`)\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.single();\n\t\t\t\t\treturn data;\n\t\t\t\t})\n\t\t\t);\n\t\t\tinventoryItems.push(...nameResults.filter((r): r is NonNullable<typeof r> => r !== null));\n\t\t}\n\n\t\t// Map results to parts\n\t\tconst results = parts.map((part) => {\n\t\t\tconst item = inventoryItems.find(\n\t\t\t\t(inv) =>\n\t\t\t\t\t(part.itemId && inv.id === part.itemId) ||\n\t\t\t\t\t(part.sku && inv.sku === part.sku) ||\n\t\t\t\t\t(part.name && inv.name.toLowerCase().includes(part.name.toLowerCase()))\n\t\t\t);\n\n\t\t\tif (!item) {\n\t\t\t\treturn { ...part, found: false, available: 0, canFulfill: false };\n\t\t\t}\n\n\t\t\tconst available = item.quantity_on_hand - (item.quantity_reserved || 0);\n\t\t\treturn {\n\t\t\t\titemId: item.id,\n\t\t\t\tsku: item.sku,\n\t\t\t\tname: item.name,\n\t\t\t\tfound: true,\n\t\t\t\tavailable,\n\t\t\t\tneeded: part.quantity,\n\t\t\t\tcanFulfill: available >= part.quantity,\n\t\t\t\tunitPrice: item.unit_price,\n\t\t\t\ttotalPrice: (item.unit_price || 0) * part.quantity,\n\t\t\t};\n\t\t});\n\n\t\treturn {\n\t\t\tallPartsAvailable: results.every((r) => r.canFulfill),\n\t\t\tparts: results,\n\t\t\tmissingParts: results.filter((r) => !r.canFulfill),\n\t\t\ttotalEstimatedPrice: results.reduce((sum, r) => sum + (r.totalPrice || 0), 0),\n\t\t};\n\t},\n});\n\n/**\n * Get low stock alerts\n */\nexport const getLowStockAlertsTool = tool({\n\tdescription: \"Get inventory items at or below reorder point\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tcategory: z.string().optional(),\n\t\tlimit: z.number().optional().default(50).describe(\"Max items to return\"),\n\t}),\n\texecute: async ({ companyId, category, limit }) => {\n\t\tconst supabase = await createClient();\n\n\t\t// Use a raw filter to get only items where quantity <= reorder_point\n\t\tlet query = supabase\n\t\t\t.from(\"inventory\")\n\t\t\t.select(\"id, sku, name, category, quantity_on_hand, reorder_point, reorder_quantity, unit_cost\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.not(\"reorder_point\", \"is\", null);\n\n\t\tif (category) query = query.eq(\"category\", category);\n\n\t\tconst { data, error } = await query.order(\"quantity_on_hand\", { ascending: true }).limit(limit * 2);\n\t\tif (error) return { error: error.message };\n\n\t\t// Filter for items at or below reorder point and limit\n\t\tconst lowStockItems = data\n\t\t\t.filter((item) => item.quantity_on_hand <= (item.reorder_point || 0))\n\t\t\t.slice(0, limit)\n\t\t\t.map((item) => ({\n\t\t\t\t...item,\n\t\t\t\tshortfall: (item.reorder_point || 0) - item.quantity_on_hand,\n\t\t\t\tsuggestedOrderQty: item.reorder_quantity || 10,\n\t\t\t\turgency: item.quantity_on_hand === 0 ? \"critical\" : item.quantity_on_hand <= (item.reorder_point || 0) / 2 ? \"high\" : \"normal\",\n\t\t\t}));\n\n\t\treturn {\n\t\t\tlowStockCount: lowStockItems.length,\n\t\t\titems: lowStockItems,\n\t\t\tcriticalCount: lowStockItems.filter((i) => i.urgency === \"critical\").length,\n\t\t};\n\t},\n});\n\n// ============================================================================\n// EQUIPMENT HISTORY TOOLS\n// ============================================================================\n\n/**\n * Get equipment at a property\n */\nexport const getPropertyEquipmentTool = tool({\n\tdescription: \"Get list of equipment installed at a customer's property\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tpropertyId: z.string().optional(),\n\t\tcustomerId: z.string().optional(),\n\t}),\n\texecute: async ({ companyId, propertyId, customerId }) => {\n\t\t// Validate: at least one filter is required\n\t\tif (!propertyId && !customerId) {\n\t\t\treturn { error: \"Either propertyId or customerId is required\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tlet query = supabase\n\t\t\t.from(\"equipment\")\n\t\t\t.select(\"id, name, model_number, serial_number, manufacturer, install_date, warranty_expiry, last_service_date, next_service_due, status, notes\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\tif (propertyId) {\n\t\t\tquery = query.eq(\"property_id\", propertyId);\n\t\t} else if (customerId) {\n\t\t\tconst { data: properties } = await supabase\n\t\t\t\t.from(\"properties\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null);\n\t\t\tif (!properties?.length) {\n\t\t\t\treturn { equipment: [], total: 0, message: \"No properties found for this customer\" };\n\t\t\t}\n\t\t\tquery = query.in(\"property_id\", properties.map((p) => p.id));\n\t\t}\n\n\t\tconst { data, error } = await query.order(\"name\").limit(100);\n\t\tif (error) return { error: error.message };\n\n\t\tconst now = new Date();\n\t\treturn {\n\t\t\tequipment: data.map((eq) => ({\n\t\t\t\t...eq,\n\t\t\t\twarrantyStatus: eq.warranty_expiry\n\t\t\t\t\t? new Date(eq.warranty_expiry) > now ? \"active\" : \"expired\"\n\t\t\t\t\t: \"unknown\",\n\t\t\t\tserviceDue: eq.next_service_due ? new Date(eq.next_service_due) <= now : false,\n\t\t\t})),\n\t\t\ttotal: data.length,\n\t\t};\n\t},\n});\n\n/**\n * Get service history for specific equipment\n */\nexport const getEquipmentServiceHistoryTool = tool({\n\tdescription: \"Get service history for a specific piece of equipment\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tequipmentId: z.string().describe(\"Equipment UUID\"),\n\t\tlimit: z.number().optional().default(10),\n\t}),\n\texecute: async ({ companyId, equipmentId, limit }) => {\n\t\tconst supabase = await createClient();\n\n\t\tconst { data: equipment } = await supabase\n\t\t\t.from(\"equipment\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", equipmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!equipment) return { error: \"Equipment not found\" };\n\n\t\tconst { data: serviceHistory } = await supabase\n\t\t\t.from(\"job_equipment\")\n\t\t\t.select(\"job:jobs(id, title, status, completed_at), notes, work_performed, created_at\")\n\t\t\t.eq(\"equipment_id\", equipmentId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\treturn {\n\t\t\tequipment: {\n\t\t\t\tid: equipment.id,\n\t\t\t\tname: equipment.name,\n\t\t\t\tmodel: equipment.model_number,\n\t\t\t\tserial: equipment.serial_number,\n\t\t\t},\n\t\t\tserviceHistory: serviceHistory || [],\n\t\t\ttotalServices: serviceHistory?.length || 0,\n\t\t};\n\t},\n});\n\n/**\n * Check equipment warranty status\n */\nexport const checkEquipmentWarrantyTool = tool({\n\tdescription: \"Check warranty status for equipment\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tequipmentId: z.string().describe(\"Equipment UUID\"),\n\t}),\n\texecute: async ({ companyId, equipmentId }) => {\n\t\tconst supabase = await createClient();\n\n\t\tconst { data: equipment, error } = await supabase\n\t\t\t.from(\"equipment\")\n\t\t\t.select(\"id, name, model_number, serial_number, warranty_expiry, warranty_type, warranty_notes\")\n\t\t\t.eq(\"id\", equipmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error || !equipment) return { error: \"Equipment not found\" };\n\n\t\tconst now = new Date();\n\t\tconst warrantyEnd = equipment.warranty_expiry ? new Date(equipment.warranty_expiry) : null;\n\t\tlet status: \"active\" | \"expired\" | \"expiring_soon\" | \"unknown\" = \"unknown\";\n\t\tlet daysRemaining = null;\n\n\t\tif (warrantyEnd) {\n\t\t\tdaysRemaining = Math.ceil((warrantyEnd.getTime() - now.getTime()) / (24 * 60 * 60 * 1000));\n\t\t\tstatus = daysRemaining < 0 ? \"expired\" : daysRemaining <= 30 ? \"expiring_soon\" : \"active\";\n\t\t}\n\n\t\treturn {\n\t\t\tequipment: { name: equipment.name, model: equipment.model_number, serial: equipment.serial_number },\n\t\t\twarranty: {\n\t\t\t\tstatus,\n\t\t\t\texpiryDate: equipment.warranty_expiry,\n\t\t\t\tdaysRemaining: daysRemaining && daysRemaining > 0 ? daysRemaining : 0,\n\t\t\t\ttype: equipment.warranty_type,\n\t\t\t},\n\t\t};\n\t},\n});\n\n// ============================================================================\n// TECHNICIAN MATCHING TOOLS\n// ============================================================================\n\n/**\n * Find technicians by skills\n */\nexport const findTechniciansBySkillsTool = tool({\n\tdescription: \"Find available technicians with specific skills or certifications\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tskills: z.array(z.string()).optional(),\n\t\tcertifications: z.array(z.string()).optional(),\n\t\tdate: z.string().optional().describe(\"Date to check availability\"),\n\t}),\n\texecute: async ({ companyId, skills, certifications, date }) => {\n\t\ttry {\n\t\t\tconst supabase = await createClient();\n\n\t\t\tconst { data: members, error } = await supabase\n\t\t\t\t.from(\"company_memberships\")\n\t\t\t\t.select(\"id, role, skills, certifications, service_areas, user:users(id, first_name, last_name, email)\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"role\", \"technician\");\n\n\t\t\tif (error) return { error: error.message };\n\n\t\t\tlet filtered = members;\n\t\t\tif (skills?.length) {\n\t\t\t\tfiltered = filtered.filter((m) =>\n\t\t\t\t\tskills.some((skill) =>\n\t\t\t\t\t\t((m.skills as string[]) || []).map((s) => s.toLowerCase()).includes(skill.toLowerCase())\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (certifications?.length) {\n\t\t\t\tfiltered = filtered.filter((m) =>\n\t\t\t\t\tcertifications.some((cert) =>\n\t\t\t\t\t\t((m.certifications as string[]) || []).map((c) => c.toLowerCase()).includes(cert.toLowerCase())\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (date) {\n\t\t\t\tconst dayStart = new Date(date);\n\t\t\t\tdayStart.setHours(0, 0, 0, 0);\n\t\t\t\tconst dayEnd = new Date(date);\n\t\t\t\tdayEnd.setHours(23, 59, 59, 999);\n\n\t\t\t\tconst { data: assignments } = await supabase\n\t\t\t\t\t.from(\"jobs\")\n\t\t\t\t\t.select(\"assigned_to\")\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.in(\"assigned_to\", filtered.map((m) => m.id))\n\t\t\t\t\t.gte(\"scheduled_start\", dayStart.toISOString())\n\t\t\t\t\t.lte(\"scheduled_start\", dayEnd.toISOString());\n\n\t\t\t\tconst jobCounts: Record<string, number> = {};\n\t\t\t\tassignments?.forEach((a) => {\n\t\t\t\t\tif (a.assigned_to) jobCounts[a.assigned_to] = (jobCounts[a.assigned_to] || 0) + 1;\n\t\t\t\t});\n\n\t\t\t\tfiltered = filtered.map((m) => ({\n\t\t\t\t\t...m,\n\t\t\t\t\tjobsOnDate: jobCounts[m.id] || 0,\n\t\t\t\t\tavailability: (jobCounts[m.id] || 0) === 0 ? \"available\" : (jobCounts[m.id] || 0) < 4 ? \"partially_booked\" : \"fully_booked\",\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttechnicians: filtered.map((m) => ({\n\t\t\t\t\tid: m.id,\n\t\t\t\t\tname: `${(m.user as { first_name: string; last_name: string })?.first_name} ${(m.user as { first_name: string; last_name: string })?.last_name}`,\n\t\t\t\t\tskills: m.skills,\n\t\t\t\t\tcertifications: m.certifications,\n\t\t\t\t\tavailability: (m as { availability?: string }).availability,\n\t\t\t\t})),\n\t\t\t\ttotal: filtered.length,\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treturn { error: err instanceof Error ? err.message : \"Failed to find technicians\" };\n\t\t}\n\t},\n});\n\n/**\n * Get technician workload\n */\nexport const getTechnicianWorkloadTool = tool({\n\tdescription: \"Get a technician's current workload and schedule\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\ttechnicianId: z.string().describe(\"Technician membership UUID\"),\n\t\tstartDate: z.string(),\n\t\tendDate: z.string(),\n\t}),\n\texecute: async ({ companyId, technicianId, startDate, endDate }) => {\n\t\ttry {\n\t\t\tconst supabase = await createClient();\n\n\t\t\tconst { data: tech } = await supabase\n\t\t\t\t.from(\"company_memberships\")\n\t\t\t\t.select(\"id, user:users(first_name, last_name)\")\n\t\t\t\t.eq(\"id\", technicianId)\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.single();\n\n\t\t\tif (!tech) return { error: \"Technician not found\" };\n\n\t\t\tconst { data: jobs } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, status, scheduled_start, scheduled_end, customer:customers(name)\")\n\t\t\t\t.eq(\"assigned_to\", technicianId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.gte(\"scheduled_start\", startDate)\n\t\t\t\t.lte(\"scheduled_start\", endDate)\n\t\t\t\t.order(\"scheduled_start\");\n\n\t\t\treturn {\n\t\t\t\ttechnician: { id: tech.id, name: `${(tech.user as { first_name: string; last_name: string })?.first_name} ${(tech.user as { first_name: string; last_name: string })?.last_name}` },\n\t\t\t\tsummary: {\n\t\t\t\t\ttotalJobs: jobs?.length || 0,\n\t\t\t\t\tcompleted: jobs?.filter((j) => j.status === \"completed\").length || 0,\n\t\t\t\t\tscheduled: jobs?.filter((j) => j.status === \"scheduled\").length || 0,\n\t\t\t\t},\n\t\t\t\tjobs: jobs?.map((j) => ({\n\t\t\t\t\tid: j.id,\n\t\t\t\t\ttitle: j.title,\n\t\t\t\t\tstatus: j.status,\n\t\t\t\t\tscheduledStart: j.scheduled_start,\n\t\t\t\t\tcustomer: (j.customer as { name: string })?.name,\n\t\t\t\t})) || [],\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treturn { error: err instanceof Error ? err.message : \"Failed to get technician workload\" };\n\t\t}\n\t},\n});\n\n// ============================================================================\n// PRICING & ESTIMATION TOOLS\n// ============================================================================\n\n/**\n * Search price book for services\n */\nexport const searchPriceBookTool = tool({\n\tdescription: \"Search price book for services, parts, and flat-rate pricing\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tquery: z.string(),\n\t\tcategory: z.string().optional(),\n\t}),\n\texecute: async ({ companyId, query, category }) => {\n\t\tconst supabase = await createClient();\n\n\t\tlet dbQuery = supabase\n\t\t\t.from(\"price_book_items\")\n\t\t\t.select(\"id, name, description, category, sku, unit_price, cost, is_active\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"is_active\", true)\n\t\t\t.or(`name.ilike.%${query}%,description.ilike.%${query}%,sku.ilike.%${query}%`);\n\n\t\tif (category) dbQuery = dbQuery.eq(\"category\", category);\n\t\tconst { data, error } = await dbQuery.order(\"name\").limit(20);\n\t\tif (error) return { error: error.message };\n\n\t\treturn {\n\t\t\titems: data.map((item) => ({\n\t\t\t\t...item,\n\t\t\t\tprofit: item.unit_price - (item.cost || 0),\n\t\t\t})),\n\t\t\ttotal: data.length,\n\t\t};\n\t},\n});\n\n/**\n * Calculate estimate from price book items\n */\nexport const calculateEstimateTool = tool({\n\tdescription: \"Calculate an estimate total from price book items\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\titems: z.array(\n\t\t\tz.object({\n\t\t\t\tpriceBookItemId: z.string().optional(),\n\t\t\t\tname: z.string().optional(),\n\t\t\t\tquantity: z.number().default(1),\n\t\t\t\tcustomPrice: z.number().optional(),\n\t\t\t})\n\t\t),\n\t\tdiscount: z.object({ type: z.enum([\"percentage\", \"fixed\"]), value: z.number() }).optional(),\n\t\ttaxRate: z.number().optional(),\n\t}),\n\texecute: async ({ companyId, items, discount, taxRate }) => {\n\t\tconst supabase = await createClient();\n\n\t\tconst priceBookIds = items.filter((i) => i.priceBookItemId).map((i) => i.priceBookItemId);\n\t\tlet priceBookItems: { id: string; name: string; unit_price: number; cost: number | null }[] = [];\n\t\tif (priceBookIds.length > 0) {\n\t\t\tconst { data } = await supabase.from(\"price_book_items\").select(\"id, name, unit_price, cost\").in(\"id\", priceBookIds);\n\t\t\tpriceBookItems = data || [];\n\t\t}\n\n\t\tconst lineItems = items.map((item) => {\n\t\t\tconst pbItem = priceBookItems.find((p) => p.id === item.priceBookItemId);\n\t\t\tconst unitPrice = item.customPrice || pbItem?.unit_price || 0;\n\t\t\treturn {\n\t\t\t\tname: item.name || pbItem?.name || \"Unknown Item\",\n\t\t\t\tquantity: item.quantity,\n\t\t\t\tunitPrice,\n\t\t\t\tlineTotal: unitPrice * item.quantity,\n\t\t\t};\n\t\t});\n\n\t\tconst subtotal = lineItems.reduce((sum, item) => sum + item.lineTotal, 0);\n\t\tlet discountAmount = 0;\n\t\tif (discount) {\n\t\t\tdiscountAmount = discount.type === \"percentage\" ? subtotal * (discount.value / 100) : discount.value;\n\t\t}\n\t\tconst afterDiscount = subtotal - discountAmount;\n\t\tconst taxAmount = afterDiscount * ((taxRate || 0) / 100);\n\n\t\treturn {\n\t\t\tlineItems,\n\t\t\tsubtotal,\n\t\t\tdiscount: discountAmount > 0 ? { ...discount, amount: discountAmount } : null,\n\t\t\ttax: { rate: taxRate || 0, amount: taxAmount },\n\t\t\tgrandTotal: afterDiscount + taxAmount,\n\t\t};\n\t},\n});\n\n// ============================================================================\n// SMART SCHEDULING TOOLS\n// ============================================================================\n\n/**\n * Suggest best technician for a job\n */\nexport const suggestTechnicianForJobTool = tool({\n\tdescription: \"Suggest the best technician for a job based on skills, location, and availability\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\tjobType: z.string(),\n\t\trequiredSkills: z.array(z.string()).optional(),\n\t\tpreferredDate: z.string(),\n\t}),\n\texecute: async ({ companyId, jobType, requiredSkills, preferredDate }) => {\n\t\ttry {\n\t\t\tconst supabase = await createClient();\n\n\t\t\tconst { data: technicians } = await supabase\n\t\t\t\t.from(\"company_memberships\")\n\t\t\t\t.select(\"id, skills, preferred_job_types, user:users(first_name, last_name)\")\n\t\t\t\t.eq(\"company_id\", companyId)\n\t\t\t\t.eq(\"role\", \"technician\");\n\n\t\t\tif (!technicians?.length) return { error: \"No technicians found\" };\n\n\t\t\tconst dayStart = new Date(preferredDate);\n\t\t\tdayStart.setHours(0, 0, 0, 0);\n\t\t\tconst dayEnd = new Date(preferredDate);\n\t\t\tdayEnd.setHours(23, 59, 59, 999);\n\n\t\t\tconst { data: existingJobs } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"assigned_to\")\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.in(\"assigned_to\", technicians.map((t) => t.id))\n\t\t\t\t.gte(\"scheduled_start\", dayStart.toISOString())\n\t\t\t\t.lte(\"scheduled_start\", dayEnd.toISOString());\n\n\t\t\tconst jobCounts: Record<string, number> = {};\n\t\t\texistingJobs?.forEach((j) => {\n\t\t\t\tif (j.assigned_to) jobCounts[j.assigned_to] = (jobCounts[j.assigned_to] || 0) + 1;\n\t\t\t});\n\n\t\t\tconst scored = technicians.map((tech) => {\n\t\t\t\tlet score = 0;\n\t\t\t\tconst reasons: string[] = [];\n\n\t\t\t\tconst techSkills = ((tech.skills as string[]) || []).map((s) => s.toLowerCase());\n\t\t\t\tconst matchedSkills = (requiredSkills || []).filter((s) => techSkills.includes(s.toLowerCase()));\n\t\t\t\tif (matchedSkills.length > 0) {\n\t\t\t\t\tscore += 40 * (matchedSkills.length / (requiredSkills?.length || 1));\n\t\t\t\t\treasons.push(`Matches ${matchedSkills.length} skills`);\n\t\t\t\t}\n\n\t\t\t\tconst preferredTypes = ((tech.preferred_job_types as string[]) || []).map((t) => t.toLowerCase());\n\t\t\t\tif (preferredTypes.includes(jobType.toLowerCase())) {\n\t\t\t\t\tscore += 20;\n\t\t\t\t\treasons.push(\"Prefers this job type\");\n\t\t\t\t}\n\n\t\t\t\tconst techJobs = jobCounts[tech.id] || 0;\n\t\t\t\tif (techJobs === 0) { score += 30; reasons.push(\"Fully available\"); }\n\t\t\t\telse if (techJobs < 3) { score += 15; reasons.push(`${techJobs} jobs scheduled`); }\n\n\t\t\t\treturn {\n\t\t\t\t\tid: tech.id,\n\t\t\t\t\tname: `${(tech.user as { first_name: string; last_name: string })?.first_name} ${(tech.user as { first_name: string; last_name: string })?.last_name}`,\n\t\t\t\t\tscore: Math.round(score),\n\t\t\t\t\treasons,\n\t\t\t\t\tjobsOnDate: techJobs,\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tscored.sort((a, b) => b.score - a.score);\n\t\t\treturn { recommendations: scored.slice(0, 5), bestMatch: scored[0] };\n\t\t} catch (err) {\n\t\t\treturn { error: err instanceof Error ? err.message : \"Failed to suggest technician\" };\n\t\t}\n\t},\n});\n\n/**\n * Optimize job order for a technician's day\n */\nexport const optimizeJobOrderTool = tool({\n\tdescription: \"Optimize the order of jobs for a technician to minimize travel time\",\n\tparameters: z.object({\n\t\tcompanyId: z.string().describe(\"Company UUID\"),\n\t\ttechnicianId: z.string(),\n\t\tdate: z.string(),\n\t}),\n\texecute: async ({ technicianId, date }) => {\n\t\ttry {\n\t\t\tconst supabase = await createClient();\n\n\t\t\tconst dayStart = new Date(date);\n\t\t\tdayStart.setHours(0, 0, 0, 0);\n\t\t\tconst dayEnd = new Date(date);\n\t\t\tdayEnd.setHours(23, 59, 59, 999);\n\n\t\t\tconst { data: jobs } = await supabase\n\t\t\t\t.from(\"jobs\")\n\t\t\t\t.select(\"id, title, scheduled_start, priority, property:properties(address, city, latitude, longitude)\")\n\t\t\t\t.eq(\"assigned_to\", technicianId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.gte(\"scheduled_start\", dayStart.toISOString())\n\t\t\t\t.lte(\"scheduled_start\", dayEnd.toISOString())\n\t\t\t\t.order(\"scheduled_start\");\n\n\t\t\tif (!jobs || jobs.length < 2) return { message: \"Not enough jobs to optimize\", jobs: jobs || [] };\n\n\t\t\tconst jobsWithCoords = jobs\n\t\t\t\t.filter((j) => (j.property as { latitude: number; longitude: number })?.latitude)\n\t\t\t\t.map((j) => ({\n\t\t\t\t\t...j,\n\t\t\t\t\tlat: (j.property as { latitude: number })?.latitude,\n\t\t\t\t\tlng: (j.property as { longitude: number })?.longitude,\n\t\t\t\t}));\n\n\t\t\tif (jobsWithCoords.length < 2) return { message: \"Not enough jobs with location data\", jobs };\n\n\t\t\t// Simple nearest-neighbor optimization\n\t\t\tconst optimized: typeof jobsWithCoords = [];\n\t\t\tconst remaining = [...jobsWithCoords];\n\t\t\tlet current = { lat: jobsWithCoords[0].lat, lng: jobsWithCoords[0].lng };\n\n\t\t\twhile (remaining.length > 0) {\n\t\t\t\tlet nearestIdx = 0;\n\t\t\t\tlet nearestDist = Infinity;\n\t\t\t\tremaining.forEach((job, idx) => {\n\t\t\t\t\tconst dist = Math.sqrt(Math.pow(job.lat - current.lat, 2) + Math.pow(job.lng - current.lng, 2));\n\t\t\t\t\tconst priorityBonus = job.priority === \"high\" ? 0.8 : 1;\n\t\t\t\t\tif (dist * priorityBonus < nearestDist) {\n\t\t\t\t\t\tnearestDist = dist * priorityBonus;\n\t\t\t\t\t\tnearestIdx = idx;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst next = remaining.splice(nearestIdx, 1)[0];\n\t\t\t\toptimized.push(next);\n\t\t\t\tcurrent = { lat: next.lat, lng: next.lng };\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\toptimizedOrder: optimized.map((j, idx) => ({\n\t\t\t\t\torder: idx + 1,\n\t\t\t\t\tjobId: j.id,\n\t\t\t\t\ttitle: j.title,\n\t\t\t\t\taddress: `${(j.property as { address: string; city: string })?.address}, ${(j.property as { address: string; city: string })?.city}`,\n\t\t\t\t})),\n\t\t\t\tjobCount: optimized.length,\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treturn { error: err instanceof Error ? err.message : \"Failed to optimize job order\" };\n\t\t}\n\t},\n});\n\n// ============================================================================\n// WEB SEARCH & RESEARCH TOOLS\n// ============================================================================\n\n/**\n * Web search tool - Search the web for information\n * Use this for general questions, industry news, regulations, pricing research, etc.\n */\nexport const webSearchTool = tool({\n\tdescription: \"Search the web for information. Use this to find answers to questions, research topics, look up current events, regulations, industry news, competitor information, or any general knowledge questions.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"The search query - be specific and include relevant keywords\"),\n\t\tnumResults: z.number().optional().default(5).describe(\"Number of results to return (1-10)\"),\n\t\tdateRestrict: z.string().optional().describe(\"Limit to recent results: d7 (7 days), m1 (1 month), y1 (1 year)\"),\n\t}),\n\texecute: async ({ query, numResults, dateRestrict }) => {\n\t\tif (!googleCustomSearchService.isConfigured()) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Web search is not configured. Please set GOOGLE_API_KEY and GOOGLE_SEARCH_ENGINE_ID.\",\n\t\t\t\tconfigStatus: googleCustomSearchService.getConfigStatus(),\n\t\t\t};\n\t\t}\n\n\t\tconst results = await googleCustomSearchService.search(query, {\n\t\t\tnum: Math.min(numResults, 10),\n\t\t\tdateRestrict,\n\t\t});\n\n\t\tif (!results) {\n\t\t\treturn { success: false, error: \"Search failed. Please try again.\" };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tquery,\n\t\t\ttotalResults: results.totalResults,\n\t\t\tsearchTime: results.searchTime,\n\t\t\tresults: results.results.map((r) => ({\n\t\t\t\ttitle: r.title,\n\t\t\t\turl: r.link,\n\t\t\t\tsnippet: r.snippet,\n\t\t\t\tsource: r.displayLink,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Web search for news - Search for recent news articles\n * Use this for industry news, current events, company news, etc.\n */\nexport const webSearchNewsTool = tool({\n\tdescription: \"Search for recent news articles. Use this for industry news, current events, company updates, regulation changes, or any time-sensitive information.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"The news search query - include topic and relevant keywords\"),\n\t\tdaysBack: z.number().optional().default(7).describe(\"How many days back to search (1-30)\"),\n\t\tnumResults: z.number().optional().default(5).describe(\"Number of results to return (1-10)\"),\n\t}),\n\texecute: async ({ query, daysBack, numResults }) => {\n\t\tif (!googleCustomSearchService.isConfigured()) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Web search is not configured. Please set GOOGLE_API_KEY and GOOGLE_SEARCH_ENGINE_ID.\",\n\t\t\t};\n\t\t}\n\n\t\tconst results = await googleCustomSearchService.searchNews(query, {\n\t\t\tdaysBack: Math.min(daysBack, 30),\n\t\t\tnum: Math.min(numResults, 10),\n\t\t});\n\n\t\tif (!results) {\n\t\t\treturn { success: false, error: \"News search failed. Please try again.\" };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tquery,\n\t\t\tsearchType: \"news\",\n\t\t\tdaysBack,\n\t\t\ttotalResults: results.totalResults,\n\t\t\tresults: results.results.map((r) => ({\n\t\t\t\ttitle: r.title,\n\t\t\t\turl: r.link,\n\t\t\t\tsnippet: r.snippet,\n\t\t\t\tsource: r.displayLink,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Technical/documentation search - Search for technical documentation, guides, and tutorials\n * Use this for code examples, API documentation, how-to guides, etc.\n */\nexport const webSearchTechnicalTool = tool({\n\tdescription: \"Search for technical documentation, guides, tutorials, and code examples. Use this when looking for how to do something technical, API documentation, troubleshooting guides, or code references.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"The technical search query - include technology names and specific topics\"),\n\t\tnumResults: z.number().optional().default(5).describe(\"Number of results to return (1-10)\"),\n\t}),\n\texecute: async ({ query, numResults }) => {\n\t\tif (!googleCustomSearchService.isConfigured()) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Web search is not configured. Please set GOOGLE_API_KEY and GOOGLE_SEARCH_ENGINE_ID.\",\n\t\t\t};\n\t\t}\n\n\t\tconst results = await googleCustomSearchService.searchTechnical(query, {\n\t\t\tnum: Math.min(numResults, 10),\n\t\t});\n\n\t\tif (!results) {\n\t\t\treturn { success: false, error: \"Technical search failed. Please try again.\" };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tquery,\n\t\t\tsearchType: \"technical\",\n\t\t\ttotalResults: results.totalResults,\n\t\t\tresults: results.results.map((r) => ({\n\t\t\t\ttitle: r.title,\n\t\t\t\turl: r.link,\n\t\t\t\tsnippet: r.snippet,\n\t\t\t\tsource: r.displayLink,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Site-specific search - Search within a specific website\n * Use this to find information within a particular domain (e.g., manufacturer sites, gov sites)\n */\nexport const webSearchSiteTool = tool({\n\tdescription: \"Search within a specific website. Use this to find information on a particular site like manufacturer documentation, government sites, or specific company websites.\",\n\tparameters: z.object({\n\t\tquery: z.string().describe(\"The search query\"),\n\t\tsite: z.string().describe(\"The domain to search within (e.g., 'epa.gov', 'osha.gov', 'lennox.com')\"),\n\t\tnumResults: z.number().optional().default(5).describe(\"Number of results to return (1-10)\"),\n\t}),\n\texecute: async ({ query, site, numResults }) => {\n\t\tif (!googleCustomSearchService.isConfigured()) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Web search is not configured. Please set GOOGLE_API_KEY and GOOGLE_SEARCH_ENGINE_ID.\",\n\t\t\t};\n\t\t}\n\n\t\tconst results = await googleCustomSearchService.searchSite(query, site, {\n\t\t\tnum: Math.min(numResults, 10),\n\t\t});\n\n\t\tif (!results) {\n\t\t\treturn { success: false, error: \"Site search failed. Please try again.\" };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tquery,\n\t\t\tsite,\n\t\t\ttotalResults: results.totalResults,\n\t\t\tresults: results.results.map((r) => ({\n\t\t\t\ttitle: r.title,\n\t\t\t\turl: r.link,\n\t\t\t\tsnippet: r.snippet,\n\t\t\t})),\n\t\t};\n\t},\n});\n\n/**\n * Maps tool names to their destructive metadata.\n * Tools marked as destructive will be intercepted and require owner approval.\n */\nexport const destructiveTools: Record<string, DestructiveToolMetadata> = {\n\t// Communication tools - sending messages to external parties\n\tsendEmail: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"high\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an email to a customer on behalf of your company\",\n\t\taffectedEntityType: \"customer\",\n\t},\n\tsendSms: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"high\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an SMS message to a customer on behalf of your company\",\n\t\taffectedEntityType: \"customer\",\n\t},\n\tinitiateCall: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"critical\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Initiates a phone call to a customer\",\n\t\taffectedEntityType: \"customer\",\n\t},\n\tsendTeamEmail: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"medium\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an internal email to a team member\",\n\t\taffectedEntityType: \"team_member\",\n\t},\n\tsendTeamSms: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"medium\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an SMS to a team member\",\n\t\taffectedEntityType: \"team_member\",\n\t},\n\tsendVendorEmail: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"high\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an email to a vendor on behalf of your company\",\n\t\taffectedEntityType: \"vendor\",\n\t},\n\tsendVendorSms: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"high\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an SMS to a vendor on behalf of your company\",\n\t\taffectedEntityType: \"vendor\",\n\t},\n\tsendImmediateNotification: {\n\t\tisDestructive: true,\n\t\tactionType: \"send_communication\",\n\t\triskLevel: \"high\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Sends an immediate notification to a recipient\",\n\t\taffectedEntityType: \"notification\",\n\t},\n\n\t// Financial tools - money movement and financial records\n\tcreateInvoice: {\n\t\tisDestructive: true,\n\t\tactionType: \"financial\",\n\t\triskLevel: \"high\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Creates a new invoice that will be sent to a customer\",\n\t\taffectedEntityType: \"invoice\",\n\t},\n\ttransferToBucket: {\n\t\tisDestructive: true,\n\t\tactionType: \"financial\",\n\t\triskLevel: \"critical\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Transfers funds between financial buckets\",\n\t\taffectedEntityType: \"finance_bucket\",\n\t},\n\n\t// Scheduling tools - affects customer commitments\n\tcreateAppointment: {\n\t\tisDestructive: true,\n\t\tactionType: \"bulk_update\",\n\t\triskLevel: \"medium\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Creates a new appointment which commits company resources\",\n\t\taffectedEntityType: \"appointment\",\n\t},\n\tcancelReminder: {\n\t\tisDestructive: true,\n\t\tactionType: \"delete\",\n\t\triskLevel: \"low\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Cancels a scheduled reminder\",\n\t\taffectedEntityType: \"reminder\",\n\t},\n\n\t// Data modification tools\n\tupdateCustomer: {\n\t\tisDestructive: true,\n\t\tactionType: \"bulk_update\",\n\t\triskLevel: \"medium\",\n\t\trequiresOwnerApproval: true,\n\t\tdescription: \"Modifies customer record information\",\n\t\taffectedEntityType: \"customer\",\n\t},\n};\n\n/**\n * Check if a tool is destructive and requires owner approval\n */\nexport function isDestructiveTool(toolName: string): boolean {\n\treturn toolName in destructiveTools;\n}\n\n/**\n * Get the metadata for a destructive tool\n */\nexport function getDestructiveToolMetadata(toolName: string): DestructiveToolMetadata | null {\n\treturn destructiveTools[toolName] || null;\n}\n\n/**\n * Get all destructive tool names\n */\nexport function getDestructiveToolNames(): string[] {\n\treturn Object.keys(destructiveTools);\n}\n","/**\n * AI Action Approval Server Actions\n *\n * Server actions for owner-only approval of destructive AI actions.\n * These actions wrap the action-approval service for use in React components.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tapproveAction,\n\trejectAction,\n\tgetPendingActionsForCompany,\n\tgetPendingActionsForChat,\n\tgetPendingAction,\n\tisCompanyOwner,\n\texpireOldActions,\n\ttype PendingAction,\n} from \"@/lib/ai/action-approval\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type { PendingAction };\n\nexport interface ApprovalActionResult {\n\tsuccess: boolean;\n\terror?: string;\n\tactionId?: string;\n\ttoolName?: string;\n\ttoolArgs?: Record<string, unknown>;\n\t// Execution fields (for approval responses)\n\texecuted?: boolean;\n\texecutionResult?: unknown;\n\texecutionError?: string;\n}\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst approveActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n});\n\nconst rejectActionSchema = z.object({\n\tactionId: z.string().uuid(\"Invalid action ID\"),\n\treason: z.string().max(500, \"Reason too long\").optional(),\n});\n\nconst getPendingActionsSchema = z.object({\n\tstatus: z.enum([\"pending\", \"approved\", \"rejected\", \"expired\"]).optional(),\n\tlimit: z.number().min(1).max(100).default(50),\n});\n\nconst getChatActionsSchema = z.object({\n\tchatId: z.string().uuid(\"Invalid chat ID\"),\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nasync function getAuthenticatedUserWithCompany() {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tassertAuthenticated(user?.id);\n\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id, role\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t403,\n\t\t);\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\trole: teamMember.role,\n\t};\n}\n\n// ============================================================================\n// Server Actions\n// ============================================================================\n\n/**\n * Approve a pending AI action - OWNER ONLY\n * This action will be executed immediately after approval\n */\nexport async function approveAIAction(\n\tinput: z.infer<typeof approveActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = approveActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner (double-check even though DB function enforces this)\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can approve destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the approval function (which calls the DB RPC)\n\t\tconst result = await approveAction(validated.actionId, userId);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to approve action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Automatically execute the approved action\n\t\tlet executionResult: { success: boolean; result?: unknown; error?: string } | null = null;\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`${process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\"}/api/ai/execute-approved`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tactionId: validated.actionId,\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t);\n\t\t\texecutionResult = await response.json();\n\t\t} catch (execError) {\n\t\t\tconsole.error(\"Failed to auto-execute approved action:\", execError);\n\t\t\t// Don't fail the approval - execution can be retried\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: result.actionId,\n\t\t\ttoolName: result.toolName,\n\t\t\ttoolArgs: result.toolArgs,\n\t\t\texecuted: executionResult?.success || false,\n\t\t\texecutionResult: executionResult?.result,\n\t\t\texecutionError: executionResult?.error,\n\t\t};\n\t});\n}\n\n/**\n * Reject a pending AI action - OWNER ONLY\n * The AI will not execute this action\n */\nexport async function rejectAIAction(\n\tinput: z.infer<typeof rejectActionSchema>,\n): Promise<ActionResult<ApprovalActionResult>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = rejectActionSchema.parse(input);\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Verify user is owner\n\t\tconst ownerCheck = await isCompanyOwner(companyId, userId);\n\t\tif (!ownerCheck) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only company owners can reject destructive AI actions\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Call the rejection function\n\t\tconst result = await rejectAction(\n\t\t\tvalidated.actionId,\n\t\t\tuserId,\n\t\t\tvalidated.reason,\n\t\t);\n\n\t\tif (!result.success) {\n\t\t\tthrow new ActionError(\n\t\t\t\tresult.error || \"Failed to reject action\",\n\t\t\t\tERROR_CODES.OPERATION_FAILED,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate AI-related paths\n\t\trevalidatePath(\"/dashboard/ai\");\n\t\trevalidatePath(\"/dashboard/settings/ai\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tactionId: validated.actionId,\n\t\t};\n\t});\n}\n\n/**\n * Get all pending actions for the current company\n * Used by the owner dashboard to review pending approvals\n */\nexport async function getCompanyPendingActions(\n\tinput?: z.infer<typeof getPendingActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = input ? getPendingActionsSchema.parse(input) : { limit: 50 };\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: validated.status,\n\t\t\tlimit: validated.limit,\n\t\t});\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get pending actions for a specific chat session\n * Used to show approval banners in the AI chat\n */\nexport async function getChatPendingActions(\n\tinput: z.infer<typeof getChatActionsSchema>,\n): Promise<ActionResult<PendingAction[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = getChatActionsSchema.parse(input);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions for the chat\n\t\tconst actions = await getPendingActionsForChat(companyId, validated.chatId);\n\n\t\treturn actions;\n\t});\n}\n\n/**\n * Get a specific pending action by ID\n */\nexport async function getPendingActionById(\n\tactionId: string,\n): Promise<ActionResult<PendingAction | null>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst validated = z.string().uuid(\"Invalid action ID\").parse(actionId);\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\tconst action = await getPendingAction(companyId, validated);\n\t\treturn action;\n\t});\n}\n\n/**\n * Check if current user is a company owner\n * Used by UI to determine if approval buttons should be enabled\n */\nexport async function checkIsCompanyOwner(): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { userId, companyId } = await getAuthenticatedUserWithCompany();\n\t\tconst isOwner = await isCompanyOwner(companyId, userId);\n\t\treturn isOwner;\n\t});\n}\n\n/**\n * Get pending action counts for notifications\n */\nexport async function getPendingActionCounts(): Promise<\n\tActionResult<{\n\t\ttotal: number;\n\t\tbyRiskLevel: Record<string, number>;\n\t}>\n> {\n\treturn await withErrorHandling(async () => {\n\t\tconst { companyId } = await getAuthenticatedUserWithCompany();\n\n\t\t// Expire old actions first\n\t\tawait expireOldActions(companyId);\n\n\t\t// Fetch pending actions\n\t\tconst actions = await getPendingActionsForCompany(companyId, {\n\t\t\tstatus: \"pending\",\n\t\t\tlimit: 100,\n\t\t});\n\n\t\t// Group by risk level\n\t\tconst byRiskLevel: Record<string, number> = {\n\t\t\tlow: 0,\n\t\t\tmedium: 0,\n\t\t\thigh: 0,\n\t\t\tcritical: 0,\n\t\t};\n\n\t\tfor (const action of actions) {\n\t\t\tbyRiskLevel[action.riskLevel] = (byRiskLevel[action.riskLevel] || 0) + 1;\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: actions.length,\n\t\t\tbyRiskLevel,\n\t\t};\n\t});\n}\n","/**\n * Google Custom Search Service\n *\n * Provides web search capabilities for the AI agent:\n * - General web search\n * - News search\n * - Image search\n * - Site-specific search\n *\n * API: Google Custom Search JSON API\n * Free Tier: 100 queries/day free, then $5/1000 queries\n * Docs: https://developers.google.com/custom-search/v1/overview\n *\n * Setup:\n * 1. Enable Custom Search API in Google Cloud Console\n * 2. Create a Programmable Search Engine at https://programmablesearchengine.google.com/\n * 3. Get your Search Engine ID (cx parameter)\n * 4. Set GOOGLE_SEARCH_ENGINE_ID in environment\n */\n\nimport { z } from \"zod\";\n\nconst USER_AGENT = \"Stratos-FMS/1.0 (support@stratos.app)\";\n\n// Zod schemas for type safety\nconst SearchResultSchema = z.object({\n\ttitle: z.string(),\n\tlink: z.string().url(),\n\tsnippet: z.string(),\n\tdisplayLink: z.string(),\n\tformattedUrl: z.string().optional(),\n\tpagemap: z\n\t\t.object({\n\t\t\tcse_thumbnail: z\n\t\t\t\t.array(\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tsrc: z.string(),\n\t\t\t\t\t\twidth: z.string().optional(),\n\t\t\t\t\t\theight: z.string().optional(),\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t.optional(),\n\t\t\tmetatags: z\n\t\t\t\t.array(\n\t\t\t\t\tz.record(z.string())\n\t\t\t\t)\n\t\t\t\t.optional(),\n\t\t})\n\t\t.optional(),\n});\n\nconst SearchResponseSchema = z.object({\n\tresults: z.array(SearchResultSchema),\n\ttotalResults: z.number(),\n\tsearchTime: z.number(),\n\tquery: z.string(),\n\tsearchType: z.enum([\"web\", \"news\", \"image\"]),\n\tnextPageToken: z.string().optional(),\n});\n\nexport type SearchResult = z.infer<typeof SearchResultSchema>;\nexport type SearchResponse = z.infer<typeof SearchResponseSchema>;\n\n/**\n * Search options\n */\nexport interface SearchOptions {\n\t/** Number of results to return (max 10 per request) */\n\tnum?: number;\n\t/** Starting index for pagination (1-based) */\n\tstart?: number;\n\t/** Restrict to specific site (e.g., \"reddit.com\") */\n\tsiteSearch?: string;\n\t/** Exclude results from site */\n\tsiteSearchExclude?: string;\n\t/** Date restriction: d[number], w[number], m[number], y[number] */\n\tdateRestrict?: string;\n\t/** Safe search level */\n\tsafe?: \"off\" | \"medium\" | \"high\";\n\t/** Filter adult content */\n\tfilter?: \"0\" | \"1\";\n\t/** Country to search from (ISO 3166-1 alpha-2) */\n\tgl?: string;\n\t/** Language of results (ISO 639-1) */\n\tlr?: string;\n\t/** Sort by date (if supported) */\n\tsort?: \"date\" | \"relevance\";\n}\n\nconst CACHE_TTL_MS = 1000 * 60 * 15; // 15 minutes\n\n// biome-ignore lint/suspicious/noConsole: Backend service logging is acceptable\nclass GoogleCustomSearchService {\n\tprivate readonly apiKey: string | undefined;\n\tprivate readonly searchEngineId: string | undefined;\n\tprivate readonly cache: Map<string, { data: SearchResponse; timestamp: number }> = new Map();\n\tprivate readonly cacheTTL = CACHE_TTL_MS;\n\n\tconstructor() {\n\t\t// Use unified GOOGLE_API_KEY for all Google services\n\t\tthis.apiKey =\n\t\t\tprocess.env.GOOGLE_API_KEY ||\n\t\t\tprocess.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY ||\n\t\t\tprocess.env.GOOGLE_MAPS_API_KEY;\n\t\tthis.searchEngineId =\n\t\t\tprocess.env.GOOGLE_SEARCH_ENGINE_ID ||\n\t\t\tprocess.env.GOOGLE_CSE_ID ||\n\t\t\tprocess.env.NEXT_PUBLIC_GOOGLE_SEARCH_ENGINE_ID;\n\t}\n\n\t/**\n\t * Perform a web search\n\t */\n\tasync search(query: string, options: SearchOptions = {}): Promise<SearchResponse | null> {\n\t\tif (!this.apiKey || !this.searchEngineId) {\n\t\t\tconsole.warn(\"Google Custom Search not configured: missing API key or Search Engine ID\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheKey = this.getCacheKey(query, options, \"web\");\n\t\tconst cached = this.cache.get(cacheKey);\n\n\t\tif (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n\t\t\treturn cached.data;\n\t\t}\n\n\t\ttry {\n\t\t\tconst params = this.buildParams(query, options);\n\t\t\tconst url = `https://www.googleapis.com/customsearch/v1?${params.toString()}`;\n\n\t\t\tconst response = await fetch(url, {\n\t\t\t\theaders: { \"User-Agent\": USER_AGENT },\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconst error = await response.json();\n\t\t\t\tconsole.error(\"Google Custom Search error:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst data = await response.json();\n\t\t\tconst searchResponse = this.parseResponse(data, query, \"web\");\n\n\t\t\tthis.cache.set(cacheKey, { data: searchResponse, timestamp: Date.now() });\n\t\t\treturn searchResponse;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Google Custom Search failed:\", error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Search for news articles\n\t * Uses date restriction to get recent results\n\t */\n\tasync searchNews(\n\t\tquery: string,\n\t\toptions: SearchOptions & { daysBack?: number } = {}\n\t): Promise<SearchResponse | null> {\n\t\tconst { daysBack = 7, ...searchOptions } = options;\n\n\t\t// Add date restriction for recent news\n\t\tconst newsOptions: SearchOptions = {\n\t\t\t...searchOptions,\n\t\t\tdateRestrict: `d${daysBack}`,\n\t\t\tsort: \"date\",\n\t\t};\n\n\t\tconst cacheKey = this.getCacheKey(query, newsOptions, \"news\");\n\t\tconst cached = this.cache.get(cacheKey);\n\n\t\tif (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n\t\t\treturn cached.data;\n\t\t}\n\n\t\tconst result = await this.search(query, newsOptions);\n\t\tif (result) {\n\t\t\tresult.searchType = \"news\";\n\t\t\tthis.cache.set(cacheKey, { data: result, timestamp: Date.now() });\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Search for images\n\t */\n\tasync searchImages(query: string, options: SearchOptions = {}): Promise<SearchResponse | null> {\n\t\tif (!this.apiKey || !this.searchEngineId) {\n\t\t\tconsole.warn(\"Google Custom Search not configured\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheKey = this.getCacheKey(query, options, \"image\");\n\t\tconst cached = this.cache.get(cacheKey);\n\n\t\tif (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n\t\t\treturn cached.data;\n\t\t}\n\n\t\ttry {\n\t\t\tconst params = this.buildParams(query, options);\n\t\t\tparams.set(\"searchType\", \"image\");\n\n\t\t\tconst url = `https://www.googleapis.com/customsearch/v1?${params.toString()}`;\n\n\t\t\tconst response = await fetch(url, {\n\t\t\t\theaders: { \"User-Agent\": USER_AGENT },\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconst error = await response.json();\n\t\t\t\tconsole.error(\"Google Image Search error:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst data = await response.json();\n\t\t\tconst searchResponse = this.parseImageResponse(data, query);\n\n\t\t\tthis.cache.set(cacheKey, { data: searchResponse, timestamp: Date.now() });\n\t\t\treturn searchResponse;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Google Image Search failed:\", error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Search within a specific site\n\t */\n\tasync searchSite(\n\t\tquery: string,\n\t\tsite: string,\n\t\toptions: SearchOptions = {}\n\t): Promise<SearchResponse | null> {\n\t\treturn this.search(query, {\n\t\t\t...options,\n\t\t\tsiteSearch: site,\n\t\t});\n\t}\n\n\t/**\n\t * Search for technical/documentation content\n\t * Focuses on official docs, Stack Overflow, GitHub\n\t */\n\tasync searchTechnical(query: string, options: SearchOptions = {}): Promise<SearchResponse | null> {\n\t\t// Append technical terms to improve results\n\t\tconst technicalQuery = `${query} documentation OR tutorial OR guide`;\n\t\treturn this.search(technicalQuery, options);\n\t}\n\n\t/**\n\t * Build URL params for API request\n\t */\n\tprivate buildParams(query: string, options: SearchOptions): URLSearchParams {\n\t\tconst params = new URLSearchParams({\n\t\t\tkey: this.apiKey!,\n\t\t\tcx: this.searchEngineId!,\n\t\t\tq: query,\n\t\t});\n\n\t\tif (options.num) params.set(\"num\", String(Math.min(options.num, 10)));\n\t\tif (options.start) params.set(\"start\", String(options.start));\n\t\tif (options.siteSearch) params.set(\"siteSearch\", options.siteSearch);\n\t\tif (options.siteSearchExclude) {\n\t\t\tparams.set(\"siteSearch\", options.siteSearchExclude);\n\t\t\tparams.set(\"siteSearchFilter\", \"e\");\n\t\t}\n\t\tif (options.dateRestrict) params.set(\"dateRestrict\", options.dateRestrict);\n\t\tif (options.safe) params.set(\"safe\", options.safe);\n\t\tif (options.filter) params.set(\"filter\", options.filter);\n\t\tif (options.gl) params.set(\"gl\", options.gl);\n\t\tif (options.lr) params.set(\"lr\", options.lr);\n\t\tif (options.sort === \"date\") params.set(\"sort\", \"date\");\n\n\t\treturn params;\n\t}\n\n\t/**\n\t * Parse API response into our schema\n\t */\n\tprivate parseResponse(\n\t\tdata: Record<string, unknown>,\n\t\tquery: string,\n\t\tsearchType: \"web\" | \"news\" | \"image\"\n\t): SearchResponse {\n\t\tconst items = (data.items as Array<Record<string, unknown>>) || [];\n\t\tconst searchInfo = data.searchInformation as { totalResults?: string; searchTime?: number } | undefined;\n\n\t\treturn {\n\t\t\tresults: items.map((item) => ({\n\t\t\t\ttitle: (item.title as string) || \"\",\n\t\t\t\tlink: (item.link as string) || \"\",\n\t\t\t\tsnippet: (item.snippet as string) || \"\",\n\t\t\t\tdisplayLink: (item.displayLink as string) || \"\",\n\t\t\t\tformattedUrl: item.formattedUrl as string | undefined,\n\t\t\t\tpagemap: item.pagemap as SearchResult[\"pagemap\"],\n\t\t\t})),\n\t\t\ttotalResults: Number.parseInt(searchInfo?.totalResults || \"0\", 10),\n\t\t\tsearchTime: searchInfo?.searchTime || 0,\n\t\t\tquery,\n\t\t\tsearchType,\n\t\t\tnextPageToken: data.queries\n\t\t\t\t? ((data.queries as Record<string, Array<{ startIndex: number }>>).nextPage?.[0]?.startIndex?.toString())\n\t\t\t\t: undefined,\n\t\t};\n\t}\n\n\t/**\n\t * Parse image search response\n\t */\n\tprivate parseImageResponse(data: Record<string, unknown>, query: string): SearchResponse {\n\t\tconst items = (data.items as Array<Record<string, unknown>>) || [];\n\t\tconst searchInfo = data.searchInformation as { totalResults?: string; searchTime?: number } | undefined;\n\n\t\treturn {\n\t\t\tresults: items.map((item) => ({\n\t\t\t\ttitle: (item.title as string) || \"\",\n\t\t\t\tlink: (item.link as string) || \"\",\n\t\t\t\tsnippet: (item.snippet as string) || \"\",\n\t\t\t\tdisplayLink: (item.displayLink as string) || \"\",\n\t\t\t\tformattedUrl: (item.image as { contextLink?: string })?.contextLink,\n\t\t\t\tpagemap: {\n\t\t\t\t\tcse_thumbnail: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsrc: (item.image as { thumbnailLink?: string })?.thumbnailLink || (item.link as string),\n\t\t\t\t\t\t\twidth: String((item.image as { thumbnailWidth?: number })?.thumbnailWidth || \"\"),\n\t\t\t\t\t\t\theight: String((item.image as { thumbnailHeight?: number })?.thumbnailHeight || \"\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t})),\n\t\t\ttotalResults: Number.parseInt(searchInfo?.totalResults || \"0\", 10),\n\t\t\tsearchTime: searchInfo?.searchTime || 0,\n\t\t\tquery,\n\t\t\tsearchType: \"image\",\n\t\t};\n\t}\n\n\t/**\n\t * Generate cache key\n\t */\n\tprivate getCacheKey(query: string, options: SearchOptions, type: string): string {\n\t\treturn `search:${type}:${query}:${JSON.stringify(options)}`;\n\t}\n\n\t/**\n\t * Check if service is configured\n\t */\n\tisConfigured(): boolean {\n\t\treturn !!this.apiKey && !!this.searchEngineId;\n\t}\n\n\t/**\n\t * Get configuration status details\n\t */\n\tgetConfigStatus(): { configured: boolean; hasApiKey: boolean; hasSearchEngineId: boolean } {\n\t\treturn {\n\t\t\tconfigured: this.isConfigured(),\n\t\t\thasApiKey: !!this.apiKey,\n\t\t\thasSearchEngineId: !!this.searchEngineId,\n\t\t};\n\t}\n\n\t/**\n\t * Clear the cache\n\t */\n\tclearCache(): void {\n\t\tthis.cache.clear();\n\t}\n}\n\nexport const googleCustomSearchService = new GoogleCustomSearchService();\n","/**\n * Portal Invitation Email Template - Customer portal access invitation\n *\n * Features:\n * - Invitation to access customer portal\n * - Secure setup link with expiration\n * - Portal features overview\n * - Getting started guide\n */\n\nimport { Text } from \"@react-email/components\";\nimport { Button } from \"../../components/button\";\nimport { Card } from \"../../components/card\";\nimport { Heading } from \"../../components/heading\";\nimport { BaseLayout } from \"../../layouts/base-layout\";\nimport { EMAIL_COLORS } from \"../../theme\";\n\nexport type PortalInvitationProps = {\n\tcustomerName: string;\n\tportalUrl: string;\n\texpiresInHours?: number;\n\tcompanyName?: string;\n\tsupportEmail?: string;\n\tsupportPhone?: string;\n\tpreviewText?: string;\n};\n\nexport default function PortalInvitationEmail({\n\tcustomerName,\n\tportalUrl,\n\texpiresInHours = 168, // 7 days default\n\tcompanyName = \"Thorbis\",\n\tsupportEmail = \"support@thorbis.com\",\n\tsupportPhone = \"(555) 123-4567\",\n\tpreviewText = \"You've been invited to access your customer portal\",\n}: PortalInvitationProps) {\n\treturn (\n\t\t<BaseLayout previewText={previewText}>\n\t\t\t<Heading level={1}>You're Invited!</Heading>\n\n\t\t\t<Text style={paragraph}>Hi {customerName},</Text>\n\n\t\t\t<Text style={paragraph}>\n\t\t\t\tGreat news! You now have access to your {companyName} customer portal -\n\t\t\t\ta convenient online hub where you can manage your services, view\n\t\t\t\tinvoices, and communicate with us anytime.\n\t\t\t</Text>\n\n\t\t\t<Card style={invitationCard}>\n\t\t\t\t<div style={invitationIcon}>🎉</div>\n\t\t\t\t<Text style={invitationTitle}>Your Portal is Ready!</Text>\n\t\t\t\t<Text style={invitationText}>\n\t\t\t\t\tClick the button below to set up your account and access all your\n\t\t\t\t\tservice information in one place.\n\t\t\t\t</Text>\n\t\t\t</Card>\n\n\t\t\t<div style={buttonContainer}>\n\t\t\t\t<Button href={portalUrl}>Set Up My Account</Button>\n\t\t\t</div>\n\n\t\t\t<Card style={expiryCard}>\n\t\t\t\t<Text style={expiryText}>\n\t\t\t\t\t⏰ This invitation link will expire in{\" \"}\n\t\t\t\t\t<strong>{expiresInHours} hours</strong>. Please complete your account\n\t\t\t\t\tsetup soon.\n\t\t\t\t</Text>\n\t\t\t</Card>\n\n\t\t\t<Card style={featuresCard}>\n\t\t\t\t<Heading level={3}>What you can do in your portal:</Heading>\n\t\t\t\t<ul style={featuresList}>\n\t\t\t\t\t<li style={featureItem}>\n\t\t\t\t\t\t<strong>📅 View & Schedule Services:</strong> Book appointments and\n\t\t\t\t\t\ttrack upcoming service visits\n\t\t\t\t\t</li>\n\t\t\t\t\t<li style={featureItem}>\n\t\t\t\t\t\t<strong>📄 Manage Invoices:</strong> View billing history and pay\n\t\t\t\t\t\tinvoices online securely\n\t\t\t\t\t</li>\n\t\t\t\t\t<li style={featureItem}>\n\t\t\t\t\t\t<strong>📊 Service History:</strong> Access complete records of all\n\t\t\t\t\t\tyour past services\n\t\t\t\t\t</li>\n\t\t\t\t\t<li style={featureItem}>\n\t\t\t\t\t\t<strong>🏠 Property Details:</strong> Manage multiple properties and\n\t\t\t\t\t\tservice locations\n\t\t\t\t\t</li>\n\t\t\t\t\t<li style={featureItem}>\n\t\t\t\t\t\t<strong>💬 Direct Communication:</strong> Message our team and get\n\t\t\t\t\t\treal-time updates\n\t\t\t\t\t</li>\n\t\t\t\t\t<li style={featureItem}>\n\t\t\t\t\t\t<strong>📱 Mobile Access:</strong> Access your account from any\n\t\t\t\t\t\tdevice, anywhere\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</Card>\n\n\t\t\t<Card style={securityCard}>\n\t\t\t\t<Heading level={3}>Secure & Private</Heading>\n\t\t\t\t<Text style={securityText}>\n\t\t\t\t\tYour portal is protected with industry-standard security. Only you can\n\t\t\t\t\taccess your account information, and all data is encrypted for your\n\t\t\t\t\tprotection.\n\t\t\t\t</Text>\n\t\t\t</Card>\n\n\t\t\t<Card style={stepsCard}>\n\t\t\t\t<Heading level={3}>Getting Started is Easy</Heading>\n\t\t\t\t<div style={stepGrid}>\n\t\t\t\t\t<div style={step}>\n\t\t\t\t\t\t<div style={stepNumber}>1</div>\n\t\t\t\t\t\t<Text style={stepText}>\n\t\t\t\t\t\t\tClick the \"Set Up My Account\" button above\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style={step}>\n\t\t\t\t\t\t<div style={stepNumber}>2</div>\n\t\t\t\t\t\t<Text style={stepText}>\n\t\t\t\t\t\t\tCreate a secure password for your account\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style={step}>\n\t\t\t\t\t\t<div style={stepNumber}>3</div>\n\t\t\t\t\t\t<Text style={stepText}>\n\t\t\t\t\t\t\tExplore your portal and manage your services!\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</Card>\n\n\t\t\t<Card style={helpCard}>\n\t\t\t\t<Heading level={3}>Need Help?</Heading>\n\t\t\t\t<Text style={helpText}>\n\t\t\t\t\tIf you have any questions about setting up your portal or need\n\t\t\t\t\tassistance, our support team is here to help.\n\t\t\t\t</Text>\n\t\t\t\t<div style={contactGrid}>\n\t\t\t\t\t<div style={contactMethod}>\n\t\t\t\t\t\t<Text style={contactLabel}>Email:</Text>\n\t\t\t\t\t\t<a href={`mailto:${supportEmail}`} style={contactLink}>\n\t\t\t\t\t\t\t{supportEmail}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style={contactMethod}>\n\t\t\t\t\t\t<Text style={contactLabel}>Phone:</Text>\n\t\t\t\t\t\t<a href={`tel:${supportPhone}`} style={contactLink}>\n\t\t\t\t\t\t\t{supportPhone}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</Card>\n\n\t\t\t<Text style={footerNote}>\n\t\t\t\t<strong>Note:</strong> If you didn't request portal access or believe\n\t\t\t\tyou received this email in error, please contact us at{\" \"}\n\t\t\t\t<a href={`mailto:${supportEmail}`} style={inlineLink}>\n\t\t\t\t\t{supportEmail}\n\t\t\t\t</a>\n\t\t\t\t.\n\t\t\t</Text>\n\t\t</BaseLayout>\n\t);\n}\n\n// Styles\nconst paragraph = {\n\tcolor: \"#374151\",\n\tfontSize: \"16px\",\n\tlineHeight: \"24px\",\n\tmargin: \"0 0 16px 0\",\n};\n\nconst invitationCard = {\n\tbackground:\n\t\t\"linear-gradient(135deg, hsl(217 91% 60%) 0%, hsl(217 91% 50%) 100%)\",\n\tborderRadius: \"12px\",\n\tpadding: \"40px\",\n\tmargin: \"24px 0\",\n\ttextAlign: \"center\" as const,\n};\n\nconst invitationIcon = {\n\tfontSize: \"64px\",\n\tmargin: \"0 0 16px 0\",\n};\n\nconst invitationTitle = {\n\tcolor: EMAIL_COLORS.primaryText,\n\tfontSize: \"24px\",\n\tfontWeight: \"600\",\n\tmargin: \"0 0 12px 0\",\n};\n\nconst invitationText = {\n\tcolor: EMAIL_COLORS.primaryText,\n\tfontSize: \"16px\",\n\tlineHeight: \"24px\",\n\tmargin: \"0\",\n\topacity: \"0.95\",\n};\n\nconst buttonContainer = {\n\tmargin: \"32px 0\",\n\ttextAlign: \"center\" as const,\n};\n\nconst expiryCard = {\n\tbackgroundColor: \"#fef3c7\",\n\tborder: \"1px solid #fde68a\",\n\tborderRadius: \"8px\",\n\tpadding: \"16px\",\n\tmargin: \"24px 0\",\n\ttextAlign: \"center\" as const,\n};\n\nconst expiryText = {\n\tcolor: \"#92400e\",\n\tfontSize: \"14px\",\n\tlineHeight: \"20px\",\n\tmargin: \"0\",\n};\n\nconst featuresCard = {\n\tbackgroundColor: \"#f0fdf4\",\n\tborder: \"1px solid #bbf7d0\",\n\tmargin: \"24px 0\",\n};\n\nconst featuresList = {\n\tcolor: \"#166534\",\n\tfontSize: \"14px\",\n\tlineHeight: \"22px\",\n\tmargin: \"12px 0 0 20px\",\n\tpadding: \"0\",\n};\n\nconst featureItem = {\n\tmargin: \"0 0 12px 0\",\n};\n\nconst securityCard = {\n\tbackgroundColor: \"#f5f3ff\",\n\tborder: \"1px solid #ddd6fe\",\n\tmargin: \"24px 0\",\n};\n\nconst securityText = {\n\tcolor: \"#5b21b6\",\n\tfontSize: \"15px\",\n\tlineHeight: \"22px\",\n\tmargin: \"12px 0 0 0\",\n};\n\nconst stepsCard = {\n\tbackgroundColor: \"#eff6ff\",\n\tborder: \"1px solid #bfdbfe\",\n\tmargin: \"24px 0\",\n};\n\nconst stepGrid = {\n\tdisplay: \"grid\" as const,\n\tgridTemplateColumns: \"1fr 1fr 1fr\",\n\tgap: \"20px\",\n\tmargin: \"20px 0 0 0\",\n};\n\nconst step = {\n\ttextAlign: \"center\" as const,\n};\n\nconst stepNumber = {\n\twidth: \"40px\",\n\theight: \"40px\",\n\tbackgroundColor: \"hsl(217 91% 60%)\",\n\tcolor: EMAIL_COLORS.primaryText,\n\tborderRadius: \"50%\",\n\tdisplay: \"inline-flex\",\n\talignItems: \"center\",\n\tjustifyContent: \"center\",\n\tfontSize: \"18px\",\n\tfontWeight: \"600\",\n\tmargin: \"0 auto 12px auto\",\n};\n\nconst stepText = {\n\tcolor: \"#1e40af\",\n\tfontSize: \"13px\",\n\tlineHeight: \"18px\",\n\tmargin: \"0\",\n};\n\nconst helpCard = {\n\tbackgroundColor: \"#fef2f2\",\n\tborder: \"1px solid #fecaca\",\n\tmargin: \"24px 0\",\n};\n\nconst helpText = {\n\tcolor: \"#991b1b\",\n\tfontSize: \"15px\",\n\tlineHeight: \"22px\",\n\tmargin: \"12px 0 20px 0\",\n};\n\nconst contactGrid = {\n\tdisplay: \"grid\" as const,\n\tgridTemplateColumns: \"1fr 1fr\",\n\tgap: \"16px\",\n};\n\nconst contactMethod = {\n\ttextAlign: \"center\" as const,\n};\n\nconst contactLabel = {\n\tcolor: \"#6b7280\",\n\tfontSize: \"12px\",\n\ttextTransform: \"uppercase\" as const,\n\tletterSpacing: \"0.05em\",\n\tmargin: \"0 0 8px 0\",\n};\n\nconst contactLink = {\n\tcolor: \"hsl(217 91% 60%)\",\n\tfontSize: \"15px\",\n\tfontWeight: \"600\",\n\ttextDecoration: \"underline\",\n};\n\nconst footerNote = {\n\tcolor: \"#6b7280\",\n\tfontSize: \"13px\",\n\tlineHeight: \"20px\",\n\tmargin: \"32px 0 0 0\",\n\tpadding: \"20px\",\n\tbackgroundColor: \"#f9fafb\",\n\tborderRadius: \"8px\",\n\ttextAlign: \"center\" as const,\n};\n\nconst inlineLink = {\n\tcolor: \"hsl(217 91% 60%)\",\n\ttextDecoration: \"underline\",\n};\n","/**\n * Customer Management Server Actions\n *\n * Comprehensive customer relationship management with:\n * - Customer CRUD operations\n * - Customer portal invitation and access\n * - Customer metrics tracking (revenue, jobs, invoices)\n * - Communication preferences\n * - Soft delete/archive support\n * - Customer search and filtering\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n    ActionError,\n    ERROR_CODES,\n    ERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n    type ActionResult,\n    assertAuthenticated,\n    assertExists,\n    withErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { geocodeAddressSilent } from \"@/lib/services/geocoding\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport PortalInvitationEmail from \"../../emails/templates/customer/portal-invitation\";\n\n// ============================================================================\n// VALIDATION SCHEMAS\n// ============================================================================\n\nconst CUSTOMER_NAME_MAX_LENGTH = 100;\nconst CUSTOMER_COMPANY_MAX_LENGTH = 200;\nconst CUSTOMER_PHONE_MAX_LENGTH = 20;\nconst CUSTOMER_ADDRESS_MAX_LENGTH = 200;\nconst CUSTOMER_ADDRESS2_MAX_LENGTH = 100;\nconst CUSTOMER_CITY_MAX_LENGTH = 100;\nconst CUSTOMER_STATE_MAX_LENGTH = 50;\n\n// HTTP Status codes\nconst HTTP_STATUS_FORBIDDEN = 403;\n\n// Search defaults\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst CUSTOMER_ZIP_MAX_LENGTH = 20;\nconst CUSTOMER_COUNTRY_MAX_LENGTH = 50;\nconst CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH = 50;\nconst CENTS_PER_DOLLAR = 100;\n\nfunction requireSiteUrl(): string {\n\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\tif (!siteUrl) {\n\t\tthrow new ActionError(\n\t\t\t\"NEXT_PUBLIC_SITE_URL is not configured\",\n\t\t\tERROR_CODES.INTERNAL_SERVER_ERROR,\n\t\t);\n\t}\n\treturn siteUrl.replace(/\\/$/, \"\");\n}\n\nconst customerSchema = z.object({\n\ttype: z\n\t\t.enum([\"residential\", \"commercial\", \"industrial\"])\n\t\t.default(\"residential\"),\n\tfirstName: z\n\t\t.string()\n\t\t.min(1, \"First name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tlastName: z\n\t\t.string()\n\t\t.min(1, \"Last name is required\")\n\t\t.max(CUSTOMER_NAME_MAX_LENGTH),\n\tcompanyName: z.string().max(CUSTOMER_COMPANY_MAX_LENGTH).optional(),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z.string().min(1, \"Phone is required\").max(CUSTOMER_PHONE_MAX_LENGTH),\n\tsecondaryPhone: z.string().max(CUSTOMER_PHONE_MAX_LENGTH).optional(),\n\taddress: z.string().max(CUSTOMER_ADDRESS_MAX_LENGTH).optional(),\n\taddress2: z.string().max(CUSTOMER_ADDRESS2_MAX_LENGTH).optional(),\n\tcity: z.string().max(CUSTOMER_CITY_MAX_LENGTH).optional(),\n\tstate: z.string().max(CUSTOMER_STATE_MAX_LENGTH).optional(),\n\tzipCode: z.string().max(CUSTOMER_ZIP_MAX_LENGTH).optional(),\n\tcountry: z.string().max(CUSTOMER_COUNTRY_MAX_LENGTH).default(\"USA\"),\n\tsource: z\n\t\t.enum([\"referral\", \"google\", \"facebook\", \"direct\", \"yelp\", \"other\"])\n\t\t.optional(),\n\treferredBy: z.string().uuid().optional().nullable(),\n\tpreferredContactMethod: z.enum([\"email\", \"phone\", \"sms\"]).default(\"email\"),\n\tpreferredTechnician: z.string().uuid().optional().nullable(),\n\tbillingEmail: z.string().email().optional().nullable(),\n\tpaymentTerms: z\n\t\t.enum([\"due_on_receipt\", \"net_15\", \"net_30\", \"net_60\"])\n\t\t.default(\"due_on_receipt\"),\n\tcreditLimit: z.number().int().min(0).default(0), // In cents\n\ttaxExempt: z.boolean().default(false),\n\ttaxExemptNumber: z\n\t\t.string()\n\t\t.max(CUSTOMER_TAX_EXEMPT_NUMBER_MAX_LENGTH)\n\t\t.optional(),\n\ttags: z.array(z.string()).optional(),\n\tnotes: z.string().optional(),\n\tinternalNotes: z.string().optional(),\n});\n\nconst communicationPreferencesSchema = z.object({\n\temail: z.boolean().default(true),\n\tsms: z.boolean().default(true),\n\tphone: z.boolean().default(true),\n\tmarketing: z.boolean().default(false),\n});\n\n// ============================================================================\n// CUSTOMER CRUD OPERATIONS\n// ============================================================================\n\n/**\n * Create a new customer with multiple contacts and properties\n */\nasync function createCustomer(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\t\tconst { contacts, properties, tags } =\n\t\t\tparseCustomerContactsPropertiesAndTags(formData);\n\t\tconst primaryContact = getPrimaryContactOrThrow(contacts);\n\t\tconst primaryProperty = getPrimaryProperty(properties);\n\n\t\tawait assertCustomerEmailNotDuplicate(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tprimaryContact.email,\n\t\t);\n\n\t\tconst customerType = formData.get(\"type\") || \"residential\";\n\t\tconst companyName = formData.get(\"companyName\");\n\t\tconst displayName = buildCustomerDisplayName(\n\t\t\tcustomerType,\n\t\t\tcompanyName,\n\t\t\tprimaryContact,\n\t\t);\n\n\t\tconst communicationPreferences = buildDefaultCommunicationPreferences();\n\t\tconst customerMetadata = buildCustomerMetadata(contacts);\n\n\t\tconst { lat: customerLat, lon: customerLon } =\n\t\t\tawait geocodePrimaryPropertyIfAvailable(primaryProperty);\n\n\t\tconst customer = await insertCustomerRecord(supabase, {\n\t\t\tcompanyId: teamMember.company_id,\n\t\t\tcustomerType,\n\t\t\tprimaryContact,\n\t\t\tcompanyNameValue: companyName,\n\t\t\tdisplayName,\n\t\t\tprimaryProperty,\n\t\t\tcustomerLat,\n\t\t\tcustomerLon,\n\t\t\tformData,\n\t\t\ttags,\n\t\t\tcommunicationPreferences,\n\t\t\tcustomerMetadata,\n\t\t});\n\n\t\tawait insertAdditionalPropertiesIfAny(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t\tcustomer.id,\n\t\t\tproperties,\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\treturn customer.id;\n\t});\n}\n\ntype ParsedCustomerContact = {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n\tphone: string;\n\trole: string;\n\tisPrimary: boolean;\n};\n\ntype ParsedCustomerProperty = {\n\tname: string;\n\taddress: string;\n\taddress2: string;\n\tcity: string;\n\tstate: string;\n\tzipCode: string;\n\tcountry: string;\n\tpropertyType: string;\n\tisPrimary: boolean;\n\tnotes: string;\n};\n\ntype ParsedCustomerFormCollections = {\n\tcontacts: ParsedCustomerContact[];\n\tproperties: ParsedCustomerProperty[];\n\ttags?: string[];\n};\n\nasync function requireCustomerCompanyMembership(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n) {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember;\n}\n\nfunction parseCustomerContactsPropertiesAndTags(\n\tformData: FormData,\n): ParsedCustomerFormCollections {\n\tconst contacts = parseContacts(formData.get(\"contacts\"));\n\tconst properties = parseProperties(formData.get(\"properties\"));\n\tconst tags = parseTagsField(formData.get(\"tags\"));\n\n\treturn { contacts, properties, tags };\n}\n\nfunction parseContacts(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerContact[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerContact[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid contacts data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseProperties(\n\tvalue: FormDataEntryValue | null,\n): ParsedCustomerProperty[] {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as ParsedCustomerProperty[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid properties data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseTagsField(\n\tvalue: FormDataEntryValue | null,\n): string[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as string[];\n\t} catch {\n\t\treturn value.split(\",\").map((t) => t.trim());\n\t}\n}\n\nfunction getPrimaryContactOrThrow(\n\tcontacts: ParsedCustomerContact[],\n): ParsedCustomerContact {\n\tconst primaryContact = contacts.find((c) => c.isPrimary) || contacts[0];\n\tif (!primaryContact) {\n\t\tthrow new ActionError(\n\t\t\t\"At least one contact is required\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\treturn primaryContact;\n}\n\nfunction getPrimaryProperty(\n\tproperties: ParsedCustomerProperty[],\n): ParsedCustomerProperty | undefined {\n\treturn properties.find((p) => p.isPrimary) || properties[0];\n}\n\nasync function assertCustomerEmailNotDuplicate(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\temail: string,\n) {\n\tconst { data: existingEmail } = await supabase\n\t\t.from(\"customers\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"email\", email)\n\t\t.is(\"deleted_at\", null)\n\t\t.single();\n\n\tif (existingEmail) {\n\t\tthrow new ActionError(\n\t\t\t\"A customer with this email already exists\",\n\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t);\n\t}\n}\n\nfunction buildCustomerDisplayName(\n\tcustomerType: FormDataEntryValue | null,\n\tcompanyNameValue: FormDataEntryValue | null,\n\tprimaryContact: ParsedCustomerContact,\n): string {\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\tif (customerType === \"commercial\" && companyName) {\n\t\treturn companyName;\n\t}\n\n\treturn `${primaryContact.firstName} ${primaryContact.lastName}`;\n}\n\nfunction buildDefaultCommunicationPreferences() {\n\treturn {\n\t\temail: true,\n\t\tsms: true,\n\t\tphone: true,\n\t\tmarketing: false,\n\t};\n}\n\nfunction buildCustomerMetadata(contacts: ParsedCustomerContact[]) {\n\treturn {\n\t\tcontacts: contacts.map((c) => ({\n\t\t\tfirstName: c.firstName,\n\t\t\tlastName: c.lastName,\n\t\t\temail: c.email,\n\t\t\tphone: c.phone,\n\t\t\trole: c.role,\n\t\t\tisPrimary: c.isPrimary,\n\t\t})),\n\t};\n}\n\nasync function geocodePrimaryPropertyIfAvailable(\n\tprimaryProperty: ParsedCustomerProperty | undefined,\n): Promise<{ lat: number | null; lon: number | null }> {\n\tif (\n\t\t!(\n\t\t\tprimaryProperty?.address &&\n\t\t\tprimaryProperty.city &&\n\t\t\tprimaryProperty.state &&\n\t\t\tprimaryProperty.zipCode\n\t\t)\n\t) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\tconst geocodeResult = await geocodeAddressSilent(\n\t\tprimaryProperty.address,\n\t\tprimaryProperty.city,\n\t\tprimaryProperty.state,\n\t\tprimaryProperty.zipCode,\n\t\tprimaryProperty.country || \"USA\",\n\t);\n\n\tif (!geocodeResult) {\n\t\treturn { lat: null, lon: null };\n\t}\n\n\treturn { lat: geocodeResult.lat, lon: geocodeResult.lon };\n}\n\ntype InsertCustomerParams = {\n\tcompanyId: string;\n\tcustomerType: FormDataEntryValue | null;\n\tprimaryContact: ParsedCustomerContact;\n\tcompanyNameValue: FormDataEntryValue | null;\n\tdisplayName: string;\n\tprimaryProperty?: ParsedCustomerProperty;\n\tcustomerLat: number | null;\n\tcustomerLon: number | null;\n\tformData: FormData;\n\ttags?: string[];\n\tcommunicationPreferences: {\n\t\temail: boolean;\n\t\tsms: boolean;\n\t\tphone: boolean;\n\t\tmarketing: boolean;\n\t};\n\tcustomerMetadata: Record<string, unknown>;\n};\n\nasync function insertCustomerRecord(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tparams: InsertCustomerParams,\n) {\n\tconst payload = buildCustomerInsertPayload(params);\n\n\tconst { data: customer, error: createError } = await supabase\n\t\t.from(\"customers\")\n\t\t.insert(payload)\n\t\t.select(\"id\")\n\t\t.single();\n\n\tif (createError || !customer) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(\"create customer\"),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn customer;\n}\n\nfunction buildCustomerInsertPayload(\n\tparams: InsertCustomerParams,\n): Record<string, unknown> {\n\tconst {\n\t\tcompanyId,\n\t\tcustomerType,\n\t\tprimaryContact,\n\t\tcompanyNameValue,\n\t\tdisplayName,\n\t\tprimaryProperty,\n\t\tcustomerLat,\n\t\tcustomerLon,\n\t\tformData,\n\t\ttags,\n\t\tcommunicationPreferences,\n\t\tcustomerMetadata,\n\t} = params;\n\n\tconst companyName = companyNameValue ? String(companyNameValue) : null;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\ttype: String(customerType || \"residential\"),\n\t\tfirst_name: primaryContact.firstName,\n\t\tlast_name: primaryContact.lastName,\n\t\tcompany_name: companyName,\n\t\tdisplay_name: displayName,\n\t\temail: primaryContact.email,\n\t\tphone: primaryContact.phone,\n\t\tsecondary_phone: null,\n\t\taddress: primaryProperty?.address || null,\n\t\taddress2: primaryProperty?.address2 || null,\n\t\tcity: primaryProperty?.city || null,\n\t\tstate: primaryProperty?.state || null,\n\t\tzip_code: primaryProperty?.zipCode || null,\n\t\tcountry: primaryProperty?.country || \"USA\",\n\t\tlat: customerLat,\n\t\tlon: customerLon,\n\t\tsource: formData.get(\"source\") ? String(formData.get(\"source\")) : null,\n\t\treferred_by: formData.get(\"referredBy\")\n\t\t\t? String(formData.get(\"referredBy\"))\n\t\t\t: null,\n\t\tpreferred_contact_method:\n\t\t\tString(formData.get(\"preferredContactMethod\")) || \"email\",\n\t\tpreferred_technician: formData.get(\"preferredTechnician\")\n\t\t\t? String(formData.get(\"preferredTechnician\"))\n\t\t\t: null,\n\t\tbilling_email: formData.get(\"billingEmail\")\n\t\t\t? String(formData.get(\"billingEmail\"))\n\t\t\t: null,\n\t\tpayment_terms: String(formData.get(\"paymentTerms\")) || \"due_on_receipt\",\n\t\tcredit_limit: formData.get(\"creditLimit\")\n\t\t\t? Number(formData.get(\"creditLimit\")) * CENTS_PER_DOLLAR\n\t\t\t: 0,\n\t\ttax_exempt: formData.get(\"taxExempt\") === \"on\",\n\t\ttax_exempt_number: formData.get(\"taxExemptNumber\")\n\t\t\t? String(formData.get(\"taxExemptNumber\"))\n\t\t\t: null,\n\t\ttags: tags || null,\n\t\tcommunication_preferences: communicationPreferences,\n\t\tnotes: formData.get(\"notes\") ? String(formData.get(\"notes\")) : null,\n\t\tinternal_notes: formData.get(\"internalNotes\")\n\t\t\t? String(formData.get(\"internalNotes\"))\n\t\t\t: null,\n\t\tmetadata: customerMetadata,\n\t\tstatus: \"active\",\n\t\tportal_enabled: false,\n\t\ttotal_revenue: 0,\n\t\ttotal_jobs: 0,\n\t\ttotal_invoices: 0,\n\t\taverage_job_value: 0,\n\t\toutstanding_balance: 0,\n\t};\n}\n\nasync function insertAdditionalPropertiesIfAny(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tcompanyId: string,\n\tcustomerId: string,\n\tproperties: ParsedCustomerProperty[],\n) {\n\tconst additionalProperties = properties.filter((p) => !p.isPrimary);\n\tif (additionalProperties.length === 0) {\n\t\treturn;\n\t}\n\n\tconst propertiesToInsert = await Promise.all(\n\t\tadditionalProperties.map(async (prop) => {\n\t\t\tlet propLat: number | null = null;\n\t\t\tlet propLon: number | null = null;\n\n\t\t\tif (prop.address && prop.city && prop.state && prop.zipCode) {\n\t\t\t\tconst geocodeResult = await geocodeAddressSilent(\n\t\t\t\t\tprop.address,\n\t\t\t\t\tprop.city,\n\t\t\t\t\tprop.state,\n\t\t\t\t\tprop.zipCode,\n\t\t\t\t\tprop.country || \"USA\",\n\t\t\t\t);\n\n\t\t\t\tif (geocodeResult) {\n\t\t\t\t\tpropLat = geocodeResult.lat;\n\t\t\t\t\tpropLon = geocodeResult.lon;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: customerId,\n\t\t\t\tname: prop.name || \"Additional Property\",\n\t\t\t\taddress: prop.address,\n\t\t\t\taddress2: prop.address2 || null,\n\t\t\t\tcity: prop.city,\n\t\t\t\tstate: prop.state,\n\t\t\t\tzip_code: prop.zipCode,\n\t\t\t\tcountry: prop.country || \"USA\",\n\t\t\t\tproperty_type: prop.propertyType || \"residential\",\n\t\t\t\tnotes: prop.notes || null,\n\t\t\t\tlat: propLat,\n\t\t\t\tlon: propLon,\n\t\t\t};\n\t\t}),\n\t);\n\n\tawait supabase.from(\"properties\").insert(propertiesToInsert);\n}\n\n/**\n * Update existing customer\n */\nasync function updateCustomer(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Parse tags if provided\n\t\tlet tags: string[] | undefined;\n\t\tconst tagsString = formData.get(\"tags\");\n\t\tif (tagsString && typeof tagsString === \"string\") {\n\t\t\ttry {\n\t\t\t\ttags = JSON.parse(tagsString);\n\t\t\t} catch {\n\t\t\t\ttags = tagsString.split(\",\").map((t) => t.trim());\n\t\t\t}\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = customerSchema.parse({\n\t\t\ttype: formData.get(\"type\") || \"residential\",\n\t\t\tfirstName: formData.get(\"firstName\"),\n\t\t\tlastName: formData.get(\"lastName\"),\n\t\t\tcompanyName: formData.get(\"companyName\") || undefined,\n\t\t\temail: formData.get(\"email\"),\n\t\t\tphone: formData.get(\"phone\"),\n\t\t\tsecondaryPhone: formData.get(\"secondaryPhone\") || undefined,\n\t\t\taddress: formData.get(\"address\") || undefined,\n\t\t\taddress2: formData.get(\"address2\") || undefined,\n\t\t\tcity: formData.get(\"city\") || undefined,\n\t\t\tstate: formData.get(\"state\") || undefined,\n\t\t\tzipCode: formData.get(\"zipCode\") || undefined,\n\t\t\tcountry: formData.get(\"country\") || \"USA\",\n\t\t\tsource: formData.get(\"source\") || undefined,\n\t\t\treferredBy: formData.get(\"referredBy\") || null,\n\t\t\tpreferredContactMethod: formData.get(\"preferredContactMethod\") || \"email\",\n\t\t\tpreferredTechnician: formData.get(\"preferredTechnician\") || null,\n\t\t\tbillingEmail: formData.get(\"billingEmail\") || null,\n\t\t\tpaymentTerms: formData.get(\"paymentTerms\") || \"due_on_receipt\",\n\t\t\tcreditLimit: formData.get(\"creditLimit\")\n\t\t\t\t? Number(formData.get(\"creditLimit\"))\n\t\t\t\t: 0,\n\t\t\ttaxExempt: formData.get(\"taxExempt\") === \"true\",\n\t\t\ttaxExemptNumber: formData.get(\"taxExemptNumber\") || undefined,\n\t\t\ttags,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t\tinternalNotes: formData.get(\"internalNotes\") || undefined,\n\t\t});\n\n\t\t// Check if email already exists (excluding current customer)\n\t\tif (data.email !== customer.email) {\n\t\t\tconst { data: existingEmail } = await supabase\n\t\t\t\t.from(\"customers\")\n\t\t\t\t.select(\"id\")\n\t\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t\t.eq(\"email\", data.email)\n\t\t\t\t.neq(\"id\", customerId)\n\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t.single();\n\n\t\t\tif (existingEmail) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\t\"A customer with this email already exists\",\n\t\t\t\t\tERROR_CODES.DB_DUPLICATE_ENTRY,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Generate display name\n\t\tconst displayName =\n\t\t\tdata.type === \"commercial\" && data.companyName\n\t\t\t\t? data.companyName\n\t\t\t\t: `${data.firstName} ${data.lastName}`;\n\n\t\tconst companyName = data.companyName ? String(data.companyName) : null;\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttype: data.type,\n\t\t\t\tfirst_name: data.firstName,\n\t\t\t\tlast_name: data.lastName,\n\t\t\t\tcompany_name: companyName,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\temail: data.email,\n\t\t\t\tphone: data.phone,\n\t\t\t\tsecondary_phone: data.secondaryPhone,\n\t\t\t\taddress: data.address,\n\t\t\t\taddress2: data.address2,\n\t\t\t\tcity: data.city,\n\t\t\t\tstate: data.state,\n\t\t\t\tzip_code: data.zipCode,\n\t\t\t\tcountry: data.country,\n\t\t\t\tsource: data.source,\n\t\t\t\treferred_by: data.referredBy,\n\t\t\t\tpreferred_contact_method: data.preferredContactMethod,\n\t\t\t\tpreferred_technician: data.preferredTechnician,\n\t\t\t\tbilling_email: data.billingEmail,\n\t\t\t\tpayment_terms: data.paymentTerms,\n\t\t\t\tcredit_limit: data.creditLimit,\n\t\t\t\ttax_exempt: data.taxExempt,\n\t\t\t\ttax_exempt_number: data.taxExemptNumber,\n\t\t\t\ttags: data.tags,\n\t\t\t\tnotes: data.notes,\n\t\t\t\tinternal_notes: data.internalNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Delete customer (soft delete/archive)\n */\nexport async function deleteCustomer(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, outstanding_balance\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Prevent deletion if customer has outstanding balance\n\t\tif (customer.outstanding_balance > 0) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot delete customer with outstanding balance. Collect payment first.\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"delete customer\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t});\n}\n\n// ============================================================================\n// CUSTOMER STATUS & PREFERENCES\n// ============================================================================\n\n/**\n * Update customer status\n */\nasync function updateCustomerStatus(\n\tcustomerId: string,\n\tstatus: \"active\" | \"inactive\" | \"archived\" | \"blocked\",\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update status\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ status })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer status\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Update communication preferences\n */\nasync function updateCommunicationPreferences(\n\tcustomerId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Validate input\n\t\tconst preferences = communicationPreferencesSchema.parse({\n\t\t\temail: formData.get(\"email\") === \"true\",\n\t\t\tsms: formData.get(\"sms\") === \"true\",\n\t\t\tphone: formData.get(\"phone\") === \"true\",\n\t\t\tmarketing: formData.get(\"marketing\") === \"true\",\n\t\t});\n\n\t\t// Update preferences\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ communication_preferences: preferences })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update communication preferences\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// CUSTOMER PORTAL\n// ============================================================================\n\n/**\n * Invite customer to portal\n * Sends an email with a secure token-based invitation link.\n */\nasync function inviteToPortal(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id, email, display_name, portal_enabled\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (customer.portal_enabled) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer is already invited to portal\",\n\t\t\t\tERROR_CODES.BUSINESS_RULE_VIOLATION,\n\t\t\t);\n\t\t}\n\n\t\t// Generate secure portal invitation token\n\t\tconst inviteToken = Buffer.from(\n\t\t\t`${customerId}:${Date.now()}:${Math.random()}`,\n\t\t).toString(\"base64url\");\n\n\t\t// Update customer\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tportal_enabled: true,\n\t\t\t\tportal_invited_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"invite customer to portal\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Send invitation email\n\t\tconst siteUrl = requireSiteUrl();\n\t\tconst portalUrl = `${siteUrl}/portal/setup?token=${inviteToken}`;\n\n\t\tconst emailResult = await sendEmail({\n\t\t\tto: customer.email,\n\t\t\tsubject: \"You've been invited to your Customer Portal\",\n\t\t\ttemplate: PortalInvitationEmail({\n\t\t\t\tcustomerName: customer.display_name,\n\t\t\t\tportalUrl,\n\t\t\t\texpiresInHours: 168, // 7 days\n\t\t\t\tsupportEmail: process.env.RESEND_FROM_EMAIL || \"support@thorbis.com\",\n\t\t\t\tsupportPhone: \"(555) 123-4567\",\n\t\t\t}),\n\t\t\ttemplateType: EmailTemplate.PORTAL_INVITATION,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treturn;\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n/**\n * Revoke portal access\n */\nasync function revokePortalAccess(\n\tcustomerId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst teamMember = await requireCustomerCompanyMembership(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t);\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Customer not found\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Revoke access\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({ portal_enabled: false })\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"revoke portal access\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n\n// ============================================================================\n// SEARCH & REPORTING\n// ============================================================================\n\n/**\n * Get customer by phone number\n * Used for incoming call lookups\n */\nexport async function getCustomerByPhone(\n\tphoneNumber: string,\n\tcompanyId: string,\n): Promise<ActionResult<unknown>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Normalize phone number (remove formatting)\n\t\tconst normalizedPhone = phoneNumber.replace(/\\D/g, \"\");\n\n\t\t// Search by primary phone or secondary phone\n\t\tconst { data: customer, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        properties:properties(*)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.or(\n\t\t\t\t`phone.eq.${phoneNumber},phone.eq.${normalizedPhone},secondary_phone.eq.${phoneNumber},secondary_phone.eq.${normalizedPhone}`,\n\t\t\t)\n\t\t\t.single();\n\n\t\tif (error && error.code !== \"PGRST116\") {\n\t\t\t// PGRST116 = no rows found\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to find customer: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customer || null;\n\t});\n}\n\n/**\n * Search customers by name, email, phone, or company\n */\nexport async function searchCustomers(\n\tsearchTerm: string,\n\toptions?: { limit?: number; offset?: number },\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Use the active company ID helper (same as getAllCustomers)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Use full-text search with ranking for best matches\n\t\t// Searches across: first_name, last_name, display_name, email, phone,\n\t\t// secondary_phone, company_name, address, city, state\n\t\t// Returns results ordered by relevance (weighted: name > contact > address)\n\t\tconst { searchCustomersFullText } = await import(\n\t\t\t\"@/lib/search/full-text-search\"\n\t\t);\n\n\t\tconst customers = await searchCustomersFullText(\n\t\t\tsupabase,\n\t\t\tactiveCompanyId,\n\t\t\tsearchTerm,\n\t\t\t{\n\t\t\t\tlimit: options?.limit || DEFAULT_SEARCH_LIMIT,\n\t\t\t\toffset: options?.offset || 0,\n\t\t\t},\n\t\t);\n\n\t\treturn customers;\n\t});\n}\n\n/**\n * Get top customers by revenue\n */\nasync function getTopCustomers(\n\tlimit = 10,\n): Promise<ActionResult<unknown[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"total_revenue\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch top customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get customers with outstanding balance\n */\ntype CustomerWithBalance = {\n\tid: string;\n\tdisplay_name: string;\n\tbalance: number;\n};\n\nasync function getCustomersWithBalance(): Promise<\n\tActionResult<CustomerWithBalance[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.gt(\"outstanding_balance\", 0)\n\t\t\t.order(\"outstanding_balance\", { ascending: false })\n\t\t\t.limit(100);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers with balance\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\ntype CustomerRecord = {\n\tid: string;\n\tcompany_id: string;\n\ttype: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\tcompany_name?: string | null;\n\temail: string;\n\tphone: string;\n\tsecondary_phone?: string;\n\taddress?: string;\n\taddress2?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip_code?: string;\n\tstatus: string;\n\ttotal_revenue?: number;\n\ttotal_jobs?: number;\n\ttotal_invoices?: number;\n\toutstanding_balance?: number;\n\tlast_job_date?: string;\n\tnext_scheduled_job?: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tarchived_at?: string | null;\n\tdeleted_at?: string | null;\n};\n\n/**\n * Get customers for phone dialer (lightweight, no enrichment)\n *\n * PERFORMANCE: Returns only basic contact info needed for dialer.\n * Use this instead of getAllCustomers() in AppHeader to avoid N+1 queries.\n *\n * Expected: 50-100ms (single query)\n * vs getAllCustomers(): 1200-2000ms (151 queries with enrichment)\n */\nexport async function getCustomersForDialer(): Promise<\n\tActionResult<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tfirst_name: string | null;\n\t\t\tlast_name: string | null;\n\t\t\tdisplay_name: string | null;\n\t\t\temail: string | null;\n\t\t\tphone: string | null;\n\t\t\tsecondary_phone?: string | null;\n\t\t\tcompany_name: string | null;\n\t\t\taddress: string | null;\n\t\t\taddress2: string | null;\n\t\t\tcity: string | null;\n\t\t\tstate: string | null;\n\t\t\tzip_code: string | null;\n\t\t}>\n\t>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"No active company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Single lightweight query - no joins, no enrichment\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\n\t\t\t\t\"id, first_name, last_name, display_name, email, phone, secondary_phone, company_name, address, address2, city, state, zip_code\",\n\t\t\t)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn customers || [];\n\t});\n}\n\n/**\n * Get all customers for the current company (WITH ENRICHMENT)\n *\n * WARNING: This function does 151 database queries for 50 customers (N+1 pattern).\n * Expected time: 1200-2000ms\n *\n * DO NOT use in AppHeader or other frequently rendered components.\n * Use getCustomersForDialer() instead for lightweight contact info.\n *\n * Only use this on dedicated customer list pages where the enriched data is needed.\n */\nasync function getAllCustomers(): Promise<\n\tActionResult<CustomerRecord[]>\n> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID (from cookie or first available)\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\n\t\tconst FORBIDDEN_STATUS_CODE = 403;\n\t\tif (!activeCompanyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\t// Verify user has access to the active company\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.maybeSingle();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You don't have access to this company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tFORBIDDEN_STATUS_CODE,\n\t\t\t);\n\t\t}\n\n\t\tconst { data: customers, error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", activeCompanyId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"display_name\", { ascending: true });\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch customers\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Use RPC function instead of N+1 queries\n\t\t// BEFORE: 151 queries for 50 customers (1 base + 50 × 3 queries each)\n\t\t// AFTER: 1 RPC call with efficient LATERAL joins\n\t\t// Performance gain: 5-10 seconds faster\n\n\t\t// Note: customers variable contains the base customer data from above query\n\t\t// We replace the enrichment logic with a single RPC call\n\t\tconst { data: enrichedData, error: enrichError } = await supabase.rpc(\n\t\t\t\"get_enriched_customers_rpc\",\n\t\t\t{\n\t\t\t\tp_company_id: activeCompanyId,\n\t\t\t},\n\t\t);\n\n\t\tif (enrichError) {\n\t\t\t// Fallback to base customers if enrichment fails\n\t\t\tconsole.error(\"Failed to enrich customers:\", enrichError);\n\t\t\treturn customers as CustomerRecord[];\n\t\t}\n\n\t\t// Merge enriched data with base customer data\n\t\tconst enrichedCustomers = (enrichedData || []).map((customer: any) => ({\n\t\t\t...customer,\n\t\t\t// Override total_jobs and total_revenue with fresh aggregated values\n\t\t\ttotal_jobs: customer.enriched_total_jobs || customer.total_jobs || 0,\n\t\t\ttotal_revenue:\n\t\t\t\tcustomer.enriched_total_revenue || customer.total_revenue || 0,\n\t\t}));\n\n\t\treturn enrichedCustomers as CustomerRecord[];\n\t});\n}\n\n/**\n * Update customer page content (Novel/Tiptap JSON)\n *\n * Saves the customer's editable page layout and content\n * Used by the Novel editor for auto-save functionality\n */\nasync function updateCustomerPageContent(\n\tcustomerId: string,\n\tpageContent: Record<string, unknown>,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Verify customer exists and belongs to company\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id, company_id\")\n\t\t\t.eq(\"id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tassertExists(customer, \"Customer\");\n\n\t\tif (customer.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"customer\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Update page content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\tpage_content: pageContent,\n\t\t\t\tcontent_updated_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update customer page\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t});\n}\n","\"use server\";\n\n/**\n * Support Session Actions for Web App\n *\n * Customer-facing actions for managing support access requests.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface SupportSession {\n\tid: string;\n\tadmin_user_id: string;\n\tticket_id: string | null;\n\treason: string;\n\trequested_at: string;\n\trequested_permissions: string[];\n\tadmin_name?: string;\n\tadmin_email?: string;\n}\n\n/**\n * Get pending support session requests for the current company\n */\nexport async function getPendingSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id from team_members\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query admin database for pending sessions\n\t\t// Note: This requires admin database access - we'll use a service role query\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\")\n\t\t\t.order(\"requested_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching pending sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// TODO: Enrich with admin user details from admin database\n\t\t// For now, return sessions without admin details\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getPendingSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Get active support sessions for the current company\n */\nexport async function getActiveSupportSessions(): Promise<{\n\tsuccess: boolean;\n\tsessions?: SupportSession[];\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user's company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Get user's company_id\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Query for active sessions\n\t\tconst adminSupabase = createClient(); // TODO: Use admin/service client\n\n\t\tconst { data: sessions, error } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        admin_user_id,\n        ticket_id,\n        reason,\n        requested_at,\n        approved_at,\n        expires_at,\n        requested_permissions\n      `\n\t\t\t)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.order(\"approved_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching active sessions:\", error);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tsessions: sessions || [],\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error in getActiveSupportSessions:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Approve a support session request\n */\nexport async function approveSupportSessionRequest(sessionId: string, durationMinutes: number = 60): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company for this session\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Call admin database to approve session\n\t\t// TODO: This should be a secure RPC call to admin database\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"active\",\n\t\t\t\tapproved_at: new Date().toISOString(),\n\t\t\t\tapproved_by: user.id,\n\t\t\t\texpires_at: expiresAt.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error approving session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in approveSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Reject a support session request\n */\nexport async function rejectSupportSessionRequest(sessionId: string, reason?: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// Update session status\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\trejected_at: new Date().toISOString(),\n\t\t\t\trejected_by: user.id,\n\t\t\t\trejection_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"pending\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error rejecting session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in rejectSupportSessionRequest:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * End an active support session (customer-initiated)\n */\nexport async function endActiveSupportSession(sessionId: string): Promise<{\n\tsuccess: boolean;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\t// Verify user is part of the company\n\t\tconst { data: teamMember } = await supabase.from(\"team_members\").select(\"company_id\").eq(\"user_id\", user.id).single();\n\n\t\tif (!teamMember) {\n\t\t\treturn { success: false, error: \"No company found\" };\n\t\t}\n\n\t\t// End the session\n\t\tconst adminSupabase = createClient(); // Use admin client\n\n\t\tconst { error: updateError } = await adminSupabase\n\t\t\t.from(\"support_sessions\")\n\t\t\t.update({\n\t\t\t\tstatus: \"ended\",\n\t\t\t\tended_at: new Date().toISOString(),\n\t\t\t\tended_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", sessionId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.eq(\"status\", \"active\");\n\n\t\tif (updateError) {\n\t\t\tconsole.error(\"Error ending session:\", updateError);\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Error in endActiveSupportSession:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[7,8,9,10,11,12,13,14,15,16,17,18,19]}