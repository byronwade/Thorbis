{"version":3,"sources":["../../../../../../apps/web/src/lib/security/rate-limit.ts","../../../../../../apps/web/.next-internal/server/app/%28auth%29/register/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["/**\n * Rate Limiting Utilities\n *\n * Provides rate limiting for authentication and API endpoints to prevent:\n * - Brute force password attacks\n * - Account enumeration\n * - Email spam/flooding\n * - DDoS attacks\n *\n * Implementation:\n * - Uses in-memory LRU cache for development/small scale\n * - Can be easily swapped with Redis/Upstash for production\n * - Sliding window algorithm for accurate rate limiting\n * - Per-identifier tracking (email, IP, user ID)\n */\n\n// Simple in-memory rate limiter using LRU cache\n// For production, replace with @upstash/ratelimit + @upstash/redis\nclass InMemoryRateLimiter {\n\tprivate requests: Map<\n\t\tstring,\n\t\t{ count: number; resetAt: number; requests: number[] }\n\t>;\n\tprivate readonly maxRequests: number;\n\tprivate readonly windowMs: number;\n\n\tconstructor(maxRequests: number, windowMs: number) {\n\t\tthis.requests = new Map();\n\t\tthis.maxRequests = maxRequests;\n\t\tthis.windowMs = windowMs;\n\n\t\t// Cleanup old entries every minute\n\t\tsetInterval(() => this.cleanup(), 60_000);\n\t}\n\n\tasync limit(identifier: string): Promise<{\n\t\tsuccess: boolean;\n\t\tlimit: number;\n\t\tremaining: number;\n\t\treset: number;\n\t}> {\n\t\tconst now = Date.now();\n\t\tconst key = identifier;\n\n\t\tlet record = this.requests.get(key);\n\n\t\t// Initialize if doesn't exist\n\t\tif (!record) {\n\t\t\trecord = {\n\t\t\t\tcount: 0,\n\t\t\t\tresetAt: now + this.windowMs,\n\t\t\t\trequests: [],\n\t\t\t};\n\t\t\tthis.requests.set(key, record);\n\t\t}\n\n\t\t// Remove requests outside the sliding window\n\t\trecord.requests = record.requests.filter(\n\t\t\t(timestamp) => timestamp > now - this.windowMs,\n\t\t);\n\n\t\t// Check if limit exceeded\n\t\tif (record.requests.length >= this.maxRequests) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tlimit: this.maxRequests,\n\t\t\t\tremaining: 0,\n\t\t\t\treset: Math.min(...record.requests) + this.windowMs,\n\t\t\t};\n\t\t}\n\n\t\t// Add new request\n\t\trecord.requests.push(now);\n\t\trecord.count = record.requests.length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tlimit: this.maxRequests,\n\t\t\tremaining: this.maxRequests - record.count,\n\t\t\treset: now + this.windowMs,\n\t\t};\n\t}\n\n\tprivate cleanup() {\n\t\tconst now = Date.now();\n\t\tfor (const [key, record] of this.requests.entries()) {\n\t\t\trecord.requests = record.requests.filter(\n\t\t\t\t(timestamp) => timestamp > now - this.windowMs,\n\t\t\t);\n\t\t\tif (record.requests.length === 0) {\n\t\t\t\tthis.requests.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\treset(identifier: string) {\n\t\tthis.requests.delete(identifier);\n\t}\n\n\tclear() {\n\t\tthis.requests.clear();\n\t}\n}\n\n// Rate limiter instances for different operations\nconst authRateLimiterInstance = new InMemoryRateLimiter(\n\t5, // 5 requests\n\t15 * 60 * 1000, // per 15 minutes\n);\n\nconst apiRateLimiterInstance = new InMemoryRateLimiter(\n\t100, // 100 requests\n\t60 * 1000, // per 1 minute\n);\n\nconst passwordResetRateLimiterInstance = new InMemoryRateLimiter(\n\t3, // 3 requests\n\t60 * 60 * 1000, // per 1 hour\n);\n\n/**\n * Auth Rate Limiter\n *\n * Use for: Sign in, Sign up, OAuth\n * Limit: 5 requests per 15 minutes per identifier\n */\nexport const authRateLimiter = {\n\tlimit: (identifier: string) => authRateLimiterInstance.limit(identifier),\n\treset: (identifier: string) => authRateLimiterInstance.reset(identifier),\n};\n\n/**\n * API Rate Limiter\n *\n * Use for: General API endpoints\n * Limit: 100 requests per minute per identifier\n */\nconst apiRateLimiter = {\n\tlimit: (identifier: string) => apiRateLimiterInstance.limit(identifier),\n\treset: (identifier: string) => apiRateLimiterInstance.reset(identifier),\n};\n\n/**\n * Password Reset Rate Limiter\n *\n * Use for: Password reset requests\n * Limit: 3 requests per hour per identifier\n */\nexport const passwordResetRateLimiter = {\n\tlimit: (identifier: string) =>\n\t\tpasswordResetRateLimiterInstance.limit(identifier),\n\treset: (identifier: string) =>\n\t\tpasswordResetRateLimiterInstance.reset(identifier),\n};\n\n/**\n * Rate Limit Error\n */\nexport class RateLimitError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic limit: number,\n\t\tpublic remaining: number,\n\t\tpublic reset: number,\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"RateLimitError\";\n\t}\n}\n\n/**\n * Check Rate Limit\n *\n * Throws RateLimitError if rate limit exceeded.\n *\n * @param identifier - Unique identifier (email, IP, user ID)\n * @param limiter - Rate limiter instance to use\n */\nexport async function checkRateLimit(\n\tidentifier: string,\n\tlimiter: typeof authRateLimiter = apiRateLimiter,\n): Promise<void> {\n\tconst { success, limit, remaining, reset } = await limiter.limit(identifier);\n\n\tif (!success) {\n\t\tconst resetDate = new Date(reset);\n\t\tthrow new RateLimitError(\n\t\t\t`Too many requests. Please try again after ${resetDate.toLocaleTimeString()}.`,\n\t\t\tlimit,\n\t\t\tremaining,\n\t\t\treset,\n\t\t);\n\t}\n}\n\n/**\n * Get Client IP Address\n *\n * Extracts IP from request headers for rate limiting.\n * Supports various proxy headers.\n */\nfunction getClientIP(request: Request): string {\n\tconst headers = new Headers(request.headers);\n\n\t// Check common proxy headers\n\tconst forwarded = headers.get(\"x-forwarded-for\");\n\tif (forwarded) {\n\t\treturn forwarded.split(\",\")[0].trim();\n\t}\n\n\tconst realIP = headers.get(\"x-real-ip\");\n\tif (realIP) {\n\t\treturn realIP;\n\t}\n\n\tconst cfIP = headers.get(\"cf-connecting-ip\"); // Cloudflare\n\tif (cfIP) {\n\t\treturn cfIP;\n\t}\n\n\t// Fallback to unknown\n\treturn \"unknown\";\n}\n\n/**\n * Production Setup Instructions\n *\n * For production, replace in-memory limiter with Redis:\n *\n * 1. Install dependencies:\n *    ```bash\n *    pnpm add @upstash/ratelimit @upstash/redis\n *    ```\n *\n * 2. Update this file:\n *    ```typescript\n *    import { Ratelimit } from \"@upstash/ratelimit\";\n *    import { Redis } from \"@upstash/redis\";\n *\n *    const redis = new Redis({\n *      url: process.env.UPSTASH_REDIS_REST_URL!,\n *      token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *    });\n *\n *    export const authRateLimiter = new Ratelimit({\n *      redis,\n *      limiter: Ratelimit.slidingWindow(5, \"15 m\"),\n *      analytics: true,\n *      prefix: \"ratelimit:auth\",\n *    });\n *    ```\n *\n * 3. Add environment variables:\n *    ```\n *    UPSTASH_REDIS_REST_URL=https://...\n *    UPSTASH_REDIS_REST_TOKEN=...\n *    ```\n */\n","export {getCurrentUserRole as '001f005176797ef23488068124fb9a744915a477de'} from 'ACTIONS_MODULE0'\nexport {canDeleteTeamMember as '406f6624261c6dd1a908026fa1408a3f6d507b6e7d'} from 'ACTIONS_MODULE0'\nexport {signInWithOAuth as '4092ddfc0e09825d6739a8441ea0b2f8f4c05296d4'} from 'ACTIONS_MODULE1'\nexport {signUp as '40104c6fe35e38f96ad479521960f3a0e1b163d436'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":"uLAkBA,OAAM,EACG,QAIS,AADf,YACmC,CACpB,QAAiB,AAElC,aAAY,CAAmB,CAAE,CAAgB,CAAE,CAClD,IAAI,CAAC,QAAQ,CAAG,IAAI,IACpB,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,QAAQ,CAAG,EAGhB,YAAY,IAAM,IAAI,CAAC,OAAO,GAAI,IACnC,CAEA,MAAM,MAAM,CAAkB,CAK3B,CACF,IAAM,EAAM,KAAK,GAAG,GAGhB,EAAS,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAkB/B,CAfK,IACJ,EAAS,CACR,CAFW,KAEJ,EACP,QAAS,EAAM,IAAI,CAAC,QAAQ,CAC5B,SAAU,EAAE,AACb,EACA,IAAI,CAAC,QAAQ,CAAC,GAAG,CAXN,AAWO,EAAK,IAIxB,EAAO,QAAQ,CAAG,EAAO,QAAQ,CAAC,MAAM,CACvC,AAAC,GAAc,EAAY,EAAM,IAAI,CAAC,QAAQ,EAI3C,EAAO,QAAQ,CAAC,MAAM,EAAI,IAAI,CAAC,WAAW,EAAE,AACxC,CACN,SAAS,EACT,MAAO,IAAI,CAAC,WAAW,CACvB,UAAW,EACX,MAAO,KAAK,GAAG,IAAI,EAAO,QAAQ,EAAI,IAAI,CAAC,QAC5C,AADoD,GAKrD,EAAO,QAAQ,CAAC,IAAI,CAAC,GACrB,EAAO,KAAK,CAAG,EAAO,QAAQ,CAAC,MAAM,CAE9B,CACN,SAAS,EACT,MAAO,IAAI,CAAC,WAAW,CACvB,UAAW,IAAI,CAAC,WAAW,CAAG,EAAO,KAAK,CAC1C,MAAO,EAAM,IAAI,CAAC,QAAQ,AAC3B,EACD,CAEQ,SAAU,CACjB,IAAM,EAAM,KAAK,GAAG,GACpB,IAAK,GAAM,CAAC,EAAK,EAAO,GAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAI,AACpD,EAAO,QAAQ,CAAG,EAAO,QAAQ,CAAC,MAAM,CACvC,AAAC,GAAc,EAAY,EAAM,IAAI,CAAC,QAAQ,EAEhB,GAAG,CAA9B,EAAO,QAAQ,CAAC,MAAM,EACzB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAGxB,CAEA,MAAM,CAAkB,CAAE,CACzB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EACtB,CAEA,OAAQ,CACP,IAAI,CAAC,QAAQ,CAAC,KAAK,EACpB,CACD,CAGA,IAAM,EAA0B,IAAI,EACnC,EACA,KAAK,AAGA,EAAyB,GAHpB,CAGwB,EAClC,IACA,KAAK,AAGA,EAAmC,IAAI,EAC5C,EACA,KAAK,CAoBA,EAAiB,CACtB,CArBU,KAqBF,AAAD,GAAwB,EAAuB,KAAK,CAAC,GAC5D,MAAO,AAAC,GAAuB,EAAuB,KAAK,CAAC,EAC7D,CAkBO,OAAM,UAAuB,2BACnC,aACC,CAAe,CACR,CAAa,CACb,CAAiB,CACjB,CAAa,CACnB,CACD,KAAK,CAAC,GAAA,IAAA,CAJC,KAAA,CAAA,EAAA,IAAA,CACA,SAAA,CAAA,EAAA,IAAA,CACA,KAAA,CAAA,EAGP,IAAI,CAAC,IAAI,CAAG,gBACb,CACD,CAUO,eAAe,EACrB,CAAkB,CAClB,EAAkC,CAAc,EAEhD,GAAM,SAAE,CAAO,OAAE,CAAK,WAAE,CAAS,OAAE,CAAK,CAAE,CAAG,MAAM,EAAQ,KAAK,CAAC,GAEjE,GAAI,CAAC,EAAS,CACb,IAAM,EAAY,IAAI,KAAK,EAC3B,OAAM,IAAI,EACT,CAAC,0CAA0C,EAAE,EAAU,kBAAkB,GAAG,CAAC,CAAC,CAC9E,EACA,EACA,EAEF,CACD,iDAnE+B,CAC9B,MAAO,AAAC,GAAuB,EAAwB,KAAK,CAAC,GAC7D,MAAO,AAAC,GAAuB,EAAwB,KAAK,CAAC,EAC9D,sDAmBwC,CACvC,MAAO,AAAC,GACP,EAAiC,KAAK,CAAC,GACxC,MAAO,AAAC,GACP,EAAiC,KAAK,CAAC,EACzC,oCCzJA,EAAA,CAAA,CAAA,QAEA,IAAA,EAAA,EAAA,CAAA,CAAA"}