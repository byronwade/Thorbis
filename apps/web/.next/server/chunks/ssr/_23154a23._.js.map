{"version":3,"sources":["../../../../../../apps/web/src/lib/payments/payment-tokens.ts","../../../../../../apps/web/src/lib/payments/processor.ts","../../../../../../apps/web/src/lib/email/company-domain-sender.ts","../../../../../../apps/web/src/lib/email/email-router.ts","../../../../../../apps/web/src/actions/payments/process-invoice-payment.ts","../../../../../../apps/web/.next-internal/server/app/%28public%29/pay/%5BinvoiceId%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["/**\n * Payment Token Utilities\n *\n * Secure token generation and validation for invoice payment links\n *\n * Features:\n * - Generate secure payment tokens with expiration\n * - Validate tokens before allowing payment\n * - Track token usage and prevent reuse\n * - IP address tracking for security\n */\n\n\"use server\";\n\nimport { emailConfig } from \"@/lib/email/resend-client\";\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport type PaymentToken = {\n\ttoken: string;\n\texpiresAt: string;\n\tpaymentLink: string;\n};\n\nexport type TokenValidation = {\n\tisValid: boolean;\n\tinvoiceId: string | null;\n\tmessage: string;\n};\n\n/**\n * Generate a secure payment token for an invoice\n *\n * @param invoiceId - UUID of the invoice\n * @param expiryHours - How many hours until token expires (default 72 hours / 3 days)\n * @param maxUses - Maximum number of times token can be used (default 1)\n * @returns Payment token details including the full payment link\n */\nexport async function generatePaymentToken(\n\tinvoiceId: string,\n\texpiryHours = 72,\n\tmaxUses = 1,\n): Promise<PaymentToken | null> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Call database function to generate token\n\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\"generate_invoice_payment_token\",\n\t\t\t{\n\t\t\t\tp_invoice_id: invoiceId,\n\t\t\t\tp_expiry_hours: expiryHours,\n\t\t\t\tp_max_uses: maxUses,\n\t\t\t},\n\t\t);\n\n\t\tif (error || !data || data.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenData = data[0];\n\t\tconst paymentLink = `${emailConfig.appUrl}/pay/${invoiceId}?token=${tokenData.token}`;\n\n\t\treturn {\n\t\t\ttoken: tokenData.token,\n\t\t\texpiresAt: tokenData.expires_at,\n\t\t\tpaymentLink,\n\t\t};\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Check a payment token (does NOT increment use count)\n * Use this for viewing the payment page\n *\n * @param token - The payment token to check\n * @returns Validation result with invoice ID if valid\n */\nexport async function validatePaymentToken(\n\ttoken: string,\n\t_ipAddress?: string,\n): Promise<TokenValidation> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tisValid: false,\n\t\t\t\tinvoiceId: null,\n\t\t\t\tmessage: \"Unable to connect to database\",\n\t\t\t};\n\t\t}\n\n\t\tconst { data, error } = await supabase.rpc(\"check_payment_token\", {\n\t\t\tp_token: token,\n\t\t});\n\n\t\tif (error || !data || data.length === 0) {\n\t\t\treturn {\n\t\t\t\tisValid: false,\n\t\t\t\tinvoiceId: null,\n\t\t\t\tmessage: \"Invalid payment token\",\n\t\t\t};\n\t\t}\n\n\t\tconst validation = data[0];\n\n\t\treturn {\n\t\t\tisValid: validation.is_valid,\n\t\t\tinvoiceId: validation.invoice_id,\n\t\t\tmessage: validation.message,\n\t\t};\n\t} catch (_error) {\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\tinvoiceId: null,\n\t\t\tmessage: \"Error validating payment token\",\n\t\t};\n\t}\n}\n\n/**\n * Mark a payment token as used (called after successful payment)\n * This deactivates the token so it cannot be used again\n *\n * @param token - The payment token to mark as used\n * @param ipAddress - Optional IP address for security tracking\n */\nexport async function markTokenAsUsed(\n\ttoken: string,\n\tipAddress?: string,\n): Promise<boolean> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { data: existingTokens, error: fetchError } = await supabase\n\t\t\t.from(\"invoice_payment_tokens\")\n\t\t\t.select(\"use_count\")\n\t\t\t.eq(\"token\", token)\n\t\t\t.limit(1);\n\n\t\tif (fetchError || !existingTokens || existingTokens.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst currentUseCount = existingTokens[0]?.use_count ?? 0;\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"invoice_payment_tokens\")\n\t\t\t.update({\n\t\t\t\tis_active: false,\n\t\t\t\tused_at: new Date().toISOString(),\n\t\t\t\tused_by_ip: ipAddress || null,\n\t\t\t\tuse_count: currentUseCount + 1,\n\t\t\t})\n\t\t\t.eq(\"token\", token);\n\n\t\tif (error) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Get all active payment tokens for an invoice\n *\n * Useful for admin purposes or showing existing payment links\n *\n * @param invoiceId - UUID of the invoice\n * @returns Array of active payment tokens\n */\nasync function getInvoicePaymentTokens(\n\tinvoiceId: string,\n): Promise<PaymentToken[]> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"invoice_payment_tokens\")\n\t\t\t.select(\"token, expires_at\")\n\t\t\t.eq(\"invoice_id\", invoiceId)\n\t\t\t.eq(\"is_active\", true)\n\t\t\t.gt(\"expires_at\", new Date().toISOString())\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error || !data) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn data.map((row) => ({\n\t\t\ttoken: row.token,\n\t\t\texpiresAt: row.expires_at,\n\t\t\tpaymentLink: `${emailConfig.appUrl}/pay/${invoiceId}?token=${row.token}`,\n\t\t}));\n\t} catch (_error) {\n\t\treturn [];\n\t}\n}\n\n/**\n * PERFORMANCE OPTIMIZED: Batch generate payment tokens for multiple invoices\n *\n * Replaces N+1 pattern where each invoice generates a token separately.\n * Uses Promise.all to parallelize RPC calls (still better than sequential).\n *\n * @param invoiceIds - Array of invoice UUIDs\n * @param expiryHours - How many hours until tokens expire (default 72 hours / 3 days)\n * @param maxUses - Maximum number of times tokens can be used (default 1)\n * @returns Map of invoiceId -> PaymentToken\n */\nexport async function generatePaymentTokensBatch(\n\tinvoiceIds: string[],\n\texpiryHours = 72,\n\tmaxUses = 1,\n): Promise<Record<string, PaymentToken>> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Generate all tokens in parallel (much faster than sequential)\n\t\tconst tokenPromises = invoiceIds.map(async (invoiceId) => {\n\t\t\tconst { data, error } = await supabase.rpc(\n\t\t\t\t\"generate_invoice_payment_token\",\n\t\t\t\t{\n\t\t\t\t\tp_invoice_id: invoiceId,\n\t\t\t\t\tp_expiry_hours: expiryHours,\n\t\t\t\t\tp_max_uses: maxUses,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error || !data || data.length === 0) {\n\t\t\t\treturn { invoiceId, token: null };\n\t\t\t}\n\n\t\t\tconst tokenData = data[0];\n\t\t\tconst paymentLink = `${emailConfig.appUrl}/pay/${invoiceId}?token=${tokenData.token}`;\n\n\t\t\treturn {\n\t\t\t\tinvoiceId,\n\t\t\t\ttoken: {\n\t\t\t\t\ttoken: tokenData.token,\n\t\t\t\t\texpiresAt: tokenData.expires_at,\n\t\t\t\t\tpaymentLink,\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\n\t\tconst results = await Promise.all(tokenPromises);\n\n\t\t// Convert array to map\n\t\treturn results.reduce(\n\t\t\t(acc, { invoiceId, token }) => {\n\t\t\t\tif (token) {\n\t\t\t\t\tacc[invoiceId] = token;\n\t\t\t\t}\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{} as Record<string, PaymentToken>,\n\t\t);\n\t} catch (_error) {\n\t\treturn {};\n\t}\n}\n","/**\n * Payment Processor Abstraction Layer\n *\n * Provides a unified interface for multiple payment processors:\n * - Stripe: For platform billing (subscriptions)\n * - Adyen: For high-value contractor payments (card-present, ACH)\n * - Plaid: For bank account linking and ACH\n * - ProfitStars: For ACH/check processing\n *\n * This abstraction allows contractors to process high-value payments\n * without Stripe's limitations while maintaining a consistent API.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type {\n\tPaymentChannel,\n\tPaymentProcessor,\n\tPaymentProcessorConfig,\n\tPaymentProcessorType,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n} from \"./processor-types\";\n\n// Re-export all types to maintain API compatibility\nexport type {\n\tPaymentProcessorType,\n\tPaymentChannel,\n\tPaymentProcessorConfig,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n\tPaymentProcessor,\n};\n\n/**\n * Get the appropriate payment processor for a company\n *\n * Determines which processor to use based on:\n * 1. Company's configured processor\n * 2. Payment amount (high-value payments use Adyen)\n * 3. Payment channel (card-present uses Adyen, ACH uses Plaid/ProfitStars)\n */\nexport async function getPaymentProcessor(\n\tcompanyId: string,\n\toptions?: {\n\t\tamount?: number;\n\t\tchannel?: PaymentChannel;\n\t\tforceProcessor?: PaymentProcessorType;\n\t},\n): Promise<PaymentProcessor | null> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\t// Check if company has at least one bank account (required for payments)\n\tconst { data: bankAccounts } = await supabase\n\t\t.from(\"finance_bank_accounts\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"is_active\", true)\n\t\t.limit(1);\n\n\tif (!bankAccounts || bankAccounts.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Get company's payment processor configuration\n\tconst { data: processors } = await supabase\n\t\t.from(\"company_payment_processors\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (!processors || processors.length === 0) {\n\t\treturn null;\n\t}\n\n\t// If force processor specified, use it\n\tif (options?.forceProcessor) {\n\t\tconst processor = processors.find(\n\t\t\t(p) => p.processor_type === options.forceProcessor,\n\t\t);\n\t\tif (processor) {\n\t\t\treturn createProcessorInstance(processor);\n\t\t}\n\t}\n\n\t// Determine processor based on payment characteristics\n\tconst amount = options?.amount || 0;\n\tconst channel = options?.channel || \"online\";\n\n\t// High-value payments (>$10k) should use Adyen\n\tif (\n\t\tamount > 1_000_000 &&\n\t\tprocessors.some((p) => p.processor_type === \"adyen\")\n\t) {\n\t\tconst adyenProcessor = processors.find((p) => p.processor_type === \"adyen\");\n\t\tif (adyenProcessor) {\n\t\t\treturn createProcessorInstance(adyenProcessor);\n\t\t}\n\t}\n\n\t// Card-present or tap-to-pay should use Adyen\n\tif (\n\t\t(channel === \"card_present\" || channel === \"tap_to_pay\") &&\n\t\tprocessors.some((p) => p.processor_type === \"adyen\")\n\t) {\n\t\tconst adyenProcessor = processors.find((p) => p.processor_type === \"adyen\");\n\t\tif (adyenProcessor) {\n\t\t\treturn createProcessorInstance(adyenProcessor);\n\t\t}\n\t}\n\n\t// ACH payments should use Plaid or ProfitStars\n\tif (channel === \"ach\") {\n\t\tconst plaidProcessor = processors.find((p) => p.processor_type === \"plaid\");\n\t\tif (plaidProcessor) {\n\t\t\treturn createProcessorInstance(plaidProcessor);\n\t\t}\n\t\tconst profitstarsProcessor = processors.find(\n\t\t\t(p) => p.processor_type === \"profitstars\",\n\t\t);\n\t\tif (profitstarsProcessor) {\n\t\t\treturn createProcessorInstance(profitstarsProcessor);\n\t\t}\n\t}\n\n\t// Default to first active processor\n\treturn createProcessorInstance(processors[0]);\n}\n\n/**\n * Create a processor instance from database configuration\n */\nasync function createProcessorInstance(\n\tconfig: any,\n): Promise<PaymentProcessor | null> {\n\tswitch (config.processor_type) {\n\t\tcase \"adyen\": {\n\t\t\tconst { AdyenProcessor } = await import(\"./processors/adyen\");\n\t\t\treturn new AdyenProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\taccountId: config.adyen_account_id,\n\t\t\t\tapiKey: config.adyen_api_key_encrypted, // Will need decryption\n\t\t\t\tmerchantAccount: config.adyen_merchant_account,\n\t\t\t\tliveMode: config.adyen_live_mode,\n\t\t\t});\n\t\t}\n\t\tcase \"plaid\": {\n\t\t\tconst { PlaidProcessor } = await import(\"./processors/plaid\");\n\t\t\treturn new PlaidProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tclientId: config.plaid_client_id,\n\t\t\t\tsecret: config.plaid_secret_encrypted, // Will need decryption\n\t\t\t\tenvironment: config.plaid_environment || \"sandbox\",\n\t\t\t});\n\t\t}\n\t\tcase \"profitstars\": {\n\t\t\tconst { ProfitStarsProcessor } = await import(\"./processors/profitstars\");\n\t\t\treturn new ProfitStarsProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tmerchantId: config.profitstars_merchant_id,\n\t\t\t\tapiKey: config.profitstars_api_key_encrypted, // Will need decryption\n\t\t\t\troutingNumber: config.profitstars_routing_number,\n\t\t\t});\n\t\t}\n\t\tcase \"stripe\": {\n\t\t\tconst { StripeProcessor } = await import(\"./processors/stripe\");\n\t\t\treturn new StripeProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tliveMode: config.adyen_live_mode,\n\t\t\t});\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Calculate trust score for a payment\n *\n * Higher trust scores allow larger payments without flagging\n */\nexport async function calculatePaymentTrustScore(\n\tcompanyId: string,\n\tamount: number,\n): Promise<{\n\tscore: number;\n\tallowed: boolean;\n\trequiresApproval: boolean;\n\treason?: string;\n}> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn {\n\t\t\tscore: 0,\n\t\t\tallowed: false,\n\t\t\trequiresApproval: true,\n\t\t\treason: \"Database unavailable\",\n\t\t};\n\t}\n\n\t// Get company's trust score\n\tconst { data: trustScore } = await supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!trustScore) {\n\t\treturn {\n\t\t\tscore: 50,\n\t\t\tallowed: false,\n\t\t\trequiresApproval: true,\n\t\t\treason: \"No trust score found\",\n\t\t};\n\t}\n\n\tconst score = Number(trustScore.overall_score);\n\n\t// Get processor configuration\n\tconst { data: processor } = await supabase\n\t\t.from(\"company_payment_processors\")\n\t\t.select(\"max_payment_amount, requires_approval_above\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.single();\n\n\tconst maxAmount = processor?.max_payment_amount || 100_000; // Default $1,000\n\tconst approvalThreshold = processor?.requires_approval_above || 50_000; // Default $500\n\n\t// Calculate if payment is allowed based on trust score\n\t// Trust score 90+: Allow up to configured max\n\t// Trust score 70-89: Allow up to 50% of max\n\t// Trust score 50-69: Allow up to 25% of max\n\t// Trust score <50: Require approval for any payment > $100\n\n\tlet allowedAmount = maxAmount;\n\tif (score >= 90) {\n\t\tallowedAmount = maxAmount;\n\t} else if (score >= 70) {\n\t\tallowedAmount = Math.floor(maxAmount * 0.5);\n\t} else if (score >= 50) {\n\t\tallowedAmount = Math.floor(maxAmount * 0.25);\n\t} else {\n\t\tallowedAmount = 10_000; // $100 minimum\n\t}\n\n\tconst allowed = amount <= allowedAmount;\n\tconst requiresApproval = amount > approvalThreshold || score < 70;\n\n\treturn {\n\t\tscore,\n\t\tallowed,\n\t\trequiresApproval,\n\t\treason: allowed\n\t\t\t? requiresApproval\n\t\t\t\t? \"Payment requires manual approval\"\n\t\t\t\t: undefined\n\t\t\t: `Payment amount exceeds allowed limit for trust score. Max allowed: $${allowedAmount / 100}`,\n\t};\n}\n\n/**\n * Update trust score after payment\n */\nexport async function updateTrustScoreAfterPayment(\n\tcompanyId: string,\n\tsuccess: boolean,\n\tamount: number,\n): Promise<void> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn;\n\t}\n\n\tconst { data: trustScore } = await supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!trustScore) {\n\t\treturn;\n\t}\n\n\t// Update metrics\n\tconst updates: any = {\n\t\ttotal_payments_count: (trustScore.total_payments_count || 0) + 1,\n\t\ttotal_payments_volume: (trustScore.total_payments_volume || 0) + amount,\n\t\tlast_calculated_at: new Date().toISOString(),\n\t};\n\n\tif (success) {\n\t\tupdates.successful_payments_count =\n\t\t\t(trustScore.successful_payments_count || 0) + 1;\n\t} else {\n\t\tupdates.failed_payments_count = (trustScore.failed_payments_count || 0) + 1;\n\t}\n\n\t// Update largest payment\n\tif (amount > (trustScore.largest_payment_amount || 0)) {\n\t\tupdates.largest_payment_amount = amount;\n\t}\n\n\t// Recalculate overall score\n\tconst totalPayments = updates.total_payments_count;\n\tconst successfulPayments =\n\t\tupdates.successful_payments_count ||\n\t\ttrustScore.successful_payments_count ||\n\t\t0;\n\tconst _failedPayments =\n\t\tupdates.failed_payments_count || trustScore.failed_payments_count || 0;\n\n\t// Success rate (0-100)\n\tconst successRate =\n\t\ttotalPayments > 0 ? (successfulPayments / totalPayments) * 100 : 50;\n\n\t// Volume factor (higher volume = higher trust, capped at 100)\n\tconst volumeFactor = Math.min(\n\t\t100,\n\t\tMath.log10((updates.total_payments_volume || 0) / 100 + 1) * 20,\n\t);\n\n\t// Account age factor (older accounts = higher trust)\n\tconst accountAgeDays = trustScore.account_age_days || 0;\n\tconst ageFactor = Math.min(100, (accountAgeDays / 30) * 10); // 100 points after 300 days\n\n\t// Calculate weighted overall score\n\tconst overallScore =\n\t\tsuccessRate * 0.4 + // 40% weight on success rate\n\t\tvolumeFactor * 0.3 + // 30% weight on volume\n\t\tageFactor * 0.2 + // 20% weight on account age\n\t\t(trustScore.business_verified ? 10 : 0) + // 10% for verification\n\t\t(trustScore.bank_account_verified ? 5 : 0) +\n\t\t(trustScore.identity_verified ? 5 : 0);\n\n\tupdates.overall_score = Math.min(100, Math.max(0, overallScore));\n\tupdates.refund_rate =\n\t\ttotalPayments > 0\n\t\t\t? ((trustScore.refunded_amount || 0) / updates.total_payments_volume) *\n\t\t\t\t100\n\t\t\t: 0;\n\n\tawait supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.update(updates)\n\t\t.eq(\"company_id\", companyId);\n}\n","/**\n * Company Domain Email Sender\n *\n * CRITICAL RULE - Reply-To Addresses:\n * ====================================\n * Reply-to ALWAYS uses the platform subdomain (mail.thorbis.com), regardless of:\n * - Which email provider is used (platform, custom domain, Gmail)\n * - What the FROM address is\n * - Whether they have a custom domain or not\n *\n * Examples:\n * - FROM: notifications@acme-plumbing.com (custom domain)\n *   REPLY-TO: support@acme-plumbing.mail.thorbis.com (platform subdomain)\n *\n * - FROM: john@gmail.com (personal Gmail)\n *   REPLY-TO: support@acme-plumbing.mail.thorbis.com (platform subdomain)\n *\n * - FROM: notifications@acme-plumbing.mail.thorbis.com (platform subdomain)\n *   REPLY-TO: support@acme-plumbing.mail.thorbis.com (same platform subdomain)\n *\n * Why?\n * - Centralizes all replies to one inbox per company\n * - Prevents replies going to custom domains or personal emails\n * - Each company controls their reply-to prefix (support@, help@, etc.)\n * - Stored in company_email_domains.reply_to_email\n */\n\nimport { Resend } from \"resend\";\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\ntype CompanyDomain = {\n\tid: string;\n\tdomain_name: string;\n\tsubdomain: string; // REQUIRED: Always use subdomain to prevent SPF conflicts\n\tfull_domain: string;\n\tstatus: string;\n\tsending_addresses: Array<{\n\t\ttype: string;\n\t\temail: string;\n\t}>;\n\treply_to_email: string | null;\n};\n\ntype EmailType =\n\t| \"invoice\"\n\t| \"estimate\"\n\t| \"reminder\"\n\t| \"notification\"\n\t| \"marketing\"\n\t| \"general\";\n\n/**\n * Get the verified email domain for a company\n * Returns null if no domain is verified\n */\nasync function getCompanyVerifiedDomain(\n\tcompanyId: string,\n): Promise<CompanyDomain | null> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\tconst { data: domain } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"verified\")\n\t\t.eq(\"sending_enabled\", true)\n\t\t.eq(\"is_suspended\", false)\n\t\t.order(\"is_platform_subdomain\", { ascending: true }) // Prefer custom domains for FROM\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.maybeSingle();\n\n\tif (!domain) {\n\t\treturn null;\n\t}\n\n\t// Construct full domain (subdomain is always required)\n\tconst fullDomain = `${domain.subdomain}.${domain.domain_name}`;\n\n\treturn {\n\t\tid: domain.id,\n\t\tdomain_name: domain.domain_name,\n\t\tsubdomain: domain.subdomain,\n\t\tfull_domain: fullDomain,\n\t\tstatus: domain.status,\n\t\tsending_addresses: domain.sending_addresses || [],\n\t\treply_to_email: domain.reply_to_email,\n\t};\n}\n\n/**\n * Get the company's platform subdomain for reply-to\n * Reply-to ALWAYS uses the platform subdomain (mail.thorbis.com)\n * This ensures replies are isolated per company, never using custom domains\n */\nasync function getCompanyPlatformReplyTo(\n\tcompanyId: string,\n): Promise<string | null> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\t// Get the platform subdomain for this company\n\tconst { data: platformDomain } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"domain_name, reply_to_email\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"is_platform_subdomain\", true)\n\t\t.eq(\"status\", \"verified\")\n\t\t.maybeSingle();\n\n\tif (!platformDomain) {\n\t\treturn null;\n\t}\n\n\t// Use configured reply-to if set, otherwise default to support@\n\tif (platformDomain.reply_to_email) {\n\t\treturn platformDomain.reply_to_email;\n\t}\n\n\t// Default: support@{company}.mail.thorbis.com\n\treturn `support@${platformDomain.domain_name}`;\n}\n\n/**\n * Get the appropriate sending address for a specific email type\n */\nfunction getSendingAddress(\n\tdomain: CompanyDomain,\n\ttype: EmailType,\n\tcompanyName: string,\n): string {\n\t// Check if company has custom sending addresses configured\n\tconst customAddress = domain.sending_addresses.find(\n\t\t(addr) => addr.type === type,\n\t);\n\n\tif (customAddress) {\n\t\treturn `${companyName} <${customAddress.email}>`;\n\t}\n\n\t// Default sending addresses based on type\n\tconst defaultEmail = `${type}@${domain.full_domain}`;\n\treturn `${companyName} <${defaultEmail}>`;\n}\n\n/**\n * Send email using company's verified domain\n * This is the PRIMARY function for ALL email sending in the platform\n */\nexport async function sendCompanyEmail({\n\tcompanyId,\n\tcompanyName,\n\ttype = \"notification\",\n\tto,\n\tsubject,\n\thtml,\n\ttext,\n\treplyTo,\n\tattachments,\n\tcommunicationId,\n}: {\n\tcompanyId: string;\n\tcompanyName: string;\n\ttype?: EmailType;\n\tto: string | string[];\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\treplyTo?: string;\n\tattachments?: Array<{\n\t\tfilename: string;\n\t\tcontent: string;\n\t}>;\n\tcommunicationId?: string;\n}) {\n\t// 1. Get company's verified domain (for FROM address)\n\tconst domain = await getCompanyVerifiedDomain(companyId);\n\n\tif (!domain) {\n\t\tthrow new Error(\n\t\t\t`Company domain not verified. Please verify your email domain in settings before sending emails.`,\n\t\t);\n\t}\n\n\t// 2. Get appropriate sending address\n\tconst fromAddress = getSendingAddress(domain, type, companyName);\n\n\t// 3. Get reply-to from platform subdomain (NEVER custom domain)\n\t// Reply-to ALWAYS uses mail.thorbis.com, even when FROM uses a custom domain\n\t// This ensures all replies are centralized to the company's platform subdomain\n\tconst platformReplyTo = await getCompanyPlatformReplyTo(companyId);\n\tconst replyToAddress = replyTo || platformReplyTo || `support@${domain.full_domain}`;\n\n\t// 4. Add email tracking if communicationId is provided\n\tlet trackedHtml = html;\n\tif (communicationId) {\n\t\tconst { addEmailTracking } = await import(\"./email-tracking\");\n\t\ttrackedHtml = addEmailTracking(html, communicationId);\n\t}\n\n\t// 5. Send email via Resend\n\ttry {\n\t\tconst { data, error } = await resend.emails.send({\n\t\t\tfrom: fromAddress,\n\t\t\tto,\n\t\t\tsubject,\n\t\t\thtml: trackedHtml,\n\t\t\ttext,\n\t\t\treplyTo: replyToAddress,\n\t\t\tattachments,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new Error(`Failed to send email: ${error.message}`);\n\t\t}\n\n\t\treturn { success: true, messageId: data?.id };\n\t} catch (error) {\n\t\tconsole.error(\"Email send error:\", error);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Check if company can send emails (has verified domain)\n */\nasync function canCompanySendEmail(companyId: string): Promise<boolean> {\n\tconst domain = await getCompanyVerifiedDomain(companyId);\n\treturn domain !== null && domain.status === \"verified\";\n}\n\n/**\n * Get company's email sending status and instructions\n */\nasync function getCompanyEmailStatus(companyId: string): Promise<{\n\tcanSend: boolean;\n\tdomain?: CompanyDomain;\n\tmessage: string;\n}> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tif (!supabase) {\n\t\treturn {\n\t\t\tcanSend: false,\n\t\t\tmessage: \"Database connection failed\",\n\t\t};\n\t}\n\n\tconst { data: domain } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!domain) {\n\t\treturn {\n\t\t\tcanSend: false,\n\t\t\tmessage:\n\t\t\t\t\"No email domain configured. Please add and verify your email domain in Settings â†’ Email Domain.\",\n\t\t};\n\t}\n\n\t// Subdomain is always required\n\tconst fullDomain = `${domain.subdomain}.${domain.domain_name}`;\n\n\tif (domain.status === \"verified\") {\n\t\treturn {\n\t\t\tcanSend: true,\n\t\t\tdomain: {\n\t\t\t\tid: domain.id,\n\t\t\t\tdomain_name: domain.domain_name,\n\t\t\t\tsubdomain: domain.subdomain,\n\t\t\t\tfull_domain: fullDomain,\n\t\t\t\tstatus: domain.status,\n\t\t\t\tsending_addresses: domain.sending_addresses || [],\n\t\t\t\treply_to_email: domain.reply_to_email,\n\t\t\t},\n\t\t\tmessage: `Ready to send from ${fullDomain}`,\n\t\t};\n\t}\n\n\tif (domain.status === \"pending\" || domain.status === \"verifying\") {\n\t\treturn {\n\t\t\tcanSend: false,\n\t\t\tdomain: {\n\t\t\t\tid: domain.id,\n\t\t\t\tdomain_name: domain.domain_name,\n\t\t\t\tsubdomain: domain.subdomain,\n\t\t\t\tfull_domain: fullDomain,\n\t\t\t\tstatus: domain.status,\n\t\t\t\tsending_addresses: domain.sending_addresses || [],\n\t\t\t\treply_to_email: domain.reply_to_email,\n\t\t\t},\n\t\t\tmessage: `Email domain ${fullDomain} is pending verification. Please add the required DNS records to verify.`,\n\t\t};\n\t}\n\n\treturn {\n\t\tcanSend: false,\n\t\tdomain: {\n\t\t\tid: domain.id,\n\t\t\tdomain_name: domain.domain_name,\n\t\t\tsubdomain: domain.subdomain,\n\t\t\tfull_domain: fullDomain,\n\t\t\tstatus: domain.status,\n\t\t\tsending_addresses: domain.sending_addresses || [],\n\t\t\treply_to_email: domain.reply_to_email,\n\t\t},\n\t\tmessage: `Email domain verification failed. Please check your DNS records or contact support.`,\n\t};\n}\n","/**\n * Email Router - Determines which email system to use\n *\n * Two email systems:\n * 1. Thorbis Platform Emails - System notifications, auth, team invites\n * 2. Company Branded Emails - Customer communications, invoices, estimates\n *\n * This router ensures emails use the correct sender and branding.\n */\n\"use server\";\n\nimport { render } from \"@react-email/components\";\nimport type { ReactElement } from \"react\";\nimport { sendCompanyEmail } from \"./company-domain-sender\";\nimport { sendEmail } from \"./email-sender\";\nimport type { EmailTemplate } from \"./email-types\";\n\n// Platform email options (Thorbis branding)\ntype PlatformEmailOptions = {\n\tcategory: \"platform\";\n\tto: string | string[];\n\tsubject: string;\n\ttemplate: ReactElement;\n\ttemplateType: EmailTemplate;\n\treplyTo?: string;\n\ttags?: { name: string; value: string }[];\n};\n\n// Company email options (Company branding)\ntype CompanyEmailOptions = {\n\tcategory: \"company\";\n\tcompanyId: string;\n\tcompanyName: string;\n\tto: string | string[];\n\tsubject: string;\n\ttemplate: ReactElement;\n\ttemplateType: EmailTemplate;\n\temailType?:\n\t\t| \"invoice\"\n\t\t| \"estimate\"\n\t\t| \"reminder\"\n\t\t| \"notification\"\n\t\t| \"marketing\"\n\t\t| \"general\";\n\treplyTo?: string;\n\ttags?: { name: string; value: string }[];\n\tcommunicationId?: string;\n};\n\ntype EmailOptions = PlatformEmailOptions | CompanyEmailOptions;\n\n/**\n * Smart email router - Automatically uses correct email system\n *\n * Usage:\n * ```typescript\n * // Platform email (Thorbis)\n * await routeEmail({\n *   category: \"platform\",\n *   to: \"user@example.com\",\n *   subject: \"Welcome to Thorbis\",\n *   template: <WelcomeEmail />,\n *   templateType: \"auth-welcome\"\n * });\n *\n * // Company email (Branded)\n * await routeEmail({\n *   category: \"company\",\n *   companyId: \"xxx\",\n *   companyName: \"ACME Plumbing\",\n *   to: \"customer@example.com\",\n *   subject: \"Invoice #1234\",\n *   template: <InvoiceEmail />,\n *   templateType: \"customer-invoice\",\n *   emailType: \"invoice\"\n * });\n * ```\n */\nasync function routeEmail(options: EmailOptions) {\n\tif (options.category === \"platform\") {\n\t\t// Use Thorbis platform email system\n\t\treturn await sendEmail({\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\ttemplate: options.template,\n\t\t\ttemplateType: options.templateType,\n\t\t\treplyTo: options.replyTo,\n\t\t\ttags: options.tags,\n\t\t\tfromOverride: \"Thorbis <noreply@thorbis.com>\", // Always use Thorbis domain\n\t\t});\n\t} else {\n\t\t// Use company branded email system\n\t\tconst html = await render(options.template);\n\n\t\treturn await sendCompanyEmail({\n\t\t\tcompanyId: options.companyId,\n\t\t\tcompanyName: options.companyName,\n\t\t\ttype: options.emailType || \"notification\",\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml,\n\t\t\treplyTo: options.replyTo,\n\t\t\tcommunicationId: options.communicationId,\n\t\t});\n\t}\n}\n\n/**\n * Helper: Send platform email (Thorbis branding)\n */\nexport async function sendPlatformEmail(\n\toptions: Omit<PlatformEmailOptions, \"category\">,\n) {\n\treturn routeEmail({ ...options, category: \"platform\" });\n}\n\n/**\n * Helper: Send company email (Company branding)\n */\nexport async function sendCompanyBrandedEmail(\n\toptions: Omit<CompanyEmailOptions, \"category\">,\n) {\n\treturn routeEmail({ ...options, category: \"company\" });\n}\n","/**\n * Process Invoice Payment Server Action\n *\n * Handles payment processing for invoices through the payment portal\n *\n * Features:\n * - Token validation\n * - Payment processing via company's processor\n * - Invoice status update\n * - Payment confirmation email\n * - Transaction logging\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { sendCompanyBrandedEmail } from \"@/lib/email/email-router\";\nimport { EmailTemplate } from \"@/lib/email/email-types\";\nimport {\n\tmarkTokenAsUsed,\n\tvalidatePaymentToken,\n} from \"@/lib/payments/payment-tokens\";\nimport {\n\tgetPaymentProcessor,\n\tupdateTrustScoreAfterPayment,\n} from \"@/lib/payments/processor\";\nimport type { PaymentChannel } from \"@/lib/payments/processor-types\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype PaymentResult = {\n\tsuccess: boolean;\n\terror?: string;\n\ttransactionId?: string;\n};\n\ntype ProcessPaymentParams = {\n\tinvoiceId: string;\n\ttoken: string;\n\tpaymentMethod: \"card\" | \"ach\";\n\tamount: number;\n\tpaymentDetails: {\n\t\tcardNumber?: string;\n\t\tcardExpiry?: string;\n\t\tcardCvc?: string;\n\t\tcardName?: string;\n\t\taccountNumber?: string;\n\t\troutingNumber?: string;\n\t\taccountName?: string;\n\t};\n};\n\nexport async function processInvoicePayment(\n\tparams: ProcessPaymentParams,\n): Promise<PaymentResult> {\n\ttry {\n\t\tconst {\n\t\t\tinvoiceId,\n\t\t\ttoken,\n\t\t\tpaymentMethod,\n\t\t\tamount,\n\t\t\tpaymentDetails: _paymentDetails,\n\t\t} = params;\n\n\t\t// Validate token\n\t\tconst validation = await validatePaymentToken(token);\n\n\t\tif (!validation.isValid || validation.invoiceId !== invoiceId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: validation.message || \"Invalid payment token\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to connect to database\",\n\t\t\t};\n\t\t}\n\n\t\t// Fetch invoice with customer and company details\n\t\tconst { data: invoice, error: invoiceError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        customer:customers!customer_id(\n          id,\n          first_name,\n          last_name,\n          display_name,\n          email\n        ),\n        company:companies!company_id(\n          id,\n          name,\n          email\n        )\n      `,\n\t\t\t)\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tif (invoiceError || !invoice) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Invoice not found\",\n\t\t\t};\n\t\t}\n\n\t\t// Check if invoice is already paid\n\t\tif (invoice.status === \"paid\") {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Invoice has already been paid\",\n\t\t\t};\n\t\t}\n\n\t\t// Verify amount matches\n\t\tif (amount !== invoice.total_amount) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Payment amount does not match invoice total\",\n\t\t\t};\n\t\t}\n\n\t\t// Get company's payment processor\n\t\tconst channel: PaymentChannel =\n\t\t\tpaymentMethod === \"card\" ? \"online\" : \"ach\";\n\n\t\tconst processor = await getPaymentProcessor(invoice.company_id, {\n\t\t\tamount,\n\t\t\tchannel,\n\t\t});\n\n\t\tlet transactionId: string;\n\t\tlet processorResponse: any;\n\n\t\tif (!processor) {\n\t\t\t// No processor configured - check if development mode for testing\n\t\t\tconst isDevelopment = process.env.NODE_ENV === \"development\";\n\n\t\t\tif (isDevelopment) {\n\t\t\t\t// Development mode - simulate payment\n\t\t\t\ttransactionId = `dev_txn_${Date.now()}`;\n\t\t\t\tprocessorResponse = {\n\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\tmessage: \"Development mode - payment simulated (no processor configured)\",\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror:\n\t\t\t\t\t\t\"Payment processing is not configured for this company. Please contact the service provider.\",\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\t// Process payment through the configured processor\n\t\t\tconst customer = Array.isArray(invoice.customer)\n\t\t\t\t? invoice.customer[0]\n\t\t\t\t: invoice.customer;\n\n\t\t\tconst paymentResponse = await processor.processPayment({\n\t\t\t\tamount,\n\t\t\t\tcurrency: \"USD\",\n\t\t\t\tinvoiceId,\n\t\t\t\tcustomerId: customer?.id || invoice.customer_id,\n\t\t\t\tchannel,\n\t\t\t\tmetadata: {\n\t\t\t\t\tinvoice_number: invoice.invoice_number,\n\t\t\t\t\tpayment_method: paymentMethod,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!paymentResponse.success) {\n\t\t\t\t// Update trust score on failure\n\t\t\t\tawait updateTrustScoreAfterPayment(invoice.company_id, false, amount);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror:\n\t\t\t\t\t\tpaymentResponse.error ||\n\t\t\t\t\t\tpaymentResponse.failureMessage ||\n\t\t\t\t\t\t\"Payment processing failed\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle requires_action (3D Secure, additional auth)\n\t\t\tif (paymentResponse.status === \"requires_action\") {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror:\n\t\t\t\t\t\t\"Additional authentication required. Please contact support for assistance.\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttransactionId = paymentResponse.transactionId || `txn_${Date.now()}`;\n\t\t\tprocessorResponse = paymentResponse.processorMetadata;\n\n\t\t\t// Update trust score on success\n\t\t\tawait updateTrustScoreAfterPayment(invoice.company_id, true, amount);\n\t\t}\n\n\t\t// Update invoice status to paid\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tstatus: \"paid\",\n\t\t\t\tpaid_at: new Date().toISOString(),\n\t\t\t\tpayment_method: paymentMethod,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Payment processed but failed to update invoice. Please contact support.\",\n\t\t\t};\n\t\t}\n\n\t\t// Log payment transaction\n\t\tawait supabase.from(\"payment_processor_transactions\").insert({\n\t\t\tcompany_id: invoice.company_id,\n\t\t\tinvoice_id: invoiceId,\n\t\t\tprocessor_type: processor ? (paymentMethod === \"card\" ? \"adyen\" : \"adyen\") : \"manual\",\n\t\t\ttransaction_id: transactionId,\n\t\t\tamount,\n\t\t\tcurrency: \"USD\",\n\t\t\tstatus: \"success\",\n\t\t\tchannel,\n\t\t\tmetadata: {\n\t\t\t\tpayment_method: paymentMethod,\n\t\t\t\tprocessor_response: processorResponse,\n\t\t\t\tsimulated: !processor,\n\t\t\t},\n\t\t});\n\n\t\t// Mark token as used\n\t\tawait markTokenAsUsed(token);\n\n\t\t// Send payment confirmation email to customer\n\t\tconst customer = Array.isArray(invoice.customer)\n\t\t\t? invoice.customer[0]\n\t\t\t: invoice.customer;\n\t\tconst company = Array.isArray(invoice.company)\n\t\t\t? invoice.company[0]\n\t\t\t: invoice.company;\n\n\t\tif (customer?.email && company) {\n\t\t\ttry {\n\t\t\t\t// Import the payment received template\n\t\t\t\tconst PaymentReceivedEmail = (\n\t\t\t\t\tawait import(\"../../../emails/templates/billing/payment-received\")\n\t\t\t\t).default;\n\n\t\t\t\t// Format payment details\n\t\t\t\tconst customerName =\n\t\t\t\t\tcustomer.display_name ||\n\t\t\t\t\t`${customer.first_name} ${customer.last_name}`.trim() ||\n\t\t\t\t\t\"Customer\";\n\t\t\t\tconst paymentAmountFormatted = `$${(amount / 100).toFixed(2)}`;\n\t\t\t\tconst paymentMethodFormatted =\n\t\t\t\t\tpaymentMethod === \"card\" ? \"Credit Card\" : \"ACH Bank Transfer\";\n\t\t\t\tconst paymentDateFormatted = new Date().toLocaleDateString(\"en-US\", {\n\t\t\t\t\tyear: \"numeric\",\n\t\t\t\t\tmonth: \"long\",\n\t\t\t\t\tday: \"numeric\",\n\t\t\t\t});\n\n\t\t\t\tawait sendCompanyBrandedEmail({\n\t\t\t\t\tcompanyId: company.id,\n\t\t\t\t\tcompanyName: company.name,\n\t\t\t\t\tto: customer.email,\n\t\t\t\t\tsubject: `Payment Received - Invoice ${invoice.invoice_number}`,\n\t\t\t\t\ttemplate: PaymentReceivedEmail({\n\t\t\t\t\t\tcustomerName,\n\t\t\t\t\t\tinvoiceNumber: invoice.invoice_number,\n\t\t\t\t\t\tpaymentAmount: paymentAmountFormatted,\n\t\t\t\t\t\tpaymentMethod: paymentMethodFormatted,\n\t\t\t\t\t\tpaymentDate: paymentDateFormatted,\n\t\t\t\t\t\treceiptUrl: `${process.env.NEXT_PUBLIC_APP_URL}/portal/invoices/${invoiceId}/receipt?token=${token}`,\n\t\t\t\t\t\tcompany: {\n\t\t\t\t\t\t\tcompanyName: company.name,\n\t\t\t\t\t\t\tsupportEmail: company.email,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\ttemplateType: EmailTemplate.PAYMENT_RECEIVED,\n\t\t\t\t\temailType: \"notification\",\n\t\t\t\t\ttags: [\n\t\t\t\t\t\t{ name: \"invoice_id\", value: invoiceId },\n\t\t\t\t\t\t{ name: \"transaction_id\", value: transactionId },\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t} catch (_emailError) {\n\t\t\t\t// Don't fail the payment if email fails\n\t\t\t\tconsole.error(\n\t\t\t\t\t\"Failed to send payment confirmation email:\",\n\t\t\t\t\t_emailError,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Revalidate invoice pages\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\ttransactionId,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Payment processing failed\",\n\t\t};\n\t}\n}\n","export {getCurrentUserRole as '001f005176797ef23488068124fb9a744915a477de'} from 'ACTIONS_MODULE0'\nexport {canDeleteTeamMember as '406f6624261c6dd1a908026fa1408a3f6d507b6e7d'} from 'ACTIONS_MODULE0'\nexport {processInvoicePayment as '4077d2f57527e7371b466b60fd322576f930d6cd64'} from 'ACTIONS_MODULE1'\nexport {markTokenAsUsed as '6048aff7615b24bbed5fff047d510e54bb65e77646'} from 'ACTIONS_MODULE2'\nexport {validatePaymentToken as '608ae817ddec034f2780624908f1db97356ccd42ef'} from 'ACTIONS_MODULE2'\nexport {generatePaymentToken as '7026bc9768ad3ab0b96efecd8a3b9c44d5e7e57eba'} from 'ACTIONS_MODULE2'\nexport {generatePaymentTokensBatch as '709bb1978cd77dad33a458251234f8c68f743d5f4c'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":"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"}