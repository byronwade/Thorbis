{"version":3,"sources":["../../../../../../apps/web/src/lib/communication/sms-service.ts","../../../../../../apps/web/src/actions/sms-actions.ts","../../../../../../apps/web/src/actions/appointments.ts"],"sourcesContent":["/**\n * SMS Service\n * \n * Handles fetching and managing SMS messages from the communications table\n * Similar structure to email-service.ts but for SMS type communications\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type { TypedSupabaseClient } from \"@/types/supabase\";\n\nexport type CompanySms = {\n\tid: string;\n\tfrom_address: string | null;\n\tfrom_name: string | null;\n\tto_address: string | null;\n\tbody: string;\n\tbody_html: string | null;\n\tcreated_at: string;\n\tread_at: string | null;\n\tdirection: \"inbound\" | \"outbound\";\n\tcustomer_id: string | null;\n\tcustomer?: {\n\t\tid: string;\n\t\tfirst_name: string | null;\n\t\tlast_name: string | null;\n\t\tdisplay_name: string | null;\n\t\temail: string | null;\n\t\tphone: string | null;\n\t\tcompany_name: string | null;\n\t} | null;\n\tsent_at: string | null;\n\tdelivered_at: string | null;\n\tstatus: string;\n\tchannel: string | null;\n\tprovider_metadata: Record<string, unknown> | null;\n\tis_archived: boolean;\n\tsnoozed_until: string | null;\n\tcategory: string | null;\n\ttags: string[] | null;\n\ttelnyx_message_id: string | null;\n};\n\nexport type GetCompanySmsInput = {\n\tlimit?: number;\n\toffset?: number;\n\ttype?: \"sent\" | \"received\" | \"all\";\n\tfolder?: \"inbox\" | \"sent\" | \"archive\" | \"trash\" | \"bin\";\n\tlabel?: string;\n\tsearch?: string | null;\n\tsortBy?: \"created_at\" | \"sent_at\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\nexport type GetCompanySmsResult = {\n\tsms: CompanySms[];\n\ttotal: number;\n\thasMore: boolean;\n};\n\nexport async function getCompanySms(\n\tcompanyId: string,\n\tinput: GetCompanySmsInput = {},\n): Promise<GetCompanySmsResult> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tconst {\n\t\tlimit = 50,\n\t\toffset = 0,\n\t\ttype = \"all\",\n\t\tfolder,\n\t\tlabel,\n\t\tsearch,\n\t\tsortBy = \"created_at\",\n\t\tsortOrder = \"desc\",\n\t} = input;\n\n\t// Build the query - get all SMS messages\n\tlet query = supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t\t{ count: \"exact\" },\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\");\n\n\t// Apply folder filtering\n\tif (folder) {\n\t\tswitch (folder) {\n\t\t\tcase \"inbox\":\n\t\t\t\t// Inbox: inbound, not archived, not deleted, not snoozed (or snooze expired)\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"inbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.or(\"snoozed_until.is.null,snoozed_until.lt.now()\");\n\t\t\t\tbreak;\n\t\t\tcase \"sent\":\n\t\t\t\t// Sent: outbound, not archived, not deleted\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"outbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"archive\":\n\t\t\t\t// Archive: is_archived = true, not deleted\n\t\t\t\tquery = query.eq(\"is_archived\", true).is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"trash\":\n\t\t\tcase \"bin\":\n\t\t\t\t// Trash: deleted_at is not null\n\t\t\t\tquery = query.not(\"deleted_at\", \"is\", null);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Custom folder or label filtering - done in memory after fetch\n\t\t\t\t// (JSONB array containment not supported by PostgREST cs operator)\n\t\t\t\tquery = query.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t// Default: exclude deleted SMS\n\t\tquery = query.is(\"deleted_at\", null);\n\t}\n\n\t// Apply direction filter\n\tif (type === \"sent\") {\n\t\tquery = query.eq(\"direction\", \"outbound\");\n\t} else if (type === \"received\") {\n\t\tquery = query.eq(\"direction\", \"inbound\");\n\t}\n\n\t// Apply search filter\n\tif (search) {\n\t\tconst searchLower = search.toLowerCase();\n\t\tquery = query.or(\n\t\t\t`from_address.ilike.%${searchLower}%,to_address.ilike.%${searchLower}%,body.ilike.%${searchLower}%`,\n\t\t);\n\t}\n\n\t// Apply sorting\n\tconst ascending = sortOrder === \"asc\";\n\tif (sortBy === \"sent_at\") {\n\t\tquery = query.order(\"sent_at\", { ascending, nullsFirst: false });\n\t} else {\n\t\tquery = query.order(\"created_at\", { ascending });\n\t}\n\n\t// Apply pagination\n\tquery = query.range(offset, offset + limit - 1);\n\n\tconst { data, error, count } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS messages:\", error);\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tlet sms = (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n\n\t// Post-process custom folder/label filtering (JSONB array containment not supported by PostgREST)\n\tconst standardFolders = [\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"];\n\tconst folderName = label || folder;\n\tif (folderName && !standardFolders.includes(folderName)) {\n\t\tsms = sms.filter((msg) => {\n\t\t\tconst msgTags = msg.tags || [];\n\t\t\treturn Array.isArray(msgTags) && msgTags.includes(folderName);\n\t\t});\n\t\treturn {\n\t\t\tsms,\n\t\t\ttotal: sms.length,\n\t\t\thasMore: false,\n\t\t};\n\t}\n\n\tconst total = count || 0;\n\tconst hasMore = offset + sms.length < total;\n\n\treturn {\n\t\tsms,\n\t\ttotal,\n\t\thasMore,\n\t};\n}\n\nexport async function getSmsById(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<CompanySms | null> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\t...data,\n\t\ttags: (data.tags as string[]) || null,\n\t\tprovider_metadata: (data.provider_metadata as Record<string, unknown>) || null,\n\t} as CompanySms;\n}\n\nexport async function markSmsAsRead(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tconsole.error(\"❌ markSmsAsRead: Missing supabase\");\n\t\treturn false;\n\t}\n\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.select(\"id, read_at\")\n\t\t.single();\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tif (!data) {\n\t\tconsole.error(\"❌ markSmsAsRead: No data returned\");\n\t\treturn false;\n\t}\n\n\tconsole.log(\"✅ markSmsAsRead success:\", { smsId, read_at: data.read_at });\n\treturn true;\n}\n\n/**\n * Get all SMS messages for a conversation thread (by phone number)\n */\nexport async function getSmsConversation(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<CompanySms[]> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn [];\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Fetch all messages where this phone number is either from or to\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.order(\"created_at\", { ascending: true });\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS conversation:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsRead(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn false;\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Mark all unread inbound messages in this conversation as read\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.eq(\"direction\", \"inbound\")\n\t\t.is(\"read_at\", null)\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.select(\"id, read_at\");\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsConversationAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tconsole.log(`✅ markSmsConversationAsRead success: Marked ${data?.length || 0} messages as read`);\n\treturn true;\n}\n\n","\"use server\";\n\nimport {\n    getCompanySms,\n    getSmsById,\n    markSmsAsRead,\n    markSmsConversationAsRead,\n    type CompanySms,\n} from \"@/lib/communication/sms-service\";\nimport { z } from \"zod\";\n\nconst getSmsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  folder: z.enum([\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst markSmsReadSchema = z.object({\n  smsId: z.string().min(1),\n});\n\nexport type GetSmsInput = z.infer<typeof getSmsSchema>;\nexport type MarkSmsReadInput = z.infer<typeof markSmsReadSchema>;\n\n// Re-export SMS types from sms-service\nexport type { CompanySms };\n\nexport type GetSmsResult = Awaited<ReturnType<typeof getCompanySms>>;\n\n/**\n * Get SMS messages for the active company\n */\nexport async function getSmsAction(\n  input: GetSmsInput\n): Promise<GetSmsResult> {\n  try {\n    const parseResult = getSmsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      throw new Error(`Invalid input parameters: ${parseResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getCompanySms(companyId, validatedInput);\n  } catch (error) {\n    console.error(\"❌ getSmsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get a specific SMS by ID\n */\nexport async function getSmsByIdAction(smsId: string): Promise<{\n  success: boolean;\n  sms?: CompanySms;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const sms = await getSmsById(companyId, smsId);\n    \n    if (!sms) {\n      return { success: false, error: \"SMS not found\" };\n    }\n\n    return { success: true, sms };\n  } catch (error) {\n    console.error(\"Error getting SMS by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an SMS as read\n */\nexport async function markSmsAsReadAction(\n  input: MarkSmsReadInput\n): Promise<boolean> {\n  try {\n    const validatedInput = markSmsReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"Invalid input parameters\");\n    }\n\n    return await markSmsAsRead(companyId, validatedInput.smsId);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsReadAction(phoneNumber: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const success = await markSmsConversationAsRead(companyId, phoneNumber);\n    return { success };\n  } catch (error) {\n    console.error(\"Error marking SMS conversation as read:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS conversation thread by phone number\n */\nexport async function getSmsConversationAction(phoneNumber: string): Promise<{\n  success: boolean;\n  messages?: CompanySms[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getSmsConversation } = await import(\"@/lib/sms/sms-service\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const messages = await getSmsConversation(companyId, phoneNumber);\n    return { success: true, messages };\n  } catch (error) {\n    console.error(\"Error fetching SMS conversation:\", error);\n    // Handle cookies() error gracefully\n    if (error instanceof Error && error.message.includes(\"cookies\")) {\n      return {\n        success: false,\n        error: \"Request context not available. Please refresh the page.\",\n      };\n    }\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS folder counts\n */\nexport async function getSmsFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    inbox: number;\n    sent: number;\n    archive: number;\n    trash: number;\n    [label: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const baseQuery = supabase\n      .from(\"communications\")\n      .select(\"*\", { count: \"exact\", head: true })\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"sms\");\n    \n    // Get counts for each folder\n    const [inboxResult, sentResult, archiveResult, trashResult] = await Promise.all([\n      // Inbox\n      baseQuery\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n      // Sent\n      baseQuery\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null),\n      // Archive\n      baseQuery.eq(\"is_archived\", true).is(\"deleted_at\", null),\n      // Trash\n      baseQuery.not(\"deleted_at\", \"is\", null),\n    ]);\n    \n    const counts = {\n      inbox: inboxResult.count || 0,\n      sent: sentResult.count || 0,\n      archive: archiveResult.count || 0,\n      trash: trashResult.count || 0,\n    };\n    \n    return { success: true, counts };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Upload SMS attachments to storage\n */\nexport async function uploadSmsAttachments(\n  files: File[]\n): Promise<{\n  success: boolean;\n  urls?: string[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const supabase = await createClient();\n    \n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const urls: string[] = [];\n    \n      // Upload each file to Supabase Storage\n      // Use company-files bucket which has proper RLS policies for company members\n      for (const file of files) {\n        const fileExt = file.name.split('.').pop();\n        const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;\n        // Path structure: companyId must be at index [0] for RLS policy (matches document-manager pattern)\n        // Format: companyId/folder/filename (storage.foldername(name))[0] = companyId\n        const filePath = `${companyId}/sms-attachments/${fileName}`;\n        \n        // Convert file to array buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const { data, error: uploadError } = await supabase.storage\n          .from('company-files') // Use company-files bucket with proper RLS\n          .upload(filePath, arrayBuffer, {\n            contentType: file.type,\n            upsert: false,\n          });\n        \n        if (uploadError) {\n          console.error(\"Upload error:\", uploadError);\n          return { success: false, error: `Failed to upload ${file.name}: ${uploadError.message}` };\n        }\n        \n        // Get public URL (or signed URL for private bucket)\n        const { data: { publicUrl } } = supabase.storage\n          .from('company-files')\n          .getPublicUrl(filePath);\n        \n        urls.push(publicUrl);\n      }\n    \n    return { success: true, urls };\n  } catch (error) {\n    console.error(\"Error uploading SMS attachments:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * SMS Template Context Type\n * Data available for auto-filling SMS templates\n */\nexport type SmsTemplateContext = {\n  companyName?: string;\n  companyPhone?: string;\n  companyEmail?: string;\n};\n\n/**\n * Get company context for SMS templates\n * Returns company info for auto-filling template messages\n */\nexport async function getCompanyContextAction(): Promise<{\n  success: boolean;\n  context?: SmsTemplateContext;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { getActiveCompany } = await import(\"@/lib/auth/company-context\");\n\n    const company = await getActiveCompany();\n    if (!company) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    return {\n      success: true,\n      context: {\n        companyName: company.name,\n        companyPhone: company.phone || undefined,\n        companyEmail: company.email || undefined,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting company context:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n","/**\n * Appointments Server Actions\n *\n * Handles appointment scheduling and management with comprehensive CRUD operations,\n * status transitions, reminders, and team assignment logic.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { ActionError, ERROR_CODES } from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nconst APPOINTMENT_NUMBER_REGEX = /APT-(\\d+)/;\nconst APPOINTMENT_NUMBER_LENGTH = 6;\nconst MILLISECONDS_PER_MINUTE = 60_000;\nconst DEFAULT_SEARCH_LIMIT = 50;\nconst DEFAULT_SEARCH_OFFSET = 0;\n\nconst getSupabaseServerClient = async (): Promise<SupabaseServerClient> => {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\treturn supabase as SupabaseServerClient;\n};\n\n// Validation Schemas\nconst createAppointmentSchema = z.object({\n\tcustomerId: z.string().uuid(\"Invalid customer ID\"),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional(),\n\tjobId: z.string().uuid(\"Invalid job ID\").optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional(),\n\ttitle: z.string().min(1, \"Appointment title is required\"),\n\tdescription: z.string().optional(),\n\tcategory: z\n\t\t.enum([\n\t\t\t\"job_appointment\",\n\t\t\t\"estimate_appointment\",\n\t\t\t\"event\",\n\t\t\t\"meeting\",\n\t\t\t\"follow_up\",\n\t\t\t\"recurring_service\",\n\t\t])\n\t\t.default(\"job_appointment\"),\n\ttype: z\n\t\t.enum([\n\t\t\t\"service_call\",\n\t\t\t\"installation\",\n\t\t\t\"maintenance\",\n\t\t\t\"inspection\",\n\t\t\t\"repair\",\n\t\t\t\"estimate\",\n\t\t\t\"follow_up\",\n\t\t\t\"winterization\",\n\t\t\t\"emergency\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]).default(\"normal\"),\n\tscheduledStart: z.string().min(1, \"Start time is required\"),\n\tscheduledEnd: z.string().min(1, \"End time is required\"),\n\tnotes: z.string().optional(),\n\ttravelTimeMinutes: z.number().int().min(0).optional(),\n});\n\nconst updateAppointmentSchema = z.object({\n\ttitle: z.string().min(1, \"Appointment title is required\").optional(),\n\tdescription: z.string().optional(),\n\tstatus: z\n\t\t.enum([\n\t\t\t\"scheduled\",\n\t\t\t\"confirmed\",\n\t\t\t\"in_progress\",\n\t\t\t\"completed\",\n\t\t\t\"cancelled\",\n\t\t\t\"no_show\",\n\t\t\t\"rescheduled\",\n\t\t])\n\t\t.optional(),\n\ttype: z\n\t\t.enum([\n\t\t\t\"service\",\n\t\t\t\"consultation\",\n\t\t\t\"estimate\",\n\t\t\t\"follow_up\",\n\t\t\t\"maintenance\",\n\t\t\t\"emergency\",\n\t\t\t\"inspection\",\n\t\t])\n\t\t.optional(),\n\tpriority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]).optional(),\n\tscheduledStart: z.string().optional(),\n\tscheduledEnd: z.string().optional(),\n\tactualStart: z.string().optional(),\n\tactualEnd: z.string().optional(),\n\tassignedTo: z.string().uuid(\"Invalid user ID\").optional().nullable(),\n\tnotes: z.string().optional(),\n\tcancellationReason: z.string().optional(),\n});\n\nconst rescheduleAppointmentSchema = z.object({\n\tscheduledStart: z.string().min(1, \"Start time is required\"),\n\tscheduledEnd: z.string().min(1, \"End time is required\"),\n\treason: z.string().optional(),\n});\n\n/**\n * Generate unique appointment number using database function\n */\nasync function generateAppointmentNumber(\n\tsupabase: SupabaseServerClient,\n\tcompanyId: string,\n): Promise<string> {\n\tconst { data, error } = await supabase.rpc(\"generate_appointment_number\", {\n\t\tp_company_id: companyId,\n\t});\n\n\tif (error || !data) {\n\t\t// Fallback to manual generation\n\t\tconst { data: latestAppointment } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"appointment_number\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tif (!latestAppointment) {\n\t\t\treturn \"APT-000001\";\n\t\t}\n\n\t\tconst match = latestAppointment.appointment_number.match(\n\t\t\tAPPOINTMENT_NUMBER_REGEX,\n\t\t);\n\t\tif (match) {\n\t\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\t\treturn `APT-${nextNumber.toString().padStart(APPOINTMENT_NUMBER_LENGTH, \"0\")}`;\n\t\t}\n\n\t\treturn `APT-${Date.now().toString().slice(-APPOINTMENT_NUMBER_LENGTH)}`;\n\t}\n\n\treturn data;\n}\n\n/**\n * Calculate duration in minutes between two dates\n */\nfunction calculateDuration(start: string, end: string): number {\n\tconst startDate = new Date(start);\n\tconst endDate = new Date(end);\n\treturn Math.round(\n\t\t(endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_MINUTE,\n\t);\n}\n\n/**\n * Validate appointment times\n */\nfunction validateAppointmentTimes(start: string, end: string): void {\n\tconst startDate = new Date(start);\n\tconst endDate = new Date(end);\n\n\tif (endDate <= startDate) {\n\t\tthrow new ActionError(\n\t\t\t\"End time must be after start time\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n\n\tif (startDate < new Date()) {\n\t\tthrow new ActionError(\n\t\t\t\"Cannot schedule appointments in the past\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nconst extractFormValues = (\n\tformData: FormData,\n\tfields: string[],\n): Record<string, unknown> => {\n\tconst result: Record<string, unknown> = {};\n\tfor (const field of fields) {\n\t\tconst value = formData.get(field);\n\t\tif (value !== null && value !== undefined && value !== \"\") {\n\t\t\tresult[field] = value;\n\t\t}\n\t}\n\treturn result;\n};\n\nconst buildUpdatePayload = (\n\tdata: z.infer<typeof updateAppointmentSchema>,\n\tduration?: number,\n): Record<string, unknown> => {\n\tconst updateData: Record<string, unknown> = { ...data };\n\tif (duration) {\n\t\tupdateData.duration_minutes = duration;\n\t}\n\n\tif (data.actualStart && data.actualEnd) {\n\t\tupdateData.actual_duration_minutes = calculateDuration(\n\t\t\tdata.actualStart,\n\t\t\tdata.actualEnd,\n\t\t);\n\t}\n\n\treturn updateData;\n};\n\nconst toSnakeCaseRecord = (data: Record<string, unknown>) => {\n\tconst result: Record<string, unknown> = {};\n\tfor (const [key, value] of Object.entries(data)) {\n\t\tconst snakeKey = key.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n\t\tresult[snakeKey] = value;\n\t}\n\treturn result;\n};\n\n/**\n * Create a new appointment\n */\nexport async function createAppointment(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\tcustomerId: formData.get(\"customerId\") as string,\n\t\t\tpropertyId: (formData.get(\"propertyId\") as string) || undefined,\n\t\t\tjobId: (formData.get(\"jobId\") as string) || undefined,\n\t\t\tassignedTo: (formData.get(\"assignedTo\") as string) || undefined,\n\t\t\ttitle: formData.get(\"title\") as string,\n\t\t\tdescription: (formData.get(\"description\") as string) || undefined,\n\t\t\tcategory: (formData.get(\"category\") as string) || \"job_appointment\",\n\t\t\ttype: (formData.get(\"type\") as string) || undefined,\n\t\t\tpriority: (formData.get(\"priority\") as string) || \"normal\",\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") as string,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") as string,\n\t\t\tnotes: (formData.get(\"notes\") as string) || undefined,\n\t\t\ttravelTimeMinutes: formData.get(\"travelTimeMinutes\")\n\t\t\t\t? Number.parseInt(formData.get(\"travelTimeMinutes\") as string, 10)\n\t\t\t\t: undefined,\n\t\t};\n\n\t\tconst validatedData = createAppointmentSchema.parse(rawData);\n\n\t\t// Validate appointment times\n\t\tvalidateAppointmentTimes(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Calculate duration\n\t\tconst duration = calculateDuration(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Generate appointment number\n\t\tconst appointmentNumber = await generateAppointmentNumber(\n\t\t\tsupabase,\n\t\t\tcompanyId,\n\t\t);\n\n\t\t// Create appointment\n\t\tconst { data: appointment, error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tcustomer_id: validatedData.customerId,\n\t\t\t\tproperty_id: validatedData.propertyId,\n\t\t\t\tjob_id: validatedData.jobId,\n\t\t\t\tassigned_to: validatedData.assignedTo,\n\t\t\t\tappointment_number: appointmentNumber,\n\t\t\t\ttitle: validatedData.title,\n\t\t\t\tdescription: validatedData.description,\n\t\t\t\tcategory: validatedData.category,\n\t\t\t\ttype: validatedData.type,\n\t\t\t\tpriority: validatedData.priority,\n\t\t\t\tscheduled_start: validatedData.scheduledStart,\n\t\t\t\tscheduled_end: validatedData.scheduledEnd,\n\t\t\t\tduration_minutes: duration,\n\t\t\t\tnotes: validatedData.notes,\n\t\t\t\ttravel_time_minutes: validatedData.travelTimeMinutes,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tcreated_by: user.id,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to create appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\tif (validatedData.jobId) {\n\t\t\trevalidatePath(`/dashboard/work/${validatedData.jobId}`);\n\t\t}\n\n\t\treturn appointment.id;\n\t});\n}\n\n/**\n * Update an existing appointment\n */\nasync function updateAppointment(\n\tappointmentId: string,\n\tformData: FormData,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Verify appointment exists and belongs to company\n\t\tconst { data: existingAppointment, error: fetchError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, company_id, status, scheduled_start, scheduled_end, job_id\")\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !existingAppointment) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Appointment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\t// Parse and validate form data\n\t\tconst rawData = extractFormValues(formData, [\n\t\t\t\"title\",\n\t\t\t\"description\",\n\t\t\t\"status\",\n\t\t\t\"type\",\n\t\t\t\"priority\",\n\t\t\t\"scheduledStart\",\n\t\t\t\"scheduledEnd\",\n\t\t\t\"actualStart\",\n\t\t\t\"actualEnd\",\n\t\t\t\"assignedTo\",\n\t\t\t\"notes\",\n\t\t\t\"cancellationReason\",\n\t\t]);\n\n\t\tconst validatedData = updateAppointmentSchema.parse(rawData);\n\n\t\t// Validate times if both are provided\n\t\tif (validatedData.scheduledStart && validatedData.scheduledEnd) {\n\t\t\tvalidateAppointmentTimes(\n\t\t\t\tvalidatedData.scheduledStart,\n\t\t\t\tvalidatedData.scheduledEnd,\n\t\t\t);\n\t\t}\n\n\t\t// Calculate new duration if times changed\n\t\tlet duration: number | undefined;\n\t\tif (validatedData.scheduledStart && validatedData.scheduledEnd) {\n\t\t\tduration = calculateDuration(\n\t\t\t\tvalidatedData.scheduledStart,\n\t\t\t\tvalidatedData.scheduledEnd,\n\t\t\t);\n\t\t}\n\n\t\t// Build update object\n\t\tconst updateData = buildUpdatePayload(validatedData, duration);\n\t\tconst dbUpdateData = toSnakeCaseRecord(updateData);\n\n\t\t// Update appointment\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update(dbUpdateData)\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to update appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t\tif (existingAppointment.job_id) {\n\t\t\trevalidatePath(`/dashboard/work/${existingAppointment.job_id}`);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Reschedule an appointment\n */\nasync function rescheduleAppointment(\n\tappointmentId: string,\n\tformData: FormData,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\tscheduledStart: formData.get(\"scheduledStart\") as string,\n\t\t\tscheduledEnd: formData.get(\"scheduledEnd\") as string,\n\t\t\treason: (formData.get(\"reason\") as string) || undefined,\n\t\t};\n\n\t\tconst validatedData = rescheduleAppointmentSchema.parse(rawData);\n\n\t\t// Validate appointment times\n\t\tvalidateAppointmentTimes(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Calculate new duration\n\t\tconst duration = calculateDuration(\n\t\t\tvalidatedData.scheduledStart,\n\t\t\tvalidatedData.scheduledEnd,\n\t\t);\n\n\t\t// Update appointment with rescheduled status\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tscheduled_start: validatedData.scheduledStart,\n\t\t\t\tscheduled_end: validatedData.scheduledEnd,\n\t\t\t\tduration_minutes: duration,\n\t\t\t\tstatus: \"rescheduled\",\n\t\t\t\tnotes: validatedData.reason\n\t\t\t\t\t? `Rescheduled: ${validatedData.reason}`\n\t\t\t\t\t: undefined,\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to reschedule appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Cancel an appointment\n */\nasync function cancelAppointment(\n\tappointmentId: string,\n\treason?: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Update appointment status to cancelled\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tcancellation_reason: reason,\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to cancel appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Complete an appointment\n */\nasync function completeAppointment(\n\tappointmentId: string,\n\tactualEnd?: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Update appointment status to completed\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tactual_end: actualEnd || new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to complete appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Archive an appointment (soft delete)\n */\nexport async function archiveAppointment(\n\tappointmentId: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Archive appointment (soft delete)\n\t\tconst now = new Date().toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({\n\t\t\t\tarchived_at: now,\n\t\t\t\tdeleted_at: now,\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tstatus: \"cancelled\", // Mark as cancelled when archived\n\t\t\t})\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to archive appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Delete an appointment (hard delete)\n */\nasync function deleteAppointment(\n\tappointmentId: string,\n): Promise<ActionResult<boolean>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Delete appointment\n\t\tconst { error } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Failed to delete appointment: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Search appointments\n */\nasync function searchAppointments(\n\tsearchQuery: string,\n\toptions?: {\n\t\tlimit?: number;\n\t\toffset?: number;\n\t},\n): Promise<ActionResult<Record<string, unknown>[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Use the RPC function for ranked search\n\t\tconst { data, error } = await supabase.rpc(\"search_appointments_ranked\", {\n\t\t\tp_company_id: companyId,\n\t\t\tp_search_query: searchQuery,\n\t\t\tp_limit: options?.limit ?? DEFAULT_SEARCH_LIMIT,\n\t\t\tp_offset: options?.offset ?? DEFAULT_SEARCH_OFFSET,\n\t\t});\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Search failed: ${error.message}`,\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn (data as Record<string, unknown>[]) || [];\n\t});\n}\n\n/**\n * Unlink appointment from job\n * Removes the job association (sets job_id to NULL)\n * Bidirectional operation - updates both appointment and job views\n */\nasync function unlinkScheduleFromJob(\n\tappointmentId: string,\n): Promise<ActionResult<void>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\n\t\t// Get current user\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get user's company\n\t\tconst companyId = await getActiveCompanyId();\n\t\tassertExists(companyId, \"Company not found for user\");\n\n\t\t// Get current appointment to verify exists and get job_id for revalidation\n\t\tconst { data: appointment, error: fetchError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (fetchError || !appointment) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Appointment not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tconst previousJobId = appointment.job_id;\n\n\t\t// Unlink appointment from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"appointments\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", appointmentId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (unlinkError) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to unlink appointment from job\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate both pages\n\t\trevalidatePath(`/dashboard/work/appointments/${appointmentId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/appointments\");\n\t\trevalidatePath(\"/dashboard/schedule\");\n\t});\n}\n"],"names":[],"mappings":"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"}