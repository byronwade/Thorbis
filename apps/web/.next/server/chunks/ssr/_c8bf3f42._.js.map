{"version":3,"sources":["../../../../../../packages/auth/src/permissions.ts","../../../../../../apps/web/src/lib/auth/permissions.ts","../../../../../../apps/web/src/actions/roles.ts","../../../../../../apps/web/src/actions/contracts.ts","../../../../../../apps/web/.next-internal/server/app/%28marketing%29/contracts/sign/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["/**\n * Permission System - Server-Side Utilities\n *\n * Provides type-safe permission checking for role-based access control (RBAC).\n * Uses database functions for secure, centralized permission logic.\n *\n * Performance optimizations:\n * - Database functions are cached by Postgres\n * - Single query permission checks\n * - Prepared statements for security\n *\n * @example\n * ```typescript\n * // Check if user can delete jobs\n * const canDelete = await hasPermission(supabase, userId, \"delete_jobs\", companyId);\n *\n * // Check if user has manager role\n * const isManager = await hasRole(supabase, userId, \"manager\", companyId);\n *\n * // Get user's role\n * const role = await getUserRole(supabase, userId, companyId);\n * ```\n */\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * User roles in the system\n * Matches the user_role ENUM in database\n */\nexport type UserRole =\n\t| \"owner\"\n\t| \"admin\"\n\t| \"manager\"\n\t| \"dispatcher\"\n\t| \"technician\"\n\t| \"csr\";\n\n/**\n * Permission keys for fine-grained access control\n */\nexport type Permission =\n\t// Manager permissions\n\t| \"view_reports\"\n\t| \"manage_team\"\n\t| \"approve_estimates\"\n\t| \"handle_escalations\"\n\t// Dispatcher permissions\n\t| \"dispatch_jobs\"\n\t| \"manage_schedule\"\n\t| \"view_tech_locations\"\n\t// Technician permissions\n\t| \"update_job_status\"\n\t| \"create_invoices\"\n\t| \"upload_photos\"\n\t// CSR permissions\n\t| \"create_jobs\"\n\t| \"schedule_appointments\"\n\t| \"send_communications\"\n\t// View permissions\n\t| \"view_customers\"\n\t| \"view_jobs\"\n\t| \"view_schedule\"\n\t// Delete permissions\n\t| \"delete_jobs\"\n\t| \"delete_customers\"\n\t| \"delete_team_members\";\n\n/**\n * Role configuration with permissions and metadata\n */\nexport type RoleConfig = {\n\tid: UserRole;\n\tlabel: string;\n\tdescription: string;\n\tpermissions: Permission[];\n\tdashboardFeatures: string[];\n};\n\n// ============================================================================\n// Role Definitions\n// ============================================================================\n\n/**\n * Complete role configurations with their permissions\n * Used for UI display and permission reference\n */\nconst ROLES: Record<UserRole, RoleConfig> = {\n\towner: {\n\t\tid: \"owner\",\n\t\tlabel: \"Owner\",\n\t\tdescription:\n\t\t\t\"Full system access with focus on business financials and growth\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"manage_team\",\n\t\t\t\"approve_estimates\",\n\t\t\t\"handle_escalations\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t\t\"delete_jobs\",\n\t\t\t\"delete_customers\",\n\t\t\t\"delete_team_members\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"financial-overview\",\n\t\t\t\"profit-margins\",\n\t\t\t\"cash-flow\",\n\t\t\t\"business-growth\",\n\t\t\t\"payroll-overview\",\n\t\t\t\"all-reports\",\n\t\t],\n\t},\n\tadmin: {\n\t\tid: \"admin\",\n\t\tlabel: \"Admin\",\n\t\tdescription: \"System administration and configuration\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"manage_team\",\n\t\t\t\"approve_estimates\",\n\t\t\t\"handle_escalations\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t\t\"delete_jobs\",\n\t\t\t\"delete_customers\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"system-settings\",\n\t\t\t\"user-management\",\n\t\t\t\"integrations\",\n\t\t\t\"audit-logs\",\n\t\t],\n\t},\n\tmanager: {\n\t\tid: \"manager\",\n\t\tlabel: \"Manager\",\n\t\tdescription:\n\t\t\t\"Oversee team performance, customer satisfaction, and operations\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"manage_team\",\n\t\t\t\"approve_estimates\",\n\t\t\t\"handle_escalations\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t\t\"delete_jobs\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"team-performance\",\n\t\t\t\"customer-satisfaction\",\n\t\t\t\"callback-queue\",\n\t\t\t\"review-alerts\",\n\t\t\t\"kpi-tracking\",\n\t\t\t\"inventory-management\",\n\t\t],\n\t},\n\tdispatcher: {\n\t\tid: \"dispatcher\",\n\t\tlabel: \"Dispatcher\",\n\t\tdescription:\n\t\t\t\"Manage technician schedules, job assignments, and real-time operations\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"dispatch-map\",\n\t\t\t\"technician-locations\",\n\t\t\t\"unassigned-jobs\",\n\t\t\t\"emergency-queue\",\n\t\t\t\"quick-dispatch\",\n\t\t\t\"tech-status\",\n\t\t],\n\t},\n\ttechnician: {\n\t\tid: \"technician\",\n\t\tlabel: \"Technician\",\n\t\tdescription:\n\t\t\t\"View assigned jobs, update job status, and track personal performance\",\n\t\tpermissions: [\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"my-schedule\",\n\t\t\t\"active-job\",\n\t\t\t\"my-earnings\",\n\t\t\t\"my-performance\",\n\t\t\t\"parts-inventory\",\n\t\t\t\"time-tracking\",\n\t\t],\n\t},\n\tcsr: {\n\t\tid: \"csr\",\n\t\tlabel: \"Customer Service Rep\",\n\t\tdescription:\n\t\t\t\"Handle customer calls, schedule appointments, and manage customer relationships\",\n\t\tpermissions: [\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"create_invoices\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"call-queue\",\n\t\t\t\"booking-calendar\",\n\t\t\t\"customer-search\",\n\t\t\t\"follow-up-queue\",\n\t\t\t\"estimate-pipeline\",\n\t\t\t\"call-scripts\",\n\t\t],\n\t},\n};\n\n// ============================================================================\n// Permission Check Functions\n// ============================================================================\n\n/**\n * Check if user has a specific role in a company\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param role - Role to check for\n * @param companyId - Company ID\n * @returns true if user has the role\n *\n * @example\n * ```typescript\n * const isManager = await hasRole(supabase, userId, \"manager\", companyId);\n * if (!isManager) {\n *   throw new Error(\"Access denied: Manager role required\");\n * }\n * ```\n */\nexport async function hasRole(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\trole: UserRole,\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"has_role\", {\n\t\tuser_uuid: userId,\n\t\trequired_role: role,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Check if user has ANY of the specified roles\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param roles - Array of roles to check\n * @param companyId - Company ID\n * @returns true if user has any of the roles\n *\n * @example\n * ```typescript\n * const canManage = await hasAnyRole(\n *   supabase,\n *   userId,\n *   [\"owner\", \"manager\", \"admin\"],\n *   companyId\n * );\n * ```\n */\nasync function hasAnyRole(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\troles: UserRole[],\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"has_any_role\", {\n\t\tuser_uuid: userId,\n\t\trequired_roles: roles,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Get user's role in a company\n *\n * @param supabase - Supabase client\n * @param userId - User ID\n * @param companyId - Company ID\n * @returns User's role or null if not found\n *\n * @example\n * ```typescript\n * const role = await getUserRole(supabase, userId, companyId);\n * console.log(`User role: ${role}`); // \"manager\"\n * ```\n */\nexport async function getUserRole(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\tcompanyId: string,\n): Promise<UserRole | null> {\n\tconst { data, error } = await supabase.rpc(\"get_user_role\", {\n\t\tuser_uuid: userId,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn null;\n\t}\n\n\treturn data as UserRole | null;\n}\n\n/**\n * Check if user has a specific permission\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param permission - Permission key to check\n * @param companyId - Company ID\n * @returns true if user has the permission\n *\n * @example\n * ```typescript\n * const canDelete = await hasPermission(supabase, userId, \"delete_jobs\", companyId);\n * if (!canDelete) {\n *   return { error: \"You don't have permission to delete jobs\" };\n * }\n * ```\n */\nexport async function hasPermission(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\tpermission: Permission,\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"has_permission\", {\n\t\tuser_uuid: userId,\n\t\tpermission_key: permission,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Check if user is the company owner\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param companyId - Company ID\n * @returns true if user is the owner\n *\n * @example\n * ```typescript\n * const isOwner = await isCompanyOwner(supabase, userId, companyId);\n * if (!isOwner) {\n *   throw new Error(\"Only company owner can perform this action\");\n * }\n * ```\n */\nexport async function isCompanyOwner(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"is_company_owner\", {\n\t\tuser_uuid: userId,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get all permissions for a role\n *\n * @param role - Role to get permissions for\n * @returns Array of permission keys\n *\n * @example\n * ```typescript\n * const managerPerms = getRolePermissions(\"manager\");\n * console.log(managerPerms); // [\"view_reports\", \"manage_team\", ...]\n * ```\n */\nfunction getRolePermissions(role: UserRole): Permission[] {\n\treturn ROLES[role]?.permissions || [];\n}\n\n/**\n * Check if a role has a specific permission (client-side check only)\n *\n * @param role - Role to check\n * @param permission - Permission to check for\n * @returns true if role has the permission\n *\n * @example\n * ```typescript\n * const canDelete = roleHasPermission(\"manager\", \"delete_jobs\");\n * ```\n */\nfunction roleHasPermission(\n\trole: UserRole,\n\tpermission: Permission,\n): boolean {\n\treturn ROLES[role]?.permissions.includes(permission);\n}\n\n/**\n * Get role configuration\n *\n * @param role - Role to get config for\n * @returns Role configuration\n *\n * @example\n * ```typescript\n * const config = getRoleConfig(\"manager\");\n * console.log(config.label); // \"Manager\"\n * ```\n */\nfunction getRoleConfig(role: UserRole): RoleConfig {\n\treturn ROLES[role];\n}\n","// Re-export from @stratos/auth package for backwards compatibility\nexport * from \"@stratos/auth/permissions\";\n","/**\n * Role Actions - Server Actions\n *\n * Server-side actions for role management and permission checks.\n * Uses Supabase RLS and database functions for security.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tgetUserRole,\n\thasPermission,\n\thasRole,\n\tisCompanyOwner,\n\ttype Permission,\n\ttype UserRole,\n} from \"@/lib/auth/permissions\";\nimport { withErrorHandling } from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst updateRoleSchema = z.object({\n\tteamMemberId: z.string().uuid(),\n\tnewRole: z.enum([\n\t\t\"owner\",\n\t\t\"admin\",\n\t\t\"manager\",\n\t\t\"dispatcher\",\n\t\t\"technician\",\n\t\t\"csr\",\n\t]),\n\treason: z.string().optional(),\n});\n\nconst updatePermissionsSchema = z.object({\n\tteamMemberId: z.string().uuid(),\n\tpermissions: z.record(z.string(), z.boolean()),\n});\n\n// ============================================================================\n// Query Actions\n// ============================================================================\n\n/**\n * Get current user's role in active company\n *\n * @returns User's role or null\n *\n * @example\n * ```typescript\n * const role = await getCurrentUserRole();\n * if (role.success && role.data === \"manager\") {\n *   // Show manager dashboard\n * }\n * ```\n */\nexport async function getCurrentUserRole() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst role = await getUserRole(supabase, user.id, companyId);\n\n\t\treturn role;\n\t});\n}\n\n/**\n * Check if current user has a specific permission\n *\n * @param permission - Permission to check\n * @returns true if user has permission\n *\n * @example\n * ```typescript\n * const result = await checkPermission(\"delete_jobs\");\n * if (!result.success || !result.data) {\n *   return { error: \"Access denied\" };\n * }\n * ```\n */\nasync function checkPermission(permission: Permission) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst hasPerm = await hasPermission(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t\tpermission,\n\t\t\tcompanyId,\n\t\t);\n\n\t\treturn hasPerm;\n\t});\n}\n\n/**\n * Check if current user has a specific role\n *\n * @param role - Role to check\n * @returns true if user has role\n *\n * @example\n * ```typescript\n * const result = await checkRole(\"manager\");\n * if (!result.success || !result.data) {\n *   redirect(\"/dashboard\");\n * }\n * ```\n */\nasync function checkRole(role: UserRole) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst hasRoleResult = await hasRole(supabase, user.id, role, companyId);\n\n\t\treturn hasRoleResult;\n\t});\n}\n\n/**\n * Check if current user is company owner\n *\n * @returns true if user is owner\n */\nasync function checkIsOwner() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst isOwner = await isCompanyOwner(supabase, user.id, companyId);\n\n\t\treturn isOwner;\n\t});\n}\n\n// ============================================================================\n// Mutation Actions\n// ============================================================================\n\n/**\n * Update team member's role\n * Only owners and admins can change roles\n *\n * @param input - Team member ID, new role, and optional reason\n * @returns Updated team member\n *\n * @example\n * ```typescript\n * const result = await updateTeamMemberRole({\n *   teamMemberId: \"123...\",\n *   newRole: \"manager\",\n *   reason: \"Promoted to management\"\n * });\n * ```\n */\nasync function updateTeamMemberRole(\n\tinput: z.infer<typeof updateRoleSchema>,\n) {\n\treturn withErrorHandling(async () => {\n\t\t// Validate input\n\t\tconst validated = updateRoleSchema.parse(input);\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Check permission - only owners and admins can change roles\n\t\tconst canManageRoles =\n\t\t\t(await isCompanyOwner(supabase, user.id, companyId)) ||\n\t\t\t(await hasRole(supabase, user.id, \"admin\", companyId));\n\n\t\tif (!canManageRoles) {\n\t\t\tthrow new Error(\"Only owners and admins can change roles\");\n\t\t}\n\n\t\t// Get current role for audit log\n\t\tconst { data: currentMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"role\")\n\t\t\t.eq(\"id\", validated.teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!currentMember) {\n\t\t\tthrow new Error(\"Team member not found\");\n\t\t}\n\n\t\t// Update role\n\t\tconst { data: updatedMember, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.update({ role: validated.newRole })\n\t\t\t.eq(\"id\", validated.teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\t// Log role change\n\t\tawait supabase.from(\"role_change_log\").insert({\n\t\t\tteam_member_id: validated.teamMemberId,\n\t\t\tchanged_by: user.id,\n\t\t\told_role: currentMember.role,\n\t\t\tnew_role: validated.newRole,\n\t\t\treason: validated.reason,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/settings/team\");\n\t\trevalidatePath(`/dashboard/settings/team/${validated.teamMemberId}`);\n\n\t\treturn updatedMember;\n\t});\n}\n\n/**\n * Update team member's custom permissions\n * Only owners and admins can change permissions\n *\n * @param input - Team member ID and permissions object\n * @returns Updated team member\n *\n * @example\n * ```typescript\n * const result = await updateTeamMemberPermissions({\n *   teamMemberId: \"123...\",\n *   permissions: {\n *     \"delete_jobs\": true,\n *     \"approve_estimates\": true\n *   }\n * });\n * ```\n */\nasync function updateTeamMemberPermissions(\n\tinput: z.infer<typeof updatePermissionsSchema>,\n) {\n\treturn withErrorHandling(async () => {\n\t\t// Validate input\n\t\tconst validated = updatePermissionsSchema.parse(input);\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Check permission\n\t\tconst canManagePermissions =\n\t\t\t(await isCompanyOwner(supabase, user.id, companyId)) ||\n\t\t\t(await hasRole(supabase, user.id, \"admin\", companyId));\n\n\t\tif (!canManagePermissions) {\n\t\t\tthrow new Error(\"Only owners and admins can change permissions\");\n\t\t}\n\n\t\t// Update permissions\n\t\tconst { data: updatedMember, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.update({ permissions: validated.permissions })\n\t\t\t.eq(\"id\", validated.teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/team\");\n\t\trevalidatePath(`/dashboard/settings/team/${validated.teamMemberId}`);\n\n\t\treturn updatedMember;\n\t});\n}\n\n/**\n * Get team members with their roles\n *\n * @returns List of team members with roles\n */\nasync function getTeamMembersWithRoles() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        users (\n          id,\n          name,\n          email,\n          avatar\n        )\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// Owner Protection Actions\n// ============================================================================\n\n/**\n * Transfer company ownership to another team member\n * Requires password verification and extensive validation\n *\n * @param input - Transfer details including new owner, password, and reason\n * @returns Transfer ID for audit\n *\n * @example\n * ```typescript\n * const result = await transferOwnership({\n *   newOwnerId: \"user-uuid\",\n *   password: \"current-password\",\n *   reason: \"Retiring from business\"\n * });\n * ```\n */\nasync function transferOwnership(input: {\n\tnewOwnerId: string;\n\tpassword: string;\n\treason?: string;\n\tipAddress?: string;\n\tuserAgent?: string;\n}) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Verify user is current owner\n\t\tconst isOwner = await isCompanyOwner(supabase, user.id, companyId);\n\t\tif (!isOwner) {\n\t\t\tthrow new Error(\"Only the current owner can transfer ownership\");\n\t\t}\n\n\t\t// Verify password\n\t\tconst { error: signInError } = await supabase.auth.signInWithPassword({\n\t\t\temail: user.email || \"\",\n\t\t\tpassword: input.password,\n\t\t});\n\n\t\tif (signInError) {\n\t\t\tthrow new Error(\"Password verification failed\");\n\t\t}\n\n\t\t// Call database function to transfer ownership\n\t\tconst { data: transferId, error } = await supabase.rpc(\n\t\t\t\"transfer_company_ownership\",\n\t\t\t{\n\t\t\t\tp_company_id: companyId,\n\t\t\t\tp_current_owner_id: user.id,\n\t\t\t\tp_new_owner_id: input.newOwnerId,\n\t\t\t\tp_reason: input.reason,\n\t\t\t\tp_ip_address: input.ipAddress,\n\t\t\t\tp_user_agent: input.userAgent,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message || \"Failed to transfer ownership\");\n\t\t}\n\n\t\t// Revalidate all relevant paths\n\t\trevalidatePath(\"/dashboard/settings/team\");\n\t\trevalidatePath(\"/dashboard\");\n\n\t\treturn transferId;\n\t});\n}\n\n/**\n * Get ownership transfer history for the company\n * Shows audit trail of all ownership changes\n *\n * @returns List of ownership transfers\n */\nasync function getOwnershipTransferHistory() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\t// Only owners and admins can view transfer history\n\t\tconst canView =\n\t\t\t(await isCompanyOwner(supabase, user.id, companyId)) ||\n\t\t\t(await hasRole(supabase, user.id, \"admin\", companyId));\n\n\t\tif (!canView) {\n\t\t\tthrow new Error(\"Only owners and admins can view transfer history\");\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"ownership_transfers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        previous_owner:users!ownership_transfers_previous_owner_id_fkey(id, name, email),\n        new_owner:users!ownership_transfers_new_owner_id_fkey(id, name, email),\n        initiated_by_user:users!ownership_transfers_initiated_by_fkey(id, name, email)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n/**\n * Check if a team member can be deleted\n * Prevents deletion of company owner\n *\n * @param teamMemberId - Team member to check\n * @returns Object with canDelete boolean and reason if not allowed\n */\nexport async function canDeleteTeamMember(teamMemberId: string) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Get team member details\n\t\tconst { data: teamMember, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id, role\")\n\t\t\t.eq(\"id\", teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error || !teamMember) {\n\t\t\tthrow new Error(\"Team member not found\");\n\t\t}\n\n\t\t// Check if user is company owner\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"owner_id\")\n\t\t\t.eq(\"id\", companyId)\n\t\t\t.single();\n\n\t\tif (company && company.owner_id === teamMember.user_id) {\n\t\t\treturn {\n\t\t\t\tcanDelete: false,\n\t\t\t\treason:\n\t\t\t\t\t\"Cannot delete company owner. Transfer ownership first before removing this team member.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tcanDelete: true,\n\t\t};\n\t});\n}\n","\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { createClient } from \"@/lib/supabase/server\";\n\nconst CONTRACT_NUMBER_PAD_LENGTH = 4;\nconst ARCHIVE_RETENTION_DAYS = 90;\nconst HOURS_PER_DAY = 24;\nconst MINUTES_PER_HOUR = 60;\nconst SECONDS_PER_MINUTE = 60;\nconst MILLISECONDS_PER_SECOND = 1000;\nconst MILLISECONDS_PER_DAY =\n\tHOURS_PER_DAY *\n\tMINUTES_PER_HOUR *\n\tSECONDS_PER_MINUTE *\n\tMILLISECONDS_PER_SECOND;\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\n/**\n * Server Actions for Contract Management\n *\n * These handle contract CRUD operations with proper validation\n * and support for both standalone contracts and contracts linked\n * to estimates/invoices for digital signature workflows.\n *\n * Database implementation: Uses Supabase client with full CRUD operations\n * Security: All operations are company-scoped via RLS and getAuthContext()\n */\n\n/**\n * Get authenticated user and company context\n */\nasync function getAuthContext() {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst typedSupabase = supabase as SupabaseServerClient;\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await typedSupabase.auth.getUser();\n\n\tif (authError || !user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\n\t// Get user's active company from team_members\n\tconst { data: teamMember, error: teamError } = await typedSupabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"status\", \"active\")\n\t\t.single();\n\n\tif (teamError || !teamMember) {\n\t\tthrow new Error(\"No active company found\");\n\t}\n\n\treturn {\n\t\tuserId: user.id,\n\t\tcompanyId: teamMember.company_id,\n\t\tsupabase: typedSupabase,\n\t};\n}\n\n/**\n * Generate unique contract number\n */\nasync function generateContractNumber(\n\tcompanyId: string,\n\tsupabase: SupabaseServerClient,\n): Promise<string> {\n\tconst year = new Date().getFullYear();\n\tconst prefix = `CON-${year}-`;\n\n\t// PERFORMANCE OPTIMIZED: Fetch only latest contract instead of ALL contracts\n\t// BEFORE: Fetched all contracts (could be 1000+)\n\t// AFTER: Fetch only latest contract with matching prefix\n\tconst { data: contracts } = await supabase\n\t\t.from(\"contracts\")\n\t\t.select(\"contract_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.like(\"contract_number\", `${prefix}%`) // Filter by year prefix in database\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1);\n\n\t// Extract number from last contract or start at 1\n\tlet nextNumber = 1;\n\tif (contracts && contracts.length > 0) {\n\t\tconst lastNumber = contracts[0].contract_number?.replace(prefix, \"\");\n\t\tnextNumber = (parseInt(lastNumber || \"0\", 10) || 0) + 1;\n\t}\n\n\treturn `${prefix}${String(nextNumber).padStart(CONTRACT_NUMBER_PAD_LENGTH, \"0\")}`;\n}\n\n/**\n * Validation schemas\n *\n * Note: Contracts are NOT linked directly to customers.\n * They must be linked to either an estimate or invoice (which have customer info).\n * The signer email is used to send the contract for signature.\n */\nconst contractSchema = z\n\t.object({\n\t\ttitle: z.string().min(1, \"Contract title is required\"),\n\t\tdescription: z.string().optional(),\n\t\tcontent: z.string().min(1, \"Contract content is required\"),\n\t\t// Must have either estimateId or invoiceId\n\t\tjobId: z.string().optional(),\n\t\testimateId: z.string().optional(),\n\t\tinvoiceId: z.string().optional(),\n\t\tcontractType: z.enum([\"service\", \"maintenance\", \"custom\"]),\n\t\tvalidFrom: z.string().optional(),\n\t\tvalidUntil: z.string().optional(),\n\t\tterms: z.string().optional(),\n\t\tnotes: z.string().optional(),\n\t\t// Signer info - email is required to send the contract\n\t\tsignerName: z.string().optional(),\n\t\tsignerEmail: z\n\t\t\t.string()\n\t\t\t.email(\"Valid email required\")\n\t\t\t.min(1, \"Signer email is required\"),\n\t\tsignerTitle: z.string().optional(),\n\t\tsignerCompany: z.string().optional(),\n\t})\n\t.refine((data) => data.estimateId || data.invoiceId, {\n\t\tmessage: \"Contract must be linked to either an estimate or invoice\",\n\t\tpath: [\"estimateId\"],\n\t});\n\nconst signContractSchema = z.object({\n\tcontractId: z.string().min(1, \"Contract ID is required\"),\n\tsignature: z.string().min(1, \"Signature is required\"),\n\tsignerName: z.string().min(1, \"Signer name is required\"),\n\tsignerEmail: z.string().email(\"Valid email required\"),\n\tsignerTitle: z.string().optional(),\n\tsignerCompany: z.string().optional(),\n\tipAddress: z.string().optional(),\n});\n\n// NOTE: Type exports moved to @/types/contracts\n// to comply with Next.js 16 \"use server\" file restrictions.\n\ntype ContractInsertPayload = {\n\tcompany_id: string;\n\tcontract_number: string;\n\ttitle: string;\n\tdescription: string | null;\n\tcontent: string;\n\tjob_id: string | null;\n\testimate_id: string | null;\n\tinvoice_id: string | null;\n\tcontract_type: string;\n\tvalid_from: string | null;\n\tvalid_until: string | null;\n\tterms: string | null;\n\tnotes: string | null;\n\tsigner_name: string | null;\n\tsigner_email: string;\n\tsigner_title: string | null;\n\tsigner_company: string | null;\n\tstatus: string;\n};\n\nconst buildContractInsertPayload = ({\n\tcompanyId,\n\tcontractNumber,\n\tdata,\n}: {\n\tcompanyId: string;\n\tcontractNumber: string;\n\tdata: z.infer<typeof contractSchema>;\n}): ContractInsertPayload => ({\n\tcompany_id: companyId,\n\tcontract_number: contractNumber,\n\ttitle: data.title,\n\tdescription: data.description || null,\n\tcontent: data.content,\n\tjob_id: data.jobId || null,\n\testimate_id: data.estimateId || null,\n\tinvoice_id: data.invoiceId || null,\n\tcontract_type: data.contractType,\n\tvalid_from: data.validFrom || null,\n\tvalid_until: data.validUntil || null,\n\tterms: data.terms || null,\n\tnotes: data.notes || null,\n\tsigner_name: data.signerName || null,\n\tsigner_email: data.signerEmail,\n\tsigner_title: data.signerTitle || null,\n\tsigner_company: data.signerCompany || null,\n\tstatus: \"draft\",\n});\n\nconst buildContractUpdatePayload = (\n\tdata: Partial<z.infer<typeof contractSchema>>,\n): Record<string, unknown> => {\n\tconst update: Record<string, unknown> = {};\n\n\tconst assign = (condition: unknown, key: string, value: unknown) => {\n\t\tif (condition !== undefined) {\n\t\t\tupdate[key] = value;\n\t\t}\n\t};\n\n\tassign(data.title, \"title\", data.title);\n\tassign(data.description, \"description\", data.description ?? null);\n\tassign(data.content, \"content\", data.content);\n\tassign(data.jobId, \"job_id\", data.jobId ?? null);\n\tassign(data.estimateId, \"estimate_id\", data.estimateId ?? null);\n\tassign(data.invoiceId, \"invoice_id\", data.invoiceId ?? null);\n\tassign(data.contractType, \"contract_type\", data.contractType);\n\tassign(data.validFrom, \"valid_from\", data.validFrom ?? null);\n\tassign(data.validUntil, \"valid_until\", data.validUntil ?? null);\n\tassign(data.terms, \"terms\", data.terms ?? null);\n\tassign(data.notes, \"notes\", data.notes ?? null);\n\tassign(data.signerName, \"signer_name\", data.signerName ?? null);\n\tassign(data.signerEmail, \"signer_email\", data.signerEmail);\n\tassign(data.signerTitle, \"signer_title\", data.signerTitle ?? null);\n\tassign(data.signerCompany, \"signer_company\", data.signerCompany ?? null);\n\n\treturn update;\n};\n\nconst reportContractIssue = (_message: string, _error?: unknown) => {\n\t// TODO: Integrate structured logging\n};\n\n/**\n * Create a new contract\n */\nasync function createContract(\n\tformData: FormData,\n): Promise<{ success: boolean; error?: string; contractId?: string }> {\n\ttry {\n\t\tconst data = contractSchema.parse({\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\"),\n\t\t\tcontent: formData.get(\"content\"),\n\t\t\tjobId: formData.get(\"jobId\"),\n\t\t\testimateId: formData.get(\"estimateId\"),\n\t\t\tinvoiceId: formData.get(\"invoiceId\"),\n\t\t\tcontractType: formData.get(\"contractType\"),\n\t\t\tvalidFrom: formData.get(\"validFrom\"),\n\t\t\tvalidUntil: formData.get(\"validUntil\"),\n\t\t\tterms: formData.get(\"terms\"),\n\t\t\tnotes: formData.get(\"notes\"),\n\t\t\tsignerName: formData.get(\"signerName\"),\n\t\t\tsignerEmail: formData.get(\"signerEmail\"),\n\t\t\tsignerTitle: formData.get(\"signerTitle\"),\n\t\t\tsignerCompany: formData.get(\"signerCompany\"),\n\t\t});\n\n\t\t// Get auth context for company scoping\n\t\tconst { companyId, supabase } = await getAuthContext();\n\n\t\t// Generate unique contract number\n\t\tconst contractNumber = await generateContractNumber(companyId, supabase);\n\n\t\t// Insert into database\n\t\tconst contractPayload = buildContractInsertPayload({\n\t\t\tcompanyId,\n\t\t\tcontractNumber,\n\t\t\tdata,\n\t\t});\n\n\t\tconst { data: contract, error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.insert(contractPayload)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error creating contract\", error);\n\t\t\tthrow new Error(\"Failed to create contract\");\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tcontractId: contract.id,\n\t\t};\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn { success: false, error: \"Failed to create contract\" };\n\t}\n}\n\n/**\n * Update an existing contract\n */\nasync function updateContract(\n\tcontractId: string,\n\tformData: FormData,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst data = contractSchema.partial().parse({\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\"),\n\t\t\tcontent: formData.get(\"content\"),\n\t\t\tjobId: formData.get(\"jobId\"),\n\t\t\testimateId: formData.get(\"estimateId\"),\n\t\t\tinvoiceId: formData.get(\"invoiceId\"),\n\t\t\tcontractType: formData.get(\"contractType\"),\n\t\t\tvalidFrom: formData.get(\"validFrom\"),\n\t\t\tvalidUntil: formData.get(\"validUntil\"),\n\t\t\tterms: formData.get(\"terms\"),\n\t\t\tnotes: formData.get(\"notes\"),\n\t\t\tsignerName: formData.get(\"signerName\"),\n\t\t\tsignerEmail: formData.get(\"signerEmail\"),\n\t\t\tsignerTitle: formData.get(\"signerTitle\"),\n\t\t\tsignerCompany: formData.get(\"signerCompany\"),\n\t\t});\n\n\t\t// Get auth context for security\n\t\tconst { companyId, supabase } = await getAuthContext();\n\n\t\tconst updateData = buildContractUpdatePayload(data);\n\n\t\tif (Object.keys(updateData).length === 0) {\n\t\t\treturn { success: true };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error updating contract\", error);\n\t\t\tthrow new Error(\"Failed to update contract\");\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(`/dashboard/work/contracts/${contractId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn { success: false, error: \"Failed to update contract\" };\n\t}\n}\n\n/**\n * Archive a contract (soft delete)\n *\n * Archives instead of permanently deleting. Can be restored within 90 days.\n */\nexport async function archiveContract(\n\tcontractId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Get auth context for security\n\t\tconst { companyId, supabase, userId } = await getAuthContext();\n\n\t\t// Cannot archive signed contracts (business rule)\n\t\tconst { data: contract } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.select(\"status\")\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (contract?.status === \"signed\" || contract?.status === \"active\") {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Cannot archive signed or active contracts. Signed contracts must be retained for records.\",\n\t\t\t};\n\t\t}\n\n\t\t// Archive contract (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + ARCHIVE_RETENTION_DAYS * MILLISECONDS_PER_DAY,\n\t\t).toISOString();\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: now,\n\t\t\t\tdeleted_by: userId,\n\t\t\t\tarchived_at: now,\n\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error archiving contract\", error);\n\t\t\tthrow new Error(\"Failed to archive contract\");\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t\treturn { success: true };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"Failed to archive contract\" };\n\t}\n}\n\n/**\n * Restore archived contract\n */\nasync function restoreContract(\n\tcontractId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Get auth context for security\n\t\tconst { companyId, supabase } = await getAuthContext();\n\n\t\t// Verify contract is archived\n\t\tconst { data: contract } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.select(\"deleted_at, status\")\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!contract?.deleted_at) {\n\t\t\treturn { success: false, error: \"Contract is not archived\" };\n\t\t}\n\n\t\t// Restore contract\n\t\tconst { error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: null,\n\t\t\t\tdeleted_by: null,\n\t\t\t\tarchived_at: null,\n\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\tstatus: contract.status === \"archived\" ? \"draft\" : contract.status,\n\t\t\t})\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error restoring contract\", error);\n\t\t\tthrow new Error(\"Failed to restore contract\");\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t\treturn { success: true };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"Failed to restore contract\" };\n\t}\n}\n\n/**\n * Delete a contract (legacy - deprecated)\n * @deprecated Use archiveContract() instead\n */\nasync function deleteContract(\n\tcontractId: string,\n): Promise<{ success: boolean; error?: string }> {\n\treturn archiveContract(contractId);\n}\n\n/**\n * Send contract for signature\n */\nasync function sendContract(\n\tcontractId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Get auth context for security\n\t\tconst { companyId, supabase } = await getAuthContext();\n\n\t\t// Update status and record sent time (company-scoped for security via RLS)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.update({\n\t\t\t\tstatus: \"sent\",\n\t\t\t\tsent_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error sending contract\", error);\n\t\t\tthrow new Error(\"Failed to send contract\");\n\t\t}\n\n\t\t// Note: Email sending will be implemented in separate task\n\t\t// await sendContractEmail(contract);\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(`/dashboard/work/contracts/${contractId}`);\n\t\treturn { success: true };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"Failed to send contract\" };\n\t}\n}\n\n/**\n * Sign a contract (customer-facing action)\n */\nexport async function signContract(\n\tformData: FormData,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst data = signContractSchema.parse({\n\t\t\tcontractId: formData.get(\"contractId\"),\n\t\t\tsignature: formData.get(\"signature\"),\n\t\t\tsignerName: formData.get(\"signerName\"),\n\t\t\tsignerEmail: formData.get(\"signerEmail\"),\n\t\t\tsignerTitle: formData.get(\"signerTitle\"),\n\t\t\tsignerCompany: formData.get(\"signerCompany\"),\n\t\t\tipAddress: formData.get(\"ipAddress\"),\n\t\t});\n\n\t\t// Update contract with signature\n\t\t// Note: This is customer-facing, no auth context needed (public action)\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.update({\n\t\t\t\tstatus: \"signed\",\n\t\t\t\tsignature: data.signature,\n\t\t\t\tsigner_name: data.signerName,\n\t\t\t\tsigner_email: data.signerEmail,\n\t\t\t\tsigner_title: data.signerTitle || null,\n\t\t\t\tsigner_company: data.signerCompany || null,\n\t\t\t\tip_address: data.ipAddress || null,\n\t\t\t\tsigned_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", data.contractId);\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error signing contract\", error);\n\t\t\tthrow new Error(\"Failed to sign contract\");\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(`/dashboard/work/contracts/${data.contractId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\t\treturn { success: false, error: \"Failed to sign contract\" };\n\t}\n}\n\n/**\n * Reject a contract\n */\nasync function rejectContract(\n\tcontractId: string,\n\treason?: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Get auth context for security\n\t\tconst { companyId, supabase } = await getAuthContext();\n\n\t\t// Update status (company-scoped for security via RLS)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\tnotes: reason || null,\n\t\t\t})\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treportContractIssue(\"Error rejecting contract\", error);\n\t\t\tthrow new Error(\"Failed to reject contract\");\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(`/dashboard/work/contracts/${contractId}`);\n\t\treturn { success: true };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"Failed to reject contract\" };\n\t}\n}\n\n/**\n * Track contract view (when customer opens the contract)\n */\nasync function trackContractView(\n\tcontractId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Get contract to check current status (public action, no auth needed)\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Supabase client not configured\");\n\t\t}\n\n\t\tconst { data: contract, error: fetchError } = await supabase\n\t\t\t.from(\"contracts\")\n\t\t\t.select(\"status\")\n\t\t\t.eq(\"id\", contractId)\n\t\t\t.single();\n\n\t\tif (fetchError) {\n\t\t\treportContractIssue(\"Error fetching contract\", fetchError);\n\t\t\tthrow new Error(\"Failed to track contract view\");\n\t\t}\n\n\t\t// Only update to 'viewed' if currently 'sent'\n\t\tif (contract && contract.status === \"sent\") {\n\t\t\tconst { error } = await supabase\n\t\t\t\t.from(\"contracts\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"viewed\",\n\t\t\t\t\tviewed_at: new Date().toISOString(),\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", contractId);\n\n\t\t\tif (error) {\n\t\t\t\treportContractIssue(\"Error updating contract view\", error);\n\t\t\t\tthrow new Error(\"Failed to update contract view\");\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/contracts\");\n\t\trevalidatePath(`/dashboard/work/contracts/${contractId}`);\n\t\treturn { success: true };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"Failed to track contract view\" };\n\t}\n}\n","export {getCurrentUserRole as '001f005176797ef23488068124fb9a744915a477de'} from 'ACTIONS_MODULE0'\nexport {canDeleteTeamMember as '406f6624261c6dd1a908026fa1408a3f6d507b6e7d'} from 'ACTIONS_MODULE0'\nexport {signContract as '406958ced3b0e89447e1ace32b290ef9715c51c340'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":"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"}