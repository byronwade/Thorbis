{"version":3,"sources":["../../../../../../apps/web/src/lib/email/deliverability-monitor.ts","../../../../../../apps/web/src/lib/email/email-types.ts","../../../../../../apps/web/src/lib/email/rate-limiter.ts","../../../../../../apps/web/src/lib/email/gmail-client.ts","../../../../../../apps/web/src/lib/email/token-encryption.ts","../../../../../../apps/web/src/lib/email/gmail-rate-limiter.ts","../../../../../../apps/web/src/lib/email/audit-logger.ts","../../../../../../apps/web/src/lib/email/email-provider.ts","../../../../../../apps/web/src/lib/email/postmark-client.ts","../../../../../../apps/web/src/lib/email/provider-monitor.ts","../../../../../../apps/web/src/lib/email/email-sender.ts"],"sourcesContent":["\"use server\";\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\n/**\n * Deliverability Monitor for Multi-Tenant Email System\n *\n * Features:\n * - Track delivery events (delivered, bounced, complained)\n * - Update domain reputation scores\n * - Auto-suspend domains with poor reputation\n * - Generate deliverability reports\n */\n\nexport type DeliveryEventType =\n\t| \"delivered\"\n\t| \"bounced\"\n\t| \"soft_bounce\"\n\t| \"complained\"\n\t| \"opened\"\n\t| \"clicked\";\n\nexport interface DeliveryEvent {\n\tdomainId: string;\n\teventType: DeliveryEventType;\n\temailId?: string;\n\tmetadata?: Record<string, any>;\n}\n\nexport interface DomainHealth {\n\tdomainId: string;\n\tdomain: string;\n\treputationScore: number;\n\tbounceRate: number;\n\tcomplaintRate: number;\n\tdeliveryRate: number;\n\tstatus: \"healthy\" | \"warning\" | \"critical\" | \"suspended\";\n\ttotalEmailsSent: number;\n\thardBounces: number;\n\tsoftBounces: number;\n\tcomplaints: number;\n\tlastHealthCheck: string | null;\n}\n\n/**\n * Record a delivery event and update domain metrics\n */\nexport async function recordDeliveryEvent(\n\tevent: DeliveryEvent\n): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Use the database function to update reputation\n\tconst { error } = await supabase.rpc(\"update_domain_reputation\", {\n\t\tp_domain_id: event.domainId,\n\t\tp_event_type: event.eventType,\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Error recording delivery event:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true };\n}\n\n/**\n * Process Resend webhook events for deliverability tracking\n */\nexport async function processResendWebhookEvent(webhookData: {\n\ttype: string;\n\tdata: {\n\t\temail_id?: string;\n\t\tfrom?: string;\n\t\tto?: string[];\n\t\tsubject?: string;\n\t\tcreated_at?: string;\n\t\t[key: string]: any;\n\t};\n}): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Map Resend event types to our event types\n\tconst eventTypeMap: Record<string, DeliveryEventType | null> = {\n\t\t\"email.delivered\": \"delivered\",\n\t\t\"email.bounced\": \"bounced\",\n\t\t\"email.complained\": \"complained\",\n\t\t\"email.opened\": \"opened\",\n\t\t\"email.clicked\": \"clicked\",\n\t\t// Soft bounces might come as delivery_delayed in some providers\n\t\t\"email.delivery_delayed\": \"soft_bounce\",\n\t};\n\n\tconst eventType = eventTypeMap[webhookData.type];\n\tif (!eventType) {\n\t\t// Not a delivery event we track\n\t\treturn { success: true };\n\t}\n\n\t// Extract domain from the \"from\" address\n\tconst fromEmail = webhookData.data.from;\n\tif (!fromEmail) {\n\t\treturn { success: true };\n\t}\n\n\tconst domain = fromEmail.includes(\"@\")\n\t\t? fromEmail.split(\"@\")[1]\n\t\t: fromEmail;\n\n\t// Look up the domain in our database\n\tconst { data: domainRecord } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"id\")\n\t\t.eq(\"domain_name\", domain)\n\t\t.maybeSingle();\n\n\tif (!domainRecord) {\n\t\t// Domain not found in our system\n\t\treturn { success: true };\n\t}\n\n\t// Record the event\n\treturn recordDeliveryEvent({\n\t\tdomainId: domainRecord.id,\n\t\teventType,\n\t\temailId: webhookData.data.email_id,\n\t\tmetadata: webhookData.data,\n\t});\n}\n\n/**\n * Get domain health status\n */\nexport async function getDomainHealth(\n\tdomainId: string\n): Promise<DomainHealth | null> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t\"id, domain_name, reputation_score, bounce_rate, total_emails_sent, hard_bounces, soft_bounces, spam_complaints, is_suspended, last_health_check\"\n\t\t)\n\t\t.eq(\"id\", domainId)\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\tconst totalEvents =\n\t\tdata.total_emails_sent + data.hard_bounces + data.soft_bounces;\n\tconst bounceRate =\n\t\ttotalEvents > 0\n\t\t\t? ((data.hard_bounces + data.soft_bounces) / totalEvents) * 100\n\t\t\t: 0;\n\tconst complaintRate =\n\t\tdata.total_emails_sent > 0\n\t\t\t? (data.spam_complaints / data.total_emails_sent) * 100\n\t\t\t: 0;\n\tconst deliveryRate =\n\t\ttotalEvents > 0 ? (data.total_emails_sent / totalEvents) * 100 : 100;\n\n\tlet status: DomainHealth[\"status\"] = \"healthy\";\n\tif (data.is_suspended) {\n\t\tstatus = \"suspended\";\n\t} else if (data.reputation_score < 30 || bounceRate > 10 || complaintRate > 0.5) {\n\t\tstatus = \"critical\";\n\t} else if (data.reputation_score < 60 || bounceRate > 5 || complaintRate > 0.2) {\n\t\tstatus = \"warning\";\n\t}\n\n\treturn {\n\t\tdomainId: data.id,\n\t\tdomain: data.domain_name,\n\t\treputationScore: Number(data.reputation_score),\n\t\tbounceRate: Number(bounceRate.toFixed(2)),\n\t\tcomplaintRate: Number(complaintRate.toFixed(3)),\n\t\tdeliveryRate: Number(deliveryRate.toFixed(2)),\n\t\tstatus,\n\t\ttotalEmailsSent: data.total_emails_sent,\n\t\thardBounces: data.hard_bounces,\n\t\tsoftBounces: data.soft_bounces,\n\t\tcomplaints: data.spam_complaints,\n\t\tlastHealthCheck: data.last_health_check,\n\t};\n}\n\n/**\n * Get all domains health for a company\n */\nexport async function getCompanyDomainsHealth(\n\tcompanyId: string\n): Promise<DomainHealth[]> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t\"id, domain_name, reputation_score, bounce_rate, total_emails_sent, hard_bounces, soft_bounces, spam_complaints, is_suspended, last_health_check\"\n\t\t)\n\t\t.eq(\"company_id\", companyId);\n\n\tif (error || !data) {\n\t\treturn [];\n\t}\n\n\treturn data.map((d) => {\n\t\tconst totalEvents = d.total_emails_sent + d.hard_bounces + d.soft_bounces;\n\t\tconst bounceRate =\n\t\t\ttotalEvents > 0 ? ((d.hard_bounces + d.soft_bounces) / totalEvents) * 100 : 0;\n\t\tconst complaintRate =\n\t\t\td.total_emails_sent > 0 ? (d.spam_complaints / d.total_emails_sent) * 100 : 0;\n\t\tconst deliveryRate =\n\t\t\ttotalEvents > 0 ? (d.total_emails_sent / totalEvents) * 100 : 100;\n\n\t\tlet status: DomainHealth[\"status\"] = \"healthy\";\n\t\tif (d.is_suspended) {\n\t\t\tstatus = \"suspended\";\n\t\t} else if (d.reputation_score < 30 || bounceRate > 10 || complaintRate > 0.5) {\n\t\t\tstatus = \"critical\";\n\t\t} else if (d.reputation_score < 60 || bounceRate > 5 || complaintRate > 0.2) {\n\t\t\tstatus = \"warning\";\n\t\t}\n\n\t\treturn {\n\t\t\tdomainId: d.id,\n\t\t\tdomain: d.domain_name,\n\t\t\treputationScore: Number(d.reputation_score),\n\t\t\tbounceRate: Number(bounceRate.toFixed(2)),\n\t\t\tcomplaintRate: Number(complaintRate.toFixed(3)),\n\t\t\tdeliveryRate: Number(deliveryRate.toFixed(2)),\n\t\t\tstatus,\n\t\t\ttotalEmailsSent: d.total_emails_sent,\n\t\t\thardBounces: d.hard_bounces,\n\t\t\tsoftBounces: d.soft_bounces,\n\t\t\tcomplaints: d.spam_complaints,\n\t\t\tlastHealthCheck: d.last_health_check,\n\t\t};\n\t});\n}\n\n/**\n * Run health check on all domains and update status\n */\nexport async function runHealthCheckForAllDomains(): Promise<{\n\tchecked: number;\n\tsuspended: number;\n\twarnings: number;\n}> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Get all active domains\n\tconst { data: domains } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"id, reputation_score, hard_bounces, soft_bounces, spam_complaints, total_emails_sent\")\n\t\t.eq(\"is_suspended\", false);\n\n\tif (!domains) {\n\t\treturn { checked: 0, suspended: 0, warnings: 0 };\n\t}\n\n\tlet suspended = 0;\n\tlet warnings = 0;\n\n\tfor (const domain of domains) {\n\t\tconst totalEvents =\n\t\t\tdomain.total_emails_sent + domain.hard_bounces + domain.soft_bounces;\n\t\tconst bounceRate =\n\t\t\ttotalEvents > 100\n\t\t\t\t? ((domain.hard_bounces + domain.soft_bounces) / totalEvents) * 100\n\t\t\t\t: 0;\n\t\tconst complaintRate =\n\t\t\tdomain.total_emails_sent > 100\n\t\t\t\t? (domain.spam_complaints / domain.total_emails_sent) * 100\n\t\t\t\t: 0;\n\n\t\t// Auto-suspend if reputation is critical\n\t\tif (domain.reputation_score < 20 || bounceRate > 15 || complaintRate > 1) {\n\t\t\tawait supabase\n\t\t\t\t.from(\"company_email_domains\")\n\t\t\t\t.update({\n\t\t\t\t\tis_suspended: true,\n\t\t\t\t\tsuspension_reason: `Auto-suspended: Reputation ${domain.reputation_score}, Bounce rate ${bounceRate.toFixed(1)}%, Complaint rate ${complaintRate.toFixed(2)}%`,\n\t\t\t\t\tsuspended_at: new Date().toISOString(),\n\t\t\t\t\tlast_health_check: new Date().toISOString(),\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", domain.id);\n\t\t\tsuspended++;\n\t\t} else if (domain.reputation_score < 50 || bounceRate > 8 || complaintRate > 0.3) {\n\t\t\t// Update health check timestamp for warning domains\n\t\t\tawait supabase\n\t\t\t\t.from(\"company_email_domains\")\n\t\t\t\t.update({ last_health_check: new Date().toISOString() })\n\t\t\t\t.eq(\"id\", domain.id);\n\t\t\twarnings++;\n\t\t} else {\n\t\t\t// Healthy, just update timestamp\n\t\t\tawait supabase\n\t\t\t\t.from(\"company_email_domains\")\n\t\t\t\t.update({ last_health_check: new Date().toISOString() })\n\t\t\t\t.eq(\"id\", domain.id);\n\t\t}\n\t}\n\n\treturn {\n\t\tchecked: domains.length,\n\t\tsuspended,\n\t\twarnings,\n\t};\n}\n\n/**\n * Generate deliverability report for a domain\n */\nexport async function generateDeliverabilityReport(domainId: string): Promise<{\n\tdomain: string;\n\tperiod: { start: string; end: string };\n\tmetrics: {\n\t\ttotalSent: number;\n\t\tdelivered: number;\n\t\tbounced: number;\n\t\tcomplained: number;\n\t\tdeliveryRate: number;\n\t\tbounceRate: number;\n\t\tcomplaintRate: number;\n\t};\n\treputation: {\n\t\tcurrent: number;\n\t\tchange: number;\n\t\tstatus: string;\n\t};\n\trecommendations: string[];\n} | null> {\n\tconst health = await getDomainHealth(domainId);\n\tif (!health) {\n\t\treturn null;\n\t}\n\n\tconst recommendations: string[] = [];\n\n\tif (health.bounceRate > 5) {\n\t\trecommendations.push(\n\t\t\t\"High bounce rate detected. Clean your email list and remove invalid addresses.\"\n\t\t);\n\t}\n\n\tif (health.complaintRate > 0.1) {\n\t\trecommendations.push(\n\t\t\t\"Spam complaints detected. Ensure recipients have opted in and make unsubscribe easy.\"\n\t\t);\n\t}\n\n\tif (health.reputationScore < 70) {\n\t\trecommendations.push(\n\t\t\t\"Reputation score is below optimal. Reduce sending volume temporarily and focus on engagement.\"\n\t\t);\n\t}\n\n\tif (health.status === \"warning\" || health.status === \"critical\") {\n\t\trecommendations.push(\n\t\t\t\"Domain health is degraded. Review your email content and sending practices.\"\n\t\t);\n\t}\n\n\tif (recommendations.length === 0) {\n\t\trecommendations.push(\n\t\t\t\"Domain health is good. Continue monitoring and maintain current practices.\"\n\t\t);\n\t}\n\n\treturn {\n\t\tdomain: health.domain,\n\t\tperiod: {\n\t\t\tstart: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\n\t\t\tend: new Date().toISOString(),\n\t\t},\n\t\tmetrics: {\n\t\t\ttotalSent: health.totalEmailsSent,\n\t\t\tdelivered: health.totalEmailsSent - health.hardBounces,\n\t\t\tbounced: health.hardBounces + health.softBounces,\n\t\t\tcomplained: health.complaints,\n\t\t\tdeliveryRate: health.deliveryRate,\n\t\t\tbounceRate: health.bounceRate,\n\t\t\tcomplaintRate: health.complaintRate,\n\t\t},\n\t\treputation: {\n\t\t\tcurrent: health.reputationScore,\n\t\t\tchange: 0, // Would need historical data to calculate\n\t\t\tstatus: health.status,\n\t\t},\n\t\trecommendations,\n\t};\n}\n","/**\n * Email Types - Type definitions for email templates\n *\n * Features:\n * - Type-safe email data\n * - Template props interfaces\n * - Email send result types\n * - Validation schemas\n */\n\nimport { z } from \"zod\";\n\n// Email send result type\nexport type EmailSendResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tdata?: {\n\t\tid?: string;\n\t\tmessage?: string;\n\t};\n};\n\n// Company branding for tenant emails\nexport type CompanyBranding = {\n\tcompanyName: string;\n\tlogoUrl?: string;\n\tprimaryColor?: string;\n\tsupportEmail?: string;\n\tsupportPhone?: string;\n\twebsiteUrl?: string;\n\taddress?: string;\n};\n\n// Base email template props\nexport type BaseEmailProps = {\n\tpreviewText?: string;\n\tcompanyName?: string; // Deprecated - use company.companyName\n\tcompany?: CompanyBranding; // For company-branded emails\n};\n\n// Authentication Email Props\nexport interface WelcomeEmailProps extends BaseEmailProps {\n\tname: string;\n\tloginUrl: string;\n}\n\nexport interface EmailVerificationProps extends BaseEmailProps {\n\tname: string;\n\tverificationUrl: string;\n}\n\nexport interface PasswordResetProps extends BaseEmailProps {\n\tname?: string;\n\tresetUrl: string;\n\texpiresInMinutes?: number;\n}\n\nexport interface PasswordChangedProps extends BaseEmailProps {\n\tname: string;\n\tchangedAt: Date;\n}\n\nexport interface MagicLinkProps extends BaseEmailProps {\n\tloginUrl: string;\n\texpiresInMinutes?: number;\n}\n\n// Job Lifecycle Email Props\nexport interface JobConfirmationProps extends BaseEmailProps {\n\tcustomerName: string;\n\tjobDate: string;\n\tjobTime: string;\n\ttechnicianName: string;\n\tjobType: string;\n\taddress: string;\n\tjobNumber: string;\n\tviewJobUrl: string;\n}\n\nexport interface AppointmentReminderProps extends BaseEmailProps {\n\tcustomerName: string;\n\tappointmentDate: string;\n\tappointmentTime: string;\n\ttechnicianName: string;\n\taddress: string;\n\trescheduleUrl: string;\n}\n\nexport interface TechEnRouteProps extends BaseEmailProps {\n\tcustomerName: string;\n\ttechnicianName: string;\n\testimatedArrival: string;\n\ttechnicianPhoto?: string;\n\ttrackingUrl?: string;\n}\n\nexport interface JobCompleteProps extends BaseEmailProps {\n\tcustomerName: string;\n\tjobNumber: string;\n\tcompletedDate: string;\n\ttotalAmount: string;\n\tinvoiceUrl: string;\n\treviewUrl: string;\n}\n\n// Billing Email Props\nexport interface InvoiceSentProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\ttotalAmount: string;\n\tdueDate: string;\n\titems: Array<{\n\t\tdescription: string;\n\t\tquantity: number;\n\t\tamount: string;\n\t}>;\n\tpaymentUrl: string;\n\tdownloadUrl: string;\n}\n\nexport interface InvoiceNotificationProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\tinvoiceDate: string;\n\tdueDate?: string;\n\ttotalAmount: number; // in cents\n\tinvoiceUrl: string;\n\tcurrency?: string;\n\titems?: Array<{\n\t\tdescription: string;\n\t\tquantity: number;\n\t\tamount: number; // in cents\n\t}>;\n\tnotes?: string;\n\tpaymentLink?: string; // Secure payment portal link\n\tcustomBody?: string; // Custom email body from template\n\tcustomFooter?: string; // Custom email footer from template\n}\n\nexport interface EstimateNotificationProps extends BaseEmailProps {\n\tcustomerName: string;\n\testimateNumber: string;\n\testimateDate: string;\n\tvalidUntil?: string;\n\ttotalAmount: number; // in cents\n\testimateUrl: string;\n\tcurrency?: string;\n\titems?: Array<{\n\t\tdescription: string;\n\t\tquantity: number;\n\t\tamount: number; // in cents\n\t}>;\n\tnotes?: string;\n}\n\nexport interface PaymentReceivedProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\tpaymentAmount: string;\n\tpaymentMethod: string;\n\tpaymentDate: string;\n\treceiptUrl: string;\n}\n\nexport interface PaymentReminderProps extends BaseEmailProps {\n\tcustomerName: string;\n\tinvoiceNumber: string;\n\ttotalAmount: string;\n\tdueDate: string;\n\tdaysOverdue: number;\n\tpaymentUrl: string;\n}\n\nexport interface EstimateSentProps extends BaseEmailProps {\n\tcustomerName: string;\n\testimateNumber: string;\n\ttotalAmount: string;\n\tvalidUntil: string;\n\titems: Array<{\n\t\tdescription: string;\n\t\tamount: string;\n\t}>;\n\tacceptUrl: string;\n\tviewUrl: string;\n}\n\n// Customer Engagement Email Props\nexport interface ReviewRequestProps extends BaseEmailProps {\n\tcustomerName: string;\n\tjobNumber: string;\n\ttechnicianName: string;\n\tcompletedDate: string;\n\treviewUrl: string;\n}\n\nexport interface ServiceReminderProps extends BaseEmailProps {\n\tcustomerName: string;\n\tserviceName: string;\n\tlastServiceDate: string;\n\tscheduleUrl: string;\n}\n\nexport interface WelcomeCustomerProps extends BaseEmailProps {\n\tcustomerName: string;\n\taccountUrl: string;\n\tsupportEmail: string;\n\tsupportPhone: string;\n}\n\nexport interface PortalInvitationProps extends BaseEmailProps {\n\tcustomerName: string;\n\tportalUrl: string;\n\texpiresInHours?: number;\n\tcompanyName?: string;\n\tsupportEmail?: string;\n\tsupportPhone?: string;\n}\n\n// Verification Email Props\nexport interface VerificationSubmittedProps extends BaseEmailProps {\n\tcompanyName: string;\n\tcontactName: string;\n\thasTollFreeNumbers: boolean;\n\thas10DLCNumbers: boolean;\n\ttollFreeCount?: number;\n\tdlcCount?: number;\n\tdashboardUrl: string;\n}\n\nexport interface VerificationCompleteProps extends BaseEmailProps {\n\tcompanyName: string;\n\tcontactName: string;\n\tverificationTypes: string[]; // [\"toll-free\", \"10dlc\"]\n\tdashboardUrl: string;\n\tmessagingUrl: string;\n}\n\n// Waitlist Email Props\nexport interface WaitlistSubscriptionProps extends BaseEmailProps {\n\tname: string;\n}\n\n// Validation Schemas\nconst emailAddressSchema = z\n\t.string()\n\t.email(\"Invalid email address\")\n\t.min(1, \"Email is required\");\n\nexport const emailSendSchema = z.object({\n\tto: z.union([emailAddressSchema, z.array(emailAddressSchema)]),\n\tsubject: z.string().min(1, \"Subject is required\").max(200),\n\treplyTo: emailAddressSchema.optional(),\n});\n\n// Template types enum\nexport enum EmailTemplate {\n\t// Auth\n\tWELCOME = \"welcome\",\n\tEMAIL_VERIFICATION = \"email-verification\",\n\tPASSWORD_RESET = \"password-reset\",\n\tPASSWORD_CHANGED = \"password-changed\",\n\tMAGIC_LINK = \"magic-link\",\n\n\t// Jobs\n\tJOB_CONFIRMATION = \"job-confirmation\",\n\tAPPOINTMENT_REMINDER = \"appointment-reminder\",\n\tTECH_EN_ROUTE = \"tech-en-route\",\n\tJOB_COMPLETE = \"job-complete\",\n\n\t// Billing\n\tINVOICE = \"invoice\",\n\tESTIMATE = \"estimate\",\n\tINVOICE_SENT = \"invoice-sent\",\n\tPAYMENT_RECEIVED = \"payment-received\",\n\tPAYMENT_REMINDER = \"payment-reminder\",\n\tESTIMATE_SENT = \"estimate-sent\",\n\n\t// Customer\n\tREVIEW_REQUEST = \"review-request\",\n\tSERVICE_REMINDER = \"service-reminder\",\n\tWELCOME_CUSTOMER = \"welcome-customer\",\n\tPORTAL_INVITATION = \"portal-invitation\",\n\n\t// Team\n\tTEAM_INVITATION = \"team-invitation\",\n\n\t// Onboarding & Verification\n\tVERIFICATION_SUBMITTED = \"verification-submitted\",\n\tVERIFICATION_COMPLETE = \"verification-complete\",\n\n\t// Waitlist\n\tWAITLIST_SUBSCRIPTION = \"waitlist-subscription\",\n\tWAITLIST_ADMIN_NOTIFICATION = \"waitlist-admin-notification\",\n\n\t// Generic\n\tGENERIC = \"generic\",\n}\n\n","/**\n * Email Rate Limiter\n *\n * Implements per-domain rate limiting for email sending to:\n * - Prevent spam/abuse\n * - Protect domain reputation\n * - Enforce plan-based limits\n * - Track daily/hourly email quotas\n */\n\n\"use server\";\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface RateLimitResult {\n\tallowed: boolean;\n\treason?: string;\n\tremaining?: number;\n\tresetAt?: string;\n}\n\nexport interface ActiveDomainInfo {\n\tdomainId: string;\n\tdomain: string;\n\treplyToEmail: string | null;\n\tdailyLimit: number;\n\thourlyLimit: number;\n\temailsSentToday: number;\n\temailsSentThisHour: number;\n}\n\n// =============================================================================\n// RATE LIMIT CONFIGURATION\n// =============================================================================\n\n// Default rate limits (can be overridden per domain/plan)\nconst DEFAULT_LIMITS = {\n\tdaily: 1000, // 1000 emails per day per domain\n\thourly: 100, // 100 emails per hour per domain\n\tperMinute: 10, // 10 emails per minute per domain\n};\n\n// In-memory cache for rate limit tracking (resets on server restart)\n// For production, use Redis or database counters\nconst rateLimitCache = new Map<\n\tstring,\n\t{\n\t\tcount: number;\n\t\twindowStart: number;\n\t}\n>();\n\n// =============================================================================\n// PUBLIC API\n// =============================================================================\n\n/**\n * Get the active email domain for a company\n *\n * Returns the verified, sending-enabled domain for the company,\n * prioritizing custom domains over platform subdomains.\n */\nexport async function getCompanyActiveDomain(\n\tcompanyId: string\n): Promise<ActiveDomainInfo | null> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Query for the active sending domain\n\tconst { data: domain, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tdomain_name,\n\t\t\treply_to_email,\n\t\t\tdaily_limit,\n\t\t\thourly_limit,\n\t\t\temails_sent_today,\n\t\t\temails_sent_this_hour,\n\t\t\tis_platform_subdomain\n\t\t`\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"verified\")\n\t\t.eq(\"sending_enabled\", true)\n\t\t.eq(\"is_suspended\", false)\n\t\t.order(\"is_platform_subdomain\", { ascending: true }) // Custom domains first\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.maybeSingle();\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching company email domain:\", error);\n\t\treturn null;\n\t}\n\n\tif (!domain) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tdomainId: domain.id,\n\t\tdomain: domain.domain_name,\n\t\treplyToEmail: domain.reply_to_email,\n\t\tdailyLimit: domain.daily_limit || DEFAULT_LIMITS.daily,\n\t\thourlyLimit: domain.hourly_limit || DEFAULT_LIMITS.hourly,\n\t\temailsSentToday: domain.emails_sent_today || 0,\n\t\temailsSentThisHour: domain.emails_sent_this_hour || 0,\n\t};\n}\n\n/**\n * Check if a domain has exceeded its rate limit\n *\n * This is a non-blocking check that doesn't increment counters.\n * Use incrementEmailCounter after successfully sending.\n */\nexport async function checkRateLimit(domainId: string): Promise<RateLimitResult> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Get current domain stats\n\tconst { data: domain, error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\n\t\t\t`\n\t\t\tdaily_limit,\n\t\t\thourly_limit,\n\t\t\temails_sent_today,\n\t\t\temails_sent_this_hour,\n\t\t\tis_suspended,\n\t\t\tdaily_limit_reset_at,\n\t\t\thourly_limit_reset_at\n\t\t`\n\t\t)\n\t\t.eq(\"id\", domainId)\n\t\t.single();\n\n\tif (error || !domain) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Domain not found or error fetching limits\",\n\t\t};\n\t}\n\n\t// Check if domain is suspended\n\tif (domain.is_suspended) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Domain is suspended due to reputation issues\",\n\t\t};\n\t}\n\n\tconst dailyLimit = domain.daily_limit || DEFAULT_LIMITS.daily;\n\tconst hourlyLimit = domain.hourly_limit || DEFAULT_LIMITS.hourly;\n\tconst emailsSentToday = domain.emails_sent_today || 0;\n\tconst emailsSentThisHour = domain.emails_sent_this_hour || 0;\n\n\t// Check daily limit\n\tif (emailsSentToday >= dailyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: `Daily email limit reached (${dailyLimit} emails/day)`,\n\t\t\tremaining: 0,\n\t\t\tresetAt: domain.daily_limit_reset_at || getNextMidnightUTC(),\n\t\t};\n\t}\n\n\t// Check hourly limit\n\tif (emailsSentThisHour >= hourlyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: `Hourly email limit reached (${hourlyLimit} emails/hour)`,\n\t\t\tremaining: 0,\n\t\t\tresetAt: domain.hourly_limit_reset_at || getNextHourUTC(),\n\t\t};\n\t}\n\n\t// Check per-minute limit (in-memory)\n\tconst minuteKey = `${domainId}:minute`;\n\tconst minuteWindow = getMinuteWindow();\n\tconst minuteCache = rateLimitCache.get(minuteKey);\n\n\tif (minuteCache && minuteCache.windowStart === minuteWindow) {\n\t\tif (minuteCache.count >= DEFAULT_LIMITS.perMinute) {\n\t\t\treturn {\n\t\t\t\tallowed: false,\n\t\t\t\treason: `Rate limit: Too many emails per minute (${DEFAULT_LIMITS.perMinute}/min)`,\n\t\t\t\tremaining: 0,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tallowed: true,\n\t\tremaining: Math.min(dailyLimit - emailsSentToday, hourlyLimit - emailsSentThisHour),\n\t};\n}\n\n/**\n * Increment the email counter after successfully sending\n *\n * This atomically increments the counters and validates limits.\n * Should be called after checkRateLimit and before actually sending.\n */\nexport async function incrementEmailCounter(\n\tdomainId: string\n): Promise<RateLimitResult> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Use a database function for atomic increment and validation\n\t// This prevents race conditions in high-concurrency scenarios\n\tconst { data, error } = await supabase.rpc(\"increment_email_counter\", {\n\t\tp_domain_id: domainId,\n\t});\n\n\tif (error) {\n\t\t// If the RPC doesn't exist, fall back to manual increment\n\t\tif (error.code === \"PGRST202\" || error.message.includes(\"function\")) {\n\t\t\treturn await incrementEmailCounterFallback(domainId);\n\t\t}\n\n\t\tconsole.error(\"Error incrementing email counter:\", error);\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: error.message,\n\t\t};\n\t}\n\n\t// Handle RPC result\n\tif (data && typeof data === \"object\") {\n\t\tconst result = data as { allowed: boolean; reason?: string; remaining?: number };\n\t\treturn {\n\t\t\tallowed: result.allowed,\n\t\t\treason: result.reason,\n\t\t\tremaining: result.remaining,\n\t\t};\n\t}\n\n\t// Default: allowed if no error\n\treturn { allowed: true };\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n/**\n * Fallback increment method when RPC function doesn't exist\n */\nasync function incrementEmailCounterFallback(\n\tdomainId: string\n): Promise<RateLimitResult> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\t// Get current counts\n\tconst { data: domain, error: fetchError } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"emails_sent_today, emails_sent_this_hour, daily_limit, hourly_limit\")\n\t\t.eq(\"id\", domainId)\n\t\t.single();\n\n\tif (fetchError || !domain) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Domain not found\",\n\t\t};\n\t}\n\n\tconst dailyLimit = domain.daily_limit || DEFAULT_LIMITS.daily;\n\tconst hourlyLimit = domain.hourly_limit || DEFAULT_LIMITS.hourly;\n\n\t// Check limits before incrementing\n\tif ((domain.emails_sent_today || 0) >= dailyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Daily limit reached\",\n\t\t};\n\t}\n\n\tif ((domain.emails_sent_this_hour || 0) >= hourlyLimit) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Hourly limit reached\",\n\t\t};\n\t}\n\n\t// Increment counters\n\tconst { error: updateError } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.update({\n\t\t\temails_sent_today: (domain.emails_sent_today || 0) + 1,\n\t\t\temails_sent_this_hour: (domain.emails_sent_this_hour || 0) + 1,\n\t\t})\n\t\t.eq(\"id\", domainId);\n\n\tif (updateError) {\n\t\tconsole.error(\"Error updating email counters:\", updateError);\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: updateError.message,\n\t\t};\n\t}\n\n\t// Update in-memory per-minute counter\n\tconst minuteKey = `${domainId}:minute`;\n\tconst minuteWindow = getMinuteWindow();\n\tconst minuteCache = rateLimitCache.get(minuteKey);\n\n\tif (minuteCache && minuteCache.windowStart === minuteWindow) {\n\t\tminuteCache.count++;\n\t} else {\n\t\trateLimitCache.set(minuteKey, {\n\t\t\tcount: 1,\n\t\t\twindowStart: minuteWindow,\n\t\t});\n\t}\n\n\treturn {\n\t\tallowed: true,\n\t\tremaining: Math.min(\n\t\t\tdailyLimit - (domain.emails_sent_today || 0) - 1,\n\t\t\thourlyLimit - (domain.emails_sent_this_hour || 0) - 1\n\t\t),\n\t};\n}\n\n/**\n * Get the current minute window (for per-minute rate limiting)\n */\nfunction getMinuteWindow(): number {\n\treturn Math.floor(Date.now() / 60000);\n}\n\n/**\n * Get the next midnight UTC timestamp\n */\nfunction getNextMidnightUTC(): string {\n\tconst now = new Date();\n\tconst tomorrow = new Date(now);\n\ttomorrow.setUTCDate(tomorrow.getUTCDate() + 1);\n\ttomorrow.setUTCHours(0, 0, 0, 0);\n\treturn tomorrow.toISOString();\n}\n\n/**\n * Get the next hour UTC timestamp\n */\nfunction getNextHourUTC(): string {\n\tconst now = new Date();\n\tconst nextHour = new Date(now);\n\tnextHour.setUTCHours(nextHour.getUTCHours() + 1, 0, 0, 0);\n\treturn nextHour.toISOString();\n}\n\n// =============================================================================\n// RESET FUNCTIONS (for cron jobs)\n// =============================================================================\n\n/**\n * Reset daily email counters (should be called by cron at midnight UTC)\n */\nexport async function resetDailyCounters(): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.update({\n\t\t\temails_sent_today: 0,\n\t\t\tdaily_limit_reset_at: getNextMidnightUTC(),\n\t\t})\n\t\t.neq(\"id\", \"\"); // Update all rows\n\n\tif (error) {\n\t\tconsole.error(\"Error resetting daily counters:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true };\n}\n\n/**\n * Reset hourly email counters (should be called by cron every hour)\n */\nexport async function resetHourlyCounters(): Promise<{ success: boolean; error?: string }> {\n\tconst supabase = await createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.update({\n\t\t\temails_sent_this_hour: 0,\n\t\t\thourly_limit_reset_at: getNextHourUTC(),\n\t\t})\n\t\t.neq(\"id\", \"\"); // Update all rows\n\n\tif (error) {\n\t\tconsole.error(\"Error resetting hourly counters:\", error);\n\t\treturn { success: false, error: error.message };\n\t}\n\n\treturn { success: true };\n}\n","/**\n * Gmail API Client (Company-Level & Per-User / Multi-Tenant)\n *\n * CRITICAL: Reply-to addresses ALWAYS use the platform subdomain (mail.thorbis.com),\n * even when sending from personal Gmail. This ensures replies go to the company's\n * centralized inbox, not the personal Gmail account.\n *\n * Example:\n * - FROM: john@gmail.com (personal Gmail)\n * - REPLY-TO: support@acme-plumbing.mail.thorbis.com (platform subdomain)\n *\n * See: /docs/email/REPLY_TO_ARCHITECTURE.md for full details\n *\n * This module provides Gmail API integration at two levels:\n * 1. Company-Level: One Gmail account for the entire company (sending only)\n * 2. Per-User: Individual team member Gmail accounts (inbox access + sending)\n *\n * Multi-Tenant Architecture:\n * - Each company can configure their own email provider\n * - Options: 'managed' (Resend/Postmark), 'gmail', or 'disabled'\n * - Company tokens stored in company_gmail_tokens table\n * - Per-user tokens stored in user_gmail_tokens table\n *\n * Key Features:\n * - Send emails via company's Gmail API\n * - Per-user inbox access and synchronization\n * - Automatic token refresh before expiration\n * - Token validation and error handling\n * - Integration with provider monitoring\n *\n * How It Works (Company-Level):\n * 1. Company admin connects Gmail via OAuth (grants gmail.send scope)\n * 2. Tokens stored in company_gmail_tokens table\n * 3. Before sending, we check/refresh tokens\n * 4. Use Gmail API to send email as company\n *\n * How It Works (Per-User):\n * 1. Team member connects their Gmail via OAuth (grants gmail.readonly + gmail.send)\n * 2. Tokens stored in user_gmail_tokens table\n * 3. Background sync job fetches inbox emails every 5-10 minutes\n * 4. Emails stored in communications table with mailbox_owner_id\n * 5. Role-based permissions control who can see which emails\n *\n * Rate Limits (Gmail API):\n * - Consumer accounts: 100 emails/day\n * - Google Workspace: 2,000 emails/day\n * - Per-minute limit: 100 messages\n *\n * Required Scopes:\n * - Company: https://www.googleapis.com/auth/gmail.send\n * - Per-User: https://www.googleapis.com/auth/gmail.readonly, gmail.send\n *\n * Environment Variables:\n * - GOOGLE_CLIENT_ID: OAuth client ID\n * - GOOGLE_CLIENT_SECRET: OAuth client secret\n *\n * @see https://developers.google.com/gmail/api/reference/rest\n */\n\n\"use server\";\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport { encryptToken, decryptToken } from \"@/lib/email/token-encryption\";\nimport { checkSyncRateLimit, acquireSyncLock, releaseSyncLock, checkApiRateLimit, validateSyncParams } from \"@/lib/email/gmail-rate-limiter\";\nimport { logGmailConnected, logGmailDisconnected, logAuditEvent, logTokenRefreshFailed, logSyncFailed } from \"@/lib/email/audit-logger\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Company email provider options\n */\nexport type CompanyEmailProvider = \"managed\" | \"gmail\" | \"disabled\";\n\n/**\n * Gmail OAuth token data structure (company-level)\n */\nexport interface CompanyGmailTokenData {\n\tcompanyId: string;\n\tgmailEmail: string;\n\tgmailDisplayName?: string;\n\taccessToken: string;\n\trefreshToken: string;\n\ttokenExpiresAt: Date;\n\tisValid: boolean;\n\tscopes: string[];\n\tconnectedBy?: string;\n\tconnectedByName?: string;\n}\n\n/**\n * Result of sending an email via Gmail\n */\nexport interface GmailSendResult {\n\tsuccess: boolean;\n\tmessageId?: string;\n\tthreadId?: string;\n\terror?: string;\n\tlabelIds?: string[];\n}\n\n/**\n * Email data for Gmail sending\n */\nexport interface GmailEmailData {\n\tto: string | string[];\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\treplyTo?: string;\n\tcc?: string | string[];\n\tbcc?: string | string[];\n\theaders?: Record<string, string>;\n}\n\n/**\n * Token refresh response from Google\n */\ninterface GoogleTokenResponse {\n\taccess_token: string;\n\texpires_in: number;\n\ttoken_type: string;\n\tscope?: string;\n\trefresh_token?: string;\n}\n\n/**\n * Per-user Gmail token data structure\n */\nexport interface UserGmailTokenData {\n\tteamMemberId: string;\n\temailAccountId: string;\n\tgmailEmail: string;\n\taccessToken: string;\n\trefreshToken: string;\n\ttokenExpiresAt: Date;\n\tscopes: string[];\n\tsyncEnabled: boolean;\n\tlastSyncedAt?: Date;\n}\n\n/**\n * Gmail message from API\n */\nexport interface GmailMessage {\n\tid: string;\n\tthreadId: string;\n\tlabelIds: string[];\n\tsnippet: string;\n\tpayload: {\n\t\theaders: Array<{ name: string; value: string }>;\n\t\tparts?: Array<{\n\t\t\tmimeType: string;\n\t\t\tbody: { data?: string; size: number };\n\t\t\tparts?: any[];\n\t\t}>;\n\t\tbody?: { data?: string; size: number };\n\t\tmimeType: string;\n\t};\n\tinternalDate: string;\n\tsizeEstimate: number;\n}\n\n/**\n * Parsed email message\n */\nexport interface ParsedGmailMessage {\n\tgmailMessageId: string;\n\tgmailThreadId: string;\n\tfrom: string;\n\tto: string[];\n\tcc?: string[];\n\tsubject: string;\n\ttextBody?: string;\n\thtmlBody?: string;\n\treceivedAt: Date;\n\thasAttachments: boolean;\n\tlabels: string[];\n}\n\n/**\n * Inbox sync result\n */\nexport interface InboxSyncResult {\n\tsuccess: boolean;\n\tmessagesFetched: number;\n\tmessagesStored: number;\n\terrors: string[];\n\tlastSyncedAt: Date;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst GOOGLE_TOKEN_URL = \"https://oauth2.googleapis.com/token\";\nconst GMAIL_API_URL = \"https://gmail.googleapis.com/gmail/v1\";\nconst GMAIL_SEND_SCOPE = \"https://www.googleapis.com/auth/gmail.send\";\nconst GMAIL_READONLY_SCOPE = \"https://www.googleapis.com/auth/gmail.readonly\";\nconst GMAIL_MODIFY_SCOPE = \"https://www.googleapis.com/auth/gmail.modify\";\nconst TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1000;\n\n// =============================================================================\n// COMPANY EMAIL PROVIDER PREFERENCE\n// =============================================================================\n\n/**\n * Get company's email provider preference\n */\nexport async function getCompanyEmailProvider(\n\tcompanyId: string\n): Promise<CompanyEmailProvider> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { data } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"email_provider\")\n\t\t\t.eq(\"id\", companyId)\n\t\t\t.single();\n\n\t\treturn (data?.email_provider as CompanyEmailProvider) || \"managed\";\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Error getting company email provider:\", error);\n\t\treturn \"managed\";\n\t}\n}\n\n/**\n * Set company's email provider preference\n */\nexport async function setCompanyEmailProvider(\n\tcompanyId: string,\n\tprovider: CompanyEmailProvider,\n\tupdatedByUserId?: string\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// If switching to Gmail, verify tokens exist\n\t\tif (provider === \"gmail\") {\n\t\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\t\t\tif (!tokens || !tokens.isValid) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"Gmail is not connected. Please connect Gmail first.\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { error } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.update({\n\t\t\t\temail_provider: provider,\n\t\t\t\temail_provider_updated_at: new Date().toISOString(),\n\t\t\t\temail_provider_updated_by: updatedByUserId || null,\n\t\t\t})\n\t\t\t.eq(\"id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\tconsole.log(`[Gmail] Company ${companyId} email provider set to: ${provider}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// TOKEN MANAGEMENT (COMPANY-LEVEL)\n// =============================================================================\n\n/**\n * Get Gmail tokens for a company\n */\nexport async function getCompanyGmailTokens(\n\tcompanyId: string\n): Promise<CompanyGmailTokenData | null> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.maybeSingle();\n\n\t\tif (error || !data) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenData: CompanyGmailTokenData = {\n\t\t\tcompanyId: data.company_id,\n\t\t\tgmailEmail: data.gmail_email,\n\t\t\tgmailDisplayName: data.gmail_display_name,\n\t\t\taccessToken: data.access_token,\n\t\t\trefreshToken: data.refresh_token,\n\t\t\ttokenExpiresAt: new Date(data.token_expires_at),\n\t\t\tisValid: data.is_valid,\n\t\t\tscopes: data.scopes || [GMAIL_SEND_SCOPE],\n\t\t\tconnectedBy: data.connected_by,\n\t\t\tconnectedByName: data.connected_by_name,\n\t\t};\n\n\t\t// Check if token needs refresh\n\t\tif (isTokenExpiringSoon(tokenData.tokenExpiresAt)) {\n\t\t\tconsole.log(`[Gmail] Token expiring soon for company ${companyId}, refreshing...`);\n\t\t\tconst refreshed = await refreshCompanyGmailToken(companyId, tokenData.refreshToken);\n\t\t\tif (refreshed) {\n\t\t\t\treturn refreshed;\n\t\t\t}\n\t\t\tconsole.warn(\"[Gmail] Token refresh failed, using existing token\");\n\t\t}\n\n\t\treturn tokenData;\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Error getting company tokens:\", error);\n\t\treturn null;\n\t}\n}\n\nfunction isTokenExpiringSoon(expiresAt: Date): boolean {\n\treturn expiresAt.getTime() - Date.now() < TOKEN_REFRESH_BUFFER_MS;\n}\n\n/**\n * Refresh Gmail OAuth token for a company\n */\nexport async function refreshCompanyGmailToken(\n\tcompanyId: string,\n\trefreshToken: string\n): Promise<CompanyGmailTokenData | null> {\n\ttry {\n\t\tconst clientId = process.env.GOOGLE_CLIENT_ID;\n\t\tconst clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n\n\t\tif (!clientId || !clientSecret) {\n\t\t\tconsole.error(\"[Gmail] Missing GOOGLE_CLIENT_ID or GOOGLE_CLIENT_SECRET\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst response = await fetch(GOOGLE_TOKEN_URL, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tclient_id: clientId,\n\t\t\t\tclient_secret: clientSecret,\n\t\t\t\trefresh_token: refreshToken,\n\t\t\t\tgrant_type: \"refresh_token\",\n\t\t\t}),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error(`[Gmail] Token refresh failed: ${response.status}`, errorText);\n\t\t\tif (response.status === 400 || response.status === 401) {\n\t\t\t\tawait markCompanyTokenInvalid(companyId, `Refresh failed: ${response.status}`);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenResponse: GoogleTokenResponse = await response.json();\n\t\tconst expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000);\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.update({\n\t\t\t\taccess_token: tokenResponse.access_token,\n\t\t\t\ttoken_expires_at: expiresAt.toISOString(),\n\t\t\t\t...(tokenResponse.refresh_token && { refresh_token: tokenResponse.refresh_token }),\n\t\t\t\tis_valid: true,\n\t\t\t\tlast_error: null,\n\t\t\t})\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select(\"*\")\n\t\t\t.single();\n\n\t\tif (error || !data) {\n\t\t\tconsole.error(\"[Gmail] Failed to update refreshed token:\", error?.message);\n\t\t\treturn null;\n\t\t}\n\n\t\tconsole.log(`[Gmail] Token refreshed for company ${companyId}`);\n\n\t\treturn {\n\t\t\tcompanyId: data.company_id,\n\t\t\tgmailEmail: data.gmail_email,\n\t\t\tgmailDisplayName: data.gmail_display_name,\n\t\t\taccessToken: data.access_token,\n\t\t\trefreshToken: data.refresh_token,\n\t\t\ttokenExpiresAt: new Date(data.token_expires_at),\n\t\t\tisValid: data.is_valid,\n\t\t\tscopes: data.scopes || [GMAIL_SEND_SCOPE],\n\t\t\tconnectedBy: data.connected_by,\n\t\t\tconnectedByName: data.connected_by_name,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Token refresh error:\", error);\n\t\treturn null;\n\t}\n}\n\nasync function markCompanyTokenInvalid(companyId: string, reason: string): Promise<void> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.update({ is_valid: false, last_error: reason })\n\t\t\t.eq(\"company_id\", companyId);\n\t\tconsole.log(`[Gmail] Marked token invalid for company ${companyId}: ${reason}`);\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Failed to mark token invalid:\", error);\n\t}\n}\n\n/**\n * Store Gmail OAuth tokens for a company\n */\nexport async function storeCompanyGmailTokens(\n\tcompanyId: string,\n\tgmailEmail: string,\n\tdisplayName: string | null,\n\taccessToken: string,\n\trefreshToken: string,\n\texpiresIn: number,\n\tscopes: string[],\n\tconnectedByUserId?: string,\n\tconnectedByName?: string\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tif (!scopes.includes(GMAIL_SEND_SCOPE)) {\n\t\t\treturn { success: false, error: `Missing required scope: ${GMAIL_SEND_SCOPE}` };\n\t\t}\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst expiresAt = new Date(Date.now() + expiresIn * 1000);\n\n\t\tconst { error } = await supabase.from(\"company_gmail_tokens\").upsert(\n\t\t\t{\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tgmail_email: gmailEmail,\n\t\t\t\tgmail_display_name: displayName,\n\t\t\t\taccess_token: accessToken,\n\t\t\t\trefresh_token: refreshToken,\n\t\t\t\ttoken_expires_at: expiresAt.toISOString(),\n\t\t\t\tscopes,\n\t\t\t\tis_valid: true,\n\t\t\t\tlast_error: null,\n\t\t\t\tconnected_by: connectedByUserId || null,\n\t\t\t\tconnected_by_name: connectedByName || null,\n\t\t\t},\n\t\t\t{ onConflict: \"company_id\" }\n\t\t);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Gmail] Failed to store tokens:\", error.message);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\tconsole.log(`[Gmail] Stored tokens for company ${companyId} (${gmailEmail})`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Disconnect Gmail from a company\n */\nexport async function disconnectCompanyGmail(\n\tcompanyId: string\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Get token to revoke\n\t\tconst { data: tokenData } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.select(\"access_token\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\t// Delete from database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.delete()\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// Reset to managed provider\n\t\tawait setCompanyEmailProvider(companyId, \"managed\");\n\n\t\t// Revoke token with Google (best effort)\n\t\tif (tokenData?.access_token) {\n\t\t\ttry {\n\t\t\t\tawait fetch(`https://oauth2.googleapis.com/revoke?token=${tokenData.access_token}`, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\tconsole.warn(\"[Gmail] Token revocation request failed (non-critical)\");\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(`[Gmail] Disconnected Gmail for company ${companyId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// EMAIL SENDING\n// =============================================================================\n\n/**\n * Send an email via company's Gmail\n */\nexport async function sendCompanyGmailEmail(\n\tcompanyId: string,\n\temailData: GmailEmailData\n): Promise<GmailSendResult> {\n\ttry {\n\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\t\tif (!tokens) {\n\t\t\treturn { success: false, error: \"Gmail not connected for this company\" };\n\t\t}\n\n\t\tif (!tokens.isValid) {\n\t\t\treturn { success: false, error: `Gmail connection invalid: ${tokens.gmailEmail}` };\n\t\t}\n\n\t\tconst mimeMessage = buildMimeMessage({\n\t\t\tfrom: tokens.gmailDisplayName\n\t\t\t\t? `${tokens.gmailDisplayName} <${tokens.gmailEmail}>`\n\t\t\t\t: tokens.gmailEmail,\n\t\t\tto: Array.isArray(emailData.to) ? emailData.to.join(\", \") : emailData.to,\n\t\t\tsubject: emailData.subject,\n\t\t\thtml: emailData.html,\n\t\t\ttext: emailData.text,\n\t\t\treplyTo: emailData.replyTo,\n\t\t\tcc: emailData.cc ? (Array.isArray(emailData.cc) ? emailData.cc.join(\", \") : emailData.cc) : undefined,\n\t\t\tbcc: emailData.bcc ? (Array.isArray(emailData.bcc) ? emailData.bcc.join(\", \") : emailData.bcc) : undefined,\n\t\t\theaders: emailData.headers,\n\t\t});\n\n\t\tconst encodedMessage = base64UrlEncode(mimeMessage);\n\n\t\tconst response = await fetch(`${GMAIL_API_URL}/users/me/messages/send`, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${tokens.accessToken}`,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t\tbody: JSON.stringify({ raw: encodedMessage }),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorData = await response.json().catch(() => ({}));\n\t\t\tconst errorMessage = errorData.error?.message || `Gmail API error: ${response.status}`;\n\t\t\tconsole.error(`[Gmail] Send failed: ${errorMessage}`);\n\t\t\tif (response.status === 401) {\n\t\t\t\tawait markCompanyTokenInvalid(companyId, \"Authentication failed\");\n\t\t\t}\n\t\t\treturn { success: false, error: errorMessage };\n\t\t}\n\n\t\tconst result = await response.json();\n\n\t\t// Update last used timestamp\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"company_gmail_tokens\")\n\t\t\t.update({ last_used_at: new Date().toISOString() })\n\t\t\t.eq(\"company_id\", companyId);\n\n\t\tconsole.log(`[Gmail] Sent email for company ${companyId} (ID: ${result.id})`);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessageId: result.id,\n\t\t\tthreadId: result.threadId,\n\t\t\tlabelIds: result.labelIds,\n\t\t};\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\tconsole.error(\"[Gmail] Send error:\", message);\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// MIME MESSAGE BUILDING\n// =============================================================================\n\ninterface MimeMessageParts {\n\tfrom: string;\n\tto: string;\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\treplyTo?: string;\n\tcc?: string;\n\tbcc?: string;\n\theaders?: Record<string, string>;\n}\n\nfunction buildMimeMessage(parts: MimeMessageParts): string {\n\tconst boundary = `boundary_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n\n\tconst lines: string[] = [\n\t\t`From: ${parts.from}`,\n\t\t`To: ${parts.to}`,\n\t\t`Subject: =?UTF-8?B?${Buffer.from(parts.subject).toString(\"base64\")}?=`,\n\t\t\"MIME-Version: 1.0\",\n\t];\n\n\tif (parts.replyTo) lines.push(`Reply-To: ${parts.replyTo}`);\n\tif (parts.cc) lines.push(`Cc: ${parts.cc}`);\n\tif (parts.bcc) lines.push(`Bcc: ${parts.bcc}`);\n\n\tif (parts.headers) {\n\t\tfor (const [key, value] of Object.entries(parts.headers)) {\n\t\t\tlines.push(`${key}: ${value}`);\n\t\t}\n\t}\n\n\tlines.push(`Content-Type: multipart/alternative; boundary=\"${boundary}\"`);\n\tlines.push(\"\");\n\n\tconst textContent = parts.text || extractTextFromHtml(parts.html);\n\tlines.push(`--${boundary}`);\n\tlines.push(\"Content-Type: text/plain; charset=UTF-8\");\n\tlines.push(\"Content-Transfer-Encoding: base64\");\n\tlines.push(\"\");\n\tlines.push(Buffer.from(textContent).toString(\"base64\"));\n\n\tlines.push(`--${boundary}`);\n\tlines.push(\"Content-Type: text/html; charset=UTF-8\");\n\tlines.push(\"Content-Transfer-Encoding: base64\");\n\tlines.push(\"\");\n\tlines.push(Buffer.from(parts.html).toString(\"base64\"));\n\n\tlines.push(`--${boundary}--`);\n\n\treturn lines.join(\"\\r\\n\");\n}\n\nfunction extractTextFromHtml(html: string): string {\n\treturn html\n\t\t.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n\t\t.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n\t\t.replace(/<[^>]+>/g, \" \")\n\t\t.replace(/\\s+/g, \" \")\n\t\t.trim();\n}\n\nfunction base64UrlEncode(str: string): string {\n\treturn Buffer.from(str)\n\t\t.toString(\"base64\")\n\t\t.replace(/\\+/g, \"-\")\n\t\t.replace(/\\//g, \"_\")\n\t\t.replace(/=+$/, \"\");\n}\n\n// =============================================================================\n// HEALTH CHECK\n// =============================================================================\n\n/**\n * Check Gmail health for a company\n */\nexport async function checkCompanyGmailHealth(\n\tcompanyId: string,\n\ttestApi: boolean = false\n): Promise<{\n\tconnected: boolean;\n\temail?: string;\n\tdisplayName?: string;\n\ttokenValid: boolean;\n\ttokenExpiresAt?: Date;\n\tapiHealthy?: boolean;\n\tconnectedBy?: string;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\n\t\tif (!tokens) {\n\t\t\treturn { connected: false, tokenValid: false };\n\t\t}\n\n\t\tconst result = {\n\t\t\tconnected: true,\n\t\t\temail: tokens.gmailEmail,\n\t\t\tdisplayName: tokens.gmailDisplayName,\n\t\t\ttokenValid: tokens.isValid,\n\t\t\ttokenExpiresAt: tokens.tokenExpiresAt,\n\t\t\tconnectedBy: tokens.connectedByName,\n\t\t\tapiHealthy: undefined as boolean | undefined,\n\t\t};\n\n\t\tif (testApi && tokens.isValid) {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(`${GMAIL_API_URL}/users/me/profile`, {\n\t\t\t\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` },\n\t\t\t\t});\n\t\t\t\tresult.apiHealthy = response.ok;\n\t\t\t} catch {\n\t\t\t\tresult.apiHealthy = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t} catch (error) {\n\t\treturn {\n\t\t\tconnected: false,\n\t\t\ttokenValid: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n// =============================================================================\n// PER-USER TOKEN MANAGEMENT\n// =============================================================================\n\n/**\n * Get Gmail tokens for a specific team member\n */\nexport async function getUserGmailTokens(\n\tteamMemberId: string\n): Promise<UserGmailTokenData | null> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.select(\"*, user_email_accounts!inner(email_address)\")\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.eq(\"sync_enabled\", true)\n\t\t\t.maybeSingle();\n\n\t\tif (error || !data) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Decrypt tokens before using (CRITICAL SECURITY)\n\t\tconst decryptedAccessToken = decryptToken(data.access_token);\n\t\tconst decryptedRefreshToken = decryptToken(data.refresh_token);\n\n\t\tconst tokenData: UserGmailTokenData = {\n\t\t\tteamMemberId: data.team_member_id,\n\t\t\temailAccountId: data.user_email_account_id,\n\t\t\tgmailEmail: data.user_email_accounts.email_address,\n\t\t\taccessToken: decryptedAccessToken,\n\t\t\trefreshToken: decryptedRefreshToken,\n\t\t\ttokenExpiresAt: new Date(data.token_expiry),\n\t\t\tscopes: data.scopes || [],\n\t\t\tsyncEnabled: data.sync_enabled,\n\t\t\tlastSyncedAt: data.last_synced_at ? new Date(data.last_synced_at) : undefined,\n\t\t};\n\n\t\t// Check if token needs refresh\n\t\tif (isTokenExpiringSoon(tokenData.tokenExpiresAt)) {\n\t\t\tconsole.log(`[Gmail] Token expiring soon for user ${teamMemberId}, refreshing...`);\n\t\t\tconst refreshed = await refreshUserGmailToken(teamMemberId, tokenData.refreshToken);\n\t\t\tif (refreshed) {\n\t\t\t\treturn refreshed;\n\t\t\t}\n\t\t\tconsole.warn(\"[Gmail] User token refresh failed, using existing token\");\n\t\t}\n\n\t\treturn tokenData;\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Error getting user tokens:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Refresh Gmail OAuth token for a team member\n */\nexport async function refreshUserGmailToken(\n\tteamMemberId: string,\n\trefreshToken: string\n): Promise<UserGmailTokenData | null> {\n\ttry {\n\t\tconst clientId = process.env.GOOGLE_CLIENT_ID;\n\t\tconst clientSecret = process.env.GOOGLE_CLIENT_SECRET;\n\n\t\tif (!clientId || !clientSecret) {\n\t\t\tconsole.error(\"[Gmail] Missing GOOGLE_CLIENT_ID or GOOGLE_CLIENT_SECRET\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst response = await fetch(GOOGLE_TOKEN_URL, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tclient_id: clientId,\n\t\t\t\tclient_secret: clientSecret,\n\t\t\t\trefresh_token: refreshToken,\n\t\t\t\tgrant_type: \"refresh_token\",\n\t\t\t}),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error(`[Gmail] User token refresh failed: ${response.status}`, errorText);\n\n\t\t\t// Log token refresh failure for audit trail\n\t\t\tawait logTokenRefreshFailed(\n\t\t\t\tteamMemberId,\n\t\t\t\t\"Unknown\", // Gmail email not available here\n\t\t\t\t`Token refresh failed: ${response.status} - ${errorText}`\n\t\t\t);\n\n\t\t\tif (response.status === 400 || response.status === 401) {\n\t\t\t\tawait markUserTokenInvalid(teamMemberId, `Refresh failed: ${response.status}`);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tokenResponse: GoogleTokenResponse = await response.json();\n\t\tconst expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000);\n\n\t\t// Encrypt refreshed tokens before storing (CRITICAL SECURITY)\n\t\tconst encryptedAccessToken = encryptToken(tokenResponse.access_token);\n\t\tconst encryptedRefreshToken = tokenResponse.refresh_token\n\t\t\t? encryptToken(tokenResponse.refresh_token)\n\t\t\t: undefined;\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.update({\n\t\t\t\taccess_token: encryptedAccessToken,\n\t\t\t\ttoken_expiry: expiresAt.toISOString(),\n\t\t\t\t...(encryptedRefreshToken && { refresh_token: encryptedRefreshToken }),\n\t\t\t})\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.select(\"*, user_email_accounts!inner(email_address)\")\n\t\t\t.single();\n\n\t\tif (error || !data) {\n\t\t\tconsole.error(\"[Gmail] Failed to update refreshed user token:\", error?.message);\n\t\t\treturn null;\n\t\t}\n\n\t\tconsole.log(`[Gmail] User token refreshed for team member ${teamMemberId}`);\n\n\t\t// Decrypt tokens for return (already encrypted in DB)\n\t\tconst decryptedAccessToken = decryptToken(data.access_token);\n\t\tconst decryptedRefreshToken = decryptToken(data.refresh_token);\n\n\t\treturn {\n\t\t\tteamMemberId: data.team_member_id,\n\t\t\temailAccountId: data.user_email_account_id,\n\t\t\tgmailEmail: data.user_email_accounts.email_address,\n\t\t\taccessToken: decryptedAccessToken,\n\t\t\trefreshToken: decryptedRefreshToken,\n\t\t\ttokenExpiresAt: new Date(data.token_expiry),\n\t\t\tscopes: data.scopes || [],\n\t\t\tsyncEnabled: data.sync_enabled,\n\t\t\tlastSyncedAt: data.last_synced_at ? new Date(data.last_synced_at) : undefined,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] User token refresh error:\", error);\n\t\treturn null;\n\t}\n}\n\nasync function markUserTokenInvalid(teamMemberId: string, reason: string): Promise<void> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.update({ sync_enabled: false })\n\t\t\t.eq(\"team_member_id\", teamMemberId);\n\t\tconsole.log(`[Gmail] Disabled sync for team member ${teamMemberId}: ${reason}`);\n\t} catch (error) {\n\t\tconsole.error(\"[Gmail] Failed to mark user token invalid:\", error);\n\t}\n}\n\n/**\n * Store Gmail OAuth tokens for a team member\n */\nexport async function storeUserGmailTokens(\n\tteamMemberId: string,\n\temailAccountId: string,\n\taccessToken: string,\n\trefreshToken: string,\n\texpiresIn: number,\n\tscopes: string[]\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tif (!scopes.includes(GMAIL_READONLY_SCOPE) && !scopes.includes(GMAIL_MODIFY_SCOPE)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Missing required scope: ${GMAIL_READONLY_SCOPE} or ${GMAIL_MODIFY_SCOPE}`,\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tconst expiresAt = new Date(Date.now() + expiresIn * 1000);\n\n\t\t// Encrypt tokens before storing (CRITICAL SECURITY)\n\t\tconst encryptedAccessToken = encryptToken(accessToken);\n\t\tconst encryptedRefreshToken = encryptToken(refreshToken);\n\n\t\tconst { error } = await supabase.from(\"user_gmail_tokens\").upsert(\n\t\t\t{\n\t\t\t\tteam_member_id: teamMemberId,\n\t\t\t\tuser_email_account_id: emailAccountId,\n\t\t\t\taccess_token: encryptedAccessToken,\n\t\t\t\trefresh_token: encryptedRefreshToken,\n\t\t\t\ttoken_expiry: expiresAt.toISOString(),\n\t\t\t\tscopes,\n\t\t\t\tsync_enabled: true,\n\t\t\t\tlast_synced_at: null,\n\t\t\t},\n\t\t\t{ onConflict: \"user_email_account_id\" }\n\t\t);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Gmail] Failed to store user tokens:\", error.message);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\tconsole.log(`[Gmail] Stored encrypted tokens for team member ${teamMemberId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Disconnect Gmail for a team member\n */\nexport async function disconnectUserGmail(\n\tteamMemberId: string\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Get token to revoke\n\t\tconst { data: tokenData } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.select(\"access_token\")\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.single();\n\n\t\t// Delete from database\n\t\tconst { error } = await supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.delete()\n\t\t\t.eq(\"team_member_id\", teamMemberId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// Revoke token with Google (best effort)\n\t\tif (tokenData?.access_token) {\n\t\t\ttry {\n\t\t\t\tawait fetch(`https://oauth2.googleapis.com/revoke?token=${tokenData.access_token}`, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\tconsole.warn(\"[Gmail] User token revocation request failed (non-critical)\");\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(`[Gmail] Disconnected Gmail for team member ${teamMemberId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n// =============================================================================\n// INBOX FETCHING\n// =============================================================================\n\n/**\n * Fetch inbox messages for a team member\n */\nexport async function fetchUserInbox(\n\tteamMemberId: string,\n\tmaxResults: number = 50,\n\tpageToken?: string\n): Promise<{ messages: GmailMessage[]; nextPageToken?: string; error?: string }> {\n\ttry {\n\t\tconst tokens = await getUserGmailTokens(teamMemberId);\n\t\tif (!tokens) {\n\t\t\treturn { messages: [], error: \"Gmail not connected for this user\" };\n\t\t}\n\n\t\t// Build query parameters\n\t\tconst params = new URLSearchParams({\n\t\t\tmaxResults: maxResults.toString(),\n\t\t\tq: \"in:inbox\", // Only fetch inbox messages\n\t\t\t...(pageToken && { pageToken }),\n\t\t});\n\n\t\t// List messages\n\t\tconst listResponse = await fetch(\n\t\t\t`${GMAIL_API_URL}/users/me/messages?${params}`,\n\t\t\t{\n\t\t\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` },\n\t\t\t}\n\t\t);\n\n\t\tif (!listResponse.ok) {\n\t\t\tconst errorText = await listResponse.text();\n\t\t\tconsole.error(`[Gmail] Inbox fetch failed: ${listResponse.status}`, errorText);\n\t\t\treturn { messages: [], error: `API error: ${listResponse.status}` };\n\t\t}\n\n\t\tconst listData = await listResponse.json();\n\t\tconst messageIds = listData.messages || [];\n\t\tconst messages: GmailMessage[] = [];\n\n\t\t// Fetch full message details for each message\n\t\tfor (const msgRef of messageIds) {\n\t\t\tconst msgResponse = await fetch(\n\t\t\t\t`${GMAIL_API_URL}/users/me/messages/${msgRef.id}`,\n\t\t\t\t{\n\t\t\t\t\theaders: { Authorization: `Bearer ${tokens.accessToken}` },\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (msgResponse.ok) {\n\t\t\t\tconst msgData = await msgResponse.json();\n\t\t\t\tmessages.push(msgData);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmessages,\n\t\t\tnextPageToken: listData.nextPageToken,\n\t\t};\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\tconsole.error(\"[Gmail] Inbox fetch error:\", message);\n\t\treturn { messages: [], error: message };\n\t}\n}\n\n/**\n * Parse Gmail message to structured format\n */\nfunction parseGmailMessage(message: GmailMessage): ParsedGmailMessage {\n\tconst headers = message.payload.headers;\n\tconst getHeader = (name: string) => headers.find(h => h.name.toLowerCase() === name.toLowerCase())?.value || \"\";\n\n\tconst from = getHeader(\"From\");\n\tconst to = getHeader(\"To\").split(\",\").map(e => e.trim()).filter(Boolean);\n\tconst cc = getHeader(\"Cc\")?.split(\",\").map(e => e.trim()).filter(Boolean);\n\tconst subject = getHeader(\"Subject\");\n\n\t// Extract body content\n\tlet textBody: string | undefined;\n\tlet htmlBody: string | undefined;\n\n\tconst extractBody = (part: any): void => {\n\t\tif (part.mimeType === \"text/plain\" && part.body?.data) {\n\t\t\ttextBody = Buffer.from(part.body.data, \"base64\").toString(\"utf-8\");\n\t\t} else if (part.mimeType === \"text/html\" && part.body?.data) {\n\t\t\thtmlBody = Buffer.from(part.body.data, \"base64\").toString(\"utf-8\");\n\t\t}\n\n\t\tif (part.parts) {\n\t\t\tpart.parts.forEach(extractBody);\n\t\t}\n\t};\n\n\tif (message.payload.parts) {\n\t\tmessage.payload.parts.forEach(extractBody);\n\t} else if (message.payload.body?.data) {\n\t\t// Single part message\n\t\tif (message.payload.mimeType === \"text/plain\") {\n\t\t\ttextBody = Buffer.from(message.payload.body.data, \"base64\").toString(\"utf-8\");\n\t\t} else if (message.payload.mimeType === \"text/html\") {\n\t\t\thtmlBody = Buffer.from(message.payload.body.data, \"base64\").toString(\"utf-8\");\n\t\t}\n\t}\n\n\treturn {\n\t\tgmailMessageId: message.id,\n\t\tgmailThreadId: message.threadId,\n\t\tfrom,\n\t\tto,\n\t\tcc,\n\t\tsubject,\n\t\ttextBody,\n\t\thtmlBody,\n\t\treceivedAt: new Date(parseInt(message.internalDate)),\n\t\thasAttachments: message.payload.parts?.some(p => p.body.size > 0 && p.mimeType.startsWith(\"attachment/\")) || false,\n\t\tlabels: message.labelIds,\n\t};\n}\n\n/**\n * Store Gmail message in communications table\n */\nexport async function storeGmailMessage(\n\tcompanyId: string,\n\tteamMemberId: string,\n\temailAccountId: string,\n\tparsedMessage: ParsedGmailMessage\n): Promise<{ success: boolean; communicationId?: string; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Check if message already exists\n\t\tconst { data: existing } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"gmail_message_id\", parsedMessage.gmailMessageId)\n\t\t\t.maybeSingle();\n\n\t\tif (existing) {\n\t\t\treturn { success: true, communicationId: existing.id };\n\t\t}\n\n\t\t// Extract customer email from \"from\" field\n\t\tconst fromEmail = parsedMessage.from.match(/<(.+?)>/)?.[1] || parsedMessage.from;\n\n\t\t// Try to find customer by email\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.eq(\"email\", fromEmail)\n\t\t\t.maybeSingle();\n\n\t\t// Insert communication\n\t\tconst { data: communication, error } = await supabase\n\t\t\t.from(\"communications\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\ttype: \"email\",\n\t\t\t\tdirection: \"inbound\",\n\t\t\t\tstatus: \"received\",\n\t\t\t\tfrom_address: fromEmail,\n\t\t\t\tto_address: parsedMessage.to[0] || \"\",\n\t\t\t\tsubject: parsedMessage.subject,\n\t\t\t\tbody: parsedMessage.htmlBody || parsedMessage.textBody || \"\",\n\t\t\t\tcustomer_id: customer?.id || null,\n\t\t\t\tmailbox_owner_id: teamMemberId,\n\t\t\t\temail_account_id: emailAccountId,\n\t\t\t\tvisibility_scope: \"private\", // Personal inbox emails default to private\n\t\t\t\tgmail_message_id: parsedMessage.gmailMessageId,\n\t\t\t\tgmail_thread_id: parsedMessage.gmailThreadId,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Gmail] Failed to store message:\", error.message);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, communicationId: communication.id };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Sync inbox for a team member\n */\nexport async function syncUserInbox(\n\tcompanyId: string,\n\tteamMemberId: string\n): Promise<InboxSyncResult> {\n\tconst startTime = new Date();\n\tlet messagesFetched = 0;\n\tlet messagesStored = 0;\n\tconst errors: string[] = [];\n\tlet syncLock: ReturnType<typeof acquireSyncLock> = null;\n\n\ttry {\n\t\t// Check rate limit before syncing (CRITICAL SAFEGUARD)\n\t\tconst rateLimitCheck = checkSyncRateLimit(teamMemberId);\n\t\tif (!rateLimitCheck.allowed) {\n\t\t\tawait logAuditEvent(\"sync_rate_limited\", {\n\t\t\t\tteamMemberId,\n\t\t\t\tretryAfter: rateLimitCheck.retryAfter,\n\t\t\t}, \"warning\");\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessagesFetched: 0,\n\t\t\t\tmessagesStored: 0,\n\t\t\t\terrors: [rateLimitCheck.reason || \"Rate limit exceeded\"],\n\t\t\t\tlastSyncedAt: startTime,\n\t\t\t};\n\t\t}\n\n\t\t// Acquire sync lock to prevent concurrent syncs\n\t\tsyncLock = acquireSyncLock(teamMemberId);\n\t\tif (!syncLock) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessagesFetched: 0,\n\t\t\t\tmessagesStored: 0,\n\t\t\t\terrors: [\"Could not acquire sync lock - another sync may be in progress\"],\n\t\t\t\tlastSyncedAt: startTime,\n\t\t\t};\n\t\t}\n\n\t\tawait logAuditEvent(\"sync_started\", { teamMemberId }, \"info\");\n\n\t\tconst tokens = await getUserGmailTokens(teamMemberId);\n\t\tif (!tokens) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessagesFetched: 0,\n\t\t\t\tmessagesStored: 0,\n\t\t\t\terrors: [\"Gmail not connected\"],\n\t\t\t\tlastSyncedAt: startTime,\n\t\t\t};\n\t\t}\n\n\t\t// Fetch messages since last sync (or all if never synced)\n\t\tlet pageToken: string | undefined;\n\t\tlet hasMore = true;\n\n\t\twhile (hasMore) {\n\t\t\tconst { messages, nextPageToken, error } = await fetchUserInbox(\n\t\t\t\tteamMemberId,\n\t\t\t\t50,\n\t\t\t\tpageToken\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\terrors.push(error);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmessagesFetched += messages.length;\n\n\t\t\t// Store each message\n\t\t\tfor (const message of messages) {\n\t\t\t\tconst parsed = parseGmailMessage(message);\n\t\t\t\tconst { success, error: storeError } = await storeGmailMessage(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tteamMemberId,\n\t\t\t\t\ttokens.emailAccountId,\n\t\t\t\t\tparsed\n\t\t\t\t);\n\n\t\t\t\tif (success) {\n\t\t\t\t\tmessagesStored++;\n\t\t\t\t} else if (storeError) {\n\t\t\t\t\terrors.push(storeError);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Continue to next page if available\n\t\t\tpageToken = nextPageToken;\n\t\t\thasMore = !!nextPageToken && messages.length > 0;\n\t\t}\n\n\t\t// Update last synced timestamp\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tawait supabase\n\t\t\t.from(\"user_gmail_tokens\")\n\t\t\t.update({ last_synced_at: startTime.toISOString() })\n\t\t\t.eq(\"team_member_id\", teamMemberId);\n\n\t\tconsole.log(\n\t\t\t`[Gmail] Synced ${messagesStored}/${messagesFetched} messages for team member ${teamMemberId}`\n\t\t);\n\n\t\t// Log successful sync\n\t\tawait logAuditEvent(\"sync_completed\", {\n\t\t\tteamMemberId,\n\t\t\tsyncMessageCount: messagesStored,\n\t\t}, \"info\");\n\n\t\treturn {\n\t\t\tsuccess: errors.length === 0,\n\t\t\tmessagesFetched,\n\t\t\tmessagesStored,\n\t\t\terrors,\n\t\t\tlastSyncedAt: startTime,\n\t\t};\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : \"Unknown error\";\n\t\terrors.push(message);\n\n\t\t// Log failed sync\n\t\tawait logAuditEvent(\"sync_failed\", {\n\t\t\tteamMemberId,\n\t\t\terror: message,\n\t\t}, \"error\");\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessagesFetched,\n\t\t\tmessagesStored,\n\t\t\terrors,\n\t\t\tlastSyncedAt: startTime,\n\t\t};\n\t} finally {\n\t\t// Always release sync lock (CRITICAL)\n\t\tif (syncLock) {\n\t\t\treleaseSyncLock(syncLock);\n\t\t}\n\t}\n}\n\n// =============================================================================\n// INTEGRATION AVAILABILITY CHECK\n// =============================================================================\n\n/**\n * Check if Gmail integration is available (env vars configured)\n */\nexport async function isGmailIntegrationEnabled(): Promise<boolean> {\n\treturn !!(\n\t\tprocess.env.GOOGLE_CLIENT_ID &&\n\t\tprocess.env.GOOGLE_CLIENT_SECRET &&\n\t\tprocess.env.NEXT_PUBLIC_APP_URL\n\t);\n}\n","/**\n * Token Encryption Service\n *\n * Encrypts and decrypts OAuth refresh tokens before storing in database.\n * Uses AES-256-GCM for authenticated encryption.\n *\n * Security Features:\n * - AES-256-GCM authenticated encryption\n * - Unique IV (initialization vector) per token\n * - Authentication tag prevents tampering\n * - Key derivation from environment variable\n *\n * Environment Variables Required:\n * - TOKEN_ENCRYPTION_KEY: 32-byte hex string (64 characters)\n *\n * Generate key with: openssl rand -hex 32\n *\n * CRITICAL: Never commit encryption key to version control!\n */\n\nimport crypto from \"crypto\";\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Encryption algorithm (AES-256-GCM) */\nconst ALGORITHM = \"aes-256-gcm\";\n\n/** IV length in bytes (12 bytes = 96 bits, recommended for GCM) */\nconst IV_LENGTH = 12;\n\n/** Auth tag length in bytes (16 bytes = 128 bits) */\nconst AUTH_TAG_LENGTH = 16;\n\n/** Encoding for encrypted output */\nconst ENCODING = \"base64\";\n\n// =============================================================================\n// KEY MANAGEMENT\n// =============================================================================\n\n/**\n * Get encryption key from environment\n * Throws error if key is missing or invalid\n */\nfunction getEncryptionKey(): Buffer {\n\tconst keyHex = process.env.TOKEN_ENCRYPTION_KEY;\n\n\tif (!keyHex) {\n\t\tthrow new Error(\n\t\t\t\"TOKEN_ENCRYPTION_KEY environment variable not set. Generate with: openssl rand -hex 32\"\n\t\t);\n\t}\n\n\t// Verify key is 32 bytes (64 hex characters)\n\tif (keyHex.length !== 64) {\n\t\tthrow new Error(\n\t\t\t\"TOKEN_ENCRYPTION_KEY must be 32 bytes (64 hex characters). Generate with: openssl rand -hex 32\"\n\t\t);\n\t}\n\n\t// Convert hex string to buffer\n\tconst key = Buffer.from(keyHex, \"hex\");\n\n\tif (key.length !== 32) {\n\t\tthrow new Error(\"Invalid TOKEN_ENCRYPTION_KEY format\");\n\t}\n\n\treturn key;\n}\n\n// =============================================================================\n// ENCRYPTION/DECRYPTION\n// =============================================================================\n\n/**\n * Encrypt a token (refresh token or access token)\n *\n * @param plaintext - Token to encrypt\n * @returns Encrypted token string (format: iv:authTag:ciphertext, all base64)\n *\n * @example\n * const encrypted = encryptToken(\"ya29.a0AfH6SMB...\");\n * // Returns: \"rL8Kx2f...==:gH3pQ9...==:aB4cD5...\"\n */\nexport function encryptToken(plaintext: string): string {\n\ttry {\n\t\tconst key = getEncryptionKey();\n\n\t\t// Generate random IV (never reuse IVs!)\n\t\tconst iv = crypto.randomBytes(IV_LENGTH);\n\n\t\t// Create cipher\n\t\tconst cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n\n\t\t// Encrypt\n\t\tlet ciphertext = cipher.update(plaintext, \"utf8\", ENCODING);\n\t\tciphertext += cipher.final(ENCODING);\n\n\t\t// Get authentication tag\n\t\tconst authTag = cipher.getAuthTag();\n\n\t\t// Return format: iv:authTag:ciphertext (all base64)\n\t\treturn [\n\t\t\tiv.toString(ENCODING),\n\t\t\tauthTag.toString(ENCODING),\n\t\t\tciphertext,\n\t\t].join(\":\");\n\t} catch (error) {\n\t\tconsole.error(\"[Token Encryption] Encryption failed:\", error);\n\t\tthrow new Error(\"Failed to encrypt token\");\n\t}\n}\n\n/**\n * Decrypt a token (refresh token or access token)\n *\n * @param encrypted - Encrypted token string (format: iv:authTag:ciphertext)\n * @returns Decrypted plaintext token\n *\n * @example\n * const plaintext = decryptToken(\"rL8Kx2f...==:gH3pQ9...==:aB4cD5...\");\n * // Returns: \"ya29.a0AfH6SMB...\"\n */\nexport function decryptToken(encrypted: string): string {\n\ttry {\n\t\tconst key = getEncryptionKey();\n\n\t\t// Parse encrypted format: iv:authTag:ciphertext\n\t\tconst parts = encrypted.split(\":\");\n\t\tif (parts.length !== 3) {\n\t\t\tthrow new Error(\"Invalid encrypted token format\");\n\t\t}\n\n\t\tconst [ivBase64, authTagBase64, ciphertext] = parts;\n\n\t\t// Convert from base64\n\t\tconst iv = Buffer.from(ivBase64, ENCODING);\n\t\tconst authTag = Buffer.from(authTagBase64, ENCODING);\n\n\t\t// Verify lengths\n\t\tif (iv.length !== IV_LENGTH) {\n\t\t\tthrow new Error(\"Invalid IV length\");\n\t\t}\n\n\t\tif (authTag.length !== AUTH_TAG_LENGTH) {\n\t\t\tthrow new Error(\"Invalid auth tag length\");\n\t\t}\n\n\t\t// Create decipher\n\t\tconst decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n\t\tdecipher.setAuthTag(authTag);\n\n\t\t// Decrypt\n\t\tlet plaintext = decipher.update(ciphertext, ENCODING, \"utf8\");\n\t\tplaintext += decipher.final(\"utf8\");\n\n\t\treturn plaintext;\n\t} catch (error) {\n\t\tconsole.error(\"[Token Encryption] Decryption failed:\", error);\n\t\tthrow new Error(\"Failed to decrypt token\");\n\t}\n}\n\n// =============================================================================\n// HELPERS\n// =============================================================================\n\n/**\n * Check if encryption key is configured\n * @returns True if key is set and valid\n */\nexport function isEncryptionConfigured(): boolean {\n\ttry {\n\t\tgetEncryptionKey();\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Test encryption/decryption round-trip\n * Useful for validating configuration\n *\n * @returns True if encryption works correctly\n */\nexport function testEncryption(): boolean {\n\ttry {\n\t\tconst testToken = \"test_token_\" + crypto.randomBytes(32).toString(\"hex\");\n\t\tconst encrypted = encryptToken(testToken);\n\t\tconst decrypted = decryptToken(encrypted);\n\n\t\treturn decrypted === testToken;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Migrate existing plaintext tokens to encrypted format\n *\n * IMPORTANT: Run this as a one-time migration script\n * DO NOT run in production without backup!\n *\n * @example\n * // In a migration script:\n * await migrateTokensToEncrypted();\n */\nexport async function migrateTokensToEncrypted() {\n\t// This would be implemented as a standalone migration script\n\t// NOT included here to prevent accidental execution\n\tconsole.warn(\n\t\t\"[Token Encryption] Migration must be run as standalone script\"\n\t);\n\tthrow new Error(\"Use standalone migration script\");\n}\n\n// =============================================================================\n// WRAPPER FUNCTIONS FOR BACKWARD COMPATIBILITY\n// =============================================================================\n\n/**\n * Encrypt token with fallback for dev/test environments\n *\n * If encryption key not configured, returns plaintext (dev only!)\n * Production should always have encryption key configured\n */\nexport function encryptTokenSafe(plaintext: string): string {\n\tif (!isEncryptionConfigured()) {\n\t\tconsole.warn(\n\t\t\t\"[Token Encryption] Encryption key not configured - storing plaintext (DEV ONLY)\"\n\t\t);\n\t\treturn plaintext;\n\t}\n\n\treturn encryptToken(plaintext);\n}\n\n/**\n * Decrypt token with fallback for migration period\n *\n * If decryption fails (likely plaintext), returns as-is\n * Allows gradual migration from plaintext to encrypted\n */\nexport function decryptTokenSafe(encrypted: string): string {\n\tif (!isEncryptionConfigured()) {\n\t\tconsole.warn(\n\t\t\t\"[Token Encryption] Encryption key not configured - returning plaintext (DEV ONLY)\"\n\t\t);\n\t\treturn encrypted;\n\t}\n\n\t// Check if token is already encrypted (contains colons)\n\tif (!encrypted.includes(\":\")) {\n\t\tconsole.warn(\n\t\t\t\"[Token Encryption] Token appears to be plaintext - returning as-is (MIGRATION MODE)\"\n\t\t);\n\t\treturn encrypted;\n\t}\n\n\ttry {\n\t\treturn decryptToken(encrypted);\n\t} catch (error) {\n\t\tconsole.error(\n\t\t\t\"[Token Encryption] Decryption failed, returning plaintext:\",\n\t\t\terror\n\t\t);\n\t\treturn encrypted;\n\t}\n}\n","/**\n * Gmail API Rate Limiter\n *\n * Prevents Gmail API quota exhaustion and abuse by implementing rate limits\n * at multiple levels: per-user, per-company, and global.\n *\n * Gmail API Quotas (Google-imposed):\n * - 1 billion quota units per day (project-wide)\n * - 250 quota units/user/second\n * - messages.get = 5 units, messages.list = 5 units\n *\n * Our Limits:\n * - Per-user: 1 sync every 5 minutes (max 12 syncs/hour)\n * - Per-user: Max 100 messages per sync\n * - Global: Max 10 concurrent syncs\n * - API endpoints: 60 requests/minute per user\n *\n * Implementation:\n * - In-memory rate limiting with Map (resets on server restart)\n * - Redis for distributed rate limiting (optional, for multi-server)\n * - Automatic cleanup of stale entries\n *\n * @see https://developers.google.com/gmail/api/reference/quota\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\ninterface RateLimitEntry {\n\tcount: number;\n\tfirstRequest: number;\n\tlastRequest: number;\n}\n\ninterface SyncLock {\n\tteamMemberId: string;\n\tstartedAt: number;\n\texpiresAt: number;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Minimum time between syncs per user (5 minutes) */\nconst SYNC_COOLDOWN_MS = 5 * 60 * 1000;\n\n/** Maximum messages per sync */\nconst MAX_MESSAGES_PER_SYNC = 100;\n\n/** Maximum concurrent syncs globally */\nconst MAX_CONCURRENT_SYNCS = 10;\n\n/** API rate limit: requests per window */\nconst API_RATE_LIMIT = 60;\n\n/** API rate limit window (1 minute) */\nconst API_RATE_WINDOW_MS = 60 * 1000;\n\n/** How long to keep rate limit entries in memory */\nconst RATE_LIMIT_CLEANUP_MS = 60 * 60 * 1000; // 1 hour\n\n/** How long a sync lock is valid (30 minutes max) */\nconst SYNC_LOCK_TIMEOUT_MS = 30 * 60 * 1000;\n\n// =============================================================================\n// IN-MEMORY STORAGE\n// =============================================================================\n\n/** Per-user API rate limits */\nconst apiRateLimits = new Map<string, RateLimitEntry>();\n\n/** Per-user last sync timestamps */\nconst lastSyncTimes = new Map<string, number>();\n\n/** Active sync locks */\nconst activeSyncLocks = new Set<SyncLock>();\n\n/** Cleanup interval */\nlet cleanupInterval: NodeJS.Timeout | null = null;\n\n// =============================================================================\n// RATE LIMIT CHECKING\n// =============================================================================\n\n/**\n * Check if user can make an API request\n *\n * @param userId - User ID (team_member_id)\n * @returns { allowed: boolean, retryAfter?: number }\n */\nexport function checkApiRateLimit(userId: string): {\n\tallowed: boolean;\n\tretryAfter?: number;\n} {\n\tconst now = Date.now();\n\tconst entry = apiRateLimits.get(userId);\n\n\tif (!entry) {\n\t\t// First request - allow and record\n\t\tapiRateLimits.set(userId, {\n\t\t\tcount: 1,\n\t\t\tfirstRequest: now,\n\t\t\tlastRequest: now,\n\t\t});\n\t\treturn { allowed: true };\n\t}\n\n\t// Check if window has expired\n\tconst windowAge = now - entry.firstRequest;\n\tif (windowAge > API_RATE_WINDOW_MS) {\n\t\t// Window expired - reset counter\n\t\tapiRateLimits.set(userId, {\n\t\t\tcount: 1,\n\t\t\tfirstRequest: now,\n\t\t\tlastRequest: now,\n\t\t});\n\t\treturn { allowed: true };\n\t}\n\n\t// Within window - check limit\n\tif (entry.count >= API_RATE_LIMIT) {\n\t\t// Rate limit exceeded\n\t\tconst retryAfter = Math.ceil(\n\t\t\t(entry.firstRequest + API_RATE_WINDOW_MS - now) / 1000\n\t\t);\n\t\treturn { allowed: false, retryAfter };\n\t}\n\n\t// Increment counter\n\tentry.count++;\n\tentry.lastRequest = now;\n\tapiRateLimits.set(userId, entry);\n\n\treturn { allowed: true };\n}\n\n/**\n * Check if user can start a sync\n *\n * @param teamMemberId - Team member ID\n * @returns { allowed: boolean, reason?: string, retryAfter?: number }\n */\nexport function checkSyncRateLimit(teamMemberId: string): {\n\tallowed: boolean;\n\treason?: string;\n\tretryAfter?: number;\n} {\n\tconst now = Date.now();\n\n\t// Check sync cooldown\n\tconst lastSync = lastSyncTimes.get(teamMemberId);\n\tif (lastSync) {\n\t\tconst timeSinceLastSync = now - lastSync;\n\t\tif (timeSinceLastSync < SYNC_COOLDOWN_MS) {\n\t\t\tconst retryAfter = Math.ceil(\n\t\t\t\t(SYNC_COOLDOWN_MS - timeSinceLastSync) / 1000\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tallowed: false,\n\t\t\t\treason: \"Sync cooldown active\",\n\t\t\t\tretryAfter,\n\t\t\t};\n\t\t}\n\t}\n\n\t// Check concurrent sync limit\n\tconst activeCount = getActiveSyncCount();\n\tif (activeCount >= MAX_CONCURRENT_SYNCS) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\treason: \"Maximum concurrent syncs reached\",\n\t\t\tretryAfter: 60, // Retry in 1 minute\n\t\t};\n\t}\n\n\t// Check if user already has active sync\n\tconst existingLock = Array.from(activeSyncLocks).find(\n\t\t(lock) => lock.teamMemberId === teamMemberId\n\t);\n\n\tif (existingLock) {\n\t\t// Check if lock is expired\n\t\tif (now > existingLock.expiresAt) {\n\t\t\t// Lock expired - remove it\n\t\t\tactiveSyncLocks.delete(existingLock);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tallowed: false,\n\t\t\t\treason: \"Sync already in progress\",\n\t\t\t\tretryAfter: Math.ceil((existingLock.expiresAt - now) / 1000),\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { allowed: true };\n}\n\n// =============================================================================\n// SYNC LOCK MANAGEMENT\n// =============================================================================\n\n/**\n * Acquire a sync lock for a user\n *\n * @param teamMemberId - Team member ID\n * @returns Lock ID if acquired, null if failed\n */\nexport function acquireSyncLock(teamMemberId: string): SyncLock | null {\n\tconst check = checkSyncRateLimit(teamMemberId);\n\tif (!check.allowed) {\n\t\treturn null;\n\t}\n\n\tconst now = Date.now();\n\tconst lock: SyncLock = {\n\t\tteamMemberId,\n\t\tstartedAt: now,\n\t\texpiresAt: now + SYNC_LOCK_TIMEOUT_MS,\n\t};\n\n\tactiveSyncLocks.add(lock);\n\tlastSyncTimes.set(teamMemberId, now);\n\n\treturn lock;\n}\n\n/**\n * Release a sync lock\n *\n * @param lock - Lock to release\n */\nexport function releaseSyncLock(lock: SyncLock): void {\n\tactiveSyncLocks.delete(lock);\n}\n\n/**\n * Get count of active syncs\n */\nexport function getActiveSyncCount(): number {\n\t// Clean up expired locks first\n\tconst now = Date.now();\n\tfor (const lock of activeSyncLocks) {\n\t\tif (now > lock.expiresAt) {\n\t\t\tactiveSyncLocks.delete(lock);\n\t\t}\n\t}\n\n\treturn activeSyncLocks.size;\n}\n\n// =============================================================================\n// CLEANUP\n// =============================================================================\n\n/**\n * Clean up stale rate limit entries\n */\nfunction cleanup(): void {\n\tconst now = Date.now();\n\n\t// Clean API rate limits\n\tfor (const [userId, entry] of apiRateLimits.entries()) {\n\t\tconst age = now - entry.lastRequest;\n\t\tif (age > RATE_LIMIT_CLEANUP_MS) {\n\t\t\tapiRateLimits.delete(userId);\n\t\t}\n\t}\n\n\t// Clean last sync times\n\tfor (const [userId, lastSync] of lastSyncTimes.entries()) {\n\t\tconst age = now - lastSync;\n\t\tif (age > RATE_LIMIT_CLEANUP_MS) {\n\t\t\tlastSyncTimes.delete(userId);\n\t\t}\n\t}\n\n\t// Clean expired sync locks\n\tfor (const lock of activeSyncLocks) {\n\t\tif (now > lock.expiresAt) {\n\t\t\tactiveSyncLocks.delete(lock);\n\t\t}\n\t}\n}\n\n/**\n * Start automatic cleanup\n */\nexport function startCleanup(): void {\n\tif (cleanupInterval) {\n\t\treturn; // Already started\n\t}\n\n\t// Run cleanup every 5 minutes\n\tcleanupInterval = setInterval(cleanup, 5 * 60 * 1000);\n\n\tconsole.log(\"[Gmail Rate Limiter] Cleanup scheduled\");\n}\n\n/**\n * Stop automatic cleanup\n */\nexport function stopCleanup(): void {\n\tif (cleanupInterval) {\n\t\tclearInterval(cleanupInterval);\n\t\tcleanupInterval = null;\n\t}\n}\n\n// =============================================================================\n// VALIDATION\n// =============================================================================\n\n/**\n * Validate sync request parameters\n *\n * @param maxResults - Requested message count\n * @returns { valid: boolean, error?: string }\n */\nexport function validateSyncParams(maxResults: number): {\n\tvalid: boolean;\n\terror?: string;\n} {\n\tif (maxResults <= 0) {\n\t\treturn { valid: false, error: \"maxResults must be positive\" };\n\t}\n\n\tif (maxResults > MAX_MESSAGES_PER_SYNC) {\n\t\treturn {\n\t\t\tvalid: false,\n\t\t\terror: `maxResults cannot exceed ${MAX_MESSAGES_PER_SYNC}`,\n\t\t};\n\t}\n\n\treturn { valid: true };\n}\n\n// =============================================================================\n// STATISTICS\n// =============================================================================\n\n/**\n * Get rate limiter statistics\n */\nexport function getRateLimiterStats(): {\n\tapiRateLimits: number;\n\tlastSyncTimes: number;\n\tactiveSyncs: number;\n\tmaxConcurrentSyncs: number;\n} {\n\treturn {\n\t\tapiRateLimits: apiRateLimits.size,\n\t\tlastSyncTimes: lastSyncTimes.size,\n\t\tactiveSyncs: getActiveSyncCount(),\n\t\tmaxConcurrentSyncs: MAX_CONCURRENT_SYNCS,\n\t};\n}\n\n/**\n * Reset all rate limits (for testing only!)\n */\nexport function resetRateLimits(): void {\n\tapiRateLimits.clear();\n\tlastSyncTimes.clear();\n\tactiveSyncLocks.clear();\n\tconsole.warn(\"[Gmail Rate Limiter] All rate limits reset\");\n}\n\n// =============================================================================\n// INITIALIZATION\n// =============================================================================\n\n// Start cleanup on module load\nstartCleanup();\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\nexport const RATE_LIMITS = {\n\tSYNC_COOLDOWN_MS,\n\tMAX_MESSAGES_PER_SYNC,\n\tMAX_CONCURRENT_SYNCS,\n\tAPI_RATE_LIMIT,\n\tAPI_RATE_WINDOW_MS,\n} as const;\n","/**\n * Email Security Audit Logger\n *\n * Logs security-relevant events for compliance, investigation, and monitoring.\n * All logs are stored in the database with retention policies.\n *\n * Events Logged:\n * - Gmail connections/disconnections\n * - Token refresh failures\n * - Permission grants/revokes\n * - Sync errors\n * - Email access (optional, for compliance)\n *\n * Usage:\n * await logAuditEvent('gmail_connected', { teamMemberId, email });\n * await logAuditEvent('permission_granted', { grantedBy, grantedTo, category });\n *\n * Database Table: email_audit_log (to be created)\n *\n * @see /docs/email/SECURITY_AUDIT.md\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport type { EmailCategory } from \"./email-permissions\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Audit event types\n */\nexport type AuditEventType =\n\t// Gmail OAuth events\n\t| \"gmail_connected\"\n\t| \"gmail_disconnected\"\n\t| \"gmail_token_refreshed\"\n\t| \"gmail_token_refresh_failed\"\n\t| \"gmail_token_revoked\"\n\t// Permission events\n\t| \"permission_granted\"\n\t| \"permission_revoked\"\n\t| \"permission_updated\"\n\t| \"permission_check_failed\"\n\t// Sync events\n\t| \"sync_started\"\n\t| \"sync_completed\"\n\t| \"sync_failed\"\n\t| \"sync_rate_limited\"\n\t// Email access events (optional)\n\t| \"email_accessed\"\n\t| \"email_sent\"\n\t| \"email_assigned\"\n\t// Security events\n\t| \"unauthorized_access_attempt\"\n\t| \"permission_escalation_attempt\"\n\t| \"invalid_oauth_state\"\n\t// System events\n\t| \"token_cleanup_executed\"\n\t| \"rate_limit_exceeded\";\n\n/**\n * Audit event severity levels\n */\nexport type AuditSeverity = \"info\" | \"warning\" | \"error\" | \"critical\";\n\n/**\n * Audit event metadata\n */\nexport interface AuditEventMetadata {\n\t// Common fields\n\tteamMemberId?: string;\n\tcompanyId?: string;\n\tuserId?: string; // auth.uid\n\tuserName?: string;\n\n\t// Gmail fields\n\tgmailEmail?: string;\n\tgmailMessageId?: string;\n\tsyncMessageCount?: number;\n\n\t// Permission fields\n\tcategory?: EmailCategory;\n\tgrantedBy?: string;\n\tgrantedTo?: string;\n\tcanRead?: boolean;\n\tcanSend?: boolean;\n\tcanAssign?: boolean;\n\n\t// Email fields\n\tcommunicationId?: string;\n\temailSubject?: string;\n\tfromAddress?: string;\n\ttoAddress?: string;\n\n\t// Error fields\n\terror?: string;\n\terrorCode?: string;\n\tstackTrace?: string;\n\n\t// Rate limiting\n\tretryAfter?: number;\n\trequestsPerMinute?: number;\n\n\t// Additional context\n\tipAddress?: string;\n\tuserAgent?: string;\n\t[key: string]: any;\n}\n\n/**\n * Audit event record\n */\nexport interface AuditEvent {\n\tid: string;\n\teventType: AuditEventType;\n\tseverity: AuditSeverity;\n\tmessage: string;\n\tmetadata: AuditEventMetadata;\n\tcreatedAt: string;\n}\n\n// =============================================================================\n// LOGGING FUNCTIONS\n// =============================================================================\n\n/**\n * Log an audit event\n *\n * @param eventType - Type of event\n * @param metadata - Event metadata\n * @param severity - Event severity (default: info)\n * @param message - Optional custom message\n *\n * @example\n * await logAuditEvent('gmail_connected', {\n *   teamMemberId: 'xxx',\n *   gmailEmail: 'user@gmail.com'\n * });\n */\nexport async function logAuditEvent(\n\teventType: AuditEventType,\n\tmetadata: AuditEventMetadata = {},\n\tseverity: AuditSeverity = \"info\",\n\tmessage?: string\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\t// Generate default message if not provided\n\t\tconst defaultMessage = generateDefaultMessage(eventType, metadata);\n\n\t\t// In production, store in database\n\t\t// For now, log to console with structured format\n\t\tconst logEntry = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\teventType,\n\t\t\tseverity,\n\t\t\tmessage: message || defaultMessage,\n\t\t\tmetadata,\n\t\t};\n\n\t\t// Console output with color coding\n\t\tconst prefix = `[Email Audit]`;\n\t\tconst severityEmoji = {\n\t\t\tinfo: \"\",\n\t\t\twarning: \"\",\n\t\t\terror: \"\",\n\t\t\tcritical: \"\",\n\t\t}[severity];\n\n\t\tconsole.log(\n\t\t\t`${prefix} ${severityEmoji} [${severity.toUpperCase()}] ${logEntry.message}`,\n\t\t\tmetadata\n\t\t);\n\n\t\t// Store in database\n\t\ttry {\n\t\t\tconst supabase = await createServiceSupabaseClient();\n\t\t\tif (supabase) {\n\t\t\t\tawait supabase.from(\"email_audit_log\").insert({\n\t\t\t\t\tcompany_id: metadata.companyId || null,\n\t\t\t\t\tevent_type: eventType,\n\t\t\t\t\tseverity,\n\t\t\t\t\tmessage: logEntry.message,\n\t\t\t\t\tteam_member_id: metadata.teamMemberId || null,\n\t\t\t\t\tuser_id: metadata.userId || null,\n\t\t\t\t\tgmail_email: metadata.gmailEmail || null,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tip_address: metadata.ipAddress || null,\n\t\t\t\t\tuser_agent: metadata.userAgent || null,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (dbError) {\n\t\t\t// Don't fail the audit log if database write fails - console log is still captured\n\t\t\tconsole.error(\"[Email Audit] Failed to store in database:\", dbError);\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to log event:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Generate default message for event type\n */\nfunction generateDefaultMessage(\n\teventType: AuditEventType,\n\tmetadata: AuditEventMetadata\n): string {\n\tconst name = metadata.userName || metadata.teamMemberId || \"User\";\n\n\tswitch (eventType) {\n\t\tcase \"gmail_connected\":\n\t\t\treturn `${name} connected Gmail account (${metadata.gmailEmail})`;\n\t\tcase \"gmail_disconnected\":\n\t\t\treturn `${name} disconnected Gmail account (${metadata.gmailEmail})`;\n\t\tcase \"gmail_token_refreshed\":\n\t\t\treturn `Gmail token refreshed for ${metadata.gmailEmail}`;\n\t\tcase \"gmail_token_refresh_failed\":\n\t\t\treturn `Failed to refresh Gmail token for ${metadata.gmailEmail}: ${metadata.error}`;\n\t\tcase \"gmail_token_revoked\":\n\t\t\treturn `Gmail token revoked for ${metadata.gmailEmail}`;\n\n\t\tcase \"permission_granted\":\n\t\t\treturn `${metadata.grantedBy} granted ${metadata.category} permissions to ${metadata.grantedTo}`;\n\t\tcase \"permission_revoked\":\n\t\t\treturn `${metadata.grantedBy} revoked ${metadata.category} permissions from ${metadata.grantedTo}`;\n\t\tcase \"permission_updated\":\n\t\t\treturn `${metadata.grantedBy} updated ${metadata.category} permissions for ${metadata.grantedTo}`;\n\t\tcase \"permission_check_failed\":\n\t\t\treturn `Permission check failed for ${name}: ${metadata.error}`;\n\n\t\tcase \"sync_started\":\n\t\t\treturn `${name} started inbox sync`;\n\t\tcase \"sync_completed\":\n\t\t\treturn `${name} completed inbox sync (${metadata.syncMessageCount} messages)`;\n\t\tcase \"sync_failed\":\n\t\t\treturn `Inbox sync failed for ${name}: ${metadata.error}`;\n\t\tcase \"sync_rate_limited\":\n\t\t\treturn `${name} sync rate limited (retry after ${metadata.retryAfter}s)`;\n\n\t\tcase \"email_accessed\":\n\t\t\treturn `${name} accessed email: ${metadata.emailSubject}`;\n\t\tcase \"email_sent\":\n\t\t\treturn `${name} sent email to ${metadata.toAddress}: ${metadata.emailSubject}`;\n\t\tcase \"email_assigned\":\n\t\t\treturn `${name} assigned email to ${metadata.grantedTo}`;\n\n\t\tcase \"unauthorized_access_attempt\":\n\t\t\treturn `Unauthorized access attempt by ${name}: ${metadata.error}`;\n\t\tcase \"permission_escalation_attempt\":\n\t\t\treturn `Permission escalation attempt by ${name}: ${metadata.error}`;\n\t\tcase \"invalid_oauth_state\":\n\t\t\treturn `Invalid OAuth state detected: ${metadata.error}`;\n\n\t\tcase \"token_cleanup_executed\":\n\t\t\treturn `Token cleanup executed: ${metadata.syncMessageCount} tokens removed`;\n\t\tcase \"rate_limit_exceeded\":\n\t\t\treturn `Rate limit exceeded for ${name} (${metadata.requestsPerMinute} req/min)`;\n\n\t\tdefault:\n\t\t\treturn `${eventType} event for ${name}`;\n\t}\n}\n\n// =============================================================================\n// CONVENIENCE FUNCTIONS\n// =============================================================================\n\n/**\n * Log Gmail connection\n */\nexport async function logGmailConnected(\n\tteamMemberId: string,\n\tuserName: string,\n\tgmailEmail: string,\n\tcompanyId: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"gmail_connected\",\n\t\t{ teamMemberId, userName, gmailEmail, companyId },\n\t\t\"info\"\n\t);\n}\n\n/**\n * Log Gmail disconnection\n */\nexport async function logGmailDisconnected(\n\tteamMemberId: string,\n\tuserName: string,\n\tgmailEmail: string,\n\tcompanyId: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"gmail_disconnected\",\n\t\t{ teamMemberId, userName, gmailEmail, companyId },\n\t\t\"info\"\n\t);\n}\n\n/**\n * Log token refresh failure\n */\nexport async function logTokenRefreshFailed(\n\tteamMemberId: string,\n\tgmailEmail: string,\n\terror: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"gmail_token_refresh_failed\",\n\t\t{ teamMemberId, gmailEmail, error },\n\t\t\"warning\"\n\t);\n}\n\n/**\n * Log permission grant\n */\nexport async function logPermissionGranted(\n\tgrantedBy: string,\n\tgrantedByName: string,\n\tgrantedTo: string,\n\tgrantedToName: string,\n\tcategory: EmailCategory,\n\tcompanyId: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"permission_granted\",\n\t\t{\n\t\t\tgrantedBy,\n\t\t\tuserName: grantedByName,\n\t\t\tgrantedTo,\n\t\t\tcategory,\n\t\t\tcompanyId,\n\t\t},\n\t\t\"info\"\n\t);\n}\n\n/**\n * Log permission revocation\n */\nexport async function logPermissionRevoked(\n\trevokedBy: string,\n\trevokedByName: string,\n\trevokedFrom: string,\n\trevokedFromName: string,\n\tcategory: EmailCategory,\n\tcompanyId: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"permission_revoked\",\n\t\t{\n\t\t\tgrantedBy: revokedBy,\n\t\t\tuserName: revokedByName,\n\t\t\tgrantedTo: revokedFrom,\n\t\t\tcategory,\n\t\t\tcompanyId,\n\t\t},\n\t\t\"info\"\n\t);\n}\n\n/**\n * Log sync failure\n */\nexport async function logSyncFailed(\n\tteamMemberId: string,\n\tuserName: string,\n\tgmailEmail: string,\n\terror: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"sync_failed\",\n\t\t{ teamMemberId, userName, gmailEmail, error },\n\t\t\"error\"\n\t);\n}\n\n/**\n * Log unauthorized access attempt\n */\nexport async function logUnauthorizedAccess(\n\tuserId: string,\n\tuserName: string,\n\tresource: string,\n\terror: string\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"unauthorized_access_attempt\",\n\t\t{ userId, userName, error, communicationId: resource },\n\t\t\"warning\"\n\t);\n}\n\n/**\n * Log rate limit exceeded\n */\nexport async function logRateLimitExceeded(\n\tuserId: string,\n\tuserName: string,\n\trequestsPerMinute: number,\n\tretryAfter: number\n): Promise<void> {\n\tawait logAuditEvent(\n\t\t\"rate_limit_exceeded\",\n\t\t{ userId, userName, requestsPerMinute, retryAfter },\n\t\t\"warning\"\n\t);\n}\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get audit events for a team member\n *\n * @param teamMemberId - Team member ID\n * @param limit - Max events to return\n * @returns List of audit events\n */\nexport async function getAuditEventsForUser(\n\tteamMemberId: string,\n\tlimit: number = 100\n): Promise<AuditEvent[]> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tif (!supabase) return [];\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_audit_log\")\n\t\t\t.select(\"id, event_type, severity, message, metadata, created_at\")\n\t\t\t.eq(\"team_member_id\", teamMemberId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Email Audit] Failed to query events for user:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []).map((row) => ({\n\t\t\tid: row.id,\n\t\t\teventType: row.event_type as AuditEventType,\n\t\t\tseverity: row.severity as AuditSeverity,\n\t\t\tmessage: row.message,\n\t\t\tmetadata: row.metadata || {},\n\t\t\tcreatedAt: row.created_at,\n\t\t}));\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to query events for user:\", error);\n\t\treturn [];\n\t}\n}\n\n/**\n * Get audit events for a company\n *\n * @param companyId - Company ID\n * @param limit - Max events to return\n * @returns List of audit events\n */\nexport async function getAuditEventsForCompany(\n\tcompanyId: string,\n\tlimit: number = 100\n): Promise<AuditEvent[]> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tif (!supabase) return [];\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_audit_log\")\n\t\t\t.select(\"id, event_type, severity, message, metadata, created_at\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Email Audit] Failed to query events for company:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []).map((row) => ({\n\t\t\tid: row.id,\n\t\t\teventType: row.event_type as AuditEventType,\n\t\t\tseverity: row.severity as AuditSeverity,\n\t\t\tmessage: row.message,\n\t\t\tmetadata: row.metadata || {},\n\t\t\tcreatedAt: row.created_at,\n\t\t}));\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to query events for company:\", error);\n\t\treturn [];\n\t}\n}\n\n/**\n * Get critical security events\n *\n * @param limit - Max events to return\n * @returns List of critical events\n */\nexport async function getCriticalSecurityEvents(\n\tlimit: number = 50\n): Promise<AuditEvent[]> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\t\tif (!supabase) return [];\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_audit_log\")\n\t\t\t.select(\"id, event_type, severity, message, metadata, created_at\")\n\t\t\t.in(\"severity\", [\"error\", \"critical\"])\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(limit);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"[Email Audit] Failed to query critical events:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []).map((row) => ({\n\t\t\tid: row.id,\n\t\t\teventType: row.event_type as AuditEventType,\n\t\t\tseverity: row.severity as AuditSeverity,\n\t\t\tmessage: row.message,\n\t\t\tmetadata: row.metadata || {},\n\t\t\tcreatedAt: row.created_at,\n\t\t}));\n\t} catch (error) {\n\t\tconsole.error(\"[Email Audit] Failed to query critical events:\", error);\n\t\treturn [];\n\t}\n}\n","/**\n * Email Provider Abstraction Layer\n *\n * This module provides a unified interface for sending emails through multiple\n * providers (Resend and Postmark) with automatic fallback support.\n *\n * Architecture:\n * \n *                     Email Provider Layer                         \n * \n *   1. Try Primary Provider (Resend)                               \n *       Success  Return result, log to monitor                  \n *       Failure  Try Fallback                                   \n *   2. Try Fallback Provider (Postmark)                            \n *       Success  Return result, log to monitor                  \n *       Failure  Return error with both provider failures       \n * \n *\n * Features:\n * - Automatic fallback when primary provider fails\n * - Health monitoring for both providers\n * - Unified response format\n * - Comprehensive logging for debugging\n * - Provider-agnostic interface for email operations\n *\n * Usage:\n * ```typescript\n * import { sendEmailWithFallback } from \"@/lib/email/email-provider\";\n *\n * const result = await sendEmailWithFallback({\n *   to: \"user@example.com\",\n *   subject: \"Welcome!\",\n *   html: \"<h1>Hello</h1>\",\n * });\n * ```\n */\n\nimport { emailConfig, isResendConfigured, resend } from \"./resend-client\";\nimport {\n\tpostmarkConfig,\n\tisPostmarkConfigured,\n\tsendPostmarkEmail,\n\tcheckPostmarkHealth,\n\ttype PostmarkResponse,\n} from \"./postmark-client\";\nimport {\n\tsendCompanyGmailEmail,\n\tgetCompanyGmailTokens,\n\tgetCompanyEmailProvider,\n\tcheckCompanyGmailHealth,\n\tisGmailIntegrationEnabled,\n\ttype CompanyEmailProvider,\n\ttype GmailSendResult,\n} from \"./gmail-client\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Supported email providers\n * - resend: Primary managed provider (high deliverability, company branding)\n * - postmark: Fallback managed provider (automatic failover)\n * - gmail: User's personal Gmail account (requires OAuth connection)\n */\nexport type EmailProvider = \"resend\" | \"postmark\" | \"gmail\";\n\n/**\n * Email send options - provider-agnostic interface\n */\n/** Attachment type for email */\nexport interface EmailAttachment {\n\tfilename: string;\n\tcontent: string; // Base64 encoded content\n\tcontentType?: string;\n}\n\nexport interface EmailSendOptions {\n\t/** Recipient email address(es) */\n\tto: string | string[];\n\t/** Email subject line */\n\tsubject: string;\n\t/** HTML body content */\n\thtml: string;\n\t/** Plain text body (optional, auto-generated if not provided) */\n\ttext?: string;\n\t/** From address (uses provider default if not specified) */\n\tfrom?: string;\n\t/** Reply-to address */\n\treplyTo?: string;\n\t/** Tags for categorization and tracking */\n\ttags?: Record<string, string>;\n\t/** Communication ID for internal tracking */\n\tcommunicationId?: string;\n\t/** Company ID - required for checking company email provider preference */\n\tcompanyId?: string;\n\t/** CC recipients */\n\tcc?: string | string[];\n\t/** BCC recipients */\n\tbcc?: string | string[];\n\t/** Email attachments */\n\tattachments?: EmailAttachment[];\n}\n\n/**\n * Result of sending an email through the provider layer\n */\nexport interface EmailProviderResult {\n\t/** Whether the email was sent successfully */\n\tsuccess: boolean;\n\t/** The provider that successfully sent the email */\n\tprovider?: EmailProvider;\n\t/** Message ID from the provider */\n\tmessageId?: string;\n\t/** Error message if failed */\n\terror?: string;\n\t/** Whether fallback was used */\n\tusedFallback?: boolean;\n\t/** Detailed results from each provider attempt */\n\tattempts: Array<{\n\t\tprovider: EmailProvider;\n\t\tsuccess: boolean;\n\t\tmessageId?: string;\n\t\terror?: string;\n\t\tlatencyMs: number;\n\t}>;\n}\n\n/**\n * Provider health status\n */\nexport interface ProviderHealthStatus {\n\tprovider: EmailProvider;\n\thealthy: boolean;\n\tlatencyMs: number;\n\tlastChecked: Date;\n\terror?: string;\n}\n\n/**\n * Combined health status for all providers\n */\nexport interface AllProvidersHealth {\n\tprimary: ProviderHealthStatus | null;\n\tfallback: ProviderHealthStatus | null;\n\trecommendedProvider: EmailProvider | null;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\n/**\n * Provider configuration\n * Determines which provider is primary and which is fallback\n */\nexport const providerConfig = {\n\t/** Primary provider - tried first */\n\tprimary: \"resend\" as EmailProvider,\n\t/** Fallback provider - used if primary fails */\n\tfallback: \"postmark\" as EmailProvider,\n\t/** Enable automatic fallback on failure */\n\tenableFallback: true,\n\t/** Log all provider operations for monitoring */\n\tenableLogging: true,\n\t/** Retry count before falling back (0 = immediate fallback) */\n\tprimaryRetries: 0,\n};\n\n// =============================================================================\n// PROVIDER AVAILABILITY\n// =============================================================================\n\n/**\n * Check if a specific provider is configured and available\n *\n * @param provider - Provider to check\n * @returns Whether the provider is available\n */\nexport function isProviderConfigured(provider: EmailProvider): boolean {\n\tswitch (provider) {\n\t\tcase \"resend\":\n\t\t\treturn isResendConfigured();\n\t\tcase \"postmark\":\n\t\t\treturn isPostmarkConfigured();\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Get list of all configured providers\n *\n * @returns Array of configured provider names\n */\nexport function getConfiguredProviders(): EmailProvider[] {\n\tconst providers: EmailProvider[] = [];\n\n\tif (isResendConfigured()) {\n\t\tproviders.push(\"resend\");\n\t}\n\n\tif (isPostmarkConfigured()) {\n\t\tproviders.push(\"postmark\");\n\t}\n\n\treturn providers;\n}\n\n/**\n * Get the best available provider\n * Returns primary if configured, otherwise fallback\n *\n * @returns Best available provider or null if none configured\n */\nexport function getBestAvailableProvider(): EmailProvider | null {\n\tif (isProviderConfigured(providerConfig.primary)) {\n\t\treturn providerConfig.primary;\n\t}\n\n\tif (providerConfig.enableFallback && isProviderConfigured(providerConfig.fallback)) {\n\t\treturn providerConfig.fallback;\n\t}\n\n\treturn null;\n}\n\n// =============================================================================\n// EMAIL SENDING\n// =============================================================================\n\n/**\n * Send email via Resend\n *\n * @param options - Email options\n * @returns Send result\n */\nasync function sendViaResend(\n\toptions: EmailSendOptions\n): Promise<{ success: boolean; messageId?: string; error?: string }> {\n\tif (!isResendConfigured() || !resend) {\n\t\treturn { success: false, error: \"Resend is not configured\" };\n\t}\n\n\ttry {\n\t\t// Build tags array for Resend\n\t\tconst tags: Array<{ name: string; value: string }> = [];\n\t\tif (options.tags) {\n\t\t\tfor (const [name, value] of Object.entries(options.tags)) {\n\t\t\t\ttags.push({ name, value });\n\t\t\t}\n\t\t}\n\t\tif (options.communicationId) {\n\t\t\ttags.push({ name: \"communication_id\", value: options.communicationId });\n\t\t}\n\n\t\t// Send via Resend\n\t\tconst { data, error } = await resend.emails.send({\n\t\t\tfrom: options.from || emailConfig.from,\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml: options.html,\n\t\t\ttext: options.text,\n\t\t\treplyTo: options.replyTo,\n\t\t\ttags: tags.length > 0 ? tags : undefined,\n\t\t});\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message || \"Resend send failed\" };\n\t\t}\n\n\t\treturn { success: true, messageId: data?.id };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Resend send failed\",\n\t\t};\n\t}\n}\n\n/**\n * Send email via Postmark\n *\n * @param options - Email options\n * @returns Send result\n */\nasync function sendViaPostmark(\n\toptions: EmailSendOptions\n): Promise<{ success: boolean; messageId?: string; error?: string }> {\n\tif (!isPostmarkConfigured()) {\n\t\treturn { success: false, error: \"Postmark is not configured\" };\n\t}\n\n\ttry {\n\t\t// Convert tags to Postmark metadata format\n\t\tconst metadata: Record<string, string> = { ...options.tags };\n\t\tif (options.communicationId) {\n\t\t\tmetadata.communication_id = options.communicationId;\n\t\t}\n\t\tif (options.companyId) {\n\t\t\tmetadata.company_id = options.companyId;\n\t\t}\n\n\t\t// Determine tag (Postmark only supports one tag per email)\n\t\tconst tag = options.tags?.template || options.tags?.type || \"transactional\";\n\n\t\t// Send via Postmark\n\t\tconst result = await sendPostmarkEmail({\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml: options.html,\n\t\t\ttext: options.text,\n\t\t\tfrom: options.from || postmarkConfig.from,\n\t\t\treplyTo: options.replyTo,\n\t\t\ttag,\n\t\t\tmetadata,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: result.error };\n\t\t}\n\n\t\treturn { success: true, messageId: result.data.MessageID };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Postmark send failed\",\n\t\t};\n\t}\n}\n\n/**\n * Send email via Gmail (company's connected Gmail account)\n *\n * @param companyId - Company ID with connected Gmail\n * @param options - Email options\n * @returns Send result\n */\nasync function sendViaGmail(\n\tcompanyId: string,\n\toptions: EmailSendOptions\n): Promise<{ success: boolean; messageId?: string; error?: string }> {\n\ttry {\n\t\tconst result = await sendCompanyGmailEmail(companyId, {\n\t\t\tto: options.to,\n\t\t\tsubject: options.subject,\n\t\t\thtml: options.html,\n\t\t\ttext: options.text,\n\t\t\treplyTo: options.replyTo,\n\t\t\tcc: options.cc,\n\t\t\tbcc: options.bcc,\n\t\t});\n\n\t\tif (!result.success) {\n\t\t\treturn { success: false, error: result.error };\n\t\t}\n\n\t\treturn { success: true, messageId: result.messageId };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Gmail send failed\",\n\t\t};\n\t}\n}\n\n/**\n * Check if Gmail is available for a company\n *\n * @param companyId - Company ID to check\n * @returns Whether Gmail is available and configured\n */\nasync function isCompanyGmailAvailable(companyId: string): Promise<boolean> {\n\ttry {\n\t\t// Check if Gmail integration is enabled globally\n\t\tif (!(await isGmailIntegrationEnabled())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tokens = await getCompanyGmailTokens(companyId);\n\t\treturn tokens !== null && tokens.isValid;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Send email with automatic fallback\n *\n * This is the main function for sending emails. It:\n * 1. Checks company's email provider preference (managed vs gmail vs disabled)\n * 2. If disabled, returns error immediately\n * 3. If Gmail preferred and available, sends via Gmail\n * 4. Otherwise, tries the primary provider (Resend)\n * 5. If primary fails and fallback is enabled, tries Postmark\n * 6. Returns detailed results including all attempts\n *\n * Provider Selection Logic (Multi-Tenant):\n * - If company preference = \"disabled\"  Return error (company has email disabled)\n * - If company preference = \"gmail\" AND valid Gmail tokens exist  Gmail\n * - If company preference = \"managed\" OR Gmail unavailable  Resend  Postmark\n *\n * @param options - Email send options\n * @returns Result with success status and attempt details\n *\n * @example\n * const result = await sendEmailWithFallback({\n *   to: \"user@example.com\",\n *   subject: \"Welcome!\",\n *   html: \"<h1>Hello</h1>\",\n *   tags: { template: \"welcome\" },\n *   companyId: \"company-123\", // Required for multi-tenant provider selection\n * });\n *\n * if (result.success) {\n *   console.log(`Sent via ${result.provider}, ID: ${result.messageId}`);\n * } else {\n *   console.error(`Failed: ${result.error}`);\n * }\n */\nexport async function sendEmailWithFallback(\n\toptions: EmailSendOptions\n): Promise<EmailProviderResult> {\n\tconst attempts: EmailProviderResult[\"attempts\"] = [];\n\tconst recipient = Array.isArray(options.to) ? options.to.join(\", \") : options.to;\n\n\t// Log the send attempt\n\tif (providerConfig.enableLogging) {\n\t\tconsole.log(`[EmailProvider] Sending email to ${recipient}, subject: \"${options.subject}\"`);\n\t}\n\n\t// ==========================================================================\n\t// COMPANY EMAIL PROVIDER CHECK (Multi-Tenant)\n\t// ==========================================================================\n\t// Each company (tenant) can choose:\n\t// - 'managed': Use our Resend/Postmark providers\n\t// - 'gmail': Use their connected Gmail account\n\t// - 'disabled': Email is disabled for this company\n\tif (options.companyId) {\n\t\tconst companyPreference = await getCompanyEmailProvider(options.companyId);\n\n\t\t// Handle disabled - company has turned off email\n\t\tif (companyPreference === \"disabled\") {\n\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\tconsole.log(`[EmailProvider] Company ${options.companyId} has email disabled`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Email is disabled for this company\",\n\t\t\t\tusedFallback: false,\n\t\t\t\tattempts: [],\n\t\t\t};\n\t\t}\n\n\t\t// Handle Gmail preference\n\t\tif (companyPreference === \"gmail\") {\n\t\t\tconst gmailAvailable = await isCompanyGmailAvailable(options.companyId);\n\n\t\t\tif (gmailAvailable) {\n\t\t\t\tconst startTime = Date.now();\n\n\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\tconsole.log(`[EmailProvider] Company ${options.companyId} prefers Gmail, attempting Gmail send...`);\n\t\t\t\t}\n\n\t\t\t\tconst result = await sendViaGmail(options.companyId, options);\n\t\t\t\tconst latencyMs = Date.now() - startTime;\n\n\t\t\t\tattempts.push({\n\t\t\t\t\tprovider: \"gmail\",\n\t\t\t\t\tsuccess: result.success,\n\t\t\t\t\tmessageId: result.messageId,\n\t\t\t\t\terror: result.error,\n\t\t\t\t\tlatencyMs,\n\t\t\t\t});\n\n\t\t\t\tif (result.success) {\n\t\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[EmailProvider]  Gmail send succeeded in ${latencyMs}ms, messageId: ${result.messageId}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tprovider: \"gmail\",\n\t\t\t\t\t\tmessageId: result.messageId,\n\t\t\t\t\t\tusedFallback: false,\n\t\t\t\t\t\tattempts,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Gmail failed - fall through to managed providers\n\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[EmailProvider]  Gmail send failed in ${latencyMs}ms: ${result.error}`\n\t\t\t\t\t);\n\t\t\t\t\tconsole.log(\"[EmailProvider] Falling back to managed providers...\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\t\tconsole.log(`[EmailProvider] Company ${options.companyId} prefers Gmail but no valid tokens, using managed providers`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ==========================================================================\n\t// MANAGED PROVIDERS: Primary (Resend)  Fallback (Postmark)\n\t// ==========================================================================\n\n\t// ==========================================================================\n\t// ATTEMPT 1: Primary Provider (Resend)\n\t// ==========================================================================\n\tif (isProviderConfigured(providerConfig.primary)) {\n\t\tconst startTime = Date.now();\n\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.log(`[EmailProvider] Trying primary provider: ${providerConfig.primary}`);\n\t\t}\n\n\t\tconst result =\n\t\t\tproviderConfig.primary === \"resend\"\n\t\t\t\t? await sendViaResend(options)\n\t\t\t\t: await sendViaPostmark(options);\n\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tattempts.push({\n\t\t\tprovider: providerConfig.primary,\n\t\t\tsuccess: result.success,\n\t\t\tmessageId: result.messageId,\n\t\t\terror: result.error,\n\t\t\tlatencyMs,\n\t\t});\n\n\t\t// If primary succeeded, return immediately\n\t\tif (result.success) {\n\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[EmailProvider]  Primary provider succeeded in ${latencyMs}ms, messageId: ${result.messageId}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tprovider: providerConfig.primary,\n\t\t\t\tmessageId: result.messageId,\n\t\t\t\tusedFallback: false,\n\t\t\t\tattempts,\n\t\t\t};\n\t\t}\n\n\t\t// Primary failed\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.warn(\n\t\t\t\t`[EmailProvider]  Primary provider failed in ${latencyMs}ms: ${result.error}`\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.warn(`[EmailProvider] Primary provider (${providerConfig.primary}) not configured`);\n\t\t}\n\t}\n\n\t// ==========================================================================\n\t// ATTEMPT 2: Fallback Provider (Postmark)\n\t// ==========================================================================\n\tif (providerConfig.enableFallback && isProviderConfigured(providerConfig.fallback)) {\n\t\tconst startTime = Date.now();\n\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.log(`[EmailProvider] Trying fallback provider: ${providerConfig.fallback}`);\n\t\t}\n\n\t\tconst result =\n\t\t\tproviderConfig.fallback === \"postmark\"\n\t\t\t\t? await sendViaPostmark(options)\n\t\t\t\t: await sendViaResend(options);\n\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tattempts.push({\n\t\t\tprovider: providerConfig.fallback,\n\t\t\tsuccess: result.success,\n\t\t\tmessageId: result.messageId,\n\t\t\terror: result.error,\n\t\t\tlatencyMs,\n\t\t});\n\n\t\t// If fallback succeeded, return\n\t\tif (result.success) {\n\t\t\tif (providerConfig.enableLogging) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[EmailProvider]  Fallback provider succeeded in ${latencyMs}ms, messageId: ${result.messageId}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tprovider: providerConfig.fallback,\n\t\t\t\tmessageId: result.messageId,\n\t\t\t\tusedFallback: true,\n\t\t\t\tattempts,\n\t\t\t};\n\t\t}\n\n\t\t// Fallback also failed\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.error(\n\t\t\t\t`[EmailProvider]  Fallback provider also failed in ${latencyMs}ms: ${result.error}`\n\t\t\t);\n\t\t}\n\t} else if (providerConfig.enableFallback) {\n\t\tif (providerConfig.enableLogging) {\n\t\t\tconsole.warn(\n\t\t\t\t`[EmailProvider] Fallback provider (${providerConfig.fallback}) not configured`\n\t\t\t);\n\t\t}\n\t}\n\n\t// ==========================================================================\n\t// ALL PROVIDERS FAILED\n\t// ==========================================================================\n\tconst errors = attempts.map((a) => `${a.provider}: ${a.error}`).join(\"; \");\n\n\tif (providerConfig.enableLogging) {\n\t\tconsole.error(`[EmailProvider]  All providers failed: ${errors}`);\n\t}\n\n\treturn {\n\t\tsuccess: false,\n\t\terror: `All email providers failed. ${errors}`,\n\t\tusedFallback: attempts.length > 1,\n\t\tattempts,\n\t};\n}\n\n// =============================================================================\n// HEALTH CHECKS\n// =============================================================================\n\n/**\n * Check health of Resend provider\n *\n * @returns Health status\n */\nasync function checkResendHealth(): Promise<ProviderHealthStatus> {\n\tconst startTime = Date.now();\n\n\tif (!isResendConfigured() || !resend) {\n\t\treturn {\n\t\t\tprovider: \"resend\",\n\t\t\thealthy: false,\n\t\t\tlatencyMs: 0,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: \"Resend is not configured\",\n\t\t};\n\t}\n\n\ttry {\n\t\t// Resend doesn't have a dedicated health endpoint\n\t\t// We'll list domains as a health check (lightweight operation)\n\t\tconst response = await fetch(\"https://api.resend.com/domains\", {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${process.env.RESEND_API_KEY}`,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t});\n\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tif (response.ok) {\n\t\t\tconsole.log(`[EmailProvider] Resend health check passed in ${latencyMs}ms`);\n\t\t\treturn {\n\t\t\t\tprovider: \"resend\",\n\t\t\t\thealthy: true,\n\t\t\t\tlatencyMs,\n\t\t\t\tlastChecked: new Date(),\n\t\t\t};\n\t\t}\n\n\t\tconst error = await response.text();\n\t\tconsole.error(`[EmailProvider] Resend health check failed: ${error}`);\n\t\treturn {\n\t\t\tprovider: \"resend\",\n\t\t\thealthy: false,\n\t\t\tlatencyMs,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: `HTTP ${response.status}: ${error}`,\n\t\t};\n\t} catch (error) {\n\t\tconst latencyMs = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\n\t\tconsole.error(`[EmailProvider] Resend health check error: ${errorMessage}`);\n\t\treturn {\n\t\t\tprovider: \"resend\",\n\t\t\thealthy: false,\n\t\t\tlatencyMs,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: errorMessage,\n\t\t};\n\t}\n}\n\n/**\n * Check health of all configured providers\n *\n * @returns Health status for all providers\n */\nexport async function checkAllProvidersHealth(): Promise<AllProvidersHealth> {\n\tconsole.log(\"[EmailProvider] Checking health of all providers...\");\n\n\tconst results: AllProvidersHealth = {\n\t\tprimary: null,\n\t\tfallback: null,\n\t\trecommendedProvider: null,\n\t};\n\n\t// Check primary (Resend)\n\tif (isProviderConfigured(\"resend\")) {\n\t\tresults.primary = await checkResendHealth();\n\t}\n\n\t// Check fallback (Postmark)\n\tif (isProviderConfigured(\"postmark\")) {\n\t\tconst postmarkHealth = await checkPostmarkHealth();\n\t\tresults.fallback = {\n\t\t\tprovider: \"postmark\",\n\t\t\thealthy: postmarkHealth.healthy,\n\t\t\tlatencyMs: postmarkHealth.latencyMs,\n\t\t\tlastChecked: new Date(),\n\t\t\terror: postmarkHealth.error,\n\t\t};\n\t}\n\n\t// Determine recommended provider based on health\n\tif (results.primary?.healthy) {\n\t\tresults.recommendedProvider = \"resend\";\n\t} else if (results.fallback?.healthy) {\n\t\tresults.recommendedProvider = \"postmark\";\n\t}\n\n\tconsole.log(\n\t\t`[EmailProvider] Health check complete. Primary: ${results.primary?.healthy ? \"healthy\" : \"unhealthy\"}, Fallback: ${results.fallback?.healthy ? \"healthy\" : \"unhealthy\"}, Recommended: ${results.recommendedProvider || \"none\"}`\n\t);\n\n\treturn results;\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Get display information about the email provider setup\n *\n * @returns Provider setup summary\n */\nexport function getProviderSetupInfo(): {\n\tprimaryConfigured: boolean;\n\tfallbackConfigured: boolean;\n\tfallbackEnabled: boolean;\n\tconfiguredProviders: EmailProvider[];\n\tstatus: \"fully_configured\" | \"primary_only\" | \"fallback_only\" | \"not_configured\";\n} {\n\tconst primaryConfigured = isProviderConfigured(providerConfig.primary);\n\tconst fallbackConfigured = isProviderConfigured(providerConfig.fallback);\n\tconst configuredProviders = getConfiguredProviders();\n\n\tlet status: \"fully_configured\" | \"primary_only\" | \"fallback_only\" | \"not_configured\";\n\n\tif (primaryConfigured && fallbackConfigured) {\n\t\tstatus = \"fully_configured\";\n\t} else if (primaryConfigured) {\n\t\tstatus = \"primary_only\";\n\t} else if (fallbackConfigured) {\n\t\tstatus = \"fallback_only\";\n\t} else {\n\t\tstatus = \"not_configured\";\n\t}\n\n\treturn {\n\t\tprimaryConfigured,\n\t\tfallbackConfigured,\n\t\tfallbackEnabled: providerConfig.enableFallback,\n\t\tconfiguredProviders,\n\t\tstatus,\n\t};\n}\n\n/**\n * Log a summary of the current provider configuration\n * Useful for debugging and startup diagnostics\n */\nexport function logProviderConfiguration(): void {\n\tconst info = getProviderSetupInfo();\n\n\tconsole.log(\"=\".repeat(60));\n\tconsole.log(\"[EmailProvider] Configuration Summary\");\n\tconsole.log(\"=\".repeat(60));\n\tconsole.log(`Primary Provider: ${providerConfig.primary} (${info.primaryConfigured ? \" configured\" : \" not configured\"})`);\n\tconsole.log(`Fallback Provider: ${providerConfig.fallback} (${info.fallbackConfigured ? \" configured\" : \" not configured\"})`);\n\tconsole.log(`Fallback Enabled: ${info.fallbackEnabled ? \"Yes\" : \"No\"}`);\n\tconsole.log(`Status: ${info.status}`);\n\tconsole.log(`Configured Providers: ${info.configuredProviders.join(\", \") || \"none\"}`);\n\tconsole.log(\"=\".repeat(60));\n}\n","/**\n * Postmark Email Client\n *\n * This module provides integration with Postmark as a fallback email provider.\n * Postmark is known for excellent deliverability and is used when Resend fails.\n *\n * Features:\n * - Email sending with automatic retry\n * - Domain/sender signature management\n * - Webhook signature verification\n * - Delivery status tracking\n *\n * Environment Variables Required:\n * - POSTMARK_API_KEY: Your Postmark server API token\n * - POSTMARK_WEBHOOK_SECRET: Secret for verifying webhook signatures (optional)\n *\n * @see https://postmarkapp.com/developer\n */\n\nimport crypto from \"node:crypto\";\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nconst POSTMARK_API_BASE = \"https://api.postmarkapp.com\";\n\n/**\n * Postmark client configuration\n * Checks environment variables and provides defaults\n */\nexport const postmarkConfig = {\n\tapiKey: process.env.POSTMARK_API_KEY || \"\",\n\twebhookSecret: process.env.POSTMARK_WEBHOOK_SECRET || \"\",\n\t// Default \"from\" address for Postmark (must be verified sender signature)\n\tfrom: process.env.POSTMARK_FROM_EMAIL || process.env.EMAIL_FROM || \"notifications@stratos.app\",\n\t// Is Postmark configured and ready to use?\n\tisConfigured: !!process.env.POSTMARK_API_KEY,\n\t// Provider name for logging/monitoring\n\tproviderName: \"postmark\" as const,\n};\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Standard response wrapper for Postmark API calls\n * Matches the pattern used by Resend for consistency\n */\nexport type PostmarkResponse<T> =\n\t| { success: true; data: T }\n\t| { success: false; error: string; errorCode?: number };\n\n/**\n * Postmark email send request\n * @see https://postmarkapp.com/developer/api/email-api\n */\nexport interface PostmarkSendRequest {\n\tFrom: string;\n\tTo: string;\n\tSubject: string;\n\tHtmlBody?: string;\n\tTextBody?: string;\n\tReplyTo?: string;\n\tTag?: string;\n\tTrackOpens?: boolean;\n\tTrackLinks?: \"None\" | \"HtmlAndText\" | \"HtmlOnly\" | \"TextOnly\";\n\tMessageStream?: string;\n\tMetadata?: Record<string, string>;\n}\n\n/**\n * Postmark email send response\n */\nexport interface PostmarkSendResponse {\n\tTo: string;\n\tSubmittedAt: string;\n\tMessageID: string;\n\tErrorCode: number;\n\tMessage: string;\n}\n\n/**\n * Postmark domain (sender signature) data\n * @see https://postmarkapp.com/developer/api/signatures-api\n */\nexport interface PostmarkDomainData {\n\tID: number;\n\tDomain: string;\n\tEmailAddress: string;\n\tReplyToEmailAddress: string;\n\tName: string;\n\tConfirmed: boolean;\n\tSPFVerified: boolean;\n\tSPFHost: string;\n\tSPFTextValue: string;\n\tDKIMVerified: boolean;\n\tWeakDKIM: boolean;\n\tDKIMHost: string;\n\tDKIMTextValue: string;\n\tDKIMPendingHost: string;\n\tDKIMPendingTextValue: string;\n\tDKIMRevokedHost: string;\n\tDKIMRevokedTextValue: string;\n\tSafeToRemoveRevokedKeyFromDNS: boolean;\n\tDKIMUpdateStatus: string;\n\tReturnPathDomain: string;\n\tReturnPathDomainCNAMEValue: string;\n\tReturnPathDomainVerified: boolean;\n}\n\n/**\n * Postmark webhook event types\n */\nexport type PostmarkWebhookEventType =\n\t| \"Delivery\"\n\t| \"Bounce\"\n\t| \"SpamComplaint\"\n\t| \"Open\"\n\t| \"Click\"\n\t| \"SubscriptionChange\";\n\n/**\n * Postmark webhook payload base\n */\nexport interface PostmarkWebhookPayload {\n\tRecordType: PostmarkWebhookEventType;\n\tMessageID: string;\n\tRecipient: string;\n\tTag: string;\n\tDeliveredAt?: string;\n\tBouncedAt?: string;\n\tType?: string; // Bounce type\n\tTypeCode?: number;\n\tDescription?: string;\n\tDetails?: string;\n\tEmail?: string;\n\tFrom?: string;\n\tSubject?: string;\n\tMetadata?: Record<string, string>;\n}\n\n// =============================================================================\n// API REQUEST HELPER\n// =============================================================================\n\n/**\n * Makes authenticated requests to Postmark API\n *\n * @param path - API endpoint path (e.g., \"/email\")\n * @param init - Fetch request options\n * @returns Typed response with success/error handling\n *\n * @example\n * const result = await postmarkRequest<PostmarkSendResponse>(\"/email\", {\n *   method: \"POST\",\n *   body: JSON.stringify(emailData),\n * });\n */\nasync function postmarkRequest<T>(\n\tpath: string,\n\tinit: RequestInit\n): Promise<PostmarkResponse<T>> {\n\t// Check if Postmark is configured\n\tif (!postmarkConfig.apiKey) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Postmark API key is not configured. Set POSTMARK_API_KEY environment variable.\",\n\t\t};\n\t}\n\n\ttry {\n\t\tconst response = await fetch(`${POSTMARK_API_BASE}${path}`, {\n\t\t\t...init,\n\t\t\theaders: {\n\t\t\t\t// Postmark uses X-Postmark-Server-Token for authentication\n\t\t\t\t\"X-Postmark-Server-Token\": postmarkConfig.apiKey,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\tAccept: \"application/json\",\n\t\t\t\t...init.headers,\n\t\t\t},\n\t\t});\n\n\t\t// Parse response body\n\t\tconst body = await response.json().catch(() => ({}));\n\n\t\t// Handle non-OK responses\n\t\tif (!response.ok) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: body.Message || body.message || response.statusText,\n\t\t\t\terrorCode: body.ErrorCode,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: body as T };\n\t} catch (error) {\n\t\t// Network or parsing error\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Postmark request failed\",\n\t\t};\n\t}\n}\n\n// =============================================================================\n// EMAIL SENDING\n// =============================================================================\n\n/**\n * Send an email via Postmark\n *\n * This is the primary email sending function for Postmark.\n * It handles HTML emails with optional tracking.\n *\n * @param options - Email send options\n * @returns Send result with MessageID on success\n *\n * @example\n * const result = await sendPostmarkEmail({\n *   to: \"user@example.com\",\n *   subject: \"Welcome!\",\n *   html: \"<h1>Hello</h1>\",\n *   from: \"hello@mycompany.com\",\n *   tags: { template: \"welcome\" },\n * });\n */\nexport async function sendPostmarkEmail(options: {\n\tto: string | string[];\n\tsubject: string;\n\thtml: string;\n\ttext?: string;\n\tfrom?: string;\n\treplyTo?: string;\n\ttag?: string;\n\ttrackOpens?: boolean;\n\ttrackLinks?: boolean;\n\tmetadata?: Record<string, string>;\n\tmessageStream?: string;\n}): Promise<PostmarkResponse<PostmarkSendResponse>> {\n\tconst {\n\t\tto,\n\t\tsubject,\n\t\thtml,\n\t\ttext,\n\t\tfrom = postmarkConfig.from,\n\t\treplyTo,\n\t\ttag,\n\t\ttrackOpens = true,\n\t\ttrackLinks = true,\n\t\tmetadata,\n\t\tmessageStream = \"outbound\", // Default message stream\n\t} = options;\n\n\t// Postmark requires single recipient per request for /email endpoint\n\t// For multiple recipients, we'd use /email/batch\n\tconst recipient = Array.isArray(to) ? to.join(\", \") : to;\n\n\tconst request: PostmarkSendRequest = {\n\t\tFrom: from,\n\t\tTo: recipient,\n\t\tSubject: subject,\n\t\tHtmlBody: html,\n\t\tTextBody: text,\n\t\tReplyTo: replyTo,\n\t\tTag: tag,\n\t\tTrackOpens: trackOpens,\n\t\tTrackLinks: trackLinks ? \"HtmlAndText\" : \"None\",\n\t\tMessageStream: messageStream,\n\t\tMetadata: metadata,\n\t};\n\n\t// Log send attempt for monitoring\n\tconsole.log(`[Postmark] Sending email to ${recipient}, subject: \"${subject}\"`);\n\n\tconst result = await postmarkRequest<PostmarkSendResponse>(\"/email\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(request),\n\t});\n\n\t// Log result for monitoring\n\tif (result.success) {\n\t\tconsole.log(`[Postmark] Email sent successfully, MessageID: ${result.data.MessageID}`);\n\t} else {\n\t\tconsole.error(`[Postmark] Email send failed: ${result.error}`);\n\t}\n\n\treturn result;\n}\n\n/**\n * Send batch emails via Postmark (up to 500 per request)\n *\n * @param emails - Array of email options\n * @returns Array of send results\n */\nexport async function sendPostmarkBatchEmails(\n\temails: Array<{\n\t\tto: string;\n\t\tsubject: string;\n\t\thtml: string;\n\t\ttext?: string;\n\t\tfrom?: string;\n\t\treplyTo?: string;\n\t\ttag?: string;\n\t\tmetadata?: Record<string, string>;\n\t}>\n): Promise<PostmarkResponse<PostmarkSendResponse[]>> {\n\tif (emails.length > 500) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Postmark batch limit is 500 emails per request\",\n\t\t};\n\t}\n\n\tconst requests: PostmarkSendRequest[] = emails.map((email) => ({\n\t\tFrom: email.from || postmarkConfig.from,\n\t\tTo: email.to,\n\t\tSubject: email.subject,\n\t\tHtmlBody: email.html,\n\t\tTextBody: email.text,\n\t\tReplyTo: email.replyTo,\n\t\tTag: email.tag,\n\t\tTrackOpens: true,\n\t\tTrackLinks: \"HtmlAndText\",\n\t\tMetadata: email.metadata,\n\t}));\n\n\tconsole.log(`[Postmark] Sending batch of ${emails.length} emails`);\n\n\treturn postmarkRequest<PostmarkSendResponse[]>(\"/email/batch\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(requests),\n\t});\n}\n\n// =============================================================================\n// DOMAIN/SENDER SIGNATURE MANAGEMENT\n// =============================================================================\n\n/**\n * List all sender signatures (domains) in Postmark\n *\n * @returns List of sender signatures\n */\nexport async function listPostmarkDomains(): Promise<\n\tPostmarkResponse<{ TotalCount: number; SenderSignatures: PostmarkDomainData[] }>\n> {\n\tconsole.log(\"[Postmark] Listing sender signatures\");\n\treturn postmarkRequest(\"/senders\", { method: \"GET\" });\n}\n\n/**\n * Get details of a specific sender signature\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Sender signature details\n */\nexport async function getPostmarkDomain(\n\tsignatureId: number\n): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconsole.log(`[Postmark] Getting sender signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}`, { method: \"GET\" });\n}\n\n/**\n * Create a new sender signature in Postmark\n *\n * Note: Postmark uses \"sender signatures\" which can be either:\n * - Individual email addresses\n * - Entire domains\n *\n * @param options - Sender signature options\n * @returns Created sender signature\n */\nexport async function createPostmarkDomain(options: {\n\tfromEmail: string;\n\tname: string;\n\treplyToEmail?: string;\n}): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconst { fromEmail, name, replyToEmail } = options;\n\n\tconsole.log(`[Postmark] Creating sender signature for ${fromEmail}`);\n\n\treturn postmarkRequest(\"/senders\", {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify({\n\t\t\tFromEmail: fromEmail,\n\t\t\tName: name,\n\t\t\tReplyToEmail: replyToEmail || fromEmail,\n\t\t}),\n\t});\n}\n\n/**\n * Delete a sender signature from Postmark\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Deletion result\n */\nexport async function deletePostmarkDomain(\n\tsignatureId: number\n): Promise<PostmarkResponse<{ Message: string }>> {\n\tconsole.log(`[Postmark] Deleting sender signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}`, { method: \"DELETE\" });\n}\n\n/**\n * Resend confirmation email for a sender signature\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Resend result\n */\nexport async function resendPostmarkConfirmation(\n\tsignatureId: number\n): Promise<PostmarkResponse<{ Message: string }>> {\n\tconsole.log(`[Postmark] Resending confirmation for signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}/resend`, { method: \"POST\" });\n}\n\n/**\n * Verify DKIM for a sender signature\n * Triggers Postmark to check DNS records\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Updated sender signature with verification status\n */\nexport async function verifyPostmarkDKIM(\n\tsignatureId: number\n): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconsole.log(`[Postmark] Verifying DKIM for signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}/verifyDkim`, { method: \"PUT\" });\n}\n\n/**\n * Verify Return-Path for a sender signature\n *\n * @param signatureId - Postmark sender signature ID\n * @returns Updated sender signature with verification status\n */\nexport async function verifyPostmarkReturnPath(\n\tsignatureId: number\n): Promise<PostmarkResponse<PostmarkDomainData>> {\n\tconsole.log(`[Postmark] Verifying Return-Path for signature ${signatureId}`);\n\treturn postmarkRequest(`/senders/${signatureId}/verifyReturnPath`, { method: \"PUT\" });\n}\n\n// =============================================================================\n// SERVER/ACCOUNT INFO\n// =============================================================================\n\n/**\n * Get Postmark server information\n * Useful for verifying API key and getting server settings\n *\n * @returns Server information\n */\nexport async function getPostmarkServerInfo(): Promise<\n\tPostmarkResponse<{\n\t\tID: number;\n\t\tName: string;\n\t\tApiTokens: string[];\n\t\tColor: string;\n\t\tSmtpApiActivated: boolean;\n\t\tRawEmailEnabled: boolean;\n\t\tInboundAddress: string;\n\t\tInboundHookUrl: string;\n\t\tBounceHookUrl: string;\n\t\tOpenHookUrl: string;\n\t\tPostFirstOpenOnly: boolean;\n\t\tTrackOpens: boolean;\n\t\tTrackLinks: string;\n\t\tInboundDomain: string;\n\t\tInboundSpamThreshold: number;\n\t}>\n> {\n\tconsole.log(\"[Postmark] Getting server info\");\n\treturn postmarkRequest(\"/server\", { method: \"GET\" });\n}\n\n// =============================================================================\n// WEBHOOK VERIFICATION\n// =============================================================================\n\n/**\n * Verify Postmark webhook signature\n *\n * Postmark webhooks don't use signatures by default, but you can configure\n * basic auth or use the webhook token. This function verifies the token\n * if POSTMARK_WEBHOOK_SECRET is configured.\n *\n * @param options - Webhook verification options\n * @returns Whether the webhook is valid\n *\n * @example\n * const isValid = verifyPostmarkWebhook({\n *   payload: requestBody,\n *   token: request.headers.get(\"X-Postmark-Token\"),\n * });\n */\nexport function verifyPostmarkWebhook(options: {\n\tpayload: string;\n\ttoken?: string | null;\n}): boolean {\n\tconst { token } = options;\n\n\t// If no secret configured, accept all webhooks (not recommended for production)\n\tif (!postmarkConfig.webhookSecret) {\n\t\tconsole.warn(\"[Postmark] No webhook secret configured - accepting webhook without verification\");\n\t\treturn true;\n\t}\n\n\t// Verify the token matches our secret\n\tif (!token) {\n\t\tconsole.error(\"[Postmark] Webhook missing token\");\n\t\treturn false;\n\t}\n\n\t// Use timing-safe comparison to prevent timing attacks\n\ttry {\n\t\tconst expected = Buffer.from(postmarkConfig.webhookSecret);\n\t\tconst received = Buffer.from(token);\n\n\t\tif (expected.length !== received.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn crypto.timingSafeEqual(expected, received);\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n// =============================================================================\n// HEALTH CHECK\n// =============================================================================\n\n/**\n * Check if Postmark is healthy and responsive\n *\n * This function attempts to fetch server info to verify:\n * 1. API key is valid\n * 2. Postmark API is reachable\n * 3. Account is in good standing\n *\n * @returns Health check result\n */\nexport async function checkPostmarkHealth(): Promise<{\n\thealthy: boolean;\n\tprovider: \"postmark\";\n\tlatencyMs: number;\n\terror?: string;\n}> {\n\tconst startTime = Date.now();\n\n\ttry {\n\t\tconst result = await getPostmarkServerInfo();\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tif (result.success) {\n\t\t\tconsole.log(`[Postmark] Health check passed in ${latencyMs}ms`);\n\t\t\treturn {\n\t\t\t\thealthy: true,\n\t\t\t\tprovider: \"postmark\",\n\t\t\t\tlatencyMs,\n\t\t\t};\n\t\t}\n\n\t\tconsole.error(`[Postmark] Health check failed: ${result.error}`);\n\t\treturn {\n\t\t\thealthy: false,\n\t\t\tprovider: \"postmark\",\n\t\t\tlatencyMs,\n\t\t\terror: result.error,\n\t\t};\n\t} catch (error) {\n\t\tconst latencyMs = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\n\t\tconsole.error(`[Postmark] Health check error: ${errorMessage}`);\n\t\treturn {\n\t\t\thealthy: false,\n\t\t\tprovider: \"postmark\",\n\t\t\tlatencyMs,\n\t\t\terror: errorMessage,\n\t\t};\n\t}\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Check if Postmark is properly configured\n *\n * @returns Whether Postmark can be used\n */\nexport function isPostmarkConfigured(): boolean {\n\treturn postmarkConfig.isConfigured;\n}\n\n/**\n * Get DNS records needed for a domain in Postmark format\n *\n * @param domain - Postmark domain data\n * @returns Formatted DNS records for display\n */\nexport function getPostmarkDNSRecords(domain: PostmarkDomainData): Array<{\n\ttype: string;\n\tname: string;\n\tvalue: string;\n\tverified: boolean;\n}> {\n\tconst records: Array<{\n\t\ttype: string;\n\t\tname: string;\n\t\tvalue: string;\n\t\tverified: boolean;\n\t}> = [];\n\n\t// DKIM record\n\tif (domain.DKIMHost && domain.DKIMTextValue) {\n\t\trecords.push({\n\t\t\ttype: \"TXT\",\n\t\t\tname: domain.DKIMHost,\n\t\t\tvalue: domain.DKIMTextValue,\n\t\t\tverified: domain.DKIMVerified,\n\t\t});\n\t}\n\n\t// Return-Path CNAME\n\tif (domain.ReturnPathDomain && domain.ReturnPathDomainCNAMEValue) {\n\t\trecords.push({\n\t\t\ttype: \"CNAME\",\n\t\t\tname: domain.ReturnPathDomain,\n\t\t\tvalue: domain.ReturnPathDomainCNAMEValue,\n\t\t\tverified: domain.ReturnPathDomainVerified,\n\t\t});\n\t}\n\n\treturn records;\n}\n","\"use server\";\n\n/**\n * Email Provider Monitor\n *\n * This module tracks the health and performance of email providers (Resend & Postmark).\n * It records every email send attempt and provides analytics for monitoring.\n *\n * Features:\n * - Track success/failure rates per provider\n * - Record latency metrics\n * - Store detailed error information\n * - Provide real-time health dashboards\n * - Alert on provider degradation\n *\n * Database Tables Used:\n * - email_provider_events: Individual send attempts\n * - email_provider_health: Aggregated health metrics (updated periodically)\n *\n * Usage:\n * ```typescript\n * // Record a successful send\n * await recordProviderEvent({\n *   provider: \"resend\",\n *   eventType: \"send_success\",\n *   messageId: \"abc123\",\n *   latencyMs: 150,\n * });\n *\n * // Get provider health stats\n * const stats = await getProviderStats(\"resend\", \"24h\");\n * ```\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport type { EmailProvider } from \"./email-provider\";\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Types of events we track for email providers\n */\nexport type ProviderEventType =\n\t| \"send_success\" // Email sent successfully\n\t| \"send_failure\" // Email send failed\n\t| \"health_check_success\" // Health check passed\n\t| \"health_check_failure\" // Health check failed\n\t| \"webhook_received\" // Webhook event received\n\t| \"fallback_triggered\"; // Fallback to secondary provider was used\n\n/**\n * Event data for recording provider activity\n */\nexport interface ProviderEventData {\n\t/** Which provider this event is for */\n\tprovider: EmailProvider;\n\t/** Type of event */\n\teventType: ProviderEventType;\n\t/** Message ID if applicable */\n\tmessageId?: string;\n\t/** Time taken for the operation in milliseconds */\n\tlatencyMs?: number;\n\t/** Error message if this was a failure */\n\terror?: string;\n\t/** Additional metadata */\n\tmetadata?: Record<string, unknown>;\n\t/** Company ID for multi-tenant tracking */\n\tcompanyId?: string;\n\t/** Domain ID if associated with a specific domain */\n\tdomainId?: string;\n}\n\n/**\n * Aggregated statistics for a provider\n */\nexport interface ProviderStats {\n\tprovider: EmailProvider;\n\tperiod: string;\n\ttotalEvents: number;\n\tsuccessCount: number;\n\tfailureCount: number;\n\tsuccessRate: number;\n\taverageLatencyMs: number;\n\tp95LatencyMs: number;\n\tfallbackCount: number;\n\tlastEventAt: Date | null;\n\tlastError: string | null;\n}\n\n/**\n * Real-time health status for dashboard\n */\nexport interface ProviderHealthDashboard {\n\tresend: {\n\t\tstatus: \"healthy\" | \"degraded\" | \"down\" | \"unknown\";\n\t\tsuccessRate24h: number;\n\t\tavgLatencyMs: number;\n\t\ttotalSent24h: number;\n\t\tlastError?: string;\n\t\tlastSuccessAt?: Date;\n\t};\n\tpostmark: {\n\t\tstatus: \"healthy\" | \"degraded\" | \"down\" | \"unknown\";\n\t\tsuccessRate24h: number;\n\t\tavgLatencyMs: number;\n\t\ttotalSent24h: number;\n\t\tlastError?: string;\n\t\tlastSuccessAt?: Date;\n\t};\n\toverall: {\n\t\tprimaryProvider: EmailProvider;\n\t\tfallbackProvider: EmailProvider;\n\t\tfallbackRate24h: number;\n\t\trecommendedAction?: string;\n\t};\n}\n\n// =============================================================================\n// EVENT RECORDING\n// =============================================================================\n\n/**\n * Record a provider event to the database\n *\n * This function logs every email provider interaction for monitoring.\n * Events are stored in the email_provider_events table.\n *\n * @param event - Event data to record\n * @returns Success status\n *\n * @example\n * await recordProviderEvent({\n *   provider: \"resend\",\n *   eventType: \"send_success\",\n *   messageId: \"msg_123\",\n *   latencyMs: 145,\n *   companyId: \"company_abc\",\n * });\n */\nexport async function recordProviderEvent(\n\tevent: ProviderEventData\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Log to console for immediate visibility\n\t\tconst logPrefix = event.eventType.includes(\"success\") ? \"\" : \"\";\n\t\tconsole.log(\n\t\t\t`[ProviderMonitor] ${logPrefix} ${event.provider}:${event.eventType}` +\n\t\t\t\t(event.latencyMs ? ` (${event.latencyMs}ms)` : \"\") +\n\t\t\t\t(event.error ? ` - ${event.error}` : \"\")\n\t\t);\n\n\t\t// Insert event into database\n\t\tconst { error } = await supabase.from(\"email_provider_events\").insert({\n\t\t\tprovider: event.provider,\n\t\t\tevent_type: event.eventType,\n\t\t\tmessage_id: event.messageId || null,\n\t\t\tlatency_ms: event.latencyMs || null,\n\t\t\terror_message: event.error || null,\n\t\t\tmetadata: event.metadata || null,\n\t\t\tcompany_id: event.companyId || null,\n\t\t\tdomain_id: event.domainId || null,\n\t\t\tcreated_at: new Date().toISOString(),\n\t\t});\n\n\t\tif (error) {\n\t\t\t// Don't fail the main operation if monitoring fails\n\t\t\tconsole.error(`[ProviderMonitor] Failed to record event: ${error.message}`);\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\t// Monitoring should never break the main flow\n\t\tconsole.error(\n\t\t\t`[ProviderMonitor] Error recording event: ${error instanceof Error ? error.message : \"Unknown error\"}`\n\t\t);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n\n/**\n * Record a successful email send\n * Convenience wrapper for recordProviderEvent\n */\nexport async function recordSendSuccess(\n\tprovider: EmailProvider,\n\tmessageId: string,\n\tlatencyMs: number,\n\toptions?: { companyId?: string; domainId?: string; metadata?: Record<string, unknown> }\n): Promise<void> {\n\tawait recordProviderEvent({\n\t\tprovider,\n\t\teventType: \"send_success\",\n\t\tmessageId,\n\t\tlatencyMs,\n\t\t...options,\n\t});\n}\n\n/**\n * Record a failed email send\n * Convenience wrapper for recordProviderEvent\n */\nexport async function recordSendFailure(\n\tprovider: EmailProvider,\n\terror: string,\n\tlatencyMs: number,\n\toptions?: { companyId?: string; domainId?: string; metadata?: Record<string, unknown> }\n): Promise<void> {\n\tawait recordProviderEvent({\n\t\tprovider,\n\t\teventType: \"send_failure\",\n\t\terror,\n\t\tlatencyMs,\n\t\t...options,\n\t});\n}\n\n/**\n * Record when fallback provider was used\n */\nexport async function recordFallbackTriggered(\n\tprimaryProvider: EmailProvider,\n\tfallbackProvider: EmailProvider,\n\tprimaryError: string,\n\toptions?: { companyId?: string; metadata?: Record<string, unknown> }\n): Promise<void> {\n\tawait recordProviderEvent({\n\t\tprovider: primaryProvider,\n\t\teventType: \"fallback_triggered\",\n\t\terror: primaryError,\n\t\tmetadata: {\n\t\t\tfallback_provider: fallbackProvider,\n\t\t\t...options?.metadata,\n\t\t},\n\t\t...options,\n\t});\n}\n\n// =============================================================================\n// STATISTICS & ANALYTICS\n// =============================================================================\n\n/**\n * Get statistics for a specific provider\n *\n * @param provider - Provider to get stats for\n * @param period - Time period (\"1h\", \"24h\", \"7d\", \"30d\")\n * @returns Provider statistics\n */\nexport async function getProviderStats(\n\tprovider: EmailProvider,\n\tperiod: \"1h\" | \"24h\" | \"7d\" | \"30d\" = \"24h\"\n): Promise<ProviderStats | null> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\t// Calculate start time based on period\n\t\tconst now = new Date();\n\t\tconst periodMs = {\n\t\t\t\"1h\": 60 * 60 * 1000,\n\t\t\t\"24h\": 24 * 60 * 60 * 1000,\n\t\t\t\"7d\": 7 * 24 * 60 * 60 * 1000,\n\t\t\t\"30d\": 30 * 24 * 60 * 60 * 1000,\n\t\t};\n\t\tconst startTime = new Date(now.getTime() - periodMs[period]).toISOString();\n\n\t\t// Query events for this provider and period\n\t\tconst { data: events, error } = await supabase\n\t\t\t.from(\"email_provider_events\")\n\t\t\t.select(\"event_type, latency_ms, error_message, created_at\")\n\t\t\t.eq(\"provider\", provider)\n\t\t\t.gte(\"created_at\", startTime)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(`[ProviderMonitor] Failed to get stats: ${error.message}`);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!events || events.length === 0) {\n\t\t\treturn {\n\t\t\t\tprovider,\n\t\t\t\tperiod,\n\t\t\t\ttotalEvents: 0,\n\t\t\t\tsuccessCount: 0,\n\t\t\t\tfailureCount: 0,\n\t\t\t\tsuccessRate: 0,\n\t\t\t\taverageLatencyMs: 0,\n\t\t\t\tp95LatencyMs: 0,\n\t\t\t\tfallbackCount: 0,\n\t\t\t\tlastEventAt: null,\n\t\t\t\tlastError: null,\n\t\t\t};\n\t\t}\n\n\t\t// Calculate statistics\n\t\tconst sendEvents = events.filter(\n\t\t\t(e) => e.event_type === \"send_success\" || e.event_type === \"send_failure\"\n\t\t);\n\t\tconst successEvents = events.filter((e) => e.event_type === \"send_success\");\n\t\tconst failureEvents = events.filter((e) => e.event_type === \"send_failure\");\n\t\tconst fallbackEvents = events.filter((e) => e.event_type === \"fallback_triggered\");\n\n\t\t// Calculate latency metrics\n\t\tconst latencies = successEvents\n\t\t\t.map((e) => e.latency_ms)\n\t\t\t.filter((l): l is number => l !== null)\n\t\t\t.sort((a, b) => a - b);\n\n\t\tconst avgLatency =\n\t\t\tlatencies.length > 0\n\t\t\t\t? latencies.reduce((sum, l) => sum + l, 0) / latencies.length\n\t\t\t\t: 0;\n\n\t\tconst p95Index = Math.floor(latencies.length * 0.95);\n\t\tconst p95Latency = latencies.length > 0 ? latencies[p95Index] || latencies[latencies.length - 1] : 0;\n\n\t\t// Find last error\n\t\tconst lastFailure = failureEvents[0];\n\n\t\treturn {\n\t\t\tprovider,\n\t\t\tperiod,\n\t\t\ttotalEvents: events.length,\n\t\t\tsuccessCount: successEvents.length,\n\t\t\tfailureCount: failureEvents.length,\n\t\t\tsuccessRate:\n\t\t\t\tsendEvents.length > 0\n\t\t\t\t\t? (successEvents.length / sendEvents.length) * 100\n\t\t\t\t\t: 0,\n\t\t\taverageLatencyMs: Math.round(avgLatency),\n\t\t\tp95LatencyMs: Math.round(p95Latency),\n\t\t\tfallbackCount: fallbackEvents.length,\n\t\t\tlastEventAt: events[0] ? new Date(events[0].created_at) : null,\n\t\t\tlastError: lastFailure?.error_message || null,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\n\t\t\t`[ProviderMonitor] Error getting stats: ${error instanceof Error ? error.message : \"Unknown error\"}`\n\t\t);\n\t\treturn null;\n\t}\n}\n\n/**\n * Get health dashboard data for all providers\n *\n * @returns Dashboard data for monitoring UI\n */\nexport async function getProviderHealthDashboard(): Promise<ProviderHealthDashboard> {\n\tconsole.log(\"[ProviderMonitor] Getting health dashboard data...\");\n\n\t// Get stats for both providers\n\tconst [resendStats, postmarkStats] = await Promise.all([\n\t\tgetProviderStats(\"resend\", \"24h\"),\n\t\tgetProviderStats(\"postmark\", \"24h\"),\n\t]);\n\n\t// Determine health status based on success rate\n\tconst getStatus = (\n\t\tstats: ProviderStats | null\n\t): \"healthy\" | \"degraded\" | \"down\" | \"unknown\" => {\n\t\tif (!stats || stats.totalEvents === 0) return \"unknown\";\n\t\tif (stats.successRate >= 99) return \"healthy\";\n\t\tif (stats.successRate >= 95) return \"degraded\";\n\t\treturn \"down\";\n\t};\n\n\t// Calculate fallback rate\n\tconst totalFallbacks = (resendStats?.fallbackCount || 0) + (postmarkStats?.fallbackCount || 0);\n\tconst totalSends =\n\t\t(resendStats?.successCount || 0) +\n\t\t(resendStats?.failureCount || 0) +\n\t\t(postmarkStats?.successCount || 0) +\n\t\t(postmarkStats?.failureCount || 0);\n\tconst fallbackRate = totalSends > 0 ? (totalFallbacks / totalSends) * 100 : 0;\n\n\t// Determine recommended action\n\tlet recommendedAction: string | undefined;\n\tconst resendStatus = getStatus(resendStats);\n\tconst postmarkStatus = getStatus(postmarkStats);\n\n\tif (resendStatus === \"down\" && postmarkStatus === \"down\") {\n\t\trecommendedAction = \"CRITICAL: Both providers are down. Check API keys and provider status.\";\n\t} else if (resendStatus === \"down\") {\n\t\trecommendedAction = \"Primary provider (Resend) is down. Traffic is using fallback.\";\n\t} else if (fallbackRate > 10) {\n\t\trecommendedAction = \"High fallback rate detected. Review primary provider health.\";\n\t} else if (resendStatus === \"degraded\") {\n\t\trecommendedAction = \"Primary provider showing degraded performance. Monitor closely.\";\n\t}\n\n\treturn {\n\t\tresend: {\n\t\t\tstatus: resendStatus,\n\t\t\tsuccessRate24h: resendStats?.successRate || 0,\n\t\t\tavgLatencyMs: resendStats?.averageLatencyMs || 0,\n\t\t\ttotalSent24h: resendStats?.successCount || 0,\n\t\t\tlastError: resendStats?.lastError || undefined,\n\t\t\tlastSuccessAt: resendStats?.lastEventAt || undefined,\n\t\t},\n\t\tpostmark: {\n\t\t\tstatus: postmarkStatus,\n\t\t\tsuccessRate24h: postmarkStats?.successRate || 0,\n\t\t\tavgLatencyMs: postmarkStats?.averageLatencyMs || 0,\n\t\t\ttotalSent24h: postmarkStats?.successCount || 0,\n\t\t\tlastError: postmarkStats?.lastError || undefined,\n\t\t\tlastSuccessAt: postmarkStats?.lastEventAt || undefined,\n\t\t},\n\t\toverall: {\n\t\t\tprimaryProvider: \"resend\",\n\t\t\tfallbackProvider: \"postmark\",\n\t\t\tfallbackRate24h: fallbackRate,\n\t\t\trecommendedAction,\n\t\t},\n\t};\n}\n\n// =============================================================================\n// CLEANUP & MAINTENANCE\n// =============================================================================\n\n/**\n * Clean up old provider events\n * Should be run periodically (e.g., daily cron job)\n *\n * @param retentionDays - Number of days to retain events\n * @returns Number of deleted events\n */\nexport async function cleanupOldEvents(\n\tretentionDays: number = 30\n): Promise<{ deleted: number; error?: string }> {\n\ttry {\n\t\tconst supabase = await createServiceSupabaseClient();\n\n\t\tconst cutoffDate = new Date();\n\t\tcutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"email_provider_events\")\n\t\t\t.delete()\n\t\t\t.lt(\"created_at\", cutoffDate.toISOString())\n\t\t\t.select(\"id\");\n\n\t\tif (error) {\n\t\t\tconsole.error(`[ProviderMonitor] Cleanup failed: ${error.message}`);\n\t\t\treturn { deleted: 0, error: error.message };\n\t\t}\n\n\t\tconst deletedCount = data?.length || 0;\n\t\tconsole.log(`[ProviderMonitor] Cleaned up ${deletedCount} events older than ${retentionDays} days`);\n\n\t\treturn { deleted: deletedCount };\n\t} catch (error) {\n\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\tconsole.error(`[ProviderMonitor] Cleanup error: ${errorMessage}`);\n\t\treturn { deleted: 0, error: errorMessage };\n\t}\n}\n\n// =============================================================================\n// ALERTING HELPERS\n// =============================================================================\n\n/**\n * Check if a provider should trigger an alert\n *\n * @param provider - Provider to check\n * @returns Alert status and reason\n */\nexport async function checkProviderAlert(\n\tprovider: EmailProvider\n): Promise<{\n\tshouldAlert: boolean;\n\tseverity: \"info\" | \"warning\" | \"critical\";\n\treason?: string;\n}> {\n\tconst stats = await getProviderStats(provider, \"1h\");\n\n\tif (!stats) {\n\t\treturn { shouldAlert: false, severity: \"info\" };\n\t}\n\n\t// No events in the last hour - might be expected during low traffic\n\tif (stats.totalEvents === 0) {\n\t\treturn { shouldAlert: false, severity: \"info\" };\n\t}\n\n\t// Critical: Success rate below 90%\n\tif (stats.successRate < 90) {\n\t\treturn {\n\t\t\tshouldAlert: true,\n\t\t\tseverity: \"critical\",\n\t\t\treason: `${provider} success rate is ${stats.successRate.toFixed(1)}% (below 90%)`,\n\t\t};\n\t}\n\n\t// Warning: Success rate below 99%\n\tif (stats.successRate < 99) {\n\t\treturn {\n\t\t\tshouldAlert: true,\n\t\t\tseverity: \"warning\",\n\t\t\treason: `${provider} success rate is ${stats.successRate.toFixed(1)}% (below 99%)`,\n\t\t};\n\t}\n\n\t// Warning: High latency\n\tif (stats.averageLatencyMs > 5000) {\n\t\treturn {\n\t\t\tshouldAlert: true,\n\t\t\tseverity: \"warning\",\n\t\t\treason: `${provider} average latency is ${stats.averageLatencyMs}ms (above 5s)`,\n\t\t};\n\t}\n\n\treturn { shouldAlert: false, severity: \"info\" };\n}\n","/**\n * Email Sender - Type-safe email sending utilities\n *\n * CRITICAL RULE - Reply-To Addresses:\n * ====================================\n * Reply-to ALWAYS uses the company's platform subdomain (mail.thorbis.com),\n * regardless of which email provider or sending method is used.\n *\n * Examples:\n * - FROM: notifications@acme.mail.thorbis.com  REPLY-TO: support@acme.mail.thorbis.com\n * - FROM: notifications@acme-plumbing.com (custom)  REPLY-TO: support@acme.mail.thorbis.com\n * - FROM: john@gmail.com (personal)  REPLY-TO: support@acme.mail.thorbis.com\n *\n * See: /docs/email/REPLY_TO_ARCHITECTURE.md for full details\n *\n * Features:\n * - Type-safe email sending with validation\n * - Development mode logging\n * - Error handling and logging\n * - Email logging to database\n * - Retry logic for failed sends\n * - Per-company rate limiting\n * - Deliverability monitoring\n */\n\n\"use server\";\n\nimport { render } from \"@react-email/components\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { ReactElement } from \"react\";\nimport { z } from \"zod\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport type { Database } from \"@/types/supabase\";\nimport { recordDeliveryEvent } from \"./deliverability-monitor\";\nimport type {\n\tEmailSendResult,\n\tEmailTemplate as EmailTemplateEnum,\n} from \"./email-types\";\nimport { emailSendSchema } from \"./email-types\";\nimport {\n\taddToSuppressionList,\n\tcheckSuppressionList,\n\trunPreSendChecks,\n} from \"./pre-send-checks\";\nimport {\n\tcheckRateLimit,\n\tgetCompanyActiveDomain,\n\tincrementEmailCounter,\n} from \"./rate-limiter\";\nimport { emailConfig, isResendConfigured, resend } from \"./resend-client\";\n\n// =============================================================================\n// MULTI-PROVIDER SUPPORT (Resend primary, Postmark fallback)\n// =============================================================================\n// Provider abstraction layer - handles automatic fallback when primary fails\nimport {\n\tsendEmailWithFallback,\n\tgetProviderSetupInfo,\n} from \"./email-provider\";\n\n// Provider monitoring - tracks success rates, latency for both providers\nimport {\n\trecordSendSuccess,\n\trecordSendFailure,\n\trecordFallbackTriggered,\n} from \"./provider-monitor\";\n\n// Attachment type for email\ntype EmailAttachment = {\n\tfilename: string;\n\tcontent: string; // Base64 encoded content\n\tcontentType?: string;\n};\n\n// Email send options\ntype SendEmailOptions = {\n\tto: string | string[];\n\tsubject: string;\n\ttemplate: ReactElement;\n\ttemplateType: EmailTemplateEnum;\n\t/** Reply-to address. Optional override.\n\t * If not provided, uses company's configured reply_to_email from company_email_domains table.\n\t * If company hasn't configured one, defaults to support@{company-subdomain}.mail.thorbis.com\n\t * This ensures replies always go to the same branded subdomain as FROM address (never custom domains) */\n\treplyTo?: string;\n\ttags?: { name: string; value: string }[];\n\tcompanyId?: string;\n\tcommunicationId?: string;\n\tfromOverride?: string;\n\t// CC/BCC recipients\n\tcc?: string | string[];\n\tbcc?: string | string[];\n\t// Attachments\n\tattachments?: EmailAttachment[];\n\t// Deliverability options\n\tisMarketingEmail?: boolean;\n\tskipPreSendChecks?: boolean; // For system emails that must go out\n\ttextContent?: string; // Plain text version for spam scoring\n\tunsubscribeUrl?: string;\n\tlistId?: string; // For List-Unsubscribe header\n};\n\n/**\n * Send email with React Email template\n *\n * Features:\n * - Validates email addresses\n * - Renders React Email template to HTML\n * - Sends via Resend\n * - Logs to database\n * - Development mode logging\n * - Rate limiting per company/domain\n * - Deliverability tracking\n */\nexport async function sendEmail({\n\tto,\n\tsubject,\n\ttemplate,\n\ttemplateType,\n\treplyTo,\n\ttags = [],\n\tcompanyId,\n\tcommunicationId,\n\tfromOverride,\n\tcc,\n\tbcc,\n\tattachments,\n\tisMarketingEmail = false,\n\tskipPreSendChecks = false,\n\ttextContent = \"\",\n\tunsubscribeUrl,\n\tlistId,\n}: SendEmailOptions): Promise<EmailSendResult> {\n\tlet activeDomainId: string | null = null;\n\tlet companyReplyTo: string | null = null;\n\tlet activeDomain: Awaited<ReturnType<typeof getCompanyActiveDomain>> = null;\n\n\ttry {\n\n\t\t// In development, log email instead of sending\n\t\tif (emailConfig.isDevelopment) {\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tid: `dev-mode-${Date.now()}`,\n\t\t\t\t\tmessage: \"Email logged in development mode (not actually sent)\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Check if at least one email provider is configured\n\t\t// We support Resend (primary) and Postmark (fallback)\n\t\tconst providerInfo = getProviderSetupInfo();\n\t\tif (providerInfo.status === \"not_configured\") {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Email service not configured. Please add RESEND_API_KEY or POSTMARK_API_KEY to environment variables.\",\n\t\t\t};\n\t\t}\n\t\tconsole.log(\n\t\t\t`[EmailSender] Providers available: ${providerInfo.configuredProviders.join(\", \")} (status: ${providerInfo.status})`\n\t\t);\n\n\t\tconst supabase = await createClient();\n\n\t\t// Fetch company email domain to get reply-to configuration\n\t\tif (companyId) {\n\t\t\tactiveDomain = await getCompanyActiveDomain(companyId);\n\t\t\tif (!activeDomain) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"No active email domain configured for this company. Please set up email in settings.\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tactiveDomainId = activeDomain.domainId;\n\n\t\t\t// Set reply-to from company's domain configuration\n\t\t\t// If not set, construct default using the company's domain (e.g., support@acme.mail.thorbis.com)\n\t\t\t// This ensures all replies go to the same branded subdomain as the FROM address\n\t\t\tif (activeDomain.replyToEmail) {\n\t\t\t\tcompanyReplyTo = activeDomain.replyToEmail;\n\t\t\t} else {\n\t\t\t\t// Default to support@{company-domain}\n\t\t\t\tcompanyReplyTo = `support@${activeDomain.domain}`;\n\t\t\t}\n\t\t}\n\n\t\t// Determine final reply-to address\n\t\t// Priority: 1) Explicit replyTo parameter, 2) Company's configured reply-to, 3) None\n\t\tconst finalReplyTo = replyTo || companyReplyTo || undefined;\n\n\t\t// Validate email data (now with proper reply-to)\n\t\tconst validatedData = emailSendSchema.parse({\n\t\t\tto,\n\t\t\tsubject,\n\t\t\treplyTo: finalReplyTo,\n\t\t});\n\n\t\t// Normalize recipient list\n\t\tconst recipientEmails = Array.isArray(validatedData.to)\n\t\t\t? validatedData.to\n\t\t\t: [validatedData.to];\n\n\t\t// Check rate limits and run pre-send checks if companyId is provided\n\t\tif (companyId && activeDomainId) {\n\n\t\t\t// Check rate limit before incrementing\n\t\t\tconst rateLimitCheck = await checkRateLimit(activeDomain.domainId);\n\t\t\tif (!rateLimitCheck.allowed) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitCheck.reason || \"Rate limit exceeded\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Run pre-send deliverability checks (unless skipped for system emails)\n\t\t\tif (!skipPreSendChecks) {\n\t\t\t\t// Render template early to get HTML for spam check\n\t\t\t\tconst preCheckHtml = await render(template);\n\t\t\t\tconst plainText = textContent || extractTextFromHtml(preCheckHtml);\n\n\t\t\t\tconst preSendResult = await runPreSendChecks(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tactiveDomain.domainId,\n\t\t\t\t\trecipientEmails,\n\t\t\t\t\tsubject,\n\t\t\t\t\tpreCheckHtml,\n\t\t\t\t\tplainText,\n\t\t\t\t\tisMarketingEmail\n\t\t\t\t);\n\n\t\t\t\t// Block if there are critical errors\n\t\t\t\tif (!preSendResult.allowed) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: `Deliverability check failed: ${preSendResult.errors.join(\"; \")}`,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tspamScore: preSendResult.spamScore,\n\t\t\t\t\t\t\twarnings: preSendResult.warnings,\n\t\t\t\t\t\t\tsuggestions: preSendResult.suggestions,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Filter out suppressed recipients\n\t\t\t\tconst activeRecipients = recipientEmails.filter((email) => {\n\t\t\t\t\tconst status = preSendResult.recipientStatus?.find(\n\t\t\t\t\t\t(r) => r.email.toLowerCase() === email.toLowerCase()\n\t\t\t\t\t);\n\t\t\t\t\treturn !status?.suppressed;\n\t\t\t\t});\n\n\t\t\t\tif (activeRecipients.length === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: \"All recipients are on suppression list - no emails sent\",\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Update validated data with filtered recipients\n\t\t\t\tif (activeRecipients.length < recipientEmails.length) {\n\t\t\t\t\tvalidatedData.to = activeRecipients.length === 1\n\t\t\t\t\t\t? activeRecipients[0]\n\t\t\t\t\t\t: activeRecipients;\n\t\t\t\t}\n\n\t\t\t\t// Log warnings if any (but still send)\n\t\t\t\tif (preSendResult.warnings.length > 0) {\n\t\t\t\t\tconsole.warn(\"[Email Deliverability Warnings]\", preSendResult.warnings);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Even for system emails, check suppression list\n\t\t\t\tconst suppressions = await checkSuppressionList(companyId, recipientEmails);\n\t\t\t\tconst activeRecipients = recipientEmails.filter((email) => {\n\t\t\t\t\tconst status = suppressions.get(email.toLowerCase());\n\t\t\t\t\treturn !status?.suppressed;\n\t\t\t\t});\n\n\t\t\t\tif (activeRecipients.length === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: \"All recipients are on suppression list\",\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (activeRecipients.length < recipientEmails.length) {\n\t\t\t\t\tvalidatedData.to = activeRecipients.length === 1\n\t\t\t\t\t\t? activeRecipients[0]\n\t\t\t\t\t\t: activeRecipients;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increment the counter (this also validates limits atomically)\n\t\t\tconst incrementResult = await incrementEmailCounter(activeDomain.domainId);\n\t\t\tif (!incrementResult.allowed) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: incrementResult.reason || \"Rate limit exceeded\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Determine from identity\n\t\tlet fromAddress = fromOverride || emailConfig.from;\n\t\tif (companyId && supabase) {\n\t\t\tconst override = await getCompanyEmailIdentity(supabase, companyId);\n\t\t\tif (override) {\n\t\t\t\tfromAddress = override;\n\t\t\t}\n\t\t}\n\n\t\t// Render template to HTML\n\t\tlet html = await render(template);\n\n\t\t// Add email tracking if communicationId is provided\n\t\tif (communicationId) {\n\t\t\tconst { addEmailTracking } = await import(\"./email-tracking\");\n\t\t\thtml = addEmailTracking(html, communicationId);\n\t\t}\n\n\t\tconst sendTags = [\n\t\t\t...tags,\n\t\t\t{ name: \"template\", value: templateType },\n\t\t\t{ name: \"environment\", value: process.env.NODE_ENV || \"development\" },\n\t\t];\n\n\t\tif (communicationId) {\n\t\t\tsendTags.push({ name: \"communication_id\", value: communicationId });\n\t\t}\n\n\t\t// Add company_id tag for webhook suppression list tracking\n\t\tif (companyId) {\n\t\t\tsendTags.push({ name: \"company_id\", value: companyId });\n\t\t}\n\n\t\t// Build enhanced headers for better deliverability\n\t\tconst emailHeaders: Record<string, string> = {\n\t\t\t// Precedence helps identify transactional vs marketing\n\t\t\t\"X-Priority\": \"3\", // Normal priority (1=High, 3=Normal, 5=Low)\n\t\t\t\"X-Mailer\": \"Stratos Email System\",\n\t\t};\n\n\t\t// Add List-Unsubscribe header for marketing emails (RFC 2369 compliance)\n\t\tif (isMarketingEmail && unsubscribeUrl) {\n\t\t\temailHeaders[\"List-Unsubscribe\"] = `<${unsubscribeUrl}>`;\n\t\t\temailHeaders[\"List-Unsubscribe-Post\"] = \"List-Unsubscribe=One-Click\";\n\t\t}\n\n\t\t// Add List-Id for mailing lists (helps with filtering)\n\t\tif (listId) {\n\t\t\temailHeaders[\"List-Id\"] = listId;\n\t\t}\n\n\t\t// Auto-Submitted header for transactional/automated emails\n\t\tif (!isMarketingEmail) {\n\t\t\temailHeaders[\"Auto-Submitted\"] = \"auto-generated\";\n\t\t\temailHeaders[\"Precedence\"] = \"bulk\"; // Prevents auto-replies\n\t\t}\n\n\t\t// =======================================================================\n\t\t// SEND EMAIL VIA PROVIDER LAYER (Resend  Postmark fallback)\n\t\t// =======================================================================\n\t\t// Convert tags to Record format for provider layer\n\t\tconst tagsRecord: Record<string, string> = {};\n\t\tfor (const tag of sendTags) {\n\t\t\ttagsRecord[tag.name] = tag.value;\n\t\t}\n\n\t\t// Track timing for monitoring\n\t\tconst sendStartTime = Date.now();\n\n\t\t// Send via provider layer (tries Resend first, then Postmark if Resend fails)\n\t\tconst providerResult = await sendEmailWithFallback({\n\t\t\tto: validatedData.to,\n\t\t\tsubject: validatedData.subject,\n\t\t\thtml,\n\t\t\ttext: textContent || extractTextFromHtml(html),\n\t\t\tfrom: fromAddress,\n\t\t\treplyTo: validatedData.replyTo,\n\t\t\ttags: tagsRecord,\n\t\t\tcommunicationId,\n\t\t\tcompanyId,\n\t\t\tcc,\n\t\t\tbcc,\n\t\t\tattachments,\n\t\t});\n\n\t\tconst sendLatencyMs = Date.now() - sendStartTime;\n\n\t\t// =======================================================================\n\t\t// RECORD PROVIDER MONITORING EVENTS\n\t\t// =======================================================================\n\t\t// Track success/failure for each provider attempt (for health dashboard)\n\t\tfor (const attempt of providerResult.attempts) {\n\t\t\tif (attempt.success) {\n\t\t\t\tawait recordSendSuccess(\n\t\t\t\t\tattempt.provider,\n\t\t\t\t\tattempt.messageId || \"\",\n\t\t\t\t\tattempt.latencyMs,\n\t\t\t\t\t{\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t\tdomainId: activeDomainId || undefined,\n\t\t\t\t\t\tmetadata: { template: templateType },\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tawait recordSendFailure(\n\t\t\t\t\tattempt.provider,\n\t\t\t\t\tattempt.error || \"Unknown error\",\n\t\t\t\t\tattempt.latencyMs,\n\t\t\t\t\t{\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t\tdomainId: activeDomainId || undefined,\n\t\t\t\t\t\tmetadata: { template: templateType },\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Record if fallback was triggered\n\t\tif (providerResult.usedFallback && providerResult.success) {\n\t\t\tconst primaryAttempt = providerResult.attempts.find((a) => a.provider === \"resend\");\n\t\t\tawait recordFallbackTriggered(\n\t\t\t\t\"resend\",\n\t\t\t\t\"postmark\",\n\t\t\t\tprimaryAttempt?.error || \"Primary failed\",\n\t\t\t\t{ companyId, metadata: { template: templateType } }\n\t\t\t);\n\t\t\tconsole.log(`[EmailSender] Used Postmark fallback after Resend failed: ${primaryAttempt?.error}`);\n\t\t}\n\n\t\t// =======================================================================\n\t\t// HANDLE RESULT\n\t\t// =======================================================================\n\t\tif (providerResult.success) {\n\t\t\t// SUCCESS: Email sent via one of the providers\n\t\t\tconsole.log(\n\t\t\t\t`[EmailSender]  Email sent via ${providerResult.provider}${providerResult.usedFallback ? \" (fallback)\" : \"\"} in ${sendLatencyMs}ms`\n\t\t\t);\n\n\t\t\t// Log successful email to database\n\t\t\ttry {\n\t\t\t\tif (supabase) {\n\t\t\t\t\tawait supabase.from(\"email_logs\").insert({\n\t\t\t\t\t\tto: Array.isArray(validatedData.to)\n\t\t\t\t\t\t\t? validatedData.to.join(\", \")\n\t\t\t\t\t\t\t: validatedData.to,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\tsubject: validatedData.subject,\n\t\t\t\t\t\thtml_body: html,\n\t\t\t\t\t\tstatus: \"sent\",\n\t\t\t\t\t\tmessage_id: providerResult.messageId,\n\t\t\t\t\t\tcompany_id: companyId || null,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\ttags: sendTags,\n\t\t\t\t\t\t\tprovider: providerResult.provider,\n\t\t\t\t\t\t\tusedFallback: providerResult.usedFallback,\n\t\t\t\t\t\t\tlatencyMs: sendLatencyMs,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsent_at: new Date().toISOString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (_logError) {\n\t\t\t\t// Don't throw - email was sent successfully even if logging failed\n\t\t\t}\n\n\t\t\t// Record delivered event for deliverability tracking\n\t\t\t// Note: This is an optimistic record; actual delivery confirmation comes via webhook\n\t\t\tif (activeDomainId) {\n\t\t\t\ttry {\n\t\t\t\t\tawait recordDeliveryEvent({\n\t\t\t\t\t\tdomainId: activeDomainId,\n\t\t\t\t\t\teventType: \"delivered\",\n\t\t\t\t\t\temailId: providerResult.messageId,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\tprovider: providerResult.provider,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} catch (_deliverabilityError) {\n\t\t\t\t\t// Don't fail the overall operation\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tid: providerResult.messageId,\n\t\t\t\t\tmessage: `Email sent successfully via ${providerResult.provider}${providerResult.usedFallback ? \" (fallback)\" : \"\"}`,\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\t// FAILURE: All providers failed\n\t\t\tconsole.error(`[EmailSender]  All providers failed: ${providerResult.error}`);\n\n\t\t\t// Log failed email to database for retry queue\n\t\t\ttry {\n\t\t\t\tif (supabase) {\n\t\t\t\t\tawait supabase.from(\"email_logs\").insert({\n\t\t\t\t\t\tto: Array.isArray(validatedData.to)\n\t\t\t\t\t\t\t? validatedData.to.join(\", \")\n\t\t\t\t\t\t\t: validatedData.to,\n\t\t\t\t\t\tfrom: fromAddress,\n\t\t\t\t\t\tsubject: validatedData.subject,\n\t\t\t\t\t\thtml_body: html,\n\t\t\t\t\t\tstatus: \"failed\",\n\t\t\t\t\t\terror_message: providerResult.error || \"All providers failed\",\n\t\t\t\t\t\tcompany_id: companyId || null,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\ttags: sendTags,\n\t\t\t\t\t\t\tattempts: providerResult.attempts,\n\t\t\t\t\t\t\tlatencyMs: sendLatencyMs,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tretry_count: 0,\n\t\t\t\t\t\tmax_retries: 3,\n\t\t\t\t\t\tnext_retry_at: new Date(Date.now() + 5 * 60 * 1000).toISOString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (_logError) {}\n\n\t\t\t// Record bounce event for deliverability tracking\n\t\t\tif (activeDomainId) {\n\t\t\t\ttry {\n\t\t\t\t\tawait recordDeliveryEvent({\n\t\t\t\t\t\tdomainId: activeDomainId,\n\t\t\t\t\t\teventType: \"bounced\",\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\terror: providerResult.error,\n\t\t\t\t\t\t\ttemplate: templateType,\n\t\t\t\t\t\t\tattempts: providerResult.attempts.length,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} catch (_deliverabilityError) {\n\t\t\t\t\t// Don't fail the overall operation\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: providerResult.error || \"Failed to send email (all providers failed)\",\n\t\t\t};\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Invalid email data\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to send email\",\n\t\t};\n\t}\n}\n\n/**\n * Send batch emails (up to 100 at once per Resend limits)\n *\n * Features:\n * - Validates batch size\n * - Sends multiple emails\n * - Returns results for each email\n */\nasync function sendBatchEmails(\n\temails: SendEmailOptions[],\n): Promise<EmailSendResult[]> {\n\tif (emails.length > 100) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Cannot send more than 100 emails at once\",\n\t\t\t},\n\t\t];\n\t}\n\n\tconst results = await Promise.all(emails.map((email) => sendEmail(email)));\n\n\treturn results;\n}\n\n/**\n * Test email configuration by sending a test email\n *\n * Features:\n * - Validates Resend configuration\n * - Sends test email to specified address\n * - Returns detailed error information\n */\nasync function testEmailConfiguration(\n\ttestEmailAddress: string,\n): Promise<EmailSendResult> {\n\ttry {\n\t\tconst validatedEmail = emailSendSchema.shape.to.parse(testEmailAddress);\n\n\t\tif (!isResendConfigured()) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Resend API key is not configured\",\n\t\t\t};\n\t\t}\n\n\t\t// Create a simple test template\n\t\tconst testTemplate = {\n\t\t\ttype: \"div\",\n\t\t\tprops: {\n\t\t\t\tchildren: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"h1\",\n\t\t\t\t\t\tprops: { children: \"Email Configuration Test\" },\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"p\",\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tchildren: \"This is a test email from your Thorbis application.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"p\",\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tchildren:\n\t\t\t\t\t\t\t\t\"If you received this, your email configuration is working correctly!\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t} as any;\n\n\t\treturn await sendEmail({\n\t\t\tto: validatedEmail,\n\t\t\tsubject: \"Test Email - Thorbis Email Configuration\",\n\t\t\ttemplate: testTemplate,\n\t\t\ttemplateType: \"welcome\" as EmailTemplateEnum,\n\t\t\ttags: [{ name: \"type\", value: \"test\" }],\n\t\t});\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Invalid email address\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Configuration test failed\",\n\t\t};\n\t}\n}\n\nasync function getCompanyEmailIdentity(\n\tsupabase: SupabaseClient<Database>,\n\tcompanyId: string,\n) {\n\t// Get company name first\n\tconst { data: company } = await supabase\n\t\t.from(\"companies\")\n\t\t.select(\"name\")\n\t\t.eq(\"id\", companyId)\n\t\t.single();\n\n\tconst companyName = company?.name || \"Notification\";\n\n\t// Check company_email_domains table for active sending domain\n\t// Prioritizes custom domains over platform subdomains\n\tconst { data: domain } = await supabase\n\t\t.from(\"company_email_domains\")\n\t\t.select(\"domain_name, is_platform_subdomain\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"verified\")\n\t\t.eq(\"sending_enabled\", true)\n\t\t.eq(\"is_suspended\", false)\n\t\t.order(\"is_platform_subdomain\", { ascending: true }) // Custom domains first\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.maybeSingle();\n\n\tif (domain?.domain_name) {\n\t\t// domain_name contains the full domain (e.g., company.mail.stratos.app or mail.custom.com)\n\t\treturn formatFromAddress(companyName, `notifications@${domain.domain_name}`);\n\t}\n\n\t// Fallback: Check old communication_email_settings (legacy)\n\tconst { data: settings } = await supabase\n\t\t.from(\"communication_email_settings\")\n\t\t.select(\"smtp_from_email, smtp_from_name\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.maybeSingle();\n\n\tif (settings?.smtp_from_email) {\n\t\treturn formatFromAddress(settings.smtp_from_name, settings.smtp_from_email);\n\t}\n\n\treturn null;\n}\n\nfunction formatFromAddress(name: string | null | undefined, email: string) {\n\tif (name?.trim()) {\n\t\treturn `${name} <${email}>`;\n\t}\n\treturn email;\n}\n\n/**\n * Extract plain text from HTML for spam scoring and multipart emails\n */\nfunction extractTextFromHtml(html: string): string {\n\t// Remove script and style tags with their content\n\tlet text = html.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n\ttext = text.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\");\n\n\t// Replace block elements with newlines\n\ttext = text.replace(/<\\/(p|div|h[1-6]|li|br|tr)>/gi, \"\\n\");\n\ttext = text.replace(/<(br|hr)\\s*\\/?>/gi, \"\\n\");\n\n\t// Remove all remaining HTML tags\n\ttext = text.replace(/<[^>]+>/g, \" \");\n\n\t// Decode common HTML entities\n\ttext = text\n\t\t.replace(/&nbsp;/gi, \" \")\n\t\t.replace(/&amp;/gi, \"&\")\n\t\t.replace(/&lt;/gi, \"<\")\n\t\t.replace(/&gt;/gi, \">\")\n\t\t.replace(/&quot;/gi, '\"')\n\t\t.replace(/&#39;/gi, \"'\")\n\t\t.replace(/&mdash;/gi, \"\")\n\t\t.replace(/&ndash;/gi, \"\");\n\n\t// Clean up whitespace\n\ttext = text.replace(/\\s+/g, \" \").trim();\n\ttext = text.replace(/\\n\\s*\\n/g, \"\\n\\n\"); // Multiple newlines to double\n\n\treturn text;\n}\n\n/**\n * Handle bounce webhook and add to suppression list\n */\nexport async function handleBounceWebhook(\n\tcompanyId: string,\n\temail: string,\n\tbounceType: \"hard\" | \"soft\",\n\tbounceReason?: string\n): Promise<void> {\n\t// Import here to avoid circular dependency\n\tconst { addToSuppressionList, addToGlobalBounceList } = await import(\"./pre-send-checks\");\n\n\t// Add to company suppression list for hard bounces\n\tif (bounceType === \"hard\") {\n\t\tawait addToSuppressionList(companyId, email, \"bounce\", bounceReason);\n\t}\n\n\t// Add to global bounce list (hard bounces only)\n\tawait addToGlobalBounceList(email, bounceType, bounceReason);\n}\n\n/**\n * Handle complaint webhook (spam report) and add to suppression list\n */\nexport async function handleComplaintWebhook(\n\tcompanyId: string,\n\temail: string\n): Promise<void> {\n\tconst { addToSuppressionList } = await import(\"./pre-send-checks\");\n\n\t// Always suppress on complaint - user marked as spam\n\tawait addToSuppressionList(\n\t\tcompanyId,\n\t\temail,\n\t\t\"complaint\",\n\t\t\"User reported email as spam\"\n\t);\n}\n"],"names":[],"mappings":"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"}