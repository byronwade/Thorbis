{"version":3,"sources":["../../../../../../apps/web/src/lib/payments/stripe-server.ts","../../../../../../apps/web/src/lib/payments/processors/stripe.ts"],"sourcesContent":["/**\n * Stripe Server - Server-side Stripe utilities\n *\n * Features:\n * - Secure Stripe API client initialization\n * - Multi-organization subscription management\n * - Billing portal session creation\n * - Subscription lifecycle management\n *\n * Performance optimizations:\n * - Server-side only (uses secret key)\n * - Type-safe with TypeScript\n * - Proper error handling\n */\n\nimport Stripe from \"stripe\";\n\n/**\n * Initialize Stripe server client\n *\n * SECURITY: This uses the secret key and must only be called server-side\n */\nfunction getStripeServer(): Stripe | null {\n\tconst secretKey = process.env.STRIPE_SECRET_KEY;\n\n\tif (!secretKey) {\n\t\treturn null;\n\t}\n\n\treturn new Stripe(secretKey, {\n\t\tapiVersion: \"2025-10-29.clover\",\n\t\ttypescript: true,\n\t});\n}\n\n// Export singleton instance\nexport const stripe = getStripeServer();\n\n/**\n * Create or retrieve Stripe customer for a user\n *\n * Creates a customer in Stripe if they don't have one yet\n * Links customer to user via metadata\n */\nasync function getOrCreateStripeCustomer(\n\tuserId: string,\n\temail: string,\n\tname?: string,\n): Promise<string | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\t// Check if customer already exists\n\t\tconst customers = await stripe.customers.list({\n\t\t\temail,\n\t\t\tlimit: 1,\n\t\t});\n\n\t\tif (customers.data.length > 0) {\n\t\t\treturn customers.data[0].id;\n\t\t}\n\n\t\t// Create new customer\n\t\tconst customer = await stripe.customers.create({\n\t\t\temail,\n\t\t\tname,\n\t\t\tmetadata: {\n\t\t\t\tuser_id: userId,\n\t\t\t},\n\t\t});\n\n\t\treturn customer.id;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Create checkout session for new subscription\n *\n * For first organization: Base plan\n * For additional organizations: Base plan + Additional org addon\n */\nasync function createCheckoutSession({\n\tcustomerId,\n\tcompanyId,\n\tisAdditionalOrg,\n\tsuccessUrl,\n\tcancelUrl,\n\tphoneNumber,\n}: {\n\tcustomerId: string;\n\tcompanyId: string;\n\tisAdditionalOrg: boolean;\n\tsuccessUrl: string;\n\tcancelUrl: string;\n\tphoneNumber?: string;\n}): Promise<string | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst basePriceId = process.env.STRIPE_PRICE_ID_BASE_PLAN;\n\t\tconst additionalOrgPriceId = process.env.STRIPE_PRICE_ID_ADDITIONAL_ORG;\n\n\t\tif (!basePriceId) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Build line items\n\t\tconst lineItems: Stripe.Checkout.SessionCreateParams.LineItem[] = [\n\t\t\t{\n\t\t\t\tprice: basePriceId,\n\t\t\t\tquantity: 1,\n\t\t\t},\n\t\t];\n\n\t\t// Add additional organization fee if this is not the first org\n\t\tif (isAdditionalOrg && additionalOrgPriceId) {\n\t\t\tlineItems.push({\n\t\t\t\tprice: additionalOrgPriceId,\n\t\t\t\tquantity: 1,\n\t\t\t});\n\t\t}\n\n\t\tconst session = await stripe.checkout.sessions.create({\n\t\t\tcustomer: customerId,\n\t\t\tmode: \"subscription\",\n\t\t\tline_items: lineItems,\n\t\t\tsuccess_url: successUrl,\n\t\t\tcancel_url: cancelUrl,\n\t\t\tmetadata: {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tis_additional_org: isAdditionalOrg.toString(),\n\t\t\t\t...(phoneNumber && { phone_number: phoneNumber }),\n\t\t\t},\n\t\t\tsubscription_data: {\n\t\t\t\tmetadata: {\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\treturn session.url;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Create billing portal session\n *\n * Allows users to manage their subscription, payment methods, and billing history\n */\nasync function createBillingPortalSession(\n\tcustomerId: string,\n\treturnUrl: string,\n): Promise<string | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst session = await stripe.billingPortal.sessions.create({\n\t\t\tcustomer: customerId,\n\t\t\treturn_url: returnUrl,\n\t\t});\n\n\t\treturn session.url;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Cancel subscription\n *\n * Cancels subscription at the end of the current billing period\n */\nasync function cancelSubscription(\n\tsubscriptionId: string,\n): Promise<boolean> {\n\tif (!stripe) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tawait stripe.subscriptions.update(subscriptionId, {\n\t\t\tcancel_at_period_end: true,\n\t\t});\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Reactivate subscription\n *\n * Removes the cancellation flag from a subscription\n */\nasync function reactivateSubscription(\n\tsubscriptionId: string,\n): Promise<boolean> {\n\tif (!stripe) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tawait stripe.subscriptions.update(subscriptionId, {\n\t\t\tcancel_at_period_end: false,\n\t\t});\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Get subscription details\n */\nasync function getSubscription(\n\tsubscriptionId: string,\n): Promise<Stripe.Subscription | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst subscription = await stripe.subscriptions.retrieve(subscriptionId);\n\t\treturn subscription;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * List all subscriptions for a customer\n */\nasync function listCustomerSubscriptions(\n\tcustomerId: string,\n): Promise<Stripe.Subscription[]> {\n\tif (!stripe) {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\tconst subscriptions = await stripe.subscriptions.list({\n\t\t\tcustomer: customerId,\n\t\t\tstatus: \"all\",\n\t\t});\n\n\t\treturn subscriptions.data;\n\t} catch (_error) {\n\t\treturn [];\n\t}\n}\n\n/**\n * Attach payment method to customer\n *\n * Attaches a payment method collected via Stripe Elements to a customer\n * and sets it as the default payment method\n */\nasync function attachPaymentMethodToCustomer(\n\tpaymentMethodId: string,\n\tcustomerId: string,\n): Promise<boolean> {\n\tif (!stripe) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\t// Attach payment method to customer\n\t\tawait stripe.paymentMethods.attach(paymentMethodId, {\n\t\t\tcustomer: customerId,\n\t\t});\n\n\t\t// Set as default payment method\n\t\tawait stripe.customers.update(customerId, {\n\t\t\tinvoice_settings: {\n\t\t\t\tdefault_payment_method: paymentMethodId,\n\t\t\t},\n\t\t});\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n","/**\n * Stripe Payment Processor\n *\n * Wrapper around existing Stripe integration.\n * Used ONLY for platform billing (subscriptions), NOT for contractor payments.\n *\n * Contractor payments should use Adyen to avoid Stripe's limitations\n * on high-value transactions.\n */\n\nimport { stripe } from \"@/lib/payments/stripe-server\";\nimport type {\n\tPaymentChannel,\n\tPaymentProcessor,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n} from \"../processor-types\";\n\ntype StripeConfig = {\n\tcompanyId: string;\n\tliveMode?: boolean;\n};\n\nexport class StripeProcessor implements PaymentProcessor {\n\tprivate readonly config: StripeConfig;\n\n\tconstructor(config: StripeConfig) {\n\t\tthis.config = config;\n\t}\n\n\tgetSupportedChannels(): PaymentChannel[] {\n\t\treturn [\"online\"];\n\t}\n\n\tasync processPayment(\n\t\trequest: ProcessPaymentRequest,\n\t): Promise<ProcessPaymentResponse> {\n\t\tif (!stripe) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tstatus: \"failed\",\n\t\t\t\terror: \"Stripe is not configured\",\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// WARNING: Stripe has limitations on high-value payments\n\t\t\t// This should only be used for platform billing, not contractor payments\n\t\t\tif (request.amount > 100_000) {\n\t\t\t\tconsole.warn(`Stripe: High-value payment of ${request.amount} cents - verify this is platform billing, not contractor payment`);\n\t\t\t}\n\n\t\t\tconst paymentIntent = await stripe.paymentIntents.create({\n\t\t\t\tamount: request.amount,\n\t\t\t\tcurrency: request.currency || \"usd\",\n\t\t\t\tcustomer: request.customerId,\n\t\t\t\tpayment_method: request.paymentMethodId,\n\t\t\t\tconfirm: true,\n\t\t\t\tmetadata: {\n\t\t\t\t\tcompany_id: this.config.companyId,\n\t\t\t\t\tinvoice_id: request.invoiceId || \"\",\n\t\t\t\t\tchannel: request.channel,\n\t\t\t\t\t...request.metadata,\n\t\t\t\t},\n\t\t\t\tdescription: request.description,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: paymentIntent.status === \"succeeded\",\n\t\t\t\ttransactionId: paymentIntent.id,\n\t\t\t\tprocessorTransactionId: paymentIntent.id,\n\t\t\t\tstatus:\n\t\t\t\t\tpaymentIntent.status === \"succeeded\"\n\t\t\t\t\t\t? \"succeeded\"\n\t\t\t\t\t\t: paymentIntent.status === \"requires_action\"\n\t\t\t\t\t\t\t? \"requires_action\"\n\t\t\t\t\t\t\t: \"processing\",\n\t\t\t\tclientSecret: paymentIntent.client_secret || undefined,\n\t\t\t\tprocessorMetadata: paymentIntent as unknown as Record<string, unknown>,\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tstatus: \"failed\",\n\t\t\t\terror: error.message || \"Payment processing failed\",\n\t\t\t\tfailureCode: error.code,\n\t\t\t\tfailureMessage: error.message,\n\t\t\t};\n\t\t}\n\t}\n\n\tasync refundPayment(\n\t\trequest: RefundPaymentRequest,\n\t): Promise<RefundPaymentResponse> {\n\t\tif (!stripe) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tstatus: \"failed\",\n\t\t\t\terror: \"Stripe is not configured\",\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\tconst refund = await stripe.refunds.create({\n\t\t\t\tpayment_intent: request.transactionId,\n\t\t\t\tamount: request.amount,\n\t\t\t\tmetadata: {\n\t\t\t\t\treason: request.reason || \"\",\n\t\t\t\t\t...request.metadata,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: refund.status === \"succeeded\",\n\t\t\t\trefundId: refund.id,\n\t\t\t\tprocessorRefundId: refund.id,\n\t\t\t\tstatus: refund.status === \"succeeded\" ? \"succeeded\" : \"processing\",\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tstatus: \"failed\",\n\t\t\t\terror: error.message || \"Refund failed\",\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getPaymentStatus(transactionId: string): Promise<{\n\t\tstatus: string;\n\t\tamount: number;\n\t\tmetadata?: Record<string, unknown>;\n\t}> {\n\t\tif (!stripe) {\n\t\t\tthrow new Error(\"Stripe is not configured\");\n\t\t}\n\n\t\tconst paymentIntent = await stripe.paymentIntents.retrieve(transactionId);\n\n\t\treturn {\n\t\t\tstatus: paymentIntent.status,\n\t\t\tamount: paymentIntent.amount,\n\t\t\tmetadata: paymentIntent as unknown as Record<string, unknown>,\n\t\t};\n\t}\n\n\tverifyWebhook(_payload: string, _signature: string): boolean {\n\t\tif (!stripe) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Stripe webhook signature verification\n\t\t\tconst webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\t\t\tif (!webhookSecret) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Note: This is a simplified check - in production, use Stripe's webhook.constructEvent\n\t\t\t// which properly verifies the signature\n\t\t\treturn true; // Placeholder - implement proper verification\n\t\t} catch (_error) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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"}