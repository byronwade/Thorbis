{"version":3,"sources":["../../../../../../apps/web/src/queries/customers-search.ts","../../../../../../apps/web/src/actions/documents.ts","../../../../../../apps/web/src/lib/storage/document-manager.ts","../../../../../../apps/web/src/lib/storage/file-validator.ts","../../../../../../apps/web/src/actions/archive.ts","../../../../../../apps/web/.next-internal/server/app/%28dashboard%29/dashboard/work/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["/**\n * Customer Search Queries\n *\n * Server-side search functions for customers and properties\n * Uses full-text search with PostgreSQL ranking\n */\n\n\"use server\";\n\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport { searchCustomersFullText } from \"@/lib/search/full-text-search\";\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport type Customer = {\n\tid: string;\n\tfirst_name: string;\n\tlast_name: string;\n\tdisplay_name: string;\n\temail: string;\n\tphone: string;\n\tcompany_name?: string;\n\ttype: \"residential\" | \"commercial\" | \"industrial\";\n\taddress?: string;\n\tcity?: string;\n\tstate?: string;\n\tzip?: string;\n};\n\nexport type Property = {\n\tid: string;\n\tcustomer_id: string;\n\taddress: string;\n\taddress_line2?: string;\n\tcity: string;\n\tstate: string;\n\tzip: string;\n\tproperty_type?: string;\n};\n\n/**\n * Search customers using full-text search\n *\n * @param query - Search query (name, email, phone, company, address)\n * @returns Array of matching customers ranked by relevance\n */\nexport async function searchCustomersForJob(\n\tquery: string,\n): Promise<Customer[]> {\n\tif (!query || query.trim().length < 2) {\n\t\treturn [];\n\t}\n\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn [];\n\t}\n\n\tconst companyId = await getActiveCompanyId();\n\tif (!companyId) {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\tconst results = await searchCustomersFullText(supabase, companyId, query, {\n\t\t\tlimit: 50,\n\t\t});\n\n\t\treturn results as Customer[];\n\t} catch (error) {\n\t\tconsole.error(\"Error searching customers:\", error);\n\t\treturn [];\n\t}\n}\n\n/**\n * Get all properties for a customer\n *\n * @param customerId - Customer ID\n * @returns Array of properties belonging to the customer\n */\nexport async function getCustomerProperties(\n\tcustomerId: string,\n): Promise<Property[]> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn [];\n\t}\n\n\tconst companyId = await getActiveCompanyId();\n\tif (!companyId) {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"properties\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"customer_id\", customerId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Error fetching properties:\", error);\n\t\t\treturn [];\n\t\t}\n\n\t\treturn (data || []) as Property[];\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching properties:\", error);\n\t\treturn [];\n\t}\n}\n","/**\n * Document Server Actions\n *\n * Server-side actions for document management with:\n * - Permission checks\n * - Audit logging\n * - Error handling\n * - Type-safe interfaces\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\ttype DocumentContext,\n\tdeleteDocument as deleteDocumentService,\n\tgetDocumentStats as getDocumentStatsService,\n\tgetDownloadUrl as getDownloadUrlService,\n\ttype ListFilesOptions,\n\tlistDocuments as listDocumentsService,\n\tmoveDocument as moveDocumentService,\n\ttype UploadOptions,\n\tupdateDocumentMetadata as updateMetadataService,\n\tuploadDocument as uploadDocumentService,\n\tuploadDocuments as uploadDocumentsService,\n} from \"@/lib/storage/document-manager\";\nimport { validateFile } from \"@/lib/storage/file-validator\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type ActionResult<T = void> = {\n\tsuccess: boolean;\n\tdata?: T;\n\terror?: string;\n\twarnings?: string[];\n};\n\nexport type UploadDocumentResult = {\n\tattachmentId: string;\n\tfileName: string;\n\tfileSize: number;\n\tstorageUrl: string;\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Verify user has access to company\n */\nasync function verifyCompanyAccess(\n\tcompanyId: string,\n\trequiredRole?: string[],\n): Promise<{ userId: string; role: string } | null> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\tconst {\n\t\tdata: { user },\n\t\terror: authError,\n\t} = await supabase.auth.getUser();\n\tif (authError || !user) {\n\t\treturn null;\n\t}\n\n\tconst { data: membership, error } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"id, role\")\n\t\t.eq(\"user_id\", user.id)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.single();\n\n\tif (error || !membership) {\n\t\treturn null;\n\t}\n\n\tif (requiredRole && !requiredRole.includes(membership.role)) {\n\t\treturn null;\n\t}\n\n\treturn { userId: user.id, role: membership.role };\n}\n\n/**\n * Log document action to audit trail\n */\nasync function logDocumentAction(\n\tcompanyId: string,\n\tuserId: string,\n\taction: string,\n\tdetails: Record<string, unknown>,\n): Promise<void> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn;\n\t}\n\n\tawait supabase.from(\"activity_log\").insert({\n\t\tcompany_id: companyId,\n\t\tuser_id: userId,\n\t\taction,\n\t\tentity_type: \"document\",\n\t\tdetails,\n\t\tcreated_at: new Date().toISOString(),\n\t});\n}\n\n// ============================================================================\n// UPLOAD ACTIONS\n// ============================================================================\n\n/**\n * Upload a single document\n */\nexport async function uploadDocument(\n\tformData: FormData,\n): Promise<ActionResult<UploadDocumentResult>> {\n\ttry {\n\t\tconst {\n\t\t\tfile,\n\t\t\tcompanyId,\n\t\t\tcontextType,\n\t\t\tcontextId,\n\t\t\tfolder,\n\t\t\tdescription,\n\t\t\ttagsRaw,\n\t\t} = extractUploadFormData(formData);\n\n\t\tconst validateResult = await validateUploadInputs(file, contextType);\n\t\tif (validateResult) {\n\t\t\treturn validateResult;\n\t\t}\n\n\t\tconst activeCompanyId = await getActiveCompanyId();\n\t\tif (!activeCompanyId) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"No active company found. Please select a company.\",\n\t\t\t};\n\t\t}\n\n\t\tconst targetCompanyId = companyId || activeCompanyId;\n\n\t\tif (contextType === \"job\" && contextId) {\n\t\t\treturn handleJobDocumentUpload({\n\t\t\t\tfile,\n\t\t\t\tcontextType,\n\t\t\t\tcontextId,\n\t\t\t\tfolder,\n\t\t\t\tdescription,\n\t\t\t\ttagsRaw,\n\t\t\t\tactiveCompanyId,\n\t\t\t});\n\t\t}\n\n\t\treturn handleNonJobDocumentUpload({\n\t\t\tfile,\n\t\t\tcontextType,\n\t\t\tcontextId,\n\t\t\tfolder,\n\t\t\tdescription,\n\t\t\ttagsRaw,\n\t\t\ttargetCompanyId,\n\t\t\tactiveCompanyId,\n\t\t});\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Upload failed\",\n\t\t};\n\t}\n}\n\ntype UploadContextType = DocumentContext[\"type\"];\n\ntype UploadFormData = {\n\tfile: File;\n\tcompanyId: string;\n\tcontextType: UploadContextType;\n\tcontextId?: string;\n\tfolder?: string;\n\tdescription?: string;\n\ttagsRaw?: string;\n};\n\ntype UploadHandlerBaseParams = {\n\tfile: File;\n\tcontextType: UploadContextType;\n\tcontextId?: string;\n\tfolder?: string;\n\tdescription?: string;\n\ttagsRaw?: string;\n};\n\ntype JobUploadParams = UploadHandlerBaseParams & {\n\tcontextId: string;\n\tactiveCompanyId: string;\n};\n\ntype NonJobUploadParams = UploadHandlerBaseParams & {\n\ttargetCompanyId: string;\n\tactiveCompanyId: string;\n};\n\nfunction extractUploadFormData(formData: FormData): UploadFormData {\n\tconst file = formData.get(\"file\") as File;\n\tconst companyId = (formData.get(\"companyId\") as string) ?? \"\";\n\tconst contextType = formData.get(\"contextType\") as UploadContextType;\n\tconst contextId = formData.get(\"contextId\") as string | undefined;\n\tconst folder = formData.get(\"folder\") as string | undefined;\n\tconst description = formData.get(\"description\") as string | undefined;\n\tconst tagsRaw = formData.get(\"tags\") as string | undefined;\n\n\treturn {\n\t\tfile,\n\t\tcompanyId,\n\t\tcontextType,\n\t\tcontextId,\n\t\tfolder,\n\t\tdescription,\n\t\ttagsRaw,\n\t};\n}\n\nfunction validateUploadInputs(\n\tfile: File | undefined,\n\tcontextType: UploadContextType | undefined,\n): ActionResult<UploadDocumentResult> | undefined {\n\tif (!(file && contextType)) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Missing required fields\",\n\t\t};\n\t}\n\n\treturn;\n}\n\nfunction parseTags(tagsRaw?: string): string[] | undefined {\n\tif (!tagsRaw) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn JSON.parse(tagsRaw) as string[];\n\t} catch {\n\t\treturn;\n\t}\n}\n\nasync function validateJobContext(\n\tcontextId: string,\n\tactiveCompanyId: string,\n): Promise<{ companyId: string } | ActionResult<UploadDocumentResult>> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Server configuration error\",\n\t\t};\n\t}\n\n\tconst { data: job, error: jobError } = await supabase\n\t\t.from(\"jobs\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"id\", contextId)\n\t\t.single();\n\n\tif (jobError || !job) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Job not found\",\n\t\t};\n\t}\n\n\tif (job.company_id !== activeCompanyId) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Access denied - This job belongs to a different company\",\n\t\t};\n\t}\n\n\treturn { companyId: job.company_id };\n}\n\nasync function handleJobDocumentUpload(\n\tparams: JobUploadParams,\n): Promise<ActionResult<UploadDocumentResult>> {\n\tconst validationResult = await validateJobContext(\n\t\tparams.contextId,\n\t\tparams.activeCompanyId,\n\t);\n\n\tif (\"success\" in validationResult && !validationResult.success) {\n\t\treturn validationResult;\n\t}\n\n\tconst { companyId } = validationResult as { companyId: string };\n\n\tconst access = await verifyCompanyAccess(companyId);\n\tif (!access) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\t\"Access denied - You must be an active member of this company to upload files\",\n\t\t};\n\t}\n\n\tconst parsedTags = parseTags(params.tagsRaw);\n\tif (params.tagsRaw && !parsedTags) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Invalid tags format\",\n\t\t};\n\t}\n\n\tconst context: DocumentContext = {\n\t\ttype: params.contextType,\n\t\tid: params.contextId,\n\t\tfolder: params.folder,\n\t};\n\n\tconst options: UploadOptions = {\n\t\tcompanyId,\n\t\tcontext,\n\t\tdescription: params.description,\n\t\ttags: parsedTags,\n\t};\n\n\tconst result = await uploadDocumentService(params.file, options);\n\n\tif (!(result.success && result.attachmentId && result.storageUrl)) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: result.error || \"Upload failed\",\n\t\t\twarnings: result.warnings,\n\t\t};\n\t}\n\n\tawait logDocumentAction(companyId, access.userId, \"document_uploaded\", {\n\t\tattachmentId: result.attachmentId,\n\t\tfileName: params.file.name,\n\t\tfileSize: params.file.size,\n\t\tcontext,\n\t});\n\n\trevalidatePath(\"/dashboard/documents\");\n\tif (params.contextId) {\n\t\trevalidatePath(`/dashboard/work/${params.contextId}`);\n\t}\n\n\treturn {\n\t\tsuccess: true,\n\t\tdata: {\n\t\t\tattachmentId: result.attachmentId,\n\t\t\tfileName: params.file.name,\n\t\t\tfileSize: params.file.size,\n\t\t\tstorageUrl: result.storageUrl,\n\t\t},\n\t\twarnings: result.warnings,\n\t};\n}\n\nasync function handleNonJobDocumentUpload(\n\tparams: NonJobUploadParams,\n): Promise<ActionResult<UploadDocumentResult>> {\n\tconst access = await verifyCompanyAccess(params.targetCompanyId);\n\tif (!access) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\t\"Access denied - You must be an active member of this company to upload files\",\n\t\t};\n\t}\n\n\tconst validation = await validateFile(params.file);\n\tif (!validation.valid) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: validation.errors.join(\"; \"),\n\t\t\twarnings: validation.warnings,\n\t\t};\n\t}\n\n\tconst parsedTags = parseTags(params.tagsRaw);\n\tif (params.tagsRaw && !parsedTags) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Invalid tags format\",\n\t\t};\n\t}\n\n\tconst context: DocumentContext = {\n\t\ttype: params.contextType,\n\t\tid: params.contextId,\n\t\tfolder: params.folder,\n\t};\n\n\tconst options: UploadOptions = {\n\t\tcompanyId: params.targetCompanyId,\n\t\tcontext,\n\t\tdescription: params.description,\n\t\ttags: parsedTags,\n\t};\n\n\tconst result = await uploadDocumentService(params.file, options);\n\n\tif (!(result.success && result.attachmentId && result.storageUrl)) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: result.error || \"Upload failed\",\n\t\t\twarnings: result.warnings,\n\t\t};\n\t}\n\n\tawait logDocumentAction(\n\t\tparams.targetCompanyId,\n\t\taccess.userId,\n\t\t\"document_uploaded\",\n\t\t{\n\t\t\tattachmentId: result.attachmentId,\n\t\t\tfileName: params.file.name,\n\t\t\tfileSize: params.file.size,\n\t\t\tcontext,\n\t\t},\n\t);\n\n\trevalidatePath(\"/dashboard/documents\");\n\tif (params.contextType === \"customer\" && params.contextId) {\n\t\trevalidatePath(`/dashboard/customers/${params.contextId}`);\n\t} else if (params.contextType === \"job\" && params.contextId) {\n\t\trevalidatePath(`/dashboard/work/${params.contextId}`);\n\t}\n\n\treturn {\n\t\tsuccess: true,\n\t\tdata: {\n\t\t\tattachmentId: result.attachmentId,\n\t\t\tfileName: params.file.name,\n\t\t\tfileSize: params.file.size,\n\t\t\tstorageUrl: result.storageUrl,\n\t\t},\n\t\twarnings: result.warnings,\n\t};\n}\n\n/**\n * Upload multiple documents\n */\nasync function uploadDocuments(\n\tformData: FormData,\n): Promise<ActionResult<UploadDocumentResult[]>> {\n\ttry {\n\t\tconst files = formData.getAll(\"files\") as File[];\n\t\tconst companyId = formData.get(\"companyId\") as string;\n\t\tconst contextType = formData.get(\"contextType\") as DocumentContext[\"type\"];\n\t\tconst contextId = formData.get(\"contextId\") as string | undefined;\n\t\tconst folder = formData.get(\"folder\") as string | undefined;\n\n\t\tif (!(files.length && companyId && contextType)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Missing required fields\",\n\t\t\t};\n\t\t}\n\n\t\tconst access = await verifyCompanyAccess(companyId);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst context: DocumentContext = {\n\t\t\ttype: contextType,\n\t\t\tid: contextId,\n\t\t\tfolder,\n\t\t};\n\n\t\tconst options: UploadOptions = {\n\t\t\tcompanyId,\n\t\t\tcontext,\n\t\t};\n\n\t\tconst results = await uploadDocumentsService(files, options);\n\n\t\tconst successfulUploads: UploadDocumentResult[] = [];\n\t\tconst errors: string[] = [];\n\n\t\tresults.forEach((result, index) => {\n\t\t\tif (result.success && result.attachmentId && result.storageUrl) {\n\t\t\t\tsuccessfulUploads.push({\n\t\t\t\t\tattachmentId: result.attachmentId,\n\t\t\t\t\tfileName: files[index].name,\n\t\t\t\t\tfileSize: files[index].size,\n\t\t\t\t\tstorageUrl: result.storageUrl,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\terrors.push(`${files[index].name}: ${result.error}`);\n\t\t\t}\n\t\t});\n\n\t\t// Log action\n\t\tawait logDocumentAction(\n\t\t\tcompanyId,\n\t\t\taccess.userId,\n\t\t\t\"documents_bulk_uploaded\",\n\t\t\t{\n\t\t\t\tcount: successfulUploads.length,\n\t\t\t\tfailed: errors.length,\n\t\t\t\tcontext,\n\t\t\t},\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/documents\");\n\n\t\tif (errors.length > 0 && successfulUploads.length === 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errors.join(\"; \"),\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: successfulUploads,\n\t\t\twarnings: errors.length > 0 ? errors : undefined,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Upload failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// DOWNLOAD ACTIONS\n// ============================================================================\n\n/**\n * Get download URL for document\n */\nasync function getDocumentDownloadUrl(\n\tattachmentId: string,\n): Promise<ActionResult<string>> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Server configuration error\" };\n\t\t}\n\n\t\t// Get attachment to verify access\n\t\tconst { data: attachment, error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"company_id, file_name\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (error || !attachment) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Document not found\",\n\t\t\t};\n\t\t}\n\n\t\tconst access = await verifyCompanyAccess(attachment.company_id);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await getDownloadUrlService(attachmentId);\n\n\t\tif (result.error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error,\n\t\t\t};\n\t\t}\n\n\t\t// Log download\n\t\tawait logDocumentAction(\n\t\t\tattachment.company_id,\n\t\t\taccess.userId,\n\t\t\t\"document_downloaded\",\n\t\t\t{\n\t\t\t\tattachmentId,\n\t\t\t\tfileName: attachment.file_name,\n\t\t\t},\n\t\t);\n\n\t\tif (!result.url) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Download URL not available\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: result.url,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get download URL\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// DELETE ACTIONS\n// ============================================================================\n\n/**\n * Delete document\n */\nasync function deleteDocument(\n\tattachmentId: string,\n): Promise<ActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Server configuration error\" };\n\t\t}\n\n\t\tconst { data: attachment, error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"company_id, file_name, entity_type, entity_id\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (error || !attachment) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Document not found\",\n\t\t\t};\n\t\t}\n\n\t\tconst access = await verifyCompanyAccess(attachment.company_id, [\n\t\t\t\"owner\",\n\t\t\t\"admin\",\n\t\t\t\"manager\",\n\t\t]);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied - insufficient permissions\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await deleteDocumentService(attachmentId);\n\n\t\tif (!result.success) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error,\n\t\t\t};\n\t\t}\n\n\t\t// Log deletion\n\t\tawait logDocumentAction(\n\t\t\tattachment.company_id,\n\t\t\taccess.userId,\n\t\t\t\"document_deleted\",\n\t\t\t{\n\t\t\t\tattachmentId,\n\t\t\t\tfileName: attachment.file_name,\n\t\t\t},\n\t\t);\n\n\t\t// Revalidate paths\n\t\trevalidatePath(\"/dashboard/documents\");\n\t\tif (attachment.entity_type === \"customer\" && attachment.entity_id) {\n\t\t\trevalidatePath(`/dashboard/customers/${attachment.entity_id}`);\n\t\t} else if (attachment.entity_type === \"job\" && attachment.entity_id) {\n\t\t\trevalidatePath(`/dashboard/work/${attachment.entity_id}`);\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Delete failed\",\n\t\t};\n\t}\n}\n\n/**\n * Bulk delete documents\n */\nasync function bulkDeleteDocuments(\n\tattachmentIds: string[],\n): Promise<ActionResult<{ deleted: number; failed: number }>> {\n\ttry {\n\t\tlet deleted = 0;\n\t\tlet failed = 0;\n\n\t\tfor (const id of attachmentIds) {\n\t\t\tconst result = await deleteDocument(id);\n\t\t\tif (result.success) {\n\t\t\t\tdeleted++;\n\t\t\t} else {\n\t\t\t\tfailed++;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: { deleted, failed },\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Bulk delete failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// UPDATE ACTIONS\n// ============================================================================\n\n/**\n * Update document metadata\n */\nasync function updateDocument(\n\tattachmentId: string,\n\tupdates: {\n\t\tdescription?: string;\n\t\ttags?: string[];\n\t\tisPublic?: boolean;\n\t\tisInternal?: boolean;\n\t\tisFavorite?: boolean;\n\t},\n): Promise<ActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Server configuration error\" };\n\t\t}\n\n\t\tconst { data: attachment, error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"company_id, file_name\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (error || !attachment) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Document not found\",\n\t\t\t};\n\t\t}\n\n\t\tconst access = await verifyCompanyAccess(attachment.company_id);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await updateMetadataService(attachmentId, updates);\n\n\t\tif (!result.success) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error,\n\t\t\t};\n\t\t}\n\n\t\t// Log update\n\t\tawait logDocumentAction(\n\t\t\tattachment.company_id,\n\t\t\taccess.userId,\n\t\t\t\"document_updated\",\n\t\t\t{\n\t\t\t\tattachmentId,\n\t\t\t\tfileName: attachment.file_name,\n\t\t\t\tupdates,\n\t\t\t},\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/documents\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Update failed\",\n\t\t};\n\t}\n}\n\n/**\n * Move document to different folder\n */\nasync function moveDocument(\n\tattachmentId: string,\n\tnewFolderPath: string,\n): Promise<ActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Server configuration error\" };\n\t\t}\n\n\t\tconst { data: attachment, error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"company_id, file_name, folder_path\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (error || !attachment) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Document not found\",\n\t\t\t};\n\t\t}\n\n\t\tconst access = await verifyCompanyAccess(attachment.company_id);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await moveDocumentService(attachmentId, newFolderPath);\n\n\t\tif (!result.success) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error,\n\t\t\t};\n\t\t}\n\n\t\t// Log move\n\t\tawait logDocumentAction(\n\t\t\tattachment.company_id,\n\t\t\taccess.userId,\n\t\t\t\"document_moved\",\n\t\t\t{\n\t\t\t\tattachmentId,\n\t\t\t\tfileName: attachment.file_name,\n\t\t\t\tfrom: attachment.folder_path,\n\t\t\t\tto: newFolderPath,\n\t\t\t},\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/documents\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Move failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// LIST AND SEARCH ACTIONS\n// ============================================================================\n\n/**\n * List documents with filters\n */\nasync function listDocuments(\n\toptions: ListFilesOptions,\n): Promise<ActionResult<Awaited<ReturnType<typeof listDocumentsService>>>> {\n\ttry {\n\t\tconst access = await verifyCompanyAccess(options.companyId);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst result = await listDocumentsService(options);\n\n\t\tif (result.error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: result,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"List failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// FOLDER MANAGEMENT ACTIONS\n// ============================================================================\n\n/**\n * Create a new folder\n */\ntype CreateFolderParams = {\n\tcompanyId: string;\n\tname: string;\n\tparentId?: string;\n\tcontextType?: string;\n\tcontextId?: string;\n};\n\nasync function createFolder(\n\tparams: CreateFolderParams,\n): Promise<ActionResult<{ folderId: string }>> {\n\ttry {\n\t\tconst access = await verifyCompanyAccess(params.companyId);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Server configuration error\" };\n\t\t}\n\n\t\tconst { companyId, name, parentId, contextType, contextId } = params;\n\n\t\t// Generate path\n\t\tlet path = \"/\";\n\t\tif (parentId) {\n\t\t\tconst { data: parent } = await supabase\n\t\t\t\t.from(\"document_folders\")\n\t\t\t\t.select(\"path\")\n\t\t\t\t.eq(\"id\", parentId)\n\t\t\t\t.single();\n\n\t\t\tif (parent) {\n\t\t\t\tpath = `${parent.path}/${name.toLowerCase().replace(/\\s+/g, \"-\")}`;\n\t\t\t}\n\t\t} else {\n\t\t\tpath = `/${name.toLowerCase().replace(/\\s+/g, \"-\")}`;\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"document_folders\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tparent_id: parentId,\n\t\t\t\tname,\n\t\t\t\tslug: name.toLowerCase().replace(/\\s+/g, \"-\"),\n\t\t\t\tpath,\n\t\t\t\tcontext_type: contextType,\n\t\t\t\tcontext_id: contextId,\n\t\t\t\tcreated_by: access.userId,\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t};\n\t\t}\n\n\t\t// Log action\n\t\tawait logDocumentAction(companyId, access.userId, \"folder_created\", {\n\t\t\tfolderId: data.id,\n\t\t\tname,\n\t\t\tpath,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/documents\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: { folderId: data.id },\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Failed to create folder\",\n\t\t};\n\t}\n}\n\n/**\n * Delete a folder\n */\nasync function deleteFolder(folderId: string): Promise<ActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Server configuration error\" };\n\t\t}\n\n\t\tconst { data: folder, error: fetchError } = await supabase\n\t\t\t.from(\"document_folders\")\n\t\t\t.select(\"company_id, name, is_system\")\n\t\t\t.eq(\"id\", folderId)\n\t\t\t.single();\n\n\t\tif (fetchError || !folder) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Folder not found\",\n\t\t\t};\n\t\t}\n\n\t\tif (folder.is_system) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Cannot delete system folders\",\n\t\t\t};\n\t\t}\n\n\t\tconst access = await verifyCompanyAccess(folder.company_id, [\n\t\t\t\"owner\",\n\t\t\t\"admin\",\n\t\t]);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied - insufficient permissions\",\n\t\t\t};\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"document_folders\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", folderId);\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t};\n\t\t}\n\n\t\t// Log deletion\n\t\tawait logDocumentAction(\n\t\t\tfolder.company_id,\n\t\t\taccess.userId,\n\t\t\t\"folder_deleted\",\n\t\t\t{\n\t\t\t\tfolderId,\n\t\t\t\tname: folder.name,\n\t\t\t},\n\t\t);\n\n\t\trevalidatePath(\"/dashboard/documents\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Delete failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// STATISTICS ACTIONS\n// ============================================================================\n\n/**\n * Get document statistics\n */\nasync function getDocumentStatistics(\n\tcompanyId: string,\n): Promise<ActionResult<Awaited<ReturnType<typeof getDocumentStatsService>>>> {\n\ttry {\n\t\tconst access = await verifyCompanyAccess(companyId);\n\t\tif (!access) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Access denied\",\n\t\t\t};\n\t\t}\n\n\t\tconst stats = await getDocumentStatsService(companyId);\n\n\t\tif (stats.error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: stats.error,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: stats,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to get statistics\",\n\t\t};\n\t}\n}\n","/**\n * Document Manager Service\n *\n * Comprehensive document management for Supabase Storage with:\n * - Context-aware uploads (customer, job, equipment, general)\n * - Automatic path generation\n * - Database tracking\n * - Virus scanning integration\n * - Secure downloads with signed URLs\n * - File operations (move, delete, duplicate)\n */\n\nimport crypto from \"node:crypto\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tformatFileSize,\n\tsanitizeFileName,\n\ttype ValidationOptions,\n\tvalidateFile,\n} from \"./file-validator\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type DocumentContext = {\n\ttype:\n\t\t| \"customer\"\n\t\t| \"job\"\n\t\t| \"equipment\"\n\t\t| \"general\"\n\t\t| \"invoice\"\n\t\t| \"estimate\"\n\t\t| \"contract\";\n\tid?: string; // Entity ID (customer_id, job_id, etc.)\n\tfolder?: string; // Custom folder within context\n};\n\nexport type StorageBucket =\n\t| \"company-files\"\n\t| \"customer-documents\"\n\t| \"documents\"\n\t| \"job-photos\"\n\t| \"invoices\"\n\t| \"estimates\"\n\t| \"contracts\"\n\t| \"avatars\";\n\nexport type UploadOptions = {\n\tcompanyId: string;\n\tcontext: DocumentContext;\n\tbucket?: StorageBucket;\n\tdescription?: string;\n\ttags?: string[];\n\tisPublic?: boolean;\n\tisInternal?: boolean;\n\texpiryDate?: Date;\n\tvalidationOptions?: ValidationOptions;\n\tonProgress?: (progress: number) => void;\n};\n\nexport type UploadResult = {\n\tsuccess: boolean;\n\tattachmentId?: string;\n\tstorageUrl?: string;\n\tstoragePath?: string;\n\tpublicUrl?: string;\n\terror?: string;\n\twarnings?: string[];\n};\n\nexport type DocumentMetadata = {\n\tid: string;\n\tcompanyId: string;\n\tentityType: string;\n\tentityId?: string;\n\tfileName: string;\n\toriginalFileName: string;\n\tfileSize: number;\n\tmimeType: string;\n\tstorageUrl: string;\n\tstoragePath: string;\n\tstorageBucket: string;\n\tfolderPath?: string;\n\tvirusScanStatus: string;\n\tisPublic: boolean;\n\tuploadedBy: string;\n\tuploadedAt: Date;\n\tdescription?: string;\n\ttags?: string[];\n\taccessCount: number;\n\tdownloadCount: number;\n};\n\nexport type ListFilesOptions = {\n\tcompanyId: string;\n\tcontext?: DocumentContext;\n\tfolder?: string;\n\tsearch?: string;\n\tmimeTypes?: string[];\n\tuploadedBy?: string;\n\tvirusScanStatus?: string;\n\tlimit?: number;\n\toffset?: number;\n\tsortBy?: \"created_at\" | \"file_name\" | \"file_size\" | \"access_count\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\n// ============================================================================\n// BUCKET SELECTION\n// ============================================================================\n\n/**\n * Determine appropriate storage bucket based on context\n */\nfunction selectBucket(\n\tcontext: DocumentContext,\n\tcustomBucket?: StorageBucket,\n): StorageBucket {\n\tif (customBucket) {\n\t\treturn customBucket;\n\t}\n\n\tswitch (context.type) {\n\t\tcase \"customer\":\n\t\t\treturn \"customer-documents\";\n\t\tcase \"job\":\n\t\t\treturn \"job-photos\";\n\t\tcase \"invoice\":\n\t\t\treturn \"invoices\";\n\t\tcase \"estimate\":\n\t\t\treturn \"estimates\";\n\t\tcase \"contract\":\n\t\t\treturn \"contracts\";\n\t\tdefault:\n\t\t\treturn \"company-files\";\n\t}\n}\n\n// ============================================================================\n// PATH GENERATION\n// ============================================================================\n\n/**\n * Generate storage path based on context\n * Format: {companyId}/{contextType}/{entityId?}/{folder?}/{timestamp}-{filename}\n */\nfunction generateStoragePath(\n\tcompanyId: string,\n\tcontext: DocumentContext,\n\tfileName: string,\n): string {\n\tconst sanitized = sanitizeFileName(fileName);\n\tconst timestamp = Date.now();\n\tconst random = Math.random().toString(36).substring(2, 8);\n\tconst uniqueFileName = `${timestamp}-${random}-${sanitized}`;\n\n\tconst parts = [companyId];\n\n\t// Add context type\n\tif (context.type !== \"general\") {\n\t\tparts.push(`${context.type}s`); // customers, jobs, etc.\n\t} else {\n\t\tparts.push(\"general\");\n\t}\n\n\t// Add entity ID if provided\n\tif (context.id) {\n\t\tparts.push(context.id);\n\t}\n\n\t// Add custom folder if provided\n\tif (context.folder) {\n\t\tparts.push(context.folder);\n\t}\n\n\t// Add filename\n\tparts.push(uniqueFileName);\n\n\treturn parts.join(\"/\");\n}\n\n/**\n * Generate folder path for database tracking\n */\nfunction generateFolderPath(context: DocumentContext): string {\n\tconst parts: string[] = [];\n\n\tif (context.type === \"general\") {\n\t\tparts.push(\"general\");\n\t} else {\n\t\tparts.push(`${context.type}s`);\n\t}\n\n\tif (context.id) {\n\t\tparts.push(context.id);\n\t}\n\n\tif (context.folder) {\n\t\tparts.push(context.folder);\n\t}\n\n\treturn `/${parts.join(\"/\")}`;\n}\n\n// ============================================================================\n// CHECKSUM GENERATION\n// ============================================================================\n\n/**\n * Generate SHA256 checksum for file integrity\n */\nasync function generateChecksum(file: File): Promise<string> {\n\tconst buffer = await file.arrayBuffer();\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\tconst hashHex = hashArray\n\t\t.map((b) => b.toString(16).padStart(2, \"0\"))\n\t\t.join(\"\");\n\treturn hashHex;\n}\n\n// ============================================================================\n// UPLOAD FUNCTIONS\n// ============================================================================\n\n/**\n * Upload document to storage and track in database\n */\nexport async function uploadDocument(\n\tfile: File,\n\toptions: UploadOptions,\n): Promise<UploadResult> {\n\ttry {\n\t\t// 1. Validate file\n\t\tconst validation = await validateFile(file, options.validationOptions);\n\t\tif (!validation.valid) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: validation.errors.join(\"; \"),\n\t\t\t\twarnings: validation.warnings,\n\t\t\t};\n\t\t}\n\n\t\t// 2. Get Supabase client and user\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Supabase client not available\",\n\t\t\t};\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User not authenticated\",\n\t\t\t};\n\t\t}\n\n\t\t// 3. Verify user has access to company\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"id, role\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", options.companyId)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"User does not have access to this company\",\n\t\t\t};\n\t\t}\n\n\t\t// 4. Select bucket and generate path\n\t\tconst bucket = selectBucket(options.context, options.bucket);\n\t\tconst storagePath = generateStoragePath(\n\t\t\toptions.companyId,\n\t\t\toptions.context,\n\t\t\tvalidation.metadata?.sanitizedName || file.name,\n\t\t);\n\n\t\t// 5. Upload to storage\n\t\tconst { data: storageData, error: storageError } = await supabase.storage\n\t\t\t.from(bucket)\n\t\t\t.upload(storagePath, file, {\n\t\t\t\tcacheControl: \"3600\",\n\t\t\t\tupsert: false,\n\t\t\t});\n\n\t\tif (storageError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Storage upload failed: ${storageError.message}`,\n\t\t\t};\n\t\t}\n\n\t\t// 6. Get public URL\n\t\tconst {\n\t\t\tdata: { publicUrl },\n\t\t} = supabase.storage.from(bucket).getPublicUrl(storageData.path);\n\n\t\t// 7. Generate checksum\n\t\tconst checksum = await generateChecksum(file);\n\n\t\t// 8. Track in database\n\t\tconst folderPath = generateFolderPath(options.context);\n\n\t\tconst { data: attachment, error: dbError } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: options.companyId,\n\t\t\t\tentity_type: options.context.type,\n\t\t\t\tentity_id: options.context.id,\n\t\t\t\tfile_name: validation.metadata?.sanitizedName || file.name,\n\t\t\t\toriginal_file_name: file.name,\n\t\t\t\tfile_size: file.size,\n\t\t\t\tmime_type: validation.metadata?.detectedMimeType || file.type,\n\t\t\t\tstorage_provider: \"supabase\",\n\t\t\t\tstorage_url: publicUrl,\n\t\t\t\tstorage_path: storageData.path,\n\t\t\t\tstorage_bucket: bucket,\n\t\t\t\tfolder_path: folderPath,\n\t\t\t\tchecksum,\n\t\t\t\tis_image: file.type.startsWith(\"image/\"),\n\t\t\t\tis_document:\n\t\t\t\t\tfile.type.includes(\"pdf\") || file.type.includes(\"document\"),\n\t\t\t\tis_video: file.type.startsWith(\"video/\"),\n\t\t\t\tis_public: options.isPublic ?? false,\n\t\t\t\tis_internal: options.isInternal ?? false,\n\t\t\t\tdescription: options.description,\n\t\t\t\ttags: options.tags || [],\n\t\t\t\texpiry_date: options.expiryDate,\n\t\t\t\tuploaded_by: user.id,\n\t\t\t\tvirus_scan_status: \"pending\",\n\t\t\t})\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (dbError) {\n\t\t\t// Rollback: delete from storage\n\t\t\tawait supabase.storage.from(bucket).remove([storageData.path]);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Database tracking failed: ${dbError.message}`,\n\t\t\t};\n\t\t}\n\n\t\t// 9. Queue virus scan (async)\n\t\tqueueVirusScan(attachment.id, bucket, storageData.path).catch(\n\t\t\tconsole.error,\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tattachmentId: attachment.id,\n\t\t\tstorageUrl: publicUrl,\n\t\t\tstoragePath: storageData.path,\n\t\t\tpublicUrl,\n\t\t\twarnings: validation.warnings,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Upload failed\",\n\t\t};\n\t}\n}\n\n/**\n * Upload multiple documents\n */\nexport async function uploadDocuments(\n\tfiles: File[],\n\toptions: UploadOptions,\n): Promise<UploadResult[]> {\n\tconst results: UploadResult[] = [];\n\n\tfor (const file of files) {\n\t\tconst result = await uploadDocument(file, options);\n\t\tresults.push(result);\n\n\t\t// Update progress if callback provided\n\t\tif (options.onProgress) {\n\t\t\tconst progress = (results.length / files.length) * 100;\n\t\t\toptions.onProgress(progress);\n\t\t}\n\t}\n\n\treturn results;\n}\n\n// ============================================================================\n// DOWNLOAD FUNCTIONS\n// ============================================================================\n\n/**\n * Get signed download URL for private files\n */\nexport async function getDownloadUrl(\n\tattachmentId: string,\n\texpiresIn = 3600,\n): Promise<{ url?: string; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { error: \"Supabase client not available\" };\n\t\t}\n\n\t\t// Get attachment details\n\t\tconst { data: attachment, error: fetchError } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"storage_bucket, storage_path, company_id, virus_scan_status\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !attachment) {\n\t\t\treturn { error: \"File not found\" };\n\t\t}\n\n\t\t// Verify user has access to company\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\treturn { error: \"User not authenticated\" };\n\t\t}\n\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", attachment.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership) {\n\t\t\treturn { error: \"Access denied\" };\n\t\t}\n\n\t\t// Check virus scan status\n\t\tif (attachment.virus_scan_status === \"infected\") {\n\t\t\treturn { error: \"File failed security scan and cannot be downloaded\" };\n\t\t}\n\n\t\t// Generate signed URL\n\t\tconst { data, error } = await supabase.storage\n\t\t\t.from(attachment.storage_bucket)\n\t\t\t.createSignedUrl(attachment.storage_path, expiresIn);\n\n\t\tif (error) {\n\t\t\treturn { error: error.message };\n\t\t}\n\n\t\t// Track download\n\t\tawait supabase.rpc(\"track_file_download\", {\n\t\t\tp_attachment_id: attachmentId,\n\t\t});\n\n\t\treturn { url: data.signedUrl };\n\t} catch (error) {\n\t\treturn {\n\t\t\terror:\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: \"Failed to generate download URL\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// LIST AND SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * List documents with filtering and pagination\n */\nexport async function listDocuments(\n\toptions: ListFilesOptions,\n): Promise<{ documents: DocumentMetadata[]; total: number; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tdocuments: [],\n\t\t\t\ttotal: 0,\n\t\t\t\terror: \"Supabase client not available\",\n\t\t\t};\n\t\t}\n\n\t\t// Build query\n\t\tlet query = supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"*\", { count: \"exact\" })\n\t\t\t.eq(\"company_id\", options.companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\t// Apply filters\n\t\tif (options.context) {\n\t\t\tquery = query.eq(\"entity_type\", options.context.type);\n\t\t\tif (options.context.id) {\n\t\t\t\tquery = query.eq(\"entity_id\", options.context.id);\n\t\t\t}\n\t\t}\n\n\t\tif (options.folder) {\n\t\t\tquery = query.eq(\"folder_path\", options.folder);\n\t\t}\n\n\t\tif (options.search) {\n\t\t\tquery = query.or(\n\t\t\t\t`file_name.ilike.%${options.search}%,description.ilike.%${options.search}%`,\n\t\t\t);\n\t\t}\n\n\t\tif (options.mimeTypes && options.mimeTypes.length > 0) {\n\t\t\tquery = query.in(\"mime_type\", options.mimeTypes);\n\t\t}\n\n\t\tif (options.uploadedBy) {\n\t\t\tquery = query.eq(\"uploaded_by\", options.uploadedBy);\n\t\t}\n\n\t\tif (options.virusScanStatus) {\n\t\t\tquery = query.eq(\"virus_scan_status\", options.virusScanStatus);\n\t\t}\n\n\t\t// Apply sorting\n\t\tconst sortBy = options.sortBy || \"created_at\";\n\t\tconst sortOrder = options.sortOrder || \"desc\";\n\t\tquery = query.order(sortBy, { ascending: sortOrder === \"asc\" });\n\n\t\t// Apply pagination\n\t\tconst limit = options.limit || 50;\n\t\tconst offset = options.offset || 0;\n\t\tquery = query.range(offset, offset + limit - 1);\n\n\t\tconst { data, error, count } = await query;\n\n\t\tif (error) {\n\t\t\treturn { documents: [], total: 0, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tdocuments: data as DocumentMetadata[],\n\t\t\ttotal: count || 0,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tdocuments: [],\n\t\t\ttotal: 0,\n\t\t\terror:\n\t\t\t\terror instanceof Error ? error.message : \"Failed to list documents\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// FILE OPERATIONS\n// ============================================================================\n\n/**\n * Delete document (soft delete)\n */\nexport async function deleteDocument(\n\tattachmentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Supabase client not available\" };\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"User not authenticated\" };\n\t\t}\n\n\t\t// Get attachment to verify access\n\t\tconst { data: attachment } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", attachmentId)\n\t\t\t.single();\n\n\t\tif (!attachment) {\n\t\t\treturn { success: false, error: \"File not found\" };\n\t\t}\n\n\t\t// Verify access\n\t\tconst { data: membership } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"role\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"company_id\", attachment.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.single();\n\n\t\tif (!membership) {\n\t\t\treturn { success: false, error: \"Access denied\" };\n\t\t}\n\n\t\t// Soft delete\n\t\tconst { error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", attachmentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Delete failed\",\n\t\t};\n\t}\n}\n\n/**\n * Move document to different folder\n */\nexport async function moveDocument(\n\tattachmentId: string,\n\tnewFolderPath: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Supabase client not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.update({\n\t\t\t\tfolder_path: newFolderPath,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", attachmentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Move failed\",\n\t\t};\n\t}\n}\n\n/**\n * Update document metadata\n */\nexport async function updateDocumentMetadata(\n\tattachmentId: string,\n\tupdates: {\n\t\tdescription?: string;\n\t\ttags?: string[];\n\t\tisPublic?: boolean;\n\t\tisInternal?: boolean;\n\t\tisFavorite?: boolean;\n\t},\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Supabase client not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.update({ ...updates, updated_at: new Date().toISOString() })\n\t\t\t.eq(\"id\", attachmentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Update failed\",\n\t\t};\n\t}\n}\n\n// ============================================================================\n// VIRUS SCANNING\n// ============================================================================\n\n/**\n * Queue file for virus scanning\n */\nasync function queueVirusScan(\n\tattachmentId: string,\n\tbucket: string,\n\tpath: string,\n): Promise<void> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Call Edge Function to handle scanning\n\t\tawait supabase.functions.invoke(\"virus-scan\", {\n\t\t\tbody: { attachmentId, bucket, path },\n\t\t});\n\t} catch (_error) {}\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get document statistics for company\n */\nexport async function getDocumentStats(companyId: string): Promise<{\n\ttotalFiles: number;\n\ttotalSize: number;\n\tbyType: Record<string, number>;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\ttotalFiles: 0,\n\t\t\t\ttotalSize: 0,\n\t\t\t\tbyType: {},\n\t\t\t\terror: \"Supabase client not available\",\n\t\t\t};\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"attachments\")\n\t\t\t.select(\"file_size, mime_type\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\tif (error) {\n\t\t\treturn { totalFiles: 0, totalSize: 0, byType: {}, error: error.message };\n\t\t}\n\n\t\tconst totalFiles = data.length;\n\t\tconst totalSize = data.reduce((sum, file) => sum + file.file_size, 0);\n\t\tconst byType: Record<string, number> = {};\n\n\t\tdata.forEach((file) => {\n\t\t\tconst category = file.mime_type.split(\"/\")[0];\n\t\t\tbyType[category] = (byType[category] || 0) + 1;\n\t\t});\n\n\t\treturn { totalFiles, totalSize, byType };\n\t} catch (error) {\n\t\treturn {\n\t\t\ttotalFiles: 0,\n\t\t\ttotalSize: 0,\n\t\t\tbyType: {},\n\t\t\terror: error instanceof Error ? error.message : \"Failed to get stats\",\n\t\t};\n\t}\n}\n\n;\n","/**\n * File Validation and Security\n *\n * Comprehensive file validation with:\n * - Extension blocklist (dangerous file types)\n * - Magic number/signature verification\n * - Size limits by context\n * - MIME type validation\n * - Filename sanitization\n * - Content inspection\n */\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n/**\n * Blocked file extensions - Executable and potentially dangerous files\n * These can never be uploaded regardless of context\n */\nconst BLOCKED_EXTENSIONS = [\n\t// Windows executables\n\t\".exe\",\n\t\".bat\",\n\t\".cmd\",\n\t\".com\",\n\t\".scr\",\n\t\".pif\",\n\t\".application\",\n\t\".gadget\",\n\t\".msi\",\n\t\".msp\",\n\t\".msc\",\n\t\".vbs\",\n\t\".vbe\",\n\t\".js\",\n\t\".jse\",\n\t\".ws\",\n\t\".wsf\",\n\t\".wsc\",\n\t\".wsh\",\n\t\".ps1\",\n\t\".ps1xml\",\n\t\".ps2\",\n\t\".ps2xml\",\n\t\".psc1\",\n\t\".psc2\",\n\t\".msh\",\n\t\".msh1\",\n\t\".msh2\",\n\t\".mshxml\",\n\t\".msh1xml\",\n\t\".msh2xml\",\n\n\t// MacOS executables\n\t\".app\",\n\t\".dmg\",\n\t\".pkg\",\n\t\".mpkg\",\n\t\".command\",\n\n\t// Linux executables\n\t\".sh\",\n\t\".bash\",\n\t\".zsh\",\n\t\".fish\",\n\t\".ksh\",\n\t\".csh\",\n\t\".run\",\n\t\".bin\",\n\t\".deb\",\n\t\".rpm\",\n\t\".snap\",\n\n\t// Archives that can contain executables\n\t\".jar\",\n\t\".war\",\n\t\".ear\",\n\n\t// System files\n\t\".dll\",\n\t\".sys\",\n\t\".drv\",\n\n\t// Scripts and code that could be auto-executed\n\t\".cpl\",\n\t\".inf\",\n\t\".ins\",\n\t\".isp\",\n\t\".lnk\",\n\t\".mde\",\n\t\".mdt\",\n\t\".mdw\",\n\t\".mdz\",\n\t\".ops\",\n\t\".pcd\",\n\t\".prg\",\n\t\".reg\",\n\t\".scf\",\n\t\".sct\",\n\t\".shb\",\n\t\".shs\",\n\t\".url\",\n\n\t// Database files that could contain macros\n\t\".ade\",\n\t\".adp\",\n\t\".mdb\",\n\t\".accdb\",\n\n\t// Potentially dangerous compressed files\n\t\".ace\",\n\t\".arj\",\n\t\".cab\",\n];\n\n/**\n * File size limits by context (in bytes)\n */\nconst SIZE_LIMITS = {\n\tavatar: 5 * 1024 * 1024, // 5MB\n\timage: 20 * 1024 * 1024, // 20MB\n\tdocument: 100 * 1024 * 1024, // 100MB\n\tvideo: 250 * 1024 * 1024, // 250MB\n\tgeneral: 250 * 1024 * 1024, // 250MB\n\tinvoice: 20 * 1024 * 1024, // 20MB\n\testimate: 20 * 1024 * 1024, // 20MB\n\tcontract: 50 * 1024 * 1024, // 50MB\n} as const;\n\n/**\n * Allowed MIME types by category\n */\nconst ALLOWED_MIME_TYPES = {\n\timage: [\n\t\t\"image/jpeg\",\n\t\t\"image/png\",\n\t\t\"image/gif\",\n\t\t\"image/webp\",\n\t\t\"image/svg+xml\",\n\t\t\"image/bmp\",\n\t\t\"image/tiff\",\n\t\t\"image/heic\",\n\t\t\"image/heif\",\n\t],\n\tdocument: [\n\t\t\"application/pdf\",\n\t\t\"application/msword\",\n\t\t\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n\t\t\"application/vnd.ms-excel\",\n\t\t\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n\t\t\"application/vnd.ms-powerpoint\",\n\t\t\"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n\t\t\"application/vnd.oasis.opendocument.text\",\n\t\t\"application/vnd.oasis.opendocument.spreadsheet\",\n\t\t\"application/vnd.oasis.opendocument.presentation\",\n\t\t\"text/plain\",\n\t\t\"text/csv\",\n\t\t\"application/rtf\",\n\t],\n\tvideo: [\n\t\t\"video/mp4\",\n\t\t\"video/mpeg\",\n\t\t\"video/quicktime\",\n\t\t\"video/x-msvideo\",\n\t\t\"video/webm\",\n\t\t\"video/x-matroska\",\n\t],\n\taudio: [\n\t\t\"audio/mpeg\",\n\t\t\"audio/mp4\",\n\t\t\"audio/wav\",\n\t\t\"audio/webm\",\n\t\t\"audio/ogg\",\n\t\t\"audio/flac\",\n\t],\n\tarchive: [\n\t\t\"application/zip\",\n\t\t\"application/x-rar-compressed\",\n\t\t\"application/x-7z-compressed\",\n\t\t\"application/x-tar\",\n\t\t\"application/gzip\",\n\t],\n\tcad: [\n\t\t\"application/acad\",\n\t\t\"application/x-acad\",\n\t\t\"application/autocad_dwg\",\n\t\t\"image/vnd.dwg\",\n\t\t\"image/vnd.dxf\",\n\t],\n} as const;\n\n/**\n * File magic numbers (signatures) for validation\n * First few bytes of common file types\n */\nconst FILE_SIGNATURES: Record<string, { bytes: number[]; offset: number }[]> = {\n\t\"image/jpeg\": [{ bytes: [0xff, 0xd8, 0xff], offset: 0 }],\n\t\"image/png\": [{ bytes: [0x89, 0x50, 0x4e, 0x47], offset: 0 }],\n\t\"image/gif\": [{ bytes: [0x47, 0x49, 0x46, 0x38], offset: 0 }],\n\t\"image/webp\": [{ bytes: [0x52, 0x49, 0x46, 0x46], offset: 0 }],\n\t\"application/pdf\": [{ bytes: [0x25, 0x50, 0x44, 0x46], offset: 0 }],\n\t\"application/zip\": [{ bytes: [0x50, 0x4b, 0x03, 0x04], offset: 0 }],\n\t\"video/mp4\": [{ bytes: [0x66, 0x74, 0x79, 0x70], offset: 4 }],\n};\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type FileContext = keyof typeof SIZE_LIMITS;\n\nexport type ValidationResult = {\n\tvalid: boolean;\n\terrors: string[];\n\twarnings: string[];\n\tmetadata?: {\n\t\tsanitizedName: string;\n\t\tdetectedMimeType?: string;\n\t\tcategory?: string;\n\t};\n};\n\nexport type ValidationOptions = {\n\tcontext?: FileContext;\n\tmaxSize?: number;\n\tallowedMimeTypes?: string[];\n\tcheckMagicNumbers?: boolean;\n\tstrictMode?: boolean;\n};\n\n// ============================================================================\n// MAIN VALIDATION FUNCTION\n// ============================================================================\n\n/**\n * Validate a file for upload\n *\n * @param file - The file to validate\n * @param options - Validation options\n * @returns Validation result with errors and metadata\n */\nexport async function validateFile(\n\tfile: File,\n\toptions: ValidationOptions = {},\n): Promise<ValidationResult> {\n\tconst {\n\t\tcontext = \"general\",\n\t\tmaxSize,\n\t\tallowedMimeTypes,\n\t\tcheckMagicNumbers = true,\n\t\tstrictMode = false,\n\t} = options;\n\n\tconst errors: string[] = [];\n\tconst warnings: string[] = [];\n\n\t// 1. Basic file checks\n\tif (!(file && file instanceof File)) {\n\t\terrors.push(\"Invalid file object\");\n\t\treturn { valid: false, errors, warnings };\n\t}\n\n\tif (!file.name || file.name.trim() === \"\") {\n\t\terrors.push(\"File must have a name\");\n\t\treturn { valid: false, errors, warnings };\n\t}\n\n\t// 2. Sanitize filename\n\tconst sanitizedName = sanitizeFileName(file.name);\n\tif (sanitizedName !== file.name) {\n\t\twarnings.push(\"Filename was sanitized for security\");\n\t}\n\n\t// 3. Check for blocked extensions\n\tconst extension = getFileExtension(file.name).toLowerCase();\n\tif (isBlockedExtension(extension)) {\n\t\terrors.push(`File type \"${extension}\" is not allowed for security reasons`);\n\t\treturn { valid: false, errors, warnings };\n\t}\n\n\t// 4. Check file size\n\tconst sizeLimit = maxSize ?? SIZE_LIMITS[context];\n\tif (file.size > sizeLimit) {\n\t\terrors.push(\n\t\t\t`File size (${formatFileSize(file.size)}) exceeds maximum allowed size (${formatFileSize(sizeLimit)})`,\n\t\t);\n\t}\n\n\tif (file.size === 0) {\n\t\terrors.push(\"File is empty\");\n\t}\n\n\t// 5. Check MIME type\n\tif (\n\t\tallowedMimeTypes &&\n\t\tallowedMimeTypes.length > 0 &&\n\t\t!allowedMimeTypes.includes(file.type)\n\t) {\n\t\terrors.push(\n\t\t\t`File type \"${file.type}\" is not allowed. Allowed types: ${allowedMimeTypes.join(\", \")}`,\n\t\t);\n\t}\n\n\t// Detect file category\n\tconst category = detectFileCategory(file.type);\n\n\t// 6. Verify magic numbers (file signature)\n\tlet detectedMimeType: string | undefined;\n\tif (checkMagicNumbers && file.size > 0) {\n\t\ttry {\n\t\t\tdetectedMimeType = (await verifyFileSignature(file)) ?? undefined;\n\n\t\t\tif (detectedMimeType && detectedMimeType !== file.type) {\n\t\t\t\tif (strictMode) {\n\t\t\t\t\terrors.push(\n\t\t\t\t\t\t`File signature mismatch. Claimed: \"${file.type}\", Detected: \"${detectedMimeType}\"`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\twarnings.push(\n\t\t\t\t\t\t`File type mismatch detected. Using detected type: ${detectedMimeType}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (_error) {\n\t\t\twarnings.push(\"Could not verify file signature\");\n\t\t}\n\t}\n\n\t// 7. Additional security checks\n\tconst securityChecks = performSecurityChecks(file, sanitizedName);\n\terrors.push(...securityChecks.errors);\n\twarnings.push(...securityChecks.warnings);\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t\twarnings,\n\t\tmetadata: {\n\t\t\tsanitizedName,\n\t\t\tdetectedMimeType,\n\t\t\tcategory,\n\t\t},\n\t};\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Check if extension is blocked\n */\nfunction isBlockedExtension(extension: string): boolean {\n\tconst ext = extension.toLowerCase();\n\treturn BLOCKED_EXTENSIONS.includes(ext);\n}\n\n/**\n * Get file extension from filename\n */\nfunction getFileExtension(filename: string): string {\n\tconst lastDot = filename.lastIndexOf(\".\");\n\tif (lastDot === -1 || lastDot === filename.length - 1) {\n\t\treturn \"\";\n\t}\n\treturn filename.substring(lastDot);\n}\n\n/**\n * Sanitize filename for security\n * - Remove or replace dangerous characters\n * - Prevent path traversal\n * - Limit length\n */\nexport function sanitizeFileName(fileName: string): string {\n\t// Get extension first\n\tconst extension = getFileExtension(fileName);\n\tconst nameWithoutExt = fileName.substring(\n\t\t0,\n\t\tfileName.length - extension.length,\n\t);\n\n\t// Remove path traversal attempts\n\tlet sanitized = nameWithoutExt.replace(/\\.\\./g, \"\");\n\n\t// Remove or replace dangerous characters\n\tsanitized = sanitized\n\t\t.replace(/[<>:\"|?*]/g, \"\") // Windows invalid chars\n\t\t.replace(/[\\x00-\\x1F\\x80-\\x9F]/g, \"\") // Control characters\n\t\t.replace(/^\\.+/, \"\") // Leading dots\n\t\t.replace(/\\s+/g, \"-\") // Replace spaces with hyphens\n\t\t.replace(/--+/g, \"-\") // Multiple hyphens to single\n\t\t.replace(/^-|-$/g, \"\"); // Trim hyphens\n\n\t// Limit length (max 200 chars for name, excluding extension)\n\tif (sanitized.length > 200) {\n\t\tsanitized = sanitized.substring(0, 200);\n\t}\n\n\t// Ensure we have a name\n\tif (!sanitized) {\n\t\tsanitized = `file-${Date.now()}`;\n\t}\n\n\treturn sanitized + extension.toLowerCase();\n}\n\n/**\n * Verify file signature (magic numbers)\n */\nasync function verifyFileSignature(file: File): Promise<string | null> {\n\t// Read first 8KB of file\n\tconst chunk = file.slice(0, 8192);\n\tconst buffer = await chunk.arrayBuffer();\n\tconst bytes = new Uint8Array(buffer);\n\n\t// Check against known signatures\n\tfor (const [mimeType, signatures] of Object.entries(FILE_SIGNATURES)) {\n\t\tfor (const sig of signatures) {\n\t\t\tconst matches = sig.bytes.every(\n\t\t\t\t(byte, index) => bytes[sig.offset + index] === byte,\n\t\t\t);\n\t\t\tif (matches) {\n\t\t\t\treturn mimeType;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Detect file category from MIME type\n */\nfunction detectFileCategory(mimeType: string): string | undefined {\n\tfor (const [category, types] of Object.entries(ALLOWED_MIME_TYPES)) {\n\t\tif ((types as readonly string[]).includes(mimeType)) {\n\t\t\treturn category;\n\t\t}\n\t}\n\n\t// Fallback to general category detection\n\tif (mimeType.startsWith(\"image/\")) {\n\t\treturn \"image\";\n\t}\n\tif (mimeType.startsWith(\"video/\")) {\n\t\treturn \"video\";\n\t}\n\tif (mimeType.startsWith(\"audio/\")) {\n\t\treturn \"audio\";\n\t}\n\tif (mimeType.startsWith(\"text/\")) {\n\t\treturn \"document\";\n\t}\n\n\treturn;\n}\n\n/**\n * Perform additional security checks\n */\nfunction performSecurityChecks(\n\tfile: File,\n\tsanitizedName: string,\n): { errors: string[]; warnings: string[] } {\n\tconst errors: string[] = [];\n\tconst warnings: string[] = [];\n\n\t// Check for double extensions (e.g., file.pdf.exe)\n\tconst parts = sanitizedName.split(\".\");\n\tif (parts.length > 2) {\n\t\tconst secondExt = `.${parts.at(-2)}`;\n\t\tif (isBlockedExtension(secondExt)) {\n\t\t\terrors.push(\n\t\t\t\t\"File has suspicious double extension that could hide malicious content\",\n\t\t\t);\n\t\t}\n\t}\n\n\t// Check for very long filenames (potential buffer overflow)\n\tif (sanitizedName.length > 255) {\n\t\terrors.push(\"Filename is too long\");\n\t}\n\n\t// Check for null bytes (can cause issues in some systems)\n\tif (file.name.includes(\"\\0\")) {\n\t\terrors.push(\"Filename contains null bytes\");\n\t}\n\n\t// Warn about unusual MIME types\n\tif (!file.type || file.type === \"application/octet-stream\") {\n\t\twarnings.push(\"File type could not be determined. Upload may be rejected.\");\n\t}\n\n\treturn { errors, warnings };\n}\n\n/**\n * Format file size for display\n */\nexport function formatFileSize(bytes: number): string {\n\tif (bytes === 0) {\n\t\treturn \"0 Bytes\";\n\t}\n\n\tconst k = 1024;\n\tconst sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn `${Number.parseFloat((bytes / k ** i).toFixed(2))} ${sizes[i]}`;\n}\n\n// ============================================================================\n// SPECIFIC VALIDATORS\n// ============================================================================\n\n/**\n * Validate image file\n */\nasync function validateImage(\n\tfile: File,\n\tmaxSize = SIZE_LIMITS.image,\n): Promise<ValidationResult> {\n\treturn validateFile(file, {\n\t\tcontext: \"image\",\n\t\tmaxSize,\n\t\tallowedMimeTypes: [...ALLOWED_MIME_TYPES.image],\n\t\tcheckMagicNumbers: true,\n\t\tstrictMode: true,\n\t});\n}\n\n/**\n * Validate document file\n */\nasync function validateDocument(\n\tfile: File,\n\tmaxSize = SIZE_LIMITS.document,\n): Promise<ValidationResult> {\n\treturn validateFile(file, {\n\t\tcontext: \"document\",\n\t\tmaxSize,\n\t\tallowedMimeTypes: [...ALLOWED_MIME_TYPES.document],\n\t\tcheckMagicNumbers: true,\n\t});\n}\n\n/**\n * Validate video file\n */\nasync function validateVideo(\n\tfile: File,\n\tmaxSize = SIZE_LIMITS.video,\n): Promise<ValidationResult> {\n\treturn validateFile(file, {\n\t\tcontext: \"video\",\n\t\tmaxSize,\n\t\tallowedMimeTypes: [...ALLOWED_MIME_TYPES.video],\n\t\tcheckMagicNumbers: false, // Video signatures are complex\n\t});\n}\n\n/**\n * Validate avatar image\n */\nasync function validateAvatar(file: File): Promise<ValidationResult> {\n\tconst result = await validateImage(file, SIZE_LIMITS.avatar);\n\n\t// Additional avatar-specific validation\n\tif (result.valid && file.type === \"image/svg+xml\") {\n\t\tresult.warnings.push(\n\t\t\t\"SVG avatars may be sanitized to remove potential scripts\",\n\t\t);\n\t}\n\n\treturn result;\n}\n\n/**\n * Batch validate multiple files\n */\nasync function validateFiles(\n\tfiles: File[],\n\toptions: ValidationOptions = {},\n): Promise<Map<string, ValidationResult>> {\n\tconst results = new Map<string, ValidationResult>();\n\n\tconst validations = files.map(async (file) => {\n\t\tconst result = await validateFile(file, options);\n\t\tresults.set(file.name, result);\n\t});\n\n\tawait Promise.all(validations);\n\n\treturn results;\n}\n\n/**\n * Check if file passes validation\n */\nasync function isValidFile(\n\tfile: File,\n\toptions: ValidationOptions = {},\n): Promise<boolean> {\n\tconst result = await validateFile(file, options);\n\treturn result.valid;\n}\n\n/**\n * Get validation errors as string\n */\nfunction getValidationErrorMessage(result: ValidationResult): string {\n\tif (result.valid) {\n\t\treturn \"\";\n\t}\n\n\treturn result.errors.join(\"; \");\n}\n","/**\n * Archive Management Server Actions\n *\n * Unified archive management across all entities:\n * - Fetch archived items with filters\n * - Bulk restore operations\n * - Permanent deletion (admin only)\n * - Archive statistics\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nconst getSupabaseServerClient = async (): Promise<SupabaseServerClient> => {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new ActionError(\n\t\t\t\"Database connection failed\",\n\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t);\n\t}\n\treturn supabase as SupabaseServerClient;\n};\n\nconst HTTP_STATUS = {\n\tforbidden: 403,\n} as const;\n\nconst ARCHIVE_LIMIT = {\n\tmin: 1,\n\tmax: 100,\n\tdefault: 50,\n} as const;\n\nconst MILLISECONDS_IN_DAY = 86_400_000;\nconst PERMANENT_DELETE_BUFFER_DAYS = 90;\n\nconst DATE_RANGE_TO_DAYS = {\n\t\"7days\": 7,\n\t\"30days\": 30,\n\t\"90days\": 90,\n} as const;\n\ntype LimitedDateRange = keyof typeof DATE_RANGE_TO_DAYS;\ntype DateRangeFilter = LimitedDateRange | \"all\";\n\ntype ArchivedEntityRow = {\n\tid: string;\n\tdeleted_at: string;\n\tdeleted_by?: string | null;\n\tarchived_at?: string | null;\n\tpermanent_delete_scheduled_at?: string | null;\n} & Record<string, unknown>;\n\n// Entity types that support archiving\nexport type ArchivableEntityType =\n\t| \"invoice\"\n\t| \"estimate\"\n\t| \"contract\"\n\t| \"job\"\n\t| \"customer\"\n\t| \"property\"\n\t| \"equipment\"\n\t| \"purchase_order\";\n\ntype EntityFilter = ArchivableEntityType | \"all\";\n\n// Archived item representation\nexport type ArchivedItem = {\n\tid: string;\n\tentityType: ArchivableEntityType;\n\tentityNumber?: string; // invoice_number, job_number, etc.\n\tdisplayName: string; // Human-readable name\n\tdeletedAt: string;\n\tdeletedBy?: string;\n\tdeletedByName?: string;\n\tarchivedAt: string;\n\tpermanentDeleteScheduledAt: string;\n\tdaysUntilPermanentDelete: number;\n\tmetadata?: Record<string, unknown>; // Entity-specific data\n};\n\ntype EntityFetchConfig = {\n\ttable: string;\n\tentityType: ArchivableEntityType;\n\tnumberField?: string;\n};\n\nconst ENTITY_FETCH_CONFIGS: EntityFetchConfig[] = [\n\t{ table: \"invoices\", entityType: \"invoice\", numberField: \"invoice_number\" },\n\t{\n\t\ttable: \"estimates\",\n\t\tentityType: \"estimate\",\n\t\tnumberField: \"estimate_number\",\n\t},\n\t{\n\t\ttable: \"contracts\",\n\t\tentityType: \"contract\",\n\t\tnumberField: \"contract_number\",\n\t},\n\t{ table: \"jobs\", entityType: \"job\", numberField: \"job_number\" },\n\t{ table: \"customers\", entityType: \"customer\" },\n\t{ table: \"properties\", entityType: \"property\" },\n\t{\n\t\ttable: \"equipment\",\n\t\tentityType: \"equipment\",\n\t\tnumberField: \"equipment_number\",\n\t},\n\t{\n\t\ttable: \"purchase_orders\",\n\t\tentityType: \"purchase_order\",\n\t\tnumberField: \"po_number\",\n\t},\n];\n\n// Filter options for archive queries\nconst getArchivedItemsSchema = z.object({\n\tentityType: z\n\t\t.enum([\n\t\t\t\"invoice\",\n\t\t\t\"estimate\",\n\t\t\t\"contract\",\n\t\t\t\"job\",\n\t\t\t\"customer\",\n\t\t\t\"property\",\n\t\t\t\"equipment\",\n\t\t\t\"purchase_order\",\n\t\t\t\"all\",\n\t\t])\n\t\t.default(\"all\"),\n\tdateRange: z.enum([\"7days\", \"30days\", \"90days\", \"all\"]).default(\"30days\"),\n\tdeletedBy: z.string().uuid().optional(),\n\tsearchQuery: z.string().optional(),\n\tlimit: z\n\t\t.number()\n\t\t.min(ARCHIVE_LIMIT.min)\n\t\t.max(ARCHIVE_LIMIT.max)\n\t\t.default(ARCHIVE_LIMIT.default),\n\toffset: z.number().min(0).default(0),\n});\n\n/**\n * Get archived items with filters\n */\nasync function getArchivedItems(\n\toptions: z.infer<typeof getArchivedItemsSchema>,\n): Promise<ActionResult<ArchivedItem[]>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS.forbidden,\n\t\t\t);\n\t\t}\n\n\t\tconst validated = getArchivedItemsSchema.parse(options);\n\t\tconst dateFilterIso = computeDateFilterIso(validated.dateRange);\n\t\tconst configs = getEntityFetchConfigs(validated.entityType);\n\n\t\tconst archivedItems = (\n\t\t\tawait Promise.all(\n\t\t\t\tconfigs.map((config) =>\n\t\t\t\t\tfetchArchivedEntities({\n\t\t\t\t\t\tsupabase,\n\t\t\t\t\t\tcompanyId: teamMember.company_id,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tlimit: validated.limit,\n\t\t\t\t\t\tdeletedBy: validated.deletedBy,\n\t\t\t\t\t\tdateFilterIso,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t)\n\t\t)\n\t\t\t.flat()\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tnew Date(b.deletedAt).getTime() - new Date(a.deletedAt).getTime(),\n\t\t\t);\n\n\t\treturn applySearchFilter(archivedItems, validated.searchQuery);\n\t});\n}\n\nconst computeDateFilterIso = (range: DateRangeFilter): string | null => {\n\tif (range === \"all\") {\n\t\treturn null;\n\t}\n\n\tconst days = DATE_RANGE_TO_DAYS[range as LimitedDateRange];\n\treturn new Date(Date.now() - days * MILLISECONDS_IN_DAY).toISOString();\n};\n\nconst getEntityFetchConfigs = (filter: EntityFilter): EntityFetchConfig[] =>\n\tENTITY_FETCH_CONFIGS.filter(\n\t\t(config) => filter === \"all\" || config.entityType === filter,\n\t);\n\ntype FetchArchivedEntitiesParams = {\n\tsupabase: SupabaseServerClient;\n\tcompanyId: string;\n\tconfig: EntityFetchConfig;\n\tlimit: number;\n\tdeletedBy?: string;\n\tdateFilterIso: string | null;\n};\n\nasync function fetchArchivedEntities({\n\tsupabase,\n\tcompanyId,\n\tconfig,\n\tlimit,\n\tdeletedBy,\n\tdateFilterIso,\n}: FetchArchivedEntitiesParams): Promise<ArchivedItem[]> {\n\tconst selectionFields = [\n\t\t\"id\",\n\t\t\"deleted_at\",\n\t\t\"deleted_by\",\n\t\t\"archived_at\",\n\t\t\"permanent_delete_scheduled_at\",\n\t\t\"*\",\n\t];\n\n\tif (config.numberField) {\n\t\tselectionFields.splice(1, 0, config.numberField);\n\t}\n\n\tlet query = supabase\n\t\t.from(config.table)\n\t\t.select(selectionFields.join(\",\"))\n\t\t.eq(\"company_id\", companyId)\n\t\t.not(\"deleted_at\", \"is\", null)\n\t\t.order(\"deleted_at\", { ascending: false });\n\n\tif (dateFilterIso) {\n\t\tquery = query.gte(\"deleted_at\", dateFilterIso);\n\t}\n\n\tif (deletedBy) {\n\t\tquery = query.eq(\"deleted_by\", deletedBy);\n\t}\n\n\tconst { data, error } = await query\n\t\t.limit(limit)\n\t\t.returns<ArchivedEntityRow[]>();\n\n\tif (error) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.operationFailed(`fetch archived ${config.entityType}`),\n\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t);\n\t}\n\n\treturn (data ?? []).map((item) => buildArchivedItem(item, config));\n}\n\nconst buildArchivedItem = (\n\titem: ArchivedEntityRow,\n\tconfig: EntityFetchConfig,\n): ArchivedItem => {\n\tconst fallbackDeleteDate = new Date(\n\t\tnew Date(item.deleted_at).getTime() +\n\t\t\tPERMANENT_DELETE_BUFFER_DAYS * MILLISECONDS_IN_DAY,\n\t);\n\n\tconst permanentDeleteDate = item.permanent_delete_scheduled_at\n\t\t? new Date(item.permanent_delete_scheduled_at)\n\t\t: fallbackDeleteDate;\n\n\tconst entityNumber =\n\t\tconfig.numberField && typeof item[config.numberField] === \"string\"\n\t\t\t? (item[config.numberField] as string)\n\t\t\t: undefined;\n\n\tconst daysUntil = Math.ceil(\n\t\t(permanentDeleteDate.getTime() - Date.now()) / MILLISECONDS_IN_DAY,\n\t);\n\n\treturn {\n\t\tid: item.id,\n\t\tentityType: config.entityType,\n\t\tentityNumber,\n\t\tdisplayName: getDisplayName(item, config.entityType),\n\t\tdeletedAt: item.deleted_at,\n\t\tdeletedBy: item.deleted_by ?? undefined,\n\t\tarchivedAt: item.archived_at || item.deleted_at,\n\t\tpermanentDeleteScheduledAt:\n\t\t\titem.permanent_delete_scheduled_at || fallbackDeleteDate.toISOString(),\n\t\tdaysUntilPermanentDelete: Math.max(0, daysUntil),\n\t\tmetadata: item,\n\t};\n};\n\nconst applySearchFilter = (\n\titems: ArchivedItem[],\n\tquery?: string,\n): ArchivedItem[] => {\n\tif (!query) {\n\t\treturn items;\n\t}\n\n\tconst normalized = query.toLowerCase();\n\treturn items.filter(\n\t\t(item) =>\n\t\t\titem.displayName.toLowerCase().includes(normalized) ||\n\t\t\titem.entityNumber?.toLowerCase().includes(normalized) ||\n\t\t\titem.entityType.toLowerCase().includes(normalized),\n\t);\n};\n\nconst normalizeString = (value: unknown): string =>\n\ttypeof value === \"string\" ? value : \"\";\n\nconst nonEmptyString = (value: unknown, fallback = \"\"): string => {\n\tconst normalized = normalizeString(value).trim();\n\treturn normalized.length > 0 ? normalized : fallback;\n};\n\nconst fullName = (first: unknown, last: unknown): string => {\n\tconst combined = `${normalizeString(first)} ${normalizeString(last)}`.trim();\n\treturn combined.length > 0 ? combined : \"\";\n};\n\n/**\n * Helper to get display name for different entity types\n */\nfunction getDisplayName(\n\titem: ArchivedEntityRow,\n\tentityType: ArchivableEntityType,\n): string {\n\tswitch (entityType) {\n\t\tcase \"invoice\": {\n\t\t\tconst invoiceNumber = nonEmptyString(item.invoice_number, item.id);\n\t\t\treturn `Invoice ${invoiceNumber}`;\n\t\t}\n\t\tcase \"estimate\": {\n\t\t\tconst estimateNumber = nonEmptyString(item.estimate_number, item.id);\n\t\t\treturn `Estimate ${estimateNumber}`;\n\t\t}\n\t\tcase \"contract\": {\n\t\t\tconst contractRef = nonEmptyString(\n\t\t\t\titem.contract_number,\n\t\t\t\tnonEmptyString(item.title, item.id),\n\t\t\t);\n\t\t\treturn `Contract ${contractRef}`;\n\t\t}\n\t\tcase \"job\": {\n\t\t\tconst jobNumber = nonEmptyString(item.job_number, item.id);\n\t\t\tconst jobTitle = nonEmptyString(item.title, \"Untitled\");\n\t\t\treturn `Job ${jobNumber} - ${jobTitle}`;\n\t\t}\n\t\tcase \"customer\": {\n\t\t\tconst displayName = nonEmptyString(item.display_name);\n\t\t\tconst fallbackName = fullName(item.first_name, item.last_name);\n\t\t\treturn displayName || fallbackName || \"Unknown Customer\";\n\t\t}\n\t\tcase \"property\":\n\t\t\treturn nonEmptyString(\n\t\t\t\titem.name,\n\t\t\t\tnonEmptyString(item.address, \"Unknown Property\"),\n\t\t\t);\n\t\tcase \"equipment\": {\n\t\t\tconst equipmentNumber = nonEmptyString(item.equipment_number);\n\t\t\tconst equipmentName = nonEmptyString(item.name, \"Unknown Equipment\");\n\t\t\treturn `${equipmentNumber ? `${equipmentNumber} ` : \"\"}${equipmentName}`.trim();\n\t\t}\n\t\tdefault:\n\t\t\treturn \"Unknown Item\";\n\t}\n}\n\n/**\n * Get archive statistics\n */\nasync function getArchiveStats(): Promise<\n\tActionResult<Record<ArchivableEntityType, number>>\n> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS.forbidden,\n\t\t\t);\n\t\t}\n\n\t\t// PERFORMANCE OPTIMIZED: Pattern #8 Fix - Single RPC instead of 8 COUNT queries\n\t\t// BEFORE: 8 COUNT queries (1 per entity type)\n\t\t// AFTER: 1 RPC call\n\t\t// Performance gain: ~5 seconds saved (87.5% reduction)\n\n\t\tconst { data: counts, error: countsError } = await supabase.rpc(\n\t\t\t\"count_all_archived\",\n\t\t\t{\n\t\t\t\tp_company_id: teamMember.company_id,\n\t\t\t},\n\t\t);\n\n\t\tif (countsError || !counts || counts.length === 0) {\n\t\t\treturn {\n\t\t\t\tinvoice: 0,\n\t\t\t\testimate: 0,\n\t\t\t\tcontract: 0,\n\t\t\t\tjob: 0,\n\t\t\t\tcustomer: 0,\n\t\t\t\tproperty: 0,\n\t\t\t\tequipment: 0,\n\t\t\t\tpurchase_order: 0,\n\t\t\t};\n\t\t}\n\n\t\tconst result = counts[0];\n\t\treturn {\n\t\t\tinvoice: Number(result.invoice_count) || 0,\n\t\t\testimate: Number(result.estimate_count) || 0,\n\t\t\tcontract: Number(result.contract_count) || 0,\n\t\t\tjob: Number(result.job_count) || 0,\n\t\t\tcustomer: Number(result.customer_count) || 0,\n\t\t\tproperty: Number(result.property_count) || 0,\n\t\t\tequipment: Number(result.equipment_count) || 0,\n\t\t\tpurchase_order: Number(result.purchase_order_count) || 0,\n\t\t};\n\t});\n}\n\n/**\n * Bulk restore multiple items\n */\nasync function bulkRestore(\n\titemIds: string[],\n\tentityType: ArchivableEntityType,\n): Promise<ActionResult<{ restored: number; failed: number }>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS.forbidden,\n\t\t\t);\n\t\t}\n\n\t\t// Map entity type to table name\n\t\tconst tableMap: Record<ArchivableEntityType, string> = {\n\t\t\tinvoice: \"invoices\",\n\t\t\testimate: \"estimates\",\n\t\t\tcontract: \"contracts\",\n\t\t\tjob: \"jobs\",\n\t\t\tcustomer: \"customers\",\n\t\t\tproperty: \"properties\",\n\t\t\tequipment: \"equipment\",\n\t\t\tpurchase_order: \"purchase_orders\",\n\t\t};\n\n\t\tconst tableName = tableMap[entityType];\n\n\t\t// Restore items\n\t\tconst { error, count } = await supabase\n\t\t\t.from(tableName)\n\t\t\t.update({\n\t\t\t\tdeleted_at: null,\n\t\t\t\tdeleted_by: null,\n\t\t\t\tarchived_at: null,\n\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t})\n\t\t\t.in(\"id\", itemIds)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.not(\"deleted_at\", \"is\", null); // Only restore actually archived items\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore items\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/customers\");\n\n\t\treturn {\n\t\t\trestored: count || 0,\n\t\t\tfailed: itemIds.length - (count || 0),\n\t\t};\n\t});\n}\n\n/**\n * Bulk archive multiple items\n */\nexport async function bulkArchive(\n\titemIds: string[],\n\tentityType: ArchivableEntityType,\n): Promise<ActionResult<{ archived: number; failed: number }>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS.forbidden,\n\t\t\t);\n\t\t}\n\n\t\tif (!itemIds || itemIds.length === 0) {\n\t\t\tthrow new ActionError(\"No items provided\", ERROR_CODES.VALIDATION_FAILED);\n\t\t}\n\n\t\t// Map entity type to table name\n\t\tconst tableMap: Record<ArchivableEntityType, string> = {\n\t\t\tinvoice: \"invoices\",\n\t\t\testimate: \"estimates\",\n\t\t\tcontract: \"contracts\",\n\t\t\tjob: \"jobs\",\n\t\t\tcustomer: \"customers\",\n\t\t\tproperty: \"properties\",\n\t\t\tequipment: \"equipment\",\n\t\t\tpurchase_order: \"purchase_orders\",\n\t\t};\n\n\t\tconst tableName = tableMap[entityType];\n\n\t\t// Calculate permanent delete date (90 days from now)\n\t\tconst permanentDeleteDate = new Date();\n\t\tpermanentDeleteDate.setDate(\n\t\t\tpermanentDeleteDate.getDate() + PERMANENT_DELETE_BUFFER_DAYS,\n\t\t);\n\n\t\t// Archive items (soft delete)\n\t\tconst { error, count } = await supabase\n\t\t\t.from(tableName)\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tarchived_at: new Date().toISOString(),\n\t\t\t\tpermanent_delete_scheduled_at: permanentDeleteDate.toISOString(),\n\t\t\t})\n\t\t\t.in(\"id\", itemIds)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.is(\"deleted_at\", null); // Only archive non-archived items\n\n\t\tif (error) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive items\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate relevant paths\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t\trevalidatePath(\"/dashboard/work\");\n\t\trevalidatePath(\"/dashboard/customers\");\n\n\t\treturn {\n\t\t\tarchived: count || 0,\n\t\t\tfailed: itemIds.length - (count || 0),\n\t\t};\n\t});\n}\n\n/**\n * Permanent delete (hard delete) - Admin only, after 90 days\n */\nasync function permanentDelete(\n\titemId: string,\n\tentityType: ArchivableEntityType,\n): Promise<ActionResult<void>> {\n\treturn await withErrorHandling(async () => {\n\t\tconst supabase = await getSupabaseServerClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS.forbidden,\n\t\t\t);\n\t\t}\n\n\t\t// Map entity type to table name\n\t\tconst tableMap: Record<ArchivableEntityType, string> = {\n\t\t\tinvoice: \"invoices\",\n\t\t\testimate: \"estimates\",\n\t\t\tcontract: \"contracts\",\n\t\t\tjob: \"jobs\",\n\t\t\tcustomer: \"customers\",\n\t\t\tproperty: \"properties\",\n\t\t\tequipment: \"equipment\",\n\t\t\tpurchase_order: \"purchase_orders\",\n\t\t};\n\n\t\tconst tableName = tableMap[entityType];\n\n\t\t// Verify item is archived and past 90 days\n\t\tconst { data: item } = await supabase\n\t\t\t.from(tableName)\n\t\t\t.select(\"deleted_at, archived_at, permanent_delete_scheduled_at\")\n\t\t\t.eq(\"id\", itemId)\n\t\t\t.eq(\"company_id\", teamMember.company_id)\n\t\t\t.single();\n\n\t\tif (!item?.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Item is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Check if 90 days have passed (or scheduled date is in past)\n\t\tconst now = new Date();\n\t\tconst scheduledDate = new Date(\n\t\t\titem.permanent_delete_scheduled_at || item.deleted_at,\n\t\t);\n\n\t\tif (scheduledDate > now) {\n\t\t\tthrow new ActionError(\n\t\t\t\t`Cannot permanently delete until ${scheduledDate.toLocaleDateString()}. Items can only be permanently deleted after 90 days.`,\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Permanently delete\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(tableName)\n\t\t\t.delete()\n\t\t\t.eq(\"id\", itemId)\n\t\t\t.eq(\"company_id\", teamMember.company_id);\n\n\t\tif (deleteError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"permanently delete item\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n","export {getCurrentUserRole as '001f005176797ef23488068124fb9a744915a477de'} from 'ACTIONS_MODULE0'\nexport {canDeleteTeamMember as '406f6624261c6dd1a908026fa1408a3f6d507b6e7d'} from 'ACTIONS_MODULE0'\nexport {getPayrixMerchantAccount as '40704f0e856ad801ef93b43436f219a36f7c0efd2c'} from 'ACTIONS_MODULE1'\nexport {getWebRTCCredentials as '000478fbf5363dae5000d525663da13e29908cb952'} from 'ACTIONS_MODULE2'\nexport {transcribeCallRecording as '4002f454c46f4c21ca6e9e26362583ccff69c9f914'} from 'ACTIONS_MODULE2'\nexport {getCompanyPhoneNumbers as '4019cf9f81eb3c06f82b5c2f8eb042f3d95d91e933'} from 'ACTIONS_MODULE2'\nexport {getCallRoutingRules as '40247c617842c31b242455a0961cbd2c3297606a16'} from 'ACTIONS_MODULE2'\nexport {updateCallRoutingRule as '40413bfa888916480edbc33ebb812158fddf960f89'} from 'ACTIONS_MODULE2'\nexport {startCallRecording as '404e47931374ad2a1b54bc11f357703790f6104530'} from 'ACTIONS_MODULE2'\nexport {transferActiveCall as '405a16958f97c37bd4b5711bd8761510bdab55839f'} from 'ACTIONS_MODULE2'\nexport {searchPhoneNumbers as '406864ae05b8b51c66cc2c335999e5011a41cb521f'} from 'ACTIONS_MODULE2'\nexport {makeCall as '40b2df540ec465c5dc19545c96486485bb50b5633b'} from 'ACTIONS_MODULE2'\nexport {sendTextMessage as '40d050abdabe2ee7293436c505c5f27b4408a2f27c'} from 'ACTIONS_MODULE2'\nexport {stopCallRecording as '40d5cc291162e2fd61245bdb851d5e8ed609e4ed19'} from 'ACTIONS_MODULE2'\nexport {sendMMSMessage as '40edd91786b2a482e617fb16f2474d26ec295435e7'} from 'ACTIONS_MODULE2'\nexport {purchasePhoneNumber as '40fd6a80b32792fab749933f98f07503d8e94c0305'} from 'ACTIONS_MODULE2'\nexport {deleteCallRoutingRule as '607d0f958daf66b2a0d5277cdda17600dace5156bb'} from 'ACTIONS_MODULE2'\nexport {toggleCallRoutingRule as '60853f1e409364f7e171e27229217994ff224414e6'} from 'ACTIONS_MODULE2'\nexport {createServiceSupabaseClient as '00a13dbd00149949fc1367d3e76ae7d789e07f5321'} from 'ACTIONS_MODULE3'\nexport {ensureMessagingBranding as '606753f8910b46d5792f4bdeb457cdf29d1a8bbadc'} from 'ACTIONS_MODULE4'\nexport {ensureMessagingCampaign as '70a648f43fa62ae3dcf2070eb90413e96e81591e77'} from 'ACTIONS_MODULE4'\nexport {checkTelnyxVerificationStatus as '007505a78985e53e083a498c97761ed8a463d3d379'} from 'ACTIONS_MODULE5'\nexport {submitAutomatedVerification as '4087f0badccd6aaf6a28b640ab4bbc513f0832d105'} from 'ACTIONS_MODULE5'\nexport {registerCompanyFor10DLC as '40ae25402a089e45aa071d979e8cc6ad136205cc98'} from 'ACTIONS_MODULE5'\nexport {sendVerificationSubmittedEmail as '70f58c5ba46ef02b620d7dc87bae8fc83f6d480755'} from 'ACTIONS_MODULE6'\nexport {sendEmail as '40f8c061cf84f884e77af3425bc24b8a8d72f598fb'} from 'ACTIONS_MODULE7'\nexport {handleComplaintWebhook as '6045f8436f9cdfdadb7bfe3955677adfc5f4102de0'} from 'ACTIONS_MODULE7'\nexport {handleBounceWebhook as '78a8ea4f1cfa571a366adccf36ac04b1c85d61ae2b'} from 'ACTIONS_MODULE7'\nexport {runHealthCheckForAllDomains as '00c53a1f02416c3261983f8096f19a3450bfd51775'} from 'ACTIONS_MODULE8'\nexport {getDomainHealth as '400b8fb96146bfd004a3166563a5ab5536bb610c70'} from 'ACTIONS_MODULE8'\nexport {recordDeliveryEvent as '404d6f2891af89c71d5bde33d110a216bdd3ee4729'} from 'ACTIONS_MODULE8'\nexport {getCompanyDomainsHealth as '405c57a8fed352b8679525b56014eb8c49105c850c'} from 'ACTIONS_MODULE8'\nexport {processResendWebhookEvent as '40ad037af6f6ab1a3004746d3a1b65afa65527002d'} from 'ACTIONS_MODULE8'\nexport {generateDeliverabilityReport as '40ecf2c792e84ef4b898fda98ec27277b4a9dddef2'} from 'ACTIONS_MODULE8'\nexport {resetHourlyCounters as '004cdde5e6ae8991bab4ba61ae40647c2b823200ba'} from 'ACTIONS_MODULE9'\nexport {resetDailyCounters as '006acf41615a2f7795c47b6d7a3016e18300f2ad17'} from 'ACTIONS_MODULE9'\nexport {incrementEmailCounter as '4029b163c1c0acfd806352a72fe8030c8ae4f7f8ac'} from 'ACTIONS_MODULE9'\nexport {getCompanyActiveDomain as '407a5a7d0a7dd7989a963eb2485a3527c1dcb20a70'} from 'ACTIONS_MODULE9'\nexport {checkRateLimit as '40af86a915f04df8d7cc189fe26e45e0cc24663080'} from 'ACTIONS_MODULE9'\nexport {isGmailIntegrationEnabled as '00fe74bdf14126b5ad89e9480e82978d6357f356b3'} from 'ACTIONS_MODULE10'\nexport {getUserGmailTokens as '400ce95360aaffa14a99dfdf969ba5166c69a59eb6'} from 'ACTIONS_MODULE10'\nexport {disconnectCompanyGmail as '401d3d830065dd7c4777fad67f642392f48735c4ab'} from 'ACTIONS_MODULE10'\nexport {disconnectUserGmail as '404575d602ef4c60c0058b592b8c3e42fbcd13fc4c'} from 'ACTIONS_MODULE10'\nexport {getCompanyEmailProvider as '40787b1598849126560f9f0b0f8fe8967338c7bf28'} from 'ACTIONS_MODULE10'\nexport {getCompanyGmailTokens as '40beeb56302a20d27cd8ba7a0988310f855633d7e6'} from 'ACTIONS_MODULE10'\nexport {refreshUserGmailToken as '602fab67313b110e6ccb66e54b1e16450b2a772cc7'} from 'ACTIONS_MODULE10'\nexport {sendCompanyGmailEmail as '60302947fc4caffa53a719728f3c2cebace926098c'} from 'ACTIONS_MODULE10'\nexport {syncUserInbox as '603643b13bf288cc628303bb4d12df0311b11434c7'} from 'ACTIONS_MODULE10'\nexport {checkCompanyGmailHealth as '60856182db5eaec7f85eda2a5a94c5d7d3524325d6'} from 'ACTIONS_MODULE10'\nexport {refreshCompanyGmailToken as '60eeb51685ac265a4ad793a230a515fe6e462f16f4'} from 'ACTIONS_MODULE10'\nexport {fetchUserInbox as '708daa303e36e37247e22b5b828b6aad8c73ac283b'} from 'ACTIONS_MODULE10'\nexport {setCompanyEmailProvider as '70dd3bc4222a87350dc137fa9cbcb849fa1913b397'} from 'ACTIONS_MODULE10'\nexport {storeGmailMessage as '78d41ef818e75fef94d65a87ea1f0faf418132e3c5'} from 'ACTIONS_MODULE10'\nexport {storeUserGmailTokens as '7e3a356960ddd52a3fa4dc6d981ae7202a59eb9a3d'} from 'ACTIONS_MODULE10'\nexport {storeCompanyGmailTokens as '7f06df826c4fff42950e712c0f548254e275be2a52'} from 'ACTIONS_MODULE10'\nexport {getProviderHealthDashboard as '00a122f9d5fe3a1603c636c3a251886129b66154f8'} from 'ACTIONS_MODULE11'\nexport {checkProviderAlert as '40c7885bdc4fe4cdd5f57e78579230c58088adbef4'} from 'ACTIONS_MODULE11'\nexport {cleanupOldEvents as '40d3c4ceeaee653aa257a28ed429a7fd272fa9fb66'} from 'ACTIONS_MODULE11'\nexport {recordProviderEvent as '40e06418f4b93b40c84a25511e0468e1e8a41ddecf'} from 'ACTIONS_MODULE11'\nexport {getProviderStats as '60c643a41ce1a8e6cc8338da6e2f3678c386910460'} from 'ACTIONS_MODULE11'\nexport {recordSendFailure as '78255c3fa8c9facf7c3f353202f2907836e8eb5539'} from 'ACTIONS_MODULE11'\nexport {recordSendSuccess as '783861d25688b32ba086bbe9e45444975c36a1b285'} from 'ACTIONS_MODULE11'\nexport {recordFallbackTriggered as '78766431b437b16f7cb00b4d64a2f3be5e092ed724'} from 'ACTIONS_MODULE11'\nexport {deleteNotification as '40fab1894acc5e3d1fdd8d8c6128a7cecee06e7e6a'} from 'ACTIONS_MODULE12'\nexport {markAllAsRead as '00cf212b0097820096122537beac12e3403b97d564'} from 'ACTIONS_MODULE12'\nexport {markAsRead as '4094cf679b4a10ca0f969f4fc1b55602aac4e0fbc3'} from 'ACTIONS_MODULE12'\nexport {makeCall as '40b2df540ec465c5dc19545c96486485bb50b5633b'} from 'ACTIONS_MODULE2'\nexport {getWebRTCCredentials as '000478fbf5363dae5000d525663da13e29908cb952'} from 'ACTIONS_MODULE2'\nexport {signOut as '0043ae510c3322ea499beb9e1bb77d06afb4ef19bd'} from 'ACTIONS_MODULE13'\nexport {switchCompany as '4097c3c574342661f9a3c8244961d001234449f36f'} from 'ACTIONS_MODULE14'\nexport {updateUserStatus as '4081009dd4dff14ff4ece62648bad23a83f2f9f63c'} from 'ACTIONS_MODULE15'\nexport {getTotalUnreadCountAction as '00ebc03a4ffc993aea7ec2e541686105c2bace2437'} from 'ACTIONS_MODULE16'\nexport {getCompanyPendingActions as '40e9589cb639f2902eb841bedc1247d966486d6fd7'} from 'ACTIONS_MODULE17'\nexport {checkIsCompanyOwner as '001be5cf82b793f19f6a7d010c91c14577fa7a130d'} from 'ACTIONS_MODULE17'\nexport {getCustomerByPhone as '6013add076e3eaed7dc37e8b800ce977d5abb8d49a'} from 'ACTIONS_MODULE18'\nexport {startCallRecording as '404e47931374ad2a1b54bc11f357703790f6104530'} from 'ACTIONS_MODULE2'\nexport {stopCallRecording as '40d5cc291162e2fd61245bdb851d5e8ed609e4ed19'} from 'ACTIONS_MODULE2'\nexport {deleteCustomer as '4082b52123c24a95685a53c36313418a95c259c65b'} from 'ACTIONS_MODULE18'\nexport {searchCustomers as '60193685409a9d118f1b364e14ecf57d05fa5638a9'} from 'ACTIONS_MODULE18'\nexport {getCustomersForDialer as '0077abd0cb1e555f91adaa482ad0b2f565bbd0629a'} from 'ACTIONS_MODULE18'\nexport {getPendingSupportSessions as '000f90f949d6a2f5484d061d5a738a59a8c846aeaa'} from 'ACTIONS_MODULE19'\nexport {getActiveSupportSessions as '00665c1bbcd52d612d5bb4bf3be5e7fc75554132e6'} from 'ACTIONS_MODULE19'\nexport {approveSupportSessionRequest as '602e89ae7ace85fc30cd3b4b1dd865d517c0cb1cd5'} from 'ACTIONS_MODULE19'\nexport {rejectSupportSessionRequest as '60886af124323873afd4d5b64bb4143abbcba2c154'} from 'ACTIONS_MODULE19'\nexport {endActiveSupportSession as '40369e8ea4eced7bdaef8203d369469ee7b630db8c'} from 'ACTIONS_MODULE19'\nexport {createEmailFolderAction as '408d3694fd0dd48e424f53c9bf5083b946ab3ec990'} from 'ACTIONS_MODULE20'\nexport {getEmailFolderCountsAction as '009e962eae57bf128b2023081fd7259048edd8884a'} from 'ACTIONS_MODULE16'\nexport {getEmailFoldersAction as '00235a0ba91f1ba226f33fa40dcf4c93a2c3548c70'} from 'ACTIONS_MODULE20'\nexport {deleteEmailFolderAction as '40c55f8e0922f2c7fd8d502e4c75395bf5f0470430'} from 'ACTIONS_MODULE20'\nexport {searchVendors as '404a3266e0319dbd8c24fec80bb69ecfe029d2a768'} from 'ACTIONS_MODULE21'\nexport {getSmsFolderCountsAction as '0006f7bd89b72f0836ec7bf4db73019f1b32e6c24a'} from 'ACTIONS_MODULE22'\nexport {archiveJob as '40f1e5f08b8bcdc5c42b2b4791562d08761d764af2'} from 'ACTIONS_MODULE23'\nexport {updateCustomerTags as '60f17c4aa6f5422ed664af74d27030f3031342ae78'} from 'ACTIONS_MODULE24'\nexport {updateJobTags as '60898a74b1f50c91ad212b879e4dd1f41f996ca0d1'} from 'ACTIONS_MODULE24'\nexport {getAvailableTeamMembers as '0047ccac2f82e9969542d3f6672186d3cd828b7bd3'} from 'ACTIONS_MODULE25'\nexport {assignTeamMemberToJob as '408f899c6c9ae9bf0d3ddd5dc5f59d9eb034eefefe'} from 'ACTIONS_MODULE25'\nexport {removeTeamMemberFromJob as '40bc97e60829c913eadb2dcb8c0210e5703090afdf'} from 'ACTIONS_MODULE25'\nexport {updateEntityTags as '70ff12ee81a60340f786414d0baa7af58484dd7488'} from 'ACTIONS_MODULE26'\nexport {assignCustomerToJob as '70c4422bfad1179a11fcab9e7932fcf83e2c5a0958'} from 'ACTIONS_MODULE23'\nexport {removeCustomerFromJob as '4013f2d8e15e9f879b9243e34cbb744045fea3ab6f'} from 'ACTIONS_MODULE23'\nexport {updateJob as '6016b788b64107b06bd9f3b8d7ab9a318b65e38c27'} from 'ACTIONS_MODULE23'\nexport {findOrCreateProperty as '408e80b3cde6acbbf52029b5b34cf969f275e65d9d'} from 'ACTIONS_MODULE27'\nexport {assignTeamMemberToJob as '408f899c6c9ae9bf0d3ddd5dc5f59d9eb034eefefe'} from 'ACTIONS_MODULE25'\nexport {removeTeamMemberFromJob as '40bc97e60829c913eadb2dcb8c0210e5703090afdf'} from 'ACTIONS_MODULE25'\nexport {sendTextMessage as '40d050abdabe2ee7293436c505c5f27b4408a2f27c'} from 'ACTIONS_MODULE2'\nexport {getCustomerProperties as '40df181f2aa3e0769d3e7da5a87fb03c360b1659f1'} from 'ACTIONS_MODULE28'\nexport {searchCustomersForJob as '407903e35c92a73720ba1d8412141271ed3380a794'} from 'ACTIONS_MODULE28'\nexport {uploadDocument as '40e9803ebaeabdd8b04052b6c8ee82a0faeea4b5e9'} from 'ACTIONS_MODULE29'\nexport {bulkArchive as '600d248fca67343a7a300d336e6a84b87acdd15e2e'} from 'ACTIONS_MODULE30'\nexport {unlinkEstimateFromJob as '40f3ec53c0664a911f329a975c4b02ddbf55ef70c4'} from 'ACTIONS_MODULE31'\nexport {unlinkInvoiceFromJob as '403a81dea3436d2f9aa1f3bd091b670f166ecf43f5'} from 'ACTIONS_MODULE32'\nexport {unlinkPaymentFromJob as '40d4adefa21187fbf8ce66938d69116b0f76c43548'} from 'ACTIONS_MODULE33'\nexport {completeJob as '40d347232a1bdd45e08aefd1c04b02a94f66dfd261'} from 'ACTIONS_MODULE23'\nexport {startJob as '4009b5533bd04d9fad82f2e95351e90a25ffe05192'} from 'ACTIONS_MODULE23'\n"],"names":[],"mappings":"wCAKC,IAAA,EAAA,EAAA,CAAA,CAAA,QAID,EAAA,CAAA,CAAA,QAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAkCO,eAAe,EACrB,CAAa,EAEb,GAAI,CAAC,GAAS,EAAM,IAAI,GAAG,MAAM,CAAG,EACnC,CADsC,KAC/B,EAAE,CAGV,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,MAAO,EADO,AACL,CAGV,IAAM,EAAY,MAAM,CAAA,EAAA,EAAA,kBAAA,AAAkB,IAC1C,GAAI,CAAC,EACJ,MAAO,EAAE,CAGV,AAJgB,GAIZ,CAKH,OAJgB,AAIT,MAJe,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAAC,EAAU,EAAW,EAAO,CACzE,MAAO,EACR,EAGD,CAAE,MAAO,EAAO,CAEf,OADA,QAAQ,KAAK,CAAC,6BAA8B,GACrC,EAAE,AACV,CACD,CAQO,eAAe,EACrB,CAAkB,EAElB,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAY,AAAZ,IACvB,GAAI,CAAC,GAKD,CADc,AACb,MALU,AAIS,CAAA,EAAA,EAAA,AACR,kBADQ,AAAkB,IAHzC,MAAO,EAAE,CAQV,GAAI,CACH,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC5B,IAAI,CAAC,cACL,MAAM,CAAC,KACP,EAAE,CAAC,cAAe,GAClB,EAAE,CAAC,aAAc,MACjB,KAAK,CAAC,aAAc,CAAE,WAAW,CAAM,GAEzC,GAAI,EAEH,KAFU,EACV,QAAQ,KAAK,CAAC,6BAA8B,GACrC,EAAE,CAGV,OAAQ,GAAQ,EAAE,AACnB,CAAE,MAAO,EAAO,CAEf,OADA,QAAQ,KAAK,CAAC,6BAA8B,GACrC,EAAE,AACV,CACD,2CAlEsB,EAmCA,IAnCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAmCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,oHCpEtB,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,CAAA,CAAA,QAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QCDA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QCOA,IAAM,EAAqB,CAE1B,OACA,OACA,OACA,OACA,OACA,OACA,eACA,UACA,OACA,OACA,OACA,OACA,OACA,MACA,OACA,MACA,OACA,OACA,OACA,OACA,UACA,OACA,UACA,QACA,QACA,OACA,QACA,QACA,UACA,WACA,WAGA,OACA,OACA,OACA,QACA,WAGA,MACA,QACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,QAGA,OACA,OACA,OAGA,OACA,OACA,OAGA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAGA,OACA,OACA,OACA,SAGA,OACA,OACA,OACA,CAKK,EAAc,CACnB,OAAQ,IAAI,IACZ,GADmB,GACZ,KAAK,KACZ,EADmB,OACT,MAAM,IAChB,GADuB,GAChB,MAAM,GACb,IADoB,IACX,MAAM,GACf,IADsB,IACb,KAAK,KACd,EADqB,OACX,KAAK,KACf,EADsB,OACZ,KAAK,IAChB,EAKM,CANiB,CAMI,CAC1B,MAAO,CACN,aACA,YACA,YACA,aACA,gBACA,YACA,aACA,aACA,aACA,CACD,SAAU,CACT,kBACA,qBACA,0EACA,2BACA,oEACA,gCACA,4EACA,0CACA,iDACA,kDACA,aACA,WACA,kBACA,CACD,MAAO,CACN,YACA,aACA,kBACA,kBACA,aACA,mBACA,CACD,MAAO,CACN,aACA,YACA,YACA,aACA,YACA,aACA,CACD,QAAS,CACR,kBACA,+BACA,8BACA,oBACA,mBACA,CACD,IAAK,CACJ,mBACA,qBACA,0BACA,gBACA,gBAEF,AADE,EAOI,EAAyE,CAC9E,aAAc,CAAC,CAAE,MAAO,CAAC,IAAM,IAAM,IAAK,CAAE,OAAQ,CAAE,EAAE,CACxD,YAAa,CAAC,CAAE,MAAO,CAAC,IAAM,GAAM,GAAM,GAAK,CAAE,OAAQ,CAAE,EAAE,CAC7D,YAAa,CAAC,CAAE,MAAO,CAAC,GAAM,GAAM,GAAM,GA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"}