{"version":3,"sources":["../../../../../../apps/web/src/actions/payrix.ts","../../../../../../apps/web/src/lib/payments/payrix-api.ts","../../../../../../apps/web/src/lib/auth/session.ts","../../../../../../packages/auth/src/user-data.ts","../../../../../../apps/web/src/components/layout/app-header-client.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/src/components/layout/app-header-error-boundary.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/src/components/layout/incoming-call-notification-wrapper.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/src/components/layout/mobile-bottom-tabs-wrapper.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/src/components/layout/notifications-initializer.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/src/components/support/support-session-provider.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/web/src/app/%28dashboard%29/layout.tsx","../../../../../../apps/web/src/components/layout/app-header.tsx","../../../../../../apps/web/src/components/layout/dashboard-auth-wrapper.tsx"],"sourcesContent":["/**\n * Payrix Server Actions\n *\n * Server-side actions for Payrix merchant boarding and payment processing\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport {\n\tgetMCCForIndustry,\n\tgetMerchantStatus,\n\tsubmitMerchantBoarding,\n} from \"@/lib/payments/payrix-api\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype MerchantBoardingData = {\n\tcompanyId: string;\n\t// Business Information\n\tyearsInBusiness: number;\n\tbusinessDescription: string;\n\taverageTicketAmount: number;\n\thighestTicketAmount: number;\n\testimatedMonthlyVolume: number;\n\t// Owner Information\n\townerFullName: string;\n\townerSSN: string; // Will be encrypted before storage\n\townerDOB: string; // YYYY-MM-DD\n\townerHomeAddress: string;\n\townerCity: string;\n\townerState: string;\n\townerZip: string;\n\townerOwnershipPercentage: number;\n\townerTitle: string;\n\t// Payment Methods\n\tacceptsCreditCards: boolean;\n\tacceptsDebitCards: boolean;\n\tacceptsACH: boolean;\n\tacceptsRecurring: boolean;\n\t// Bank Account (from Plaid)\n\tbankAccountNumber: string;\n\tbankRoutingNumber: string;\n\tbankAccountType: \"checking\" | \"savings\";\n};\n\n/**\n * Submit merchant boarding application to Payrix\n */\nasync function submitPayrixMerchantBoarding(data: MerchantBoardingData) {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get company information\n\t\tconst { data: company, error: companyError } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", data.companyId)\n\t\t\t.single();\n\n\t\tif (companyError || !company) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Company not found\",\n\t\t\t};\n\t\t}\n\n\t\t// Parse company address\n\t\tconst addressParts = company.address?.split(\",\").map((s) => s.trim()) || [];\n\t\tconst [street, city, state, zip] = addressParts;\n\n\t\t// Determine entity type based on company structure\n\t\tconst entityType =\n\t\t\tcompany.company_size === \"individual\" || company.company_size === \"1-5\"\n\t\t\t\t? 1\n\t\t\t\t: company.legal_name?.includes(\"LLC\")\n\t\t\t\t\t? 3\n\t\t\t\t\t: 2;\n\n\t\t// Get MCC code for industry\n\t\tconst mccCode = getMCCForIndustry(company.industry || \"general\");\n\n\t\t// Calculate annual volume from monthly estimate\n\t\tconst annualVolume = data.estimatedMonthlyVolume * 12;\n\n\t\t// Parse owner name\n\t\tconst [firstName, ...lastNameParts] = data.ownerFullName.split(\" \");\n\t\tconst lastName = lastNameParts.join(\" \");\n\n\t\t// Prepare Payrix boarding request\n\t\tconst boardingRequest = {\n\t\t\tentity: {\n\t\t\t\ttype: entityType as 1 | 2 | 3,\n\t\t\t\tname: company.legal_name || company.name,\n\t\t\t\tdba: company.doing_business_as || company.name,\n\t\t\t\temail: company.email || \"\",\n\t\t\t\tphone: company.phone || \"\",\n\t\t\t\taddress1: street || \"\",\n\t\t\t\tcity: city || \"\",\n\t\t\t\tstate: state || \"\",\n\t\t\t\tzip: zip || \"\",\n\t\t\t\tcountry: \"US\",\n\t\t\t\twebsite: company.website || data.businessDescription,\n\t\t\t\tein: company.ein || undefined,\n\t\t\t},\n\t\t\tmerchant: {\n\t\t\t\tstatus: 1 as const, // Active\n\t\t\t\tmcc: mccCode,\n\t\t\t\testablished: new Date(\n\t\t\t\t\tnew Date().getFullYear() - data.yearsInBusiness,\n\t\t\t\t\t0,\n\t\t\t\t\t1,\n\t\t\t\t)\n\t\t\t\t\t.toISOString()\n\t\t\t\t\t.split(\"T\")[0],\n\t\t\t\tannualVolume,\n\t\t\t\taverageTicket: data.averageTicketAmount,\n\t\t\t\thighTicket: data.highestTicketAmount,\n\t\t\t\trefundPolicy: \"30 days\",\n\t\t\t},\n\t\t\tmembers: [\n\t\t\t\t{\n\t\t\t\t\tfirstName,\n\t\t\t\t\tlastName,\n\t\t\t\t\ttitle: data.ownerTitle,\n\t\t\t\t\temail: company.email || \"\",\n\t\t\t\t\tphone: company.phone || \"\",\n\t\t\t\t\tdob: data.ownerDOB,\n\t\t\t\t\tssn: data.ownerSSN, // Payrix will encrypt this\n\t\t\t\t\townership: data.ownerOwnershipPercentage,\n\t\t\t\t\taddress1: data.ownerHomeAddress,\n\t\t\t\t\tcity: data.ownerCity,\n\t\t\t\t\tstate: data.ownerState,\n\t\t\t\t\tzip: data.ownerZip,\n\t\t\t\t\tcountry: \"US\",\n\t\t\t\t},\n\t\t\t],\n\t\t\taccounts: [\n\t\t\t\t{\n\t\t\t\t\ttype: (data.bankAccountType === \"checking\" ? 1 : 2) as 1 | 2,\n\t\t\t\t\tnumber: data.bankAccountNumber,\n\t\t\t\t\trouting: data.bankRoutingNumber,\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\t// Submit to Payrix\n\t\tconst payrixResponse = await submitMerchantBoarding(boardingRequest);\n\n\t\tif (!payrixResponse.success) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: payrixResponse.error || \"Failed to submit merchant application\",\n\t\t\t};\n\t\t}\n\n\t\t// Save merchant account to database\n\t\tconst { error: insertError } = await supabase\n\t\t\t.from(\"payrix_merchant_accounts\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: data.companyId,\n\t\t\t\tpayrix_entity_id: payrixResponse.data?.entityId,\n\t\t\t\tpayrix_merchant_id: payrixResponse.data?.merchantId,\n\t\t\t\tpayrix_member_id: payrixResponse.data?.memberId,\n\t\t\t\tstatus: \"submitted\",\n\t\t\t\tboarding_status: payrixResponse.data?.boardingStatus,\n\t\t\t\tyears_in_business: data.yearsInBusiness,\n\t\t\t\tbusiness_description: data.businessDescription,\n\t\t\t\tbusiness_website: company.website,\n\t\t\t\taverage_ticket_amount: data.averageTicketAmount,\n\t\t\t\thighest_ticket_amount: data.highestTicketAmount,\n\t\t\t\testimated_monthly_volume: data.estimatedMonthlyVolume,\n\t\t\t\testimated_annual_volume: annualVolume,\n\t\t\t\taccepts_credit_cards: data.acceptsCreditCards,\n\t\t\t\taccepts_debit_cards: data.acceptsDebitCards,\n\t\t\t\taccepts_ach: data.acceptsACH,\n\t\t\t\taccepts_recurring: data.acceptsRecurring,\n\t\t\t\towner_full_name: data.ownerFullName,\n\t\t\t\towner_ssn_encrypted: \"***-**-****\", // Store masked version\n\t\t\t\towner_dob: new Date(data.ownerDOB),\n\t\t\t\towner_home_address: data.ownerHomeAddress,\n\t\t\t\towner_city: data.ownerCity,\n\t\t\t\towner_state: data.ownerState,\n\t\t\t\towner_zip: data.ownerZip,\n\t\t\t\towner_ownership_percentage: data.ownerOwnershipPercentage,\n\t\t\t\towner_title: data.ownerTitle,\n\t\t\t\tmcc_code: mccCode,\n\t\t\t\tpayrix_response: payrixResponse.data,\n\t\t\t\tsubmitted_at: new Date().toISOString(),\n\t\t\t});\n\n\t\tif (insertError) {\n\t\t\tconsole.error(\"Failed to save merchant account:\", insertError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to save merchant account to database\",\n\t\t\t};\n\t\t}\n\n\t\trevalidatePath(\"/welcome\");\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmerchantId: payrixResponse.data?.merchantId,\n\t\t\tstatus: payrixResponse.data?.status,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Payrix boarding error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Check Payrix merchant account status\n */\nasync function checkPayrixMerchantStatus(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\t// Get merchant account from database\n\t\tconst { data: merchantAccount, error } = await supabase\n\t\t\t.from(\"payrix_merchant_accounts\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error || !merchantAccount) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Merchant account not found\",\n\t\t\t};\n\t\t}\n\n\t\t// If we have a Payrix merchant ID, check status\n\t\tif (merchantAccount.payrix_merchant_id) {\n\t\t\tconst statusResponse = await getMerchantStatus(\n\t\t\t\tmerchantAccount.payrix_merchant_id,\n\t\t\t);\n\n\t\t\tif (statusResponse.success && statusResponse.data) {\n\t\t\t\t// Update database with latest status\n\t\t\t\tawait supabase\n\t\t\t\t\t.from(\"payrix_merchant_accounts\")\n\t\t\t\t\t.update({\n\t\t\t\t\t\tstatus: statusResponse.data.active ? \"approved\" : \"under_review\",\n\t\t\t\t\t\tboarding_status: statusResponse.data.boardingStatus,\n\t\t\t\t\t\tboarding_substatus: statusResponse.data.boardingSubstatus,\n\t\t\t\t\t\tlast_sync_at: new Date().toISOString(),\n\t\t\t\t\t\tapproved_at: statusResponse.data.active\n\t\t\t\t\t\t\t? new Date().toISOString()\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\t})\n\t\t\t\t\t.eq(\"id\", merchantAccount.id);\n\n\t\t\t\trevalidatePath(\"/welcome\");\n\t\t\t}\n\n\t\t\treturn statusResponse;\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tstatus: merchantAccount.status,\n\t\t\t\tboardingStatus: merchantAccount.boarding_status,\n\t\t\t\tactive: merchantAccount.status === \"approved\",\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Payrix status check error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Get Payrix merchant account for company\n */\nexport async function getPayrixMerchantAccount(companyId: string) {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tconst { data: merchantAccount, error } = await supabase\n\t\t\t.from(\"payrix_merchant_accounts\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.maybeSingle();\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: merchantAccount,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Get merchant account error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error occurred\",\n\t\t};\n\t}\n}\n","/**\n * Payrix API Client\n *\n * Integration with Payrix payment processing for merchant boarding,\n * payment processing, and account management.\n *\n * Documentation: https://resource.payrix.com/\n * API Base: https://api.payrix.com\n */\n\nconst PAYRIX_API_BASE = process.env.PAYRIX_API_URL || \"https://api.payrix.com\";\nconst PAYRIX_API_KEY = process.env.PAYRIX_API_KEY;\nconst PAYRIX_PARTNER_ID = process.env.PAYRIX_PARTNER_ID;\n\ntype PayrixEntity = {\n\ttype: 1 | 2 | 3; // 1 = Individual, 2 = Corporation, 3 = LLC\n\tname: string;\n\tdba?: string;\n\temail: string;\n\tphone: string;\n\taddress1: string;\n\taddress2?: string;\n\tcity: string;\n\tstate: string;\n\tzip: string;\n\tcountry: string;\n\twebsite?: string;\n\tein?: string;\n};\n\ntype PayrixMerchant = {\n\tstatus: 1 | 2 | 3; // 1 = Active, 2 = Inactive, 3 = Suspended\n\tmcc: string; // Merchant Category Code\n\testablished: string; // YYYY-MM-DD\n\tannualVolume: number;\n\taverageTicket: number;\n\thighTicket: number;\n\trefundPolicy?: string;\n};\n\ntype PayrixMember = {\n\tfirstName: string;\n\tlastName: string;\n\ttitle: string;\n\temail: string;\n\tphone: string;\n\tdob: string; // YYYY-MM-DD\n\tssn: string; // Last 4 digits or full (encrypted)\n\townership: number; // Percentage\n\taddress1: string;\n\taddress2?: string;\n\tcity: string;\n\tstate: string;\n\tzip: string;\n\tcountry: string;\n};\n\ntype PayrixAccount = {\n\ttype: 1 | 2; // 1 = Checking, 2 = Savings\n\tnumber: string; // Account number\n\trouting: string; // Routing number\n};\n\ntype PayrixBoardingRequest = {\n\tentity: PayrixEntity;\n\tmerchant: PayrixMerchant;\n\tmembers: PayrixMember[];\n\taccounts: PayrixAccount[];\n};\n\ntype PayrixBoardingResponse = {\n\tsuccess: boolean;\n\tdata?: {\n\t\tentityId: string;\n\t\tmerchantId: string;\n\t\tmemberId: string;\n\t\tstatus: string;\n\t\tboardingStatus: string;\n\t};\n\terror?: string;\n\tdetails?: any;\n};\n\n/**\n * Create headers for Payrix API requests\n */\nfunction getPayrixHeaders(): HeadersInit {\n\tif (!PAYRIX_API_KEY) {\n\t\tthrow new Error(\"Payrix API key not configured\");\n\t}\n\n\treturn {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${PAYRIX_API_KEY}`,\n\t\tAPIKEY: PAYRIX_API_KEY,\n\t};\n}\n\n/**\n * Submit merchant boarding application to Payrix\n *\n * @param request - Merchant boarding data\n * @returns Payrix boarding response\n */\nexport async function submitMerchantBoarding(\n\trequest: PayrixBoardingRequest,\n): Promise<PayrixBoardingResponse> {\n\ttry {\n\t\tconst response = await fetch(`${PAYRIX_API_BASE}/entities`, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: getPayrixHeaders(),\n\t\t\tbody: JSON.stringify({\n\t\t\t\ttype: request.entity.type,\n\t\t\t\tname: request.entity.name,\n\t\t\t\tdba: request.entity.dba,\n\t\t\t\temail: request.entity.email,\n\t\t\t\tphone: request.entity.phone,\n\t\t\t\taddress: {\n\t\t\t\t\tline1: request.entity.address1,\n\t\t\t\t\tline2: request.entity.address2,\n\t\t\t\t\tcity: request.entity.city,\n\t\t\t\t\tstate: request.entity.state,\n\t\t\t\t\tzip: request.entity.zip,\n\t\t\t\t\tcountry: request.entity.country,\n\t\t\t\t},\n\t\t\t\twebsite: request.entity.website,\n\t\t\t\tein: request.entity.ein,\n\t\t\t\tmerchant: {\n\t\t\t\t\tstatus: request.merchant.status,\n\t\t\t\t\tmcc: request.merchant.mcc,\n\t\t\t\t\testablished: request.merchant.established,\n\t\t\t\t\tannualVolume: request.merchant.annualVolume,\n\t\t\t\t\taverageTicket: request.merchant.averageTicket,\n\t\t\t\t\thighTicket: request.merchant.highTicket,\n\t\t\t\t\trefundPolicy: request.merchant.refundPolicy,\n\t\t\t\t},\n\t\t\t\tmembers: request.members.map((member) => ({\n\t\t\t\t\tfirst: member.firstName,\n\t\t\t\t\tlast: member.lastName,\n\t\t\t\t\ttitle: member.title,\n\t\t\t\t\temail: member.email,\n\t\t\t\t\tphone: member.phone,\n\t\t\t\t\tdob: member.dob,\n\t\t\t\t\tssn: member.ssn,\n\t\t\t\t\townership: member.ownership,\n\t\t\t\t\taddress: {\n\t\t\t\t\t\tline1: member.address1,\n\t\t\t\t\t\tline2: member.address2,\n\t\t\t\t\t\tcity: member.city,\n\t\t\t\t\t\tstate: member.state,\n\t\t\t\t\t\tzip: member.zip,\n\t\t\t\t\t\tcountry: member.country,\n\t\t\t\t\t},\n\t\t\t\t})),\n\t\t\t\taccounts: request.accounts.map((account) => ({\n\t\t\t\t\ttype: account.type,\n\t\t\t\t\tnumber: account.number,\n\t\t\t\t\trouting: account.routing,\n\t\t\t\t})),\n\t\t\t}),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorData = await response.json().catch(() => ({}));\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: errorData.message || \"Failed to submit merchant boarding\",\n\t\t\t\tdetails: errorData,\n\t\t\t};\n\t\t}\n\n\t\tconst data = await response.json();\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tentityId: data.response?.data?.[0]?.id,\n\t\t\t\tmerchantId: data.response?.data?.[0]?.merchant?.[0]?.id,\n\t\t\t\tmemberId: data.response?.data?.[0]?.members?.[0]?.id,\n\t\t\t\tstatus: data.response?.data?.[0]?.merchant?.[0]?.status,\n\t\t\t\tboardingStatus: data.response?.data?.[0]?.merchant?.[0]?.boardingStatus,\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Payrix boarding error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Check merchant boarding status\n *\n * @param merchantId - Payrix merchant ID\n * @returns Merchant status information\n */\nexport async function getMerchantStatus(merchantId: string) {\n\ttry {\n\t\tconst response = await fetch(`${PAYRIX_API_BASE}/merchants/${merchantId}`, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: getPayrixHeaders(),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(\"Failed to fetch merchant status\");\n\t\t}\n\n\t\tconst data = await response.json();\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tstatus: data.response?.data?.[0]?.status,\n\t\t\t\tboardingStatus: data.response?.data?.[0]?.boardingStatus,\n\t\t\t\tboardingSubstatus: data.response?.data?.[0]?.boardingSubstatus,\n\t\t\t\tactive: data.response?.data?.[0]?.status === 1,\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Payrix status check error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error occurred\",\n\t\t};\n\t}\n}\n\n/**\n * Get merchant category codes (MCC)\n * Common codes for field service businesses\n */\nexport const MERCHANT_CATEGORY_CODES = {\n\tHVAC: \"1711\", // Heating, Plumbing, A/C\n\tPLUMBING: \"1711\",\n\tELECTRICAL: \"1731\",\n\tPEST_CONTROL: \"7342\",\n\tLOCKSMITH: \"7699\",\n\tAPPLIANCE_REPAIR: \"7623\",\n\tGARAGE_DOOR: \"1799\",\n\tLANDSCAPING: \"0780\",\n\tPOOL_SERVICE: \"7699\",\n\tCLEANING: \"7349\",\n\tROOFING: \"1761\",\n\tCARPENTRY: \"1751\",\n\tPAINTING: \"1721\",\n\tGENERAL_CONTRACTOR: \"1520\",\n} as const;\n\n/**\n * Get MCC code for industry\n */\nexport function getMCCForIndustry(industry: string): string {\n\tconst industryUpper = industry.toUpperCase().replace(/[^A-Z]/g, \"_\");\n\treturn (\n\t\tMERCHANT_CATEGORY_CODES[\n\t\t\tindustryUpper as keyof typeof MERCHANT_CATEGORY_CODES\n\t\t] || MERCHANT_CATEGORY_CODES.GENERAL_CONTRACTOR\n\t);\n}\n","// Re-export from @stratos/auth package for backwards compatibility\nexport * from \"@stratos/auth/session\";\n","/**\n * User Data Utilities - Secure, Cached User Data Retrieval\n *\n * Performance optimizations:\n * - React cache() for request-level memoization\n * - Supabase RLS enforces security at database level\n * - Type-safe with full TypeScript support\n * - Automatic avatar generation if none provided\n */\n\nimport { cache } from \"react\";\nimport { createClient } from \"@stratos/database/server\";\nimport { createServiceSupabaseClient } from \"@stratos/database/service-client\";\nimport { isOnboardingComplete } from \"@stratos/shared/onboarding\";\nimport { getCurrentUser } from \"./session\";\n\nexport type UserStatus = \"online\" | \"available\" | \"busy\";\n\nexport type UserProfile = {\n\tid: string;\n\tfull_name: string;\n\temail: string;\n\tavatar_url: string;\n\tbio?: string;\n\tphone?: string;\n\tstatus?: UserStatus;\n\temailVerified: boolean;\n\tcreatedAt: Date;\n};\n\n/**\n * Get User Profile - Cached and Secure\n *\n * Fetches user data from both Supabase Auth and public.users table\n * Cached per request for optimal performance\n * RLS ensures users can only access their own data\n */\nexport const getUserProfile = cache(async (): Promise<UserProfile | null> => {\n\ttry {\n\t\t// Get authenticated user from Supabase Auth\n\t\tconst user = await getCurrentUser();\n\t\tif (!user) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\t// Return mock user for development\n\t\t\treturn {\n\t\t\t\tid: \"dev-user-1\",\n\t\t\t\tfull_name: \"Development User\",\n\t\t\t\temail: \"dev@example.com\",\n\t\t\t\tavatar_url: \"https://api.dicebear.com/7.x/avataaars/svg?seed=dev\",\n\t\t\t\temailVerified: true,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t};\n\t\t}\n\n\t\t// Fetch user profile from public.users table (with RLS)\n\t\tconst { data: profile, error } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", user.id)\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn getUserProfileFromAuth(user);\n\t\t}\n\n\t\t// Merge auth data with profile data\n\t\treturn {\n\t\t\tid: user.id,\n\t\t\tfull_name:\n\t\t\t\tprofile?.full_name ||\n\t\t\t\tuser.user_metadata?.name ||\n\t\t\t\tuser.email?.split(\"@\")[0] ||\n\t\t\t\t\"User\",\n\t\t\temail: user.email || profile?.email || \"\",\n\t\t\tavatar_url:\n\t\t\t\tprofile?.avatar_url ||\n\t\t\t\tuser.user_metadata?.avatar_url ||\n\t\t\t\tgenerateAvatar(user.email || profile?.email),\n\t\t\tbio: profile?.bio || undefined,\n\t\t\tphone: profile?.phone || undefined,\n\t\t\tstatus: (profile?.status as UserStatus) || \"online\",\n\t\t\temailVerified: !!user.email_confirmed_at,\n\t\t\tcreatedAt: new Date(profile?.created_at || user.created_at),\n\t\t};\n\t} catch (_error) {\n\t\treturn {\n\t\t\tid: \"dev-user-1\",\n\t\t\tfull_name: \"Development User\",\n\t\t\temail: \"dev@example.com\",\n\t\t\tavatar_url: \"https://api.dicebear.com/7.x/avataaars/svg?seed=dev\",\n\t\t\temailVerified: true,\n\t\t\tcreatedAt: new Date(),\n\t\t};\n\t}\n});\n\n/**\n * Get User Profile from Auth Only\n *\n * Fallback when public.users table doesn't have the profile yet\n */\nfunction getUserProfileFromAuth(user: any): UserProfile {\n\treturn {\n\t\tid: user.id,\n\t\tfull_name: user.user_metadata?.name || user.email?.split(\"@\")[0] || \"User\",\n\t\temail: user.email || \"\",\n\t\tavatar_url: user.user_metadata?.avatar_url || generateAvatar(user.email),\n\t\temailVerified: !!user.email_confirmed_at,\n\t\tcreatedAt: new Date(user.created_at),\n\t};\n}\n\n/**\n * Generate Avatar URL\n *\n * Creates a unique avatar based on user email using DiceBear API\n * Falls back to initials if no email provided\n */\nfunction generateAvatar(email?: string | null): string {\n\tif (!email) {\n\t\treturn \"https://api.dicebear.com/7.x/initials/svg?seed=User\";\n\t}\n\n\t// Use email as seed for consistent avatar\n\treturn `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(email)}&backgroundColor=0ea5e9&textColor=ffffff`;\n}\n\n/**\n * Get User Initials\n *\n * Extracts initials from user name for avatar fallback\n */\nfunction getUserInitials(name: string): string {\n\treturn name\n\t\t.split(\" \")\n\t\t.map((n) => n[0])\n\t\t.join(\"\")\n\t\t.toUpperCase()\n\t\t.slice(0, 2);\n}\n\n/**\n * Format User Display Name\n *\n * Returns first name only for compact display\n */\nfunction getUserDisplayName(name: string): string {\n\treturn name.split(\" \")[0] || name;\n}\n\n/**\n * Check if User Email is Verified\n *\n * Security check for features that require verified email\n */\nconst isUserEmailVerified = cache(async (): Promise<boolean> => {\n\tconst user = await getCurrentUser();\n\tif (!user) {\n\t\treturn false;\n\t}\n\n\treturn !!user.email_confirmed_at;\n});\n\n/**\n * Get User Companies\n *\n * Fetches companies the user belongs to\n *\n * SECURITY: Uses service role because:\n * - Query filters to user's own memberships (user_id = authenticated user)\n * - JOIN to companies table causes RLS recursion with anon key\n * - User only sees their own team_members records\n * - Companies table has its own RLS protection\n */\nexport const getUserCompaniesWithStatus = cache(\n\tasync (): Promise<\n\t\tArray<{\n\t\t\tid: string;\n\t\t\tname: string;\n\t\t\tlogo?: string | null;\n\t\t\tplan: string;\n\t\t\tonboardingComplete?: boolean;\n\t\t\thasPayment?: boolean;\n\t\t}>\n\t> => {\n\t\ttry {\n\t\t\tconst user = await getCurrentUser();\n\t\t\tif (!user) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Use service role to bypass RLS recursion on JOIN\n\t\t\t// Query is safe: explicitly filtered to user's own records\n\t\t\tconst supabase = await createServiceSupabaseClient();\n\t\t\tif (!supabase) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Fetch user's companies via team_members join\n\t\t\t// Exclude archived companies (deleted_at IS NULL)\n\t\t\tconst { data: memberships, error } = await supabase\n\t\t\t\t.from(\"company_memberships\")\n\t\t\t\t.select(\n\t\t\t\t\t`\n        company_id,\n        companies!inner (\n          id,\n          name,\n          logo,\n          stripe_subscription_status,\n          onboarding_progress,\n          onboarding_completed_at,\n          deleted_at\n        )\n      `,\n\t\t\t\t)\n\t\t\t\t.eq(\"user_id\", user.id)\n\t\t\t\t.eq(\"status\", \"active\")\n\t\t\t\t.is(\"companies.deleted_at\", null); // Exclude archived companies\n\n\t\t\tif (error) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Map to simplified structure with onboarding status\n\t\t\t// Deduplicate by company ID in case of multiple team_member records\n\t\t\tconst companyMap = new Map<\n\t\t\t\tstring,\n\t\t\t\t{\n\t\t\t\t\tid: string;\n\t\t\t\t\tname: string;\n\t\t\t\t\tlogo?: string | null;\n\t\t\t\t\tplan: string;\n\t\t\t\t\tonboardingComplete: boolean;\n\t\t\t\t\thasPayment: boolean;\n\t\t\t\t}\n\t\t\t>();\n\n\t\t\tmemberships?.forEach((m: any) => {\n\t\t\t\tconst companyId = m.companies.id;\n\t\t\t\tif (!companyMap.has(companyId)) {\n\t\t\t\t\tconst subscriptionStatus = m.companies.stripe_subscription_status;\n\t\t\t\t\tconst onboardingProgress =\n\t\t\t\t\t\t(m.companies.onboarding_progress as Record<string, unknown>) ||\n\t\t\t\t\t\tnull;\n\t\t\t\t\tconst onboardingComplete = isOnboardingComplete({\n\t\t\t\t\t\tprogress: onboardingProgress,\n\t\t\t\t\t\tcompletedAt: m.companies.onboarding_completed_at ?? null,\n\t\t\t\t\t});\n\t\t\t\t\tconst hasPayment =\n\t\t\t\t\t\tsubscriptionStatus === \"active\" ||\n\t\t\t\t\t\tsubscriptionStatus === \"trialing\";\n\n\t\t\t\t\tlet planLabel = \"Active\";\n\t\t\t\t\tif (!(hasPayment && onboardingComplete)) {\n\t\t\t\t\t\tplanLabel =\n\t\t\t\t\t\t\tsubscriptionStatus === \"incomplete\"\n\t\t\t\t\t\t\t\t? \"Incomplete Onboarding\"\n\t\t\t\t\t\t\t\t: \"Setup Required\";\n\t\t\t\t\t}\n\n\t\t\t\t\tcompanyMap.set(companyId, {\n\t\t\t\t\t\tid: companyId,\n\t\t\t\t\t\tname: m.companies.name,\n\t\t\t\t\t\tlogo: m.companies.logo,\n\t\t\t\t\t\tplan: planLabel,\n\t\t\t\t\t\tonboardingComplete,\n\t\t\t\t\t\thasPayment,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn Array.from(companyMap.values());\n\t\t} catch (_error) {\n\t\t\treturn [];\n\t\t}\n\t},\n);\n\n/**\n * Get User Company ID\n *\n * Gets the primary company ID for the current user\n * Returns null if user is not part of any company\n * Cached per request for optimal performance\n */\nexport const getUserCompanyId = cache(async (): Promise<string | null> => {\n\ttry {\n\t\tconst user = await getCurrentUser();\n\t\tif (!user) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Get first active company membership\n\t\tconst { data: membership, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn membership?.company_id || null;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n});\n\n/**\n * Update User Profile\n *\n * Securely updates user profile data\n * RLS ensures users can only update their own profile\n */\nasync function updateUserProfile(\n\tupdates: Partial<{\n\t\tfull_name: string;\n\t\tbio: string;\n\t\tphone: string;\n\t\tavatar_url: string;\n\t}>,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst user = await getCurrentUser();\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service not available\" };\n\t\t}\n\n\t\t// Update profiles table (RLS enforced)\n\t\tconst { error } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.update({\n\t\t\t\t...updates,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", user.id);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// If updating full_name or avatar_url, also update auth metadata\n\t\tif (updates.full_name || updates.avatar_url) {\n\t\t\tconst { error: authError } = await supabase.auth.updateUser({\n\t\t\t\tdata: {\n\t\t\t\t\tname: updates.full_name,\n\t\t\t\t\tavatar_url: updates.avatar_url,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (authError) {\n\t\t\t\t// Don't fail the whole operation if auth update fails\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Update failed\",\n\t\t};\n\t}\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AppHeaderClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call AppHeaderClient() from the server but AppHeaderClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/components/layout/app-header-client.tsx\",\n    \"AppHeaderClient\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AppHeaderErrorBoundary = registerClientReference(\n    function() { throw new Error(\"Attempted to call AppHeaderErrorBoundary() from the server but AppHeaderErrorBoundary is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/components/layout/app-header-error-boundary.tsx\",\n    \"AppHeaderErrorBoundary\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const IncomingCallNotificationWrapper = registerClientReference(\n    function() { throw new Error(\"Attempted to call IncomingCallNotificationWrapper() from the server but IncomingCallNotificationWrapper is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/components/layout/incoming-call-notification-wrapper.tsx\",\n    \"IncomingCallNotificationWrapper\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const MobileBottomTabsWrapper = registerClientReference(\n    function() { throw new Error(\"Attempted to call MobileBottomTabsWrapper() from the server but MobileBottomTabsWrapper is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/components/layout/mobile-bottom-tabs-wrapper.tsx\",\n    \"MobileBottomTabsWrapper\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const NotificationsInitializer = registerClientReference(\n    function() { throw new Error(\"Attempted to call NotificationsInitializer() from the server but NotificationsInitializer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/components/layout/notifications-initializer.tsx\",\n    \"NotificationsInitializer\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const SupportSessionProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call SupportSessionProvider() from the server but SupportSessionProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/components/support/support-session-provider.tsx\",\n    \"SupportSessionProvider\",\n);\n","import { Suspense } from \"react\";\nimport { AppHeader } from \"@/components/layout/app-header\";\nimport { AppHeaderErrorBoundary } from \"@/components/layout/app-header-error-boundary\";\nimport { DashboardAuthWrapper } from \"@/components/layout/dashboard-auth-wrapper\";\nimport { IncomingCallNotificationWrapper } from \"@/components/layout/incoming-call-notification-wrapper\";\nimport { MobileBottomTabsWrapper } from \"@/components/layout/mobile-bottom-tabs-wrapper\";\nimport { NotificationsInitializer } from \"@/components/layout/notifications-initializer\";\nimport { SupportSessionProvider } from \"@/components/support/support-session-provider\";\n\n/**\n * Dashboard Layout - Server Component with PPR\n *\n * Uses Partial Prerendering (PPR) to optimize performance:\n * - Static shell (header) renders instantly (5-20ms)\n * - Auth checks happen in the background (non-blocking)\n * - Content streams in progressively\n *\n * The AppHeader is rendered immediately (static).\n * Auth checks happen via DashboardAuthWrapper but don't block rendering.\n *\n * Performance: Instant header, progressive content loading\n */\nexport default function DashboardLayout({\n\tchildren,\n}: Readonly<{\n\tchildren: React.ReactNode;\n}>) {\n\treturn (\n\t\t<div data-dashboard-layout className=\"flex h-full flex-col overflow-hidden\">\n\t\t\t{/* Header with company context - wrapped in error boundary and Suspense for PPR */}\n\t\t\t<AppHeaderErrorBoundary>\n\t\t\t\t<Suspense fallback={<HeaderSkeleton />}>\n\t\t\t\t\t<AppHeader />\n\t\t\t\t</Suspense>\n\t\t\t</AppHeaderErrorBoundary>\n\n\t\t\t{/* Desktop + toast notifications bootstrap */}\n\t\t\t<NotificationsInitializer />\n\n\t\t\t{/* Incoming call notifications */}\n\t\t\t<IncomingCallNotificationWrapper />\n\n\t\t\t{/* Auth wrapper handles redirects but doesn't block rendering */}\n\t\t\t<Suspense fallback={null}>\n\t\t\t\t<DashboardAuthWrapper />\n\t\t\t</Suspense>\n\n\t\t\t{/* Page content - each page has its own Suspense boundaries */}\n\t\t\t{/* Support session provider polls for pending/active sessions and displays approval modal + banner */}\n\t\t\t<SupportSessionProvider>\n\t\t\t\t<main id=\"main-content\" className=\"flex-1 flex flex-col overflow-y-auto pb-16 lg:pb-0\">\n\t\t\t\t\t{children}\n\t\t\t\t</main>\n\t\t\t</SupportSessionProvider>\n\n\t\t\t{/* Mobile Bottom Tab Bar - Native iOS/Android style navigation */}\n\t\t\t<MobileBottomTabsWrapper />\n\t\t</div>\n\t);\n}\n\n// Header skeleton - renders instantly while header loads\nfunction HeaderSkeleton() {\n\treturn (\n\t\t<header className=\"border-border/40 bg-background/95 supports-[backdrop-filter]:bg-background/60 sticky top-0 z-50 w-full border-b backdrop-blur\">\n\t\t\t<div className=\"flex h-14 items-center px-4\">\n\t\t\t\t<div className=\"flex flex-1 items-center gap-4\">\n\t\t\t\t\t{/* Logo skeleton */}\n\t\t\t\t\t<div className=\"bg-muted h-8 w-32 animate-pulse rounded\" />\n\n\t\t\t\t\t{/* Nav skeleton */}\n\t\t\t\t\t<div className=\"hidden md:flex md:gap-2\">\n\t\t\t\t\t\t<div className=\"bg-muted h-8 w-20 animate-pulse rounded\" />\n\t\t\t\t\t\t<div className=\"bg-muted h-8 w-20 animate-pulse rounded\" />\n\t\t\t\t\t\t<div className=\"bg-muted h-8 w-20 animate-pulse rounded\" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Right side skeleton */}\n\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t<div className=\"bg-muted size-8 animate-pulse rounded-full\" />\n\t\t\t\t\t<div className=\"bg-muted size-8 animate-pulse rounded-full\" />\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</header>\n\t);\n}\n","import { getPayrixMerchantAccount } from \"@/actions/payrix\";\nimport { getCompanyPhoneNumbers } from \"@/actions/telnyx\";\nimport { getActiveCompanyId, getUserCompanies } from \"@/lib/auth/company-context\";\nimport { getUserProfile } from \"@/lib/auth/user-data\";\nimport { getUnifiedLayoutConfig } from \"@/lib/layout/unified-layout-config\";\nimport { headers } from \"next/headers\";\nimport { AppHeaderClient } from \"./app-header-client\";\n\n/**\n * AppHeader - Server Component\n *\n * Performance optimizations:\n * - Server Component fetches user data BEFORE rendering (eliminates loading flash)\n * - Uses cached getUserProfile() and getUserCompanies() with RLS security\n * - Uses LIGHTWEIGHT getCustomersForDialer() instead of getAllCustomers()\n *   (50-100ms vs 1200-2000ms - eliminates N+1 query pattern)\n * - Fetches company phones for dialer functionality\n * - Passes data to minimal client component for interactivity only\n * - Better SEO and initial page load performance\n *\n * Why Server Component?\n * - Dashboard is always protected (user always logged in via middleware)\n * - No need for client-side loading states or auth checks\n * - Faster initial render with server-fetched data\n * - Smaller JavaScript bundle (auth logic stays on server)\n *\n * Conditional Rendering:\n * - Dashboard layout decides when to render the header (e.g. hides on TV/welcome routes)\n */\n\nexport async function AppHeader() {\n\t// For now, always pass null - the client component will handle sub-header detection\n\tconst subHeaderComponent = null;\n\n\t// Fetch user profile and companies on server (cached with React cache())\n\t// This runs on server BEFORE sending HTML to client\n\t// Handle prerender cookie access gracefully\n\tlet userProfile;\n\tlet companies;\n\tlet activeCompanyId;\n\n\ttry {\n\t\t[userProfile, companies, activeCompanyId] = await Promise.all([\n\t\t\tgetUserProfile(),\n\t\t\tgetUserCompanies(),\n\t\t\tgetActiveCompanyId(),\n\t\t]);\n\t} catch (error) {\n\t\t// During prerendering, cookies() may reject - this is expected\n\t\t// Return null and let the client-side handle it\n\t\tif (error instanceof Error && error.message.includes(\"prerendering\")) {\n\t\t\treturn null;\n\t\t}\n\t\t// Log error for monitoring but don't expose details to user\n\t\tconsole.error(\"AppHeader: Failed to fetch user data\", error);\n\t\tthrow error; // Let error boundary handle it\n\t}\n\n\t// If no user, this should never happen because dashboard is protected by middleware\n\t// But we handle it gracefully anyway\n\tif (!userProfile) {\n\t\treturn null; // Middleware will redirect to login\n\t}\n\n\t// Fetch ONLY company phone numbers on server\n\t// PERFORMANCE: Customer data is lazy-loaded on client when dialer opens\n\t// This saves 400-800ms per page load by not fetching ALL customers upfront\n\tlet companyPhones: any[] = [];\n\tlet hasPhoneNumbers = false;\n\tlet hasPayrixAccount = false;\n\tlet payrixStatus: string | null = null;\n\n\tif (activeCompanyId) {\n\t\ttry {\n\t\t\tconst [phonesResult, payrixResult] = await Promise.all([\n\t\t\t\tgetCompanyPhoneNumbers(activeCompanyId),\n\t\t\t\tgetPayrixMerchantAccount(activeCompanyId),\n\t\t\t]);\n\n\t\t\tif (phonesResult.success && phonesResult.data) {\n\t\t\t\tcompanyPhones = phonesResult.data.map((p) => ({\n\t\t\t\t\tid: p.id,\n\t\t\t\t\tnumber: p.phone_number,\n\t\t\t\t\tlabel: p.formatted_number || p.phone_number,\n\t\t\t\t}));\n\t\t\t\thasPhoneNumbers = phonesResult.data.length > 0;\n\t\t\t}\n\n\t\t\tif (payrixResult.success && payrixResult.data) {\n\t\t\t\thasPayrixAccount = true;\n\t\t\t\tpayrixStatus = payrixResult.data.status;\n\t\t\t}\n\t\t} catch (_error) {\n\t\t\t// Continue without phone/payrix data - component will handle empty array\n\t\t}\n\t}\n\n\t// Pass server-fetched data to client component for interactivity\n\t// Customers will be lazy-loaded on client side when dialer is opened\n\treturn (\n\t\t<AppHeaderClient\n\t\t\tactiveCompanyId={activeCompanyId}\n\t\t\tcompanies={companies}\n\t\t\tcompanyPhones={companyPhones}\n\t\t\tuserProfile={userProfile}\n\t\t\thasPhoneNumbers={hasPhoneNumbers}\n\t\t\thasPayrixAccount={hasPayrixAccount}\n\t\t\tpayrixStatus={payrixStatus}\n\t\t\tsubHeader={subHeaderComponent}\n\t\t/>\n\t);\n}\n","import { redirect } from \"next/navigation\";\nimport { getCurrentUser } from \"@/lib/auth/session\";\n\n/**\n * Dashboard Auth Wrapper - Async Server Component\n *\n * Handles authentication checks WITHOUT blocking rendering.\n * This component is wrapped in Suspense with fallback={null} so it doesn't\n * show a loading screen - it just performs auth checks in the background.\n *\n * NOTE: Onboarding redirects temporarily disabled.\n * The welcome/onboarding page is at /dashboard/welcome\n *\n * This component renders nothing - it only performs checks and redirects.\n */\nexport async function DashboardAuthWrapper() {\n\t// Check authentication - redirect to login if not authenticated\n\tconst user = await getCurrentUser();\n\n\tif (!user) {\n\t\tredirect(\"/login?message=Please log in to access the dashboard\");\n\t}\n\n\t// NOTE: Onboarding redirect logic temporarily disabled\n\t// Users can access any dashboard page regardless of onboarding status\n\t// The welcome/onboarding page is available at /dashboard/welcome\n\n\t// This component renders nothing - it only performs auth checks and redirects\n\treturn null;\n}\n"],"names":[],"mappings":"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","ignoreList":[4,5,6,7,8,9]}