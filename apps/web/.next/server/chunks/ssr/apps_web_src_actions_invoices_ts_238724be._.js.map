{"version":3,"sources":["../../../../../../apps/web/src/actions/invoices.ts"],"sourcesContent":["/**\n * Invoices Server Actions\n *\n * Handles invoice management with CRUD operations, payment tracking,\n * customer interactions, and payment status management.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\tassertSupabase,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { sendInvoiceEmail } from \"./invoice-communications\";\n\n// Invoice number pattern for parsing\nconst INVOICE_NUMBER_PATTERN = /INV-\\d{4}-(\\d+)/;\n\n// Validation Schemas\nconst lineItemSchema = z.object({\n\tdescription: z.string().min(1, \"Description is required\"),\n\tquantity: z.number().min(0.01, \"Quantity must be greater than 0\"),\n\tunitPrice: z.number().min(0, \"Price must be positive\"),\n\ttotal: z.number().min(0, \"Total must be positive\"),\n});\n\nconst createInvoiceSchema = z.object({\n\tcustomerId: z.string().uuid(\"Invalid customer ID\"),\n\tjobId: z.string().uuid(\"Invalid job ID\").optional(),\n\ttitle: z.string().min(1, \"Invoice title is required\"),\n\tdescription: z.string().optional(),\n\tlineItems: z\n\t\t.array(lineItemSchema)\n\t\t.min(1, \"At least one line item is required\"),\n\ttaxRate: z.number().min(0).max(100).default(0),\n\tdiscountAmount: z.number().min(0).default(0),\n\tdueDays: z.number().min(0).default(30),\n\tterms: z.string().optional(),\n\tnotes: z.string().optional(),\n});\n\nconst updateInvoiceSchema = z.object({\n\ttitle: z.string().min(1, \"Invoice title is required\").optional(),\n\tdescription: z.string().optional(),\n\tlineItems: z.array(lineItemSchema).optional(),\n\ttaxRate: z.number().min(0).max(100).optional(),\n\tdiscountAmount: z.number().min(0).optional(),\n\tdueDays: z.number().min(0).optional(),\n\tterms: z.string().optional(),\n\tnotes: z.string().optional(),\n});\n\nconst recordPaymentSchema = z.object({\n\tamount: z.number().min(0.01, \"Payment amount must be greater than 0\"),\n\tmethod: z.enum([\"cash\", \"check\", \"card\", \"bank_transfer\", \"other\"]),\n\treference: z.string().optional(),\n\tnotes: z.string().optional(),\n});\n\n/**\n * Generate unique invoice number\n */\nasync function generateInvoiceNumber(\n\tsupabase: any,\n\tcompanyId: string,\n): Promise<string> {\n\tconst { data: latestInvoice } = await supabase\n\t\t.from(\"invoices\")\n\t\t.select(\"invoice_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestInvoice) {\n\t\treturn `INV-${new Date().getFullYear()}-001`;\n\t}\n\n\tconst match = latestInvoice.invoice_number.match(INVOICE_NUMBER_PATTERN);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `INV-${new Date().getFullYear()}-${nextNumber.toString().padStart(3, \"0\")}`;\n\t}\n\n\treturn `INV-${new Date().getFullYear()}-${Date.now().toString().slice(-3)}`;\n}\n\n/**\n * Calculate invoice totals\n */\nfunction calculateTotals(\n\tlineItems: any[],\n\ttaxRate: number,\n\tdiscountAmount: number,\n) {\n\tconst subtotal = lineItems.reduce((sum, item) => sum + item.total, 0);\n\tconst taxAmount = Math.round((subtotal * taxRate) / 100);\n\tconst totalAmount = subtotal + taxAmount - discountAmount;\n\n\treturn {\n\t\tsubtotal: Math.round(subtotal * 100), // Convert to cents\n\t\ttaxAmount: Math.round(taxAmount * 100),\n\t\tdiscountAmount: Math.round(discountAmount * 100),\n\t\ttotalAmount: Math.round(totalAmount * 100),\n\t};\n}\n\n/**\n * Create a new invoice\n */\nasync function createInvoice(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Parse line items from JSON\n\t\tconst lineItemsJson = formData.get(\"lineItems\") as string;\n\t\tconst lineItems = lineItemsJson ? JSON.parse(lineItemsJson) : [];\n\n\t\tconst data = createInvoiceSchema.parse({\n\t\t\tcustomerId: formData.get(\"customerId\"),\n\t\t\tjobId: formData.get(\"jobId\") || undefined,\n\t\t\ttitle: formData.get(\"title\"),\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tlineItems,\n\t\t\ttaxRate: formData.get(\"taxRate\")\n\t\t\t\t? Number.parseFloat(formData.get(\"taxRate\") as string)\n\t\t\t\t: 0,\n\t\t\tdiscountAmount: formData.get(\"discountAmount\")\n\t\t\t\t? Number.parseFloat(formData.get(\"discountAmount\") as string)\n\t\t\t\t: 0,\n\t\t\tdueDays: formData.get(\"dueDays\")\n\t\t\t\t? Number.parseInt(formData.get(\"dueDays\") as string, 10)\n\t\t\t\t: 30,\n\t\t\tterms: formData.get(\"terms\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t});\n\n\t\t// Calculate totals\n\t\tconst totals = calculateTotals(\n\t\t\tdata.lineItems,\n\t\t\tdata.taxRate,\n\t\t\tdata.discountAmount,\n\t\t);\n\n\t\t// Calculate due date\n\t\tconst dueDate = new Date();\n\t\tdueDate.setDate(dueDate.getDate() + data.dueDays);\n\n\t\t// Generate invoice number\n\t\tconst invoiceNumber = await generateInvoiceNumber(\n\t\t\tsupabase,\n\t\t\tteamMember.company_id,\n\t\t);\n\n\t\t// Create invoice\n\t\tconst { data: newInvoice, error: createError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: teamMember.company_id,\n\t\t\t\tcustomer_id: data.customerId,\n\t\t\t\tjob_id: data.jobId,\n\t\t\t\tinvoice_number: invoiceNumber,\n\t\t\t\ttitle: data.title,\n\t\t\t\tdescription: data.description,\n\t\t\t\tstatus: \"draft\",\n\t\t\t\tsubtotal: totals.subtotal,\n\t\t\t\ttax_amount: totals.taxAmount,\n\t\t\t\tdiscount_amount: totals.discountAmount,\n\t\t\t\ttotal_amount: totals.totalAmount,\n\t\t\t\tpaid_amount: 0,\n\t\t\t\tbalance_amount: totals.totalAmount,\n\t\t\t\tdue_date: dueDate.toISOString(),\n\t\t\t\tline_items: data.lineItems,\n\t\t\t\tterms: data.terms,\n\t\t\t\tnotes: data.notes,\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create invoice\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(\"/dashboard/finance/invoices\");\n\t\treturn newInvoice.id;\n\t});\n}\n\n/**\n * Update an invoice\n */\nasync function updateInvoice(\n\tinvoiceId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice belongs to company\n\t\tconst { data: existingInvoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(existingInvoice, \"Invoice\");\n\n\t\tif (existingInvoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Only draft invoices can be edited\n\t\tif (existingInvoice.status !== \"draft\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only draft invoices can be edited\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Parse line items if provided\n\t\tconst lineItemsJson = formData.get(\"lineItems\") as string;\n\t\tconst lineItems = lineItemsJson ? JSON.parse(lineItemsJson) : undefined;\n\n\t\tconst data = updateInvoiceSchema.parse({\n\t\t\ttitle: formData.get(\"title\") || undefined,\n\t\t\tdescription: formData.get(\"description\") || undefined,\n\t\t\tlineItems,\n\t\t\ttaxRate: formData.get(\"taxRate\")\n\t\t\t\t? Number.parseFloat(formData.get(\"taxRate\") as string)\n\t\t\t\t: undefined,\n\t\t\tdiscountAmount: formData.get(\"discountAmount\")\n\t\t\t\t? Number.parseFloat(formData.get(\"discountAmount\") as string)\n\t\t\t\t: undefined,\n\t\t\tdueDays: formData.get(\"dueDays\")\n\t\t\t\t? Number.parseInt(formData.get(\"dueDays\") as string, 10)\n\t\t\t\t: undefined,\n\t\t\tterms: formData.get(\"terms\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t});\n\n\t\t// Prepare update data\n\t\tconst updateData: any = {};\n\t\tif (data.title) {\n\t\t\tupdateData.title = data.title;\n\t\t}\n\t\tif (data.description !== undefined) {\n\t\t\tupdateData.description = data.description;\n\t\t}\n\t\tif (data.terms !== undefined) {\n\t\t\tupdateData.terms = data.terms;\n\t\t}\n\t\tif (data.notes !== undefined) {\n\t\t\tupdateData.notes = data.notes;\n\t\t}\n\n\t\t// Recalculate totals if line items changed\n\t\tif (data.lineItems) {\n\t\t\tconst taxRate = data.taxRate ?? 0;\n\t\t\tconst discountAmount = data.discountAmount ?? 0;\n\t\t\tconst totals = calculateTotals(data.lineItems, taxRate, discountAmount);\n\n\t\t\tupdateData.line_items = data.lineItems;\n\t\t\tupdateData.subtotal = totals.subtotal;\n\t\t\tupdateData.tax_amount = totals.taxAmount;\n\t\t\tupdateData.discount_amount = totals.discountAmount;\n\t\t\tupdateData.total_amount = totals.totalAmount;\n\t\t\tupdateData.balance_amount = totals.totalAmount; // Reset balance on edit\n\t\t}\n\n\t\t// Update due date if dueDays changed\n\t\tif (data.dueDays !== undefined) {\n\t\t\tconst dueDate = new Date();\n\t\t\tdueDate.setDate(dueDate.getDate() + data.dueDays);\n\t\t\tupdateData.due_date = dueDate.toISOString();\n\t\t}\n\n\t\t// Update invoice\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update invoice\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t});\n}\n\n/**\n * Send invoice to customer\n */\nasync function sendInvoice(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice belongs to company\n\t\tconst { data: existingInvoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, status, customer_id\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(existingInvoice, \"Invoice\");\n\n\t\tif (existingInvoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Can only send draft invoices\n\t\tif (existingInvoice.status !== \"draft\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invoice has already been sent\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Send email to customer with invoice PDF\n\t\tconst emailResult = await sendInvoiceEmail(invoiceId);\n\t\tif (!emailResult.success) {\n\t\t\tconsole.error(\"Failed to send invoice email:\", emailResult.error);\n\t\t\t// Continue with status update even if email fails - don't block the workflow\n\t\t}\n\n\t\t// Update status to sent\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tstatus: \"sent\",\n\t\t\t\tsent_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"send invoice\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t});\n}\n\n/**\n * Mark invoice as viewed (customer opened it)\n */\nasync function markInvoiceViewed(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// This can be called publicly by customer, so no auth check\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"status, viewed_at\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\t// Only mark as viewed if sent and not already viewed\n\t\tif (invoice.status === \"sent\" && !invoice.viewed_at) {\n\t\t\tconst { error: updateError } = await supabase\n\t\t\t\t.from(\"invoices\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"viewed\",\n\t\t\t\t\tviewed_at: new Date().toISOString(),\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", invoiceId);\n\n\t\t\tif (updateError) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\tERROR_MESSAGES.operationFailed(\"mark invoice as viewed\"),\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t});\n}\n\n/**\n * Record a payment for an invoice\n */\nasync function recordPayment(\n\tinvoiceId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tconst data = recordPaymentSchema.parse({\n\t\t\tamount: formData.get(\"amount\")\n\t\t\t\t? Number.parseFloat(formData.get(\"amount\") as string)\n\t\t\t\t: 0,\n\t\t\tmethod: formData.get(\"method\"),\n\t\t\treference: formData.get(\"reference\") || undefined,\n\t\t\tnotes: formData.get(\"notes\") || undefined,\n\t\t});\n\n\t\t// Get invoice\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, customer_id, total_amount, paid_amount, balance_amount, status\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot record payment on cancelled invoices\n\t\tif (invoice.status === \"cancelled\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot record payment on cancelled invoices\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Convert payment amount to cents\n\t\tconst paymentAmountCents = Math.round(data.amount * 100);\n\n\t\t// Validate payment amount\n\t\tif (paymentAmountCents > invoice.balance_amount) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Payment amount exceeds remaining balance\",\n\t\t\t\tERROR_CODES.PAYMENT_INVALID_AMOUNT,\n\t\t\t);\n\t\t}\n\n\t\t// Calculate new amounts\n\t\tconst newPaidAmount = invoice.paid_amount + paymentAmountCents;\n\t\tconst newBalanceAmount = invoice.total_amount - newPaidAmount;\n\n\t\t// Determine new status\n\t\tlet newStatus = invoice.status;\n\t\tif (newBalanceAmount === 0) {\n\t\t\tnewStatus = \"paid\";\n\t\t} else if (newPaidAmount > 0 && newBalanceAmount > 0) {\n\t\t\tnewStatus = \"partial\";\n\t\t}\n\n\t\t// Update invoice\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tpaid_amount: newPaidAmount,\n\t\t\t\tbalance_amount: newBalanceAmount,\n\t\t\t\tstatus: newStatus,\n\t\t\t\tpaid_at: newBalanceAmount === 0 ? new Date().toISOString() : null,\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"record payment\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Create payment record in payments table\n\t\tconst paymentNumber = `PAY-${Date.now().toString(36).toUpperCase()}`;\n\t\tconst { error: paymentError } = await supabase.from(\"payments\").insert({\n\t\t\tcompany_id: invoice.company_id,\n\t\t\tcustomer_id: invoice.customer_id,\n\t\t\tinvoice_id: invoiceId,\n\t\t\tpayment_number: paymentNumber,\n\t\t\tamount: paymentAmountCents,\n\t\t\tpayment_method: data.method,\n\t\t\tpayment_type: \"invoice_payment\",\n\t\t\treference_number: data.reference || null,\n\t\t\tnotes: data.notes || null,\n\t\t\tstatus: \"completed\",\n\t\t\tprocessed_by: user?.id,\n\t\t\tprocessed_at: new Date().toISOString(),\n\t\t\tcompleted_at: new Date().toISOString(),\n\t\t\treceipt_emailed: false,\n\t\t\tis_reconciled: false,\n\t\t});\n\n\t\tif (paymentError) {\n\t\t\t// Log error but don't fail the whole operation - invoice is already updated\n\t\t\tconsole.error(\"Failed to create payment record:\", paymentError);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t\trevalidatePath(\"/dashboard/finance\");\n\t});\n}\n\n/**\n * Mark invoice as overdue (automated or manual)\n */\nasync function markInvoiceOverdue(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get invoice\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, status, due_date, balance_amount\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Only sent, viewed, or partial invoices can be marked overdue\n\t\tif (![\"sent\", \"viewed\", \"partial\"].includes(invoice.status)) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invoice cannot be marked as overdue\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice is actually overdue\n\t\tconst dueDate = new Date(invoice.due_date);\n\t\tif (dueDate > new Date()) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invoice is not yet due\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Update status to overdue\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({ status: \"overdue\" })\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"mark invoice as overdue\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t});\n}\n\n/**\n * Cancel invoice\n */\nasync function cancelInvoice(\n\tinvoiceId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get invoice\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, status, paid_amount, notes\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel paid invoices\n\t\tif (invoice.status === \"paid\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot cancel paid invoices. Please issue a refund instead\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot cancel if partially paid without explicit reason\n\t\tif (invoice.paid_amount > 0 && !reason) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cancellation reason is required for partially paid invoices\",\n\t\t\t\tERROR_CODES.VALIDATION_REQUIRED_FIELD,\n\t\t\t);\n\t\t}\n\n\t\t// Add cancellation reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${invoice.notes || \"\"}\\n\\n[CANCELLED]: ${reason}`.trim()\n\t\t\t: invoice.notes;\n\n\t\t// Cancel invoice\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tstatus: \"cancelled\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"cancel invoice\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t});\n}\n\n/**\n * Archive invoice (soft delete)\n *\n * Replaces deleteInvoice - now archives instead of permanently deleting.\n * Archived invoices can be restored within 90 days.\n */\nexport async function archiveInvoice(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID using the helper function\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice belongs to company\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive paid invoices (business rule)\n\t\tif (invoice.status === \"paid\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"This invoice has been paid and cannot be archived. Paid invoices must be kept for tax and legal compliance.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive invoice (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + 90 * 24 * 60 * 60 * 1000,\n\t\t).toISOString(); // 90 days from now\n\n\t\tconst { error: archiveError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: now,\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tarchived_at: now,\n\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\t// Note: Keep the current status, use archived_at to indicate archived state\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (archiveError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive invoice\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived invoice\n *\n * Restores an archived invoice back to its previous status (draft/sent/viewed/etc.)\n */\nasync function restoreInvoice(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\t// Get active company ID using the helper function\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice belongs to company and is archived\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\tif (!invoice.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invoice is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore invoice\n\t\tconst { error: restoreError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: null,\n\t\t\t\tdeleted_by: null,\n\t\t\t\tarchived_at: null,\n\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\tstatus: invoice.status === \"archived\" ? \"draft\" : invoice.status, // Restore to draft if was archived\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (restoreError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore invoice\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Delete invoice (legacy - deprecated, use archiveInvoice instead)\n * @deprecated Use archiveInvoice() instead\n */\nasync function deleteInvoice(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\t// Redirect to archive function\n\treturn archiveInvoice(invoiceId);\n}\n\n/**\n * Update Invoice Content (TipTap JSON)\n *\n * Saves the TipTap editor content for the invoice\n */\nasync function updateInvoiceContent(\n\tinvoiceId: string,\n\tcontent: any,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice belongs to company\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Update invoice content\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({\n\t\t\t\tpage_content: content,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update invoice content\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t});\n}\n\n/**\n * Get Invoice Payments\n *\n * Fetches all payments applied to an invoice via the invoice_payments junction table\n */\nasync function getInvoicePayments(\n\tinvoiceId: string,\n): Promise<ActionResult<any[]>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Verify invoice belongs to company\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Fetch payments via junction table\n\t\tconst { data: invoicePayments, error: paymentsError } = await supabase\n\t\t\t.from(\"invoice_payments\")\n\t\t\t.select(\n\t\t\t\t`\n        id,\n        amount_applied,\n        applied_at,\n        notes,\n        payment:payments!payment_id (\n          id,\n          payment_number,\n          amount,\n          payment_method,\n          payment_type,\n          status,\n          card_brand,\n          card_last4,\n          check_number,\n          reference_number,\n          processor_name,\n          receipt_url,\n          receipt_number,\n          refunded_amount,\n          refund_reason,\n          processed_at,\n          completed_at,\n          notes,\n          customer:customers!customer_id (\n            id,\n            display_name,\n            first_name,\n            last_name,\n            email\n          )\n        )\n      `,\n\t\t\t)\n\t\t\t.eq(\"invoice_id\", invoiceId)\n\t\t\t.order(\"applied_at\", { ascending: false });\n\n\t\tif (paymentsError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"fetch invoice payments\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\treturn invoicePayments || [];\n\t});\n}\n\n/**\n * Generate Invoice PDF\n *\n * Generates a PDF from the invoice TipTap content\n * Returns a URL to the generated PDF\n */\nasync function generateInvoicePDF(\n\tinvoiceId: string,\n): Promise<ActionResult<{ pdfUrl: string; invoice: any }>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst { data: teamMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"company_id\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!teamMember?.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"You must be part of a company\",\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// Get full invoice data with relations\n\t\tconst { data: invoice } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        customer:customers!customer_id(\n          id,\n          first_name,\n          last_name,\n          email,\n          phone,\n          billing_address,\n          billing_city,\n          billing_state,\n          billing_zip\n        ),\n        company:companies!company_id(\n          id,\n          name,\n          email,\n          phone,\n          website,\n          tax_id\n        )\n      `,\n\t\t\t)\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tassertExists(invoice, \"Invoice\");\n\n\t\tif (invoice.company_id !== teamMember.company_id) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"invoice\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\t403,\n\t\t\t);\n\t\t}\n\n\t\t// TODO: Generate PDF using @react-pdf/renderer\n\t\t// This would convert the page_content JSON to PDF\n\t\t// For now, return a placeholder\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tpdfUrl: `/api/invoices/${invoiceId}/pdf`,\n\t\t\tinvoice,\n\t\t};\n\t});\n}\n\n/**\n * Unlink invoice from job\n * Removes the job association (sets job_id to NULL)\n * Bidirectional operation - updates both invoice and job views\n */\nexport async function unlinkInvoiceFromJob(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tassertSupabase(supabase);\n\n\t\t// Get current invoice to verify exists and get job_id for revalidation\n\t\tconst { data: invoice, error: fetchError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tif (fetchError || !invoice) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Invoice not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tconst previousJobId = invoice.job_id;\n\n\t\t// Unlink invoice from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", invoiceId);\n\n\t\tif (unlinkError) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to unlink invoice from job\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate both pages\n\t\trevalidatePath(`/dashboard/work/invoices/${invoiceId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/invoices\");\n\t});\n}\n\n/**\n * Unlink job from invoice (convenience wrapper)\n *\n * This is a convenience function that calls unlinkInvoiceFromJob.\n * Provided for clearer naming when calling from the invoice detail page.\n * The implementation is the same - it removes the job_id from the invoice.\n *\n * @param invoiceId - ID of the invoice to unlink from its job\n * @returns Promise<ActionResult<void>>\n */\nasync function unlinkJobFromInvoice(\n\tinvoiceId: string,\n): Promise<ActionResult<void>> {\n\t// Just call the main function - same implementation\n\treturn unlinkInvoiceFromJob(invoiceId);\n}\n"],"names":[],"mappings":"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"}