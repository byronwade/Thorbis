{"version":3,"sources":["../../../../../../apps/web/src/actions/ai-activity.ts","../../../../../../apps/web/src/lib/ai/audit-trail.ts","../../../../../../apps/web/src/lib/ai/action-reverter.ts","../../../../../../apps/web/.next-internal/server/app/%28dashboard%29/dashboard/ai/activity/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport { getActiveCompany } from \"@/lib/auth/company-context\";\nimport { getCurrentUser } from \"@/lib/auth/session\";\nimport { getAuditStatistics, getHighSeverityAuditEntries } from \"@/lib/ai/audit-trail\";\nimport { revertSnapshot, previewRevert, getRevertableActions } from \"@/lib/ai/action-reverter\";\nimport { revalidatePath } from \"next/cache\";\n\nexport type ActivityLogEntry = {\n\tid: string;\n\taction: string;\n\tentityType: string;\n\tentityId: string | null;\n\ttoolName: string | null;\n\tseverity: string;\n\tisReversible: boolean;\n\treversed: boolean;\n\tcreatedAt: string;\n\tuserId: string | null;\n\tchatId: string | null;\n\tbeforeState: Record<string, unknown> | null;\n\tafterState: Record<string, unknown> | null;\n\tchangedFields: string[];\n};\n\nexport async function getActivityLogAction(options?: {\n\tlimit?: number;\n\toffset?: number;\n\tseverityFilter?: string[];\n\tactionFilter?: string[];\n\tdateFrom?: string;\n\tdateTo?: string;\n}): Promise<{\n\tentries: ActivityLogEntry[];\n\ttotal: number;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\t\tif (!company?.id) {\n\t\t\treturn { entries: [], total: 0, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { entries: [], total: 0, error: \"Database connection failed\" };\n\t\t}\n\n\t\tconst limit = options?.limit || 50;\n\t\tconst offset = options?.offset || 0;\n\n\t\tlet query = supabase\n\t\t\t.from(\"ai_audit_log\")\n\t\t\t.select(\n\t\t\t\t\"id, action, entity_type, entity_id, tool_name, severity, is_reversible, reversed, created_at, user_id, chat_id, before_state, after_state, changed_fields\",\n\t\t\t\t{ count: \"exact\" }\n\t\t\t)\n\t\t\t.eq(\"company_id\", company.id)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (options?.severityFilter && options.severityFilter.length > 0) {\n\t\t\tquery = query.in(\"severity\", options.severityFilter);\n\t\t}\n\n\t\tif (options?.actionFilter && options.actionFilter.length > 0) {\n\t\t\tquery = query.in(\"action\", options.actionFilter);\n\t\t}\n\n\t\tif (options?.dateFrom) {\n\t\t\tquery = query.gte(\"created_at\", options.dateFrom);\n\t\t}\n\n\t\tif (options?.dateTo) {\n\t\t\tquery = query.lte(\"created_at\", options.dateTo);\n\t\t}\n\n\t\tconst { data, error, count } = await query.range(offset, offset + limit - 1);\n\n\t\tif (error) {\n\t\t\tconsole.error(\"Failed to fetch activity log:\", error);\n\t\t\treturn { entries: [], total: 0, error: error.message };\n\t\t}\n\n\t\treturn {\n\t\t\tentries: (data || []).map((entry) => ({\n\t\t\t\tid: entry.id,\n\t\t\t\taction: entry.action,\n\t\t\t\tentityType: entry.entity_type,\n\t\t\t\tentityId: entry.entity_id,\n\t\t\t\ttoolName: entry.tool_name,\n\t\t\t\tseverity: entry.severity,\n\t\t\t\tisReversible: entry.is_reversible,\n\t\t\t\treversed: entry.reversed,\n\t\t\t\tcreatedAt: entry.created_at,\n\t\t\t\tuserId: entry.user_id,\n\t\t\t\tchatId: entry.chat_id,\n\t\t\t\tbeforeState: entry.before_state as Record<string, unknown> | null,\n\t\t\t\tafterState: entry.after_state as Record<string, unknown> | null,\n\t\t\t\tchangedFields: (entry.changed_fields as string[]) || [],\n\t\t\t})),\n\t\t\ttotal: count || 0,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching activity log:\", error);\n\t\treturn { entries: [], total: 0, error: \"Failed to fetch activity log\" };\n\t}\n}\n\nexport async function getActivityStatsAction(dateRange?: {\n\tstart: string;\n\tend: string;\n}): Promise<{\n\tstats: {\n\t\ttotalActions: number;\n\t\tbyAction: Record<string, number>;\n\t\tbySeverity: Record<string, number>;\n\t\tbyEntityType: Record<string, number>;\n\t\treversalRate: number;\n\t\tcriticalActionsCount: number;\n\t\ttopTools: Array<{ tool: string; count: number }>;\n\t} | null;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\t\tif (!company?.id) {\n\t\t\treturn { stats: null, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst start = dateRange?.start ? new Date(dateRange.start) : new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n\t\tconst end = dateRange?.end ? new Date(dateRange.end) : new Date();\n\n\t\tconst stats = await getAuditStatistics(company.id, { start, end });\n\t\treturn { stats };\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching activity stats:\", error);\n\t\treturn { stats: null, error: \"Failed to fetch activity stats\" };\n\t}\n}\n\nexport async function getHighSeverityActionsAction(): Promise<{\n\tentries: Array<{\n\t\tid: string;\n\t\taction: string;\n\t\tentityType: string;\n\t\tentityId: string | null;\n\t\tuserId: string | null;\n\t\ttoolName: string | null;\n\t\tseverity: string;\n\t\treversed: boolean;\n\t\tcreatedAt: string;\n\t}>;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\t\tif (!company?.id) {\n\t\t\treturn { entries: [], error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst entries = await getHighSeverityAuditEntries(company.id, {\n\t\t\tsince: new Date(Date.now() - 24 * 60 * 60 * 1000),\n\t\t\tlimit: 50,\n\t\t});\n\n\t\treturn { entries };\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching high severity actions:\", error);\n\t\treturn { entries: [], error: \"Failed to fetch high severity actions\" };\n\t}\n}\n\nexport async function previewUndoAction(snapshotId: string): Promise<{\n\tpreview: {\n\t\tentityType: string;\n\t\tentityId: string;\n\t\toperation: string;\n\t\tcurrentState: Record<string, unknown> | null;\n\t\twillRestoreTo: Record<string, unknown>;\n\t\tchangedFields: string[];\n\t\tcanRevert: boolean;\n\t\treason?: string;\n\t} | null;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\t\tif (!company?.id) {\n\t\t\treturn { preview: null, error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst preview = await previewRevert(company.id, snapshotId);\n\t\treturn { preview };\n\t} catch (error) {\n\t\tconsole.error(\"Error previewing undo:\", error);\n\t\treturn { preview: null, error: \"Failed to preview undo\" };\n\t}\n}\n\nexport async function undoActionAction(\n\tsnapshotId: string,\n\treason: string\n): Promise<{\n\tsuccess: boolean;\n\trevertedEntities: Array<{\n\t\tentityType: string;\n\t\tentityId: string;\n\t\trevertedFields: string[];\n\t}>;\n\tfailedEntities: Array<{\n\t\tentityType: string;\n\t\tentityId: string;\n\t\terror: string;\n\t}>;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst [company, user] = await Promise.all([getActiveCompany(), getCurrentUser()]);\n\t\tif (!company?.id || !user?.id) {\n\t\t\treturn { success: false, revertedEntities: [], failedEntities: [], error: \"Not authenticated\" };\n\t\t}\n\n\t\tconst result = await revertSnapshot(company.id, snapshotId, user.id, reason);\n\n\t\tif (result.success) {\n\t\t\trevalidatePath(\"/dashboard/ai/activity\");\n\t\t}\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconsole.error(\"Error undoing action:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\trevertedEntities: [],\n\t\t\tfailedEntities: [],\n\t\t\terror: \"Failed to undo action\",\n\t\t};\n\t}\n}\n\nexport async function getRevertableActionsAction(chatId?: string): Promise<{\n\tactions: Array<{\n\t\tid: string;\n\t\tmessageId: string;\n\t\tentityType: string;\n\t\tentityId: string;\n\t\toperation: string;\n\t\tchangedFields: string[];\n\t\tisReverted: boolean;\n\t\tcreatedAt: string;\n\t}>;\n\terror?: string;\n}> {\n\ttry {\n\t\tconst company = await getActiveCompany();\n\t\tif (!company?.id) {\n\t\t\treturn { actions: [], error: \"Not authenticated\" };\n\t\t}\n\n\t\tif (!chatId) {\n\t\t\treturn { actions: [], error: \"Chat ID required\" };\n\t\t}\n\n\t\tconst actions = await getRevertableActions(company.id, chatId, {\n\t\t\tlimit: 50,\n\t\t\tincludeReverted: true,\n\t\t});\n\n\t\treturn { actions };\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching revertable actions:\", error);\n\t\treturn { actions: [], error: \"Failed to fetch revertable actions\" };\n\t}\n}\n","/**\n * AI Audit Trail Service - Tamper-evident logging for AI actions\n * Based on industry best practices from Langfuse, Datadog, and compliance standards\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport crypto from \"crypto\";\n\nexport type AuditAction =\n  | \"create\"\n  | \"update\"\n  | \"delete\"\n  | \"query\"\n  | \"tool_call\"\n  | \"api_call\"\n  | \"file_access\"\n  | \"permission_change\"\n  | \"configuration_change\"\n  | \"data_export\"\n  | \"bulk_operation\";\n\nexport type AuditSeverity = \"low\" | \"medium\" | \"high\" | \"critical\";\n\nexport interface AuditContext {\n  companyId: string;\n  userId?: string;\n  chatId?: string;\n  messageId?: string;\n  traceId?: string;\n  spanId?: string;\n  sessionId?: string;\n}\n\nexport interface AuditLogEntry {\n  action: AuditAction;\n  entityType: string;\n  entityId?: string;\n  entityIds?: string[];\n  beforeState?: Record<string, unknown>;\n  afterState?: Record<string, unknown>;\n  changedFields?: string[];\n  toolName?: string;\n  toolParams?: Record<string, unknown>;\n  toolResult?: Record<string, unknown>;\n  severity?: AuditSeverity;\n  ipAddress?: string;\n  userAgent?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface ReversalRequest {\n  auditLogId: string;\n  reason: string;\n  reversedBy: string;\n  reversalMethod: \"automatic\" | \"manual\" | \"partial\";\n  partialFields?: string[];\n}\n\n/**\n * Calculate SHA-256 checksum for tamper detection\n */\nfunction calculateChecksum(data: Record<string, unknown>): string {\n  const normalized = JSON.stringify(data, Object.keys(data).sort());\n  return crypto.createHash(\"sha256\").update(normalized).digest(\"hex\");\n}\n\n/**\n * Determine severity based on action and entity type\n */\nfunction determineSeverity(action: AuditAction, entityType: string): AuditSeverity {\n  // Critical actions\n  if (action === \"delete\" || action === \"permission_change\") return \"critical\";\n  if (action === \"bulk_operation\") return \"high\";\n  if (entityType.includes(\"payment\") || entityType.includes(\"invoice\")) return \"high\";\n  if (action === \"configuration_change\") return \"high\";\n  if (action === \"data_export\") return \"high\";\n  if (action === \"update\") return \"medium\";\n  if (action === \"create\") return \"medium\";\n  return \"low\";\n}\n\n/**\n * Extract changed fields from before/after states\n */\nfunction extractChangedFields(\n  before?: Record<string, unknown>,\n  after?: Record<string, unknown>\n): string[] {\n  if (!before || !after) return [];\n\n  const changedFields: string[] = [];\n  const allKeys = new Set([...Object.keys(before), ...Object.keys(after)]);\n\n  for (const key of allKeys) {\n    if (JSON.stringify(before[key]) !== JSON.stringify(after[key])) {\n      changedFields.push(key);\n    }\n  }\n\n  return changedFields;\n}\n\n/**\n * Create an audit log entry with tamper-evident checksum\n */\nexport async function createAuditLog(\n  context: AuditContext,\n  entry: AuditLogEntry\n): Promise<string> {\n  const supabase = createServiceSupabaseClient();\n  const auditId = crypto.randomUUID();\n  const timestamp = new Date().toISOString();\n\n  // Calculate changed fields if not provided\n  const changedFields =\n    entry.changedFields || extractChangedFields(entry.beforeState, entry.afterState);\n\n  // Determine severity if not provided\n  const severity = entry.severity || determineSeverity(entry.action, entry.entityType);\n\n  // Prepare the data for checksum calculation\n  const checksumData = {\n    id: auditId,\n    company_id: context.companyId,\n    user_id: context.userId,\n    chat_id: context.chatId,\n    message_id: context.messageId,\n    trace_id: context.traceId,\n    span_id: context.spanId,\n    action: entry.action,\n    entity_type: entry.entityType,\n    entity_id: entry.entityId,\n    entity_ids: entry.entityIds,\n    before_state: entry.beforeState,\n    after_state: entry.afterState,\n    changed_fields: changedFields,\n    tool_name: entry.toolName,\n    tool_params: entry.toolParams,\n    tool_result: entry.toolResult,\n    timestamp,\n  };\n\n  const checksum = calculateChecksum(checksumData);\n\n  const { error } = await supabase.from(\"ai_audit_log\").insert({\n    id: auditId,\n    company_id: context.companyId,\n    user_id: context.userId,\n    chat_id: context.chatId,\n    message_id: context.messageId,\n    trace_id: context.traceId,\n    span_id: context.spanId,\n    action: entry.action,\n    entity_type: entry.entityType,\n    entity_id: entry.entityId,\n    entity_ids: entry.entityIds || [],\n    before_state: entry.beforeState,\n    after_state: entry.afterState,\n    changed_fields: changedFields,\n    tool_name: entry.toolName,\n    tool_params: entry.toolParams,\n    tool_result: entry.toolResult,\n    severity,\n    ip_address: entry.ipAddress,\n    user_agent: entry.userAgent,\n    metadata: entry.metadata || {},\n    checksum,\n    is_reversible: entry.action !== \"query\" && entry.beforeState !== undefined,\n    reversed: false,\n    created_at: timestamp,\n  });\n\n  if (error) {\n    console.error(\"Failed to create audit log:\", error);\n    throw error;\n  }\n\n  return auditId;\n}\n\n/**\n * Verify audit log integrity by recalculating checksum\n */\nexport async function verifyAuditLogIntegrity(\n  companyId: string,\n  auditLogId: string\n): Promise<{ valid: boolean; reason?: string }> {\n  const supabase = createServiceSupabaseClient();\n\n  const { data, error } = await supabase\n    .from(\"ai_audit_log\")\n    .select(\"*\")\n    .eq(\"id\", auditLogId)\n    .eq(\"company_id\", companyId)\n    .single();\n\n  if (error || !data) {\n    return { valid: false, reason: \"Audit log not found\" };\n  }\n\n  // Recalculate checksum\n  const checksumData = {\n    id: data.id,\n    company_id: data.company_id,\n    user_id: data.user_id,\n    chat_id: data.chat_id,\n    message_id: data.message_id,\n    trace_id: data.trace_id,\n    span_id: data.span_id,\n    action: data.action,\n    entity_type: data.entity_type,\n    entity_id: data.entity_id,\n    entity_ids: data.entity_ids,\n    before_state: data.before_state,\n    after_state: data.after_state,\n    changed_fields: data.changed_fields,\n    tool_name: data.tool_name,\n    tool_params: data.tool_params,\n    tool_result: data.tool_result,\n    timestamp: data.created_at,\n  };\n\n  const calculatedChecksum = calculateChecksum(checksumData);\n\n  if (calculatedChecksum !== data.checksum) {\n    return { valid: false, reason: \"Checksum mismatch - data may have been tampered\" };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Get audit trail for a specific entity\n */\nexport async function getEntityAuditTrail(\n  companyId: string,\n  entityType: string,\n  entityId: string,\n  options?: { limit?: number; offset?: number }\n): Promise<{\n  entries: Array<{\n    id: string;\n    action: string;\n    changedFields: string[];\n    beforeState: Record<string, unknown> | null;\n    afterState: Record<string, unknown> | null;\n    userId: string | null;\n    toolName: string | null;\n    severity: string;\n    reversed: boolean;\n    createdAt: string;\n  }>;\n  total: number;\n}> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 50;\n  const offset = options?.offset || 0;\n\n  // Get total count\n  const { count } = await supabase\n    .from(\"ai_audit_log\")\n    .select(\"*\", { count: \"exact\", head: true })\n    .eq(\"company_id\", companyId)\n    .eq(\"entity_type\", entityType)\n    .eq(\"entity_id\", entityId);\n\n  // Get entries\n  const { data, error } = await supabase\n    .from(\"ai_audit_log\")\n    .select(\n      \"id, action, changed_fields, before_state, after_state, user_id, tool_name, severity, reversed, created_at\"\n    )\n    .eq(\"company_id\", companyId)\n    .eq(\"entity_type\", entityType)\n    .eq(\"entity_id\", entityId)\n    .order(\"created_at\", { ascending: false })\n    .range(offset, offset + limit - 1);\n\n  if (error) {\n    console.error(\"Failed to get entity audit trail:\", error);\n    return { entries: [], total: 0 };\n  }\n\n  return {\n    entries: (data || []).map((entry) => ({\n      id: entry.id,\n      action: entry.action,\n      changedFields: entry.changed_fields || [],\n      beforeState: entry.before_state as Record<string, unknown> | null,\n      afterState: entry.after_state as Record<string, unknown> | null,\n      userId: entry.user_id,\n      toolName: entry.tool_name,\n      severity: entry.severity,\n      reversed: entry.reversed,\n      createdAt: entry.created_at,\n    })),\n    total: count || 0,\n  };\n}\n\n/**\n * Get audit trail for a chat session\n */\nexport async function getChatAuditTrail(\n  companyId: string,\n  chatId: string,\n  options?: { limit?: number; offset?: number; severityFilter?: AuditSeverity[] }\n): Promise<{\n  entries: Array<{\n    id: string;\n    action: string;\n    entityType: string;\n    entityId: string | null;\n    toolName: string | null;\n    severity: string;\n    isReversible: boolean;\n    reversed: boolean;\n    createdAt: string;\n  }>;\n  total: number;\n}> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 50;\n  const offset = options?.offset || 0;\n\n  let query = supabase\n    .from(\"ai_audit_log\")\n    .select(\"*\", { count: \"exact\" })\n    .eq(\"company_id\", companyId)\n    .eq(\"chat_id\", chatId);\n\n  if (options?.severityFilter && options.severityFilter.length > 0) {\n    query = query.in(\"severity\", options.severityFilter);\n  }\n\n  const { data, error, count } = await query\n    .order(\"created_at\", { ascending: false })\n    .range(offset, offset + limit - 1);\n\n  if (error) {\n    console.error(\"Failed to get chat audit trail:\", error);\n    return { entries: [], total: 0 };\n  }\n\n  return {\n    entries: (data || []).map((entry) => ({\n      id: entry.id,\n      action: entry.action,\n      entityType: entry.entity_type,\n      entityId: entry.entity_id,\n      toolName: entry.tool_name,\n      severity: entry.severity,\n      isReversible: entry.is_reversible,\n      reversed: entry.reversed,\n      createdAt: entry.created_at,\n    })),\n    total: count || 0,\n  };\n}\n\n/**\n * Get high-severity audit entries for monitoring\n */\nexport async function getHighSeverityAuditEntries(\n  companyId: string,\n  options?: {\n    since?: Date;\n    limit?: number;\n    includeReversed?: boolean;\n  }\n): Promise<\n  Array<{\n    id: string;\n    action: string;\n    entityType: string;\n    entityId: string | null;\n    userId: string | null;\n    toolName: string | null;\n    severity: string;\n    reversed: boolean;\n    createdAt: string;\n  }>\n> {\n  const supabase = createServiceSupabaseClient();\n  const since = options?.since || new Date(Date.now() - 24 * 60 * 60 * 1000); // Last 24 hours\n\n  let query = supabase\n    .from(\"ai_audit_log\")\n    .select(\n      \"id, action, entity_type, entity_id, user_id, tool_name, severity, reversed, created_at\"\n    )\n    .eq(\"company_id\", companyId)\n    .in(\"severity\", [\"high\", \"critical\"])\n    .gte(\"created_at\", since.toISOString())\n    .order(\"created_at\", { ascending: false })\n    .limit(options?.limit || 100);\n\n  if (!options?.includeReversed) {\n    query = query.eq(\"reversed\", false);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error(\"Failed to get high severity audit entries:\", error);\n    return [];\n  }\n\n  return (data || []).map((entry) => ({\n    id: entry.id,\n    action: entry.action,\n    entityType: entry.entity_type,\n    entityId: entry.entity_id,\n    userId: entry.user_id,\n    toolName: entry.tool_name,\n    severity: entry.severity,\n    reversed: entry.reversed,\n    createdAt: entry.created_at,\n  }));\n}\n\n/**\n * Record a reversal action\n */\nexport async function recordReversal(\n  companyId: string,\n  request: ReversalRequest\n): Promise<string> {\n  const supabase = createServiceSupabaseClient();\n  const reversalId = crypto.randomUUID();\n\n  // Get the original audit log entry\n  const { data: auditLog, error: fetchError } = await supabase\n    .from(\"ai_audit_log\")\n    .select(\"*\")\n    .eq(\"id\", request.auditLogId)\n    .eq(\"company_id\", companyId)\n    .single();\n\n  if (fetchError || !auditLog) {\n    throw new Error(\"Audit log entry not found\");\n  }\n\n  if (!auditLog.is_reversible) {\n    throw new Error(\"This action is not reversible\");\n  }\n\n  if (auditLog.reversed) {\n    throw new Error(\"This action has already been reversed\");\n  }\n\n  // Create reversal record\n  const { error: insertError } = await supabase.from(\"ai_audit_reversal\").insert({\n    id: reversalId,\n    company_id: companyId,\n    audit_log_id: request.auditLogId,\n    reversed_by: request.reversedBy,\n    reversal_reason: request.reason,\n    reversal_method: request.reversalMethod,\n    original_action: auditLog.action,\n    original_entity_type: auditLog.entity_type,\n    original_entity_id: auditLog.entity_id,\n    restored_state: auditLog.before_state,\n    partial_fields: request.partialFields,\n    created_at: new Date().toISOString(),\n  });\n\n  if (insertError) {\n    console.error(\"Failed to record reversal:\", insertError);\n    throw insertError;\n  }\n\n  // Mark original audit log as reversed\n  const { error: updateError } = await supabase\n    .from(\"ai_audit_log\")\n    .update({\n      reversed: true,\n      reversed_at: new Date().toISOString(),\n      reversed_by: request.reversedBy,\n      reversal_id: reversalId,\n    })\n    .eq(\"id\", request.auditLogId)\n    .eq(\"company_id\", companyId);\n\n  if (updateError) {\n    console.error(\"Failed to update audit log:\", updateError);\n  }\n\n  return reversalId;\n}\n\n/**\n * Get audit statistics for monitoring dashboard\n */\nexport async function getAuditStatistics(\n  companyId: string,\n  dateRange: { start: Date; end: Date }\n): Promise<{\n  totalActions: number;\n  byAction: Record<string, number>;\n  bySeverity: Record<string, number>;\n  byEntityType: Record<string, number>;\n  reversalRate: number;\n  criticalActionsCount: number;\n  topTools: Array<{ tool: string; count: number }>;\n}> {\n  const supabase = createServiceSupabaseClient();\n\n  const { data, error } = await supabase\n    .from(\"ai_audit_log\")\n    .select(\"action, severity, entity_type, tool_name, reversed\")\n    .eq(\"company_id\", companyId)\n    .gte(\"created_at\", dateRange.start.toISOString())\n    .lte(\"created_at\", dateRange.end.toISOString());\n\n  if (error || !data) {\n    return {\n      totalActions: 0,\n      byAction: {},\n      bySeverity: {},\n      byEntityType: {},\n      reversalRate: 0,\n      criticalActionsCount: 0,\n      topTools: [],\n    };\n  }\n\n  const byAction: Record<string, number> = {};\n  const bySeverity: Record<string, number> = {};\n  const byEntityType: Record<string, number> = {};\n  const toolCounts: Record<string, number> = {};\n  let reversedCount = 0;\n  let criticalCount = 0;\n\n  for (const entry of data) {\n    byAction[entry.action] = (byAction[entry.action] || 0) + 1;\n    bySeverity[entry.severity] = (bySeverity[entry.severity] || 0) + 1;\n    byEntityType[entry.entity_type] = (byEntityType[entry.entity_type] || 0) + 1;\n\n    if (entry.tool_name) {\n      toolCounts[entry.tool_name] = (toolCounts[entry.tool_name] || 0) + 1;\n    }\n\n    if (entry.reversed) reversedCount++;\n    if (entry.severity === \"critical\") criticalCount++;\n  }\n\n  const topTools = Object.entries(toolCounts)\n    .map(([tool, count]) => ({ tool, count }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n\n  return {\n    totalActions: data.length,\n    byAction,\n    bySeverity,\n    byEntityType,\n    reversalRate: data.length > 0 ? (reversedCount / data.length) * 100 : 0,\n    criticalActionsCount: criticalCount,\n    topTools,\n  };\n}\n","/**\n * AI Action Reverter Service - Rubrik-style selective rollback for AI actions\n * Based on Rubrik Agent Rewind patterns for granular recovery\n */\n\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport { recordReversal } from \"./audit-trail\";\nimport crypto from \"crypto\";\n\nexport type SnapshotType = \"full\" | \"partial\" | \"field_level\";\nexport type RevertStatus = \"pending\" | \"in_progress\" | \"completed\" | \"failed\" | \"partial\";\n\nexport interface ActionSnapshot {\n  entityType: string;\n  entityId: string;\n  beforeState: Record<string, unknown>;\n  afterState: Record<string, unknown>;\n  changedFields: string[];\n  operation: \"create\" | \"update\" | \"delete\";\n}\n\nexport interface RevertResult {\n  success: boolean;\n  revertedEntities: Array<{\n    entityType: string;\n    entityId: string;\n    revertedFields: string[];\n  }>;\n  failedEntities: Array<{\n    entityType: string;\n    entityId: string;\n    error: string;\n  }>;\n  reversalId?: string;\n}\n\n/**\n * Create an action snapshot before AI performs an action\n */\nexport async function createActionSnapshot(\n  companyId: string,\n  messageId: string,\n  chatId: string,\n  snapshot: ActionSnapshot\n): Promise<string> {\n  const supabase = createServiceSupabaseClient();\n  const snapshotId = crypto.randomUUID();\n\n  const { error } = await supabase.from(\"ai_action_snapshots\").insert({\n    id: snapshotId,\n    company_id: companyId,\n    message_id: messageId,\n    chat_id: chatId,\n    entity_type: snapshot.entityType,\n    entity_id: snapshot.entityId,\n    before_state: snapshot.beforeState,\n    after_state: snapshot.afterState,\n    changed_fields: snapshot.changedFields,\n    operation: snapshot.operation,\n    snapshot_type: snapshot.changedFields.length > 0 ? \"field_level\" : \"full\",\n    is_reverted: false,\n    created_at: new Date().toISOString(),\n  });\n\n  if (error) {\n    console.error(\"Failed to create action snapshot:\", error);\n    throw error;\n  }\n\n  return snapshotId;\n}\n\n/**\n * Create bulk snapshots for multiple entities (e.g., bulk operations)\n */\nexport async function createBulkSnapshots(\n  companyId: string,\n  messageId: string,\n  chatId: string,\n  snapshots: ActionSnapshot[]\n): Promise<string[]> {\n  const supabase = createServiceSupabaseClient();\n  const snapshotIds: string[] = [];\n\n  const records = snapshots.map((snapshot) => {\n    const id = crypto.randomUUID();\n    snapshotIds.push(id);\n    return {\n      id,\n      company_id: companyId,\n      message_id: messageId,\n      chat_id: chatId,\n      entity_type: snapshot.entityType,\n      entity_id: snapshot.entityId,\n      before_state: snapshot.beforeState,\n      after_state: snapshot.afterState,\n      changed_fields: snapshot.changedFields,\n      operation: snapshot.operation,\n      snapshot_type: \"full\" as const,\n      is_reverted: false,\n      created_at: new Date().toISOString(),\n    };\n  });\n\n  const { error } = await supabase.from(\"ai_action_snapshots\").insert(records);\n\n  if (error) {\n    console.error(\"Failed to create bulk snapshots:\", error);\n    throw error;\n  }\n\n  return snapshotIds;\n}\n\n/**\n * Get all snapshots for a specific message (for undo capability)\n */\nexport async function getMessageSnapshots(\n  companyId: string,\n  messageId: string\n): Promise<\n  Array<{\n    id: string;\n    entityType: string;\n    entityId: string;\n    operation: string;\n    changedFields: string[];\n    isReverted: boolean;\n    createdAt: string;\n  }>\n> {\n  const supabase = createServiceSupabaseClient();\n\n  const { data, error } = await supabase\n    .from(\"ai_action_snapshots\")\n    .select(\"id, entity_type, entity_id, operation, changed_fields, is_reverted, created_at\")\n    .eq(\"company_id\", companyId)\n    .eq(\"message_id\", messageId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    console.error(\"Failed to get message snapshots:\", error);\n    return [];\n  }\n\n  return (data || []).map((s) => ({\n    id: s.id,\n    entityType: s.entity_type,\n    entityId: s.entity_id,\n    operation: s.operation,\n    changedFields: s.changed_fields || [],\n    isReverted: s.is_reverted,\n    createdAt: s.created_at,\n  }));\n}\n\n/**\n * Get revertable actions for a chat session\n */\nexport async function getRevertableActions(\n  companyId: string,\n  chatId: string,\n  options?: { limit?: number; includeReverted?: boolean }\n): Promise<\n  Array<{\n    id: string;\n    messageId: string;\n    entityType: string;\n    entityId: string;\n    operation: string;\n    changedFields: string[];\n    isReverted: boolean;\n    createdAt: string;\n  }>\n> {\n  const supabase = createServiceSupabaseClient();\n  const limit = options?.limit || 50;\n\n  let query = supabase\n    .from(\"ai_action_snapshots\")\n    .select(\n      \"id, message_id, entity_type, entity_id, operation, changed_fields, is_reverted, created_at\"\n    )\n    .eq(\"company_id\", companyId)\n    .eq(\"chat_id\", chatId)\n    .order(\"created_at\", { ascending: false })\n    .limit(limit);\n\n  if (!options?.includeReverted) {\n    query = query.eq(\"is_reverted\", false);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error(\"Failed to get revertable actions:\", error);\n    return [];\n  }\n\n  return (data || []).map((s) => ({\n    id: s.id,\n    messageId: s.message_id,\n    entityType: s.entity_type,\n    entityId: s.entity_id,\n    operation: s.operation,\n    changedFields: s.changed_fields || [],\n    isReverted: s.is_reverted,\n    createdAt: s.created_at,\n  }));\n}\n\n/**\n * Revert a single snapshot to its before state\n */\nexport async function revertSnapshot(\n  companyId: string,\n  snapshotId: string,\n  userId: string,\n  reason: string,\n  options?: { partialFields?: string[] }\n): Promise<RevertResult> {\n  const supabase = createServiceSupabaseClient();\n\n  // Get the snapshot\n  const { data: snapshot, error: fetchError } = await supabase\n    .from(\"ai_action_snapshots\")\n    .select(\"*\")\n    .eq(\"id\", snapshotId)\n    .eq(\"company_id\", companyId)\n    .single();\n\n  if (fetchError || !snapshot) {\n    return {\n      success: false,\n      revertedEntities: [],\n      failedEntities: [\n        { entityType: \"unknown\", entityId: \"unknown\", error: \"Snapshot not found\" },\n      ],\n    };\n  }\n\n  if (snapshot.is_reverted) {\n    return {\n      success: false,\n      revertedEntities: [],\n      failedEntities: [\n        {\n          entityType: snapshot.entity_type,\n          entityId: snapshot.entity_id,\n          error: \"Already reverted\",\n        },\n      ],\n    };\n  }\n\n  try {\n    // Determine what to restore\n    let stateToRestore = snapshot.before_state as Record<string, unknown>;\n    let revertedFields = snapshot.changed_fields as string[];\n\n    if (options?.partialFields && options.partialFields.length > 0) {\n      // Partial revert - only restore specific fields\n      const currentState = snapshot.after_state as Record<string, unknown>;\n      stateToRestore = { ...currentState };\n      for (const field of options.partialFields) {\n        if (field in (snapshot.before_state as Record<string, unknown>)) {\n          stateToRestore[field] = (snapshot.before_state as Record<string, unknown>)[field];\n        }\n      }\n      revertedFields = options.partialFields;\n    }\n\n    // Handle different operations\n    if (snapshot.operation === \"create\") {\n      // For creates, we need to soft-delete or restore deleted_at\n      const { error: deleteError } = await supabase\n        .from(snapshot.entity_type)\n        .update({ deleted_at: new Date().toISOString() })\n        .eq(\"id\", snapshot.entity_id)\n        .eq(\"company_id\", companyId);\n\n      if (deleteError) throw deleteError;\n    } else if (snapshot.operation === \"delete\") {\n      // For deletes, restore the record\n      const { error: restoreError } = await supabase\n        .from(snapshot.entity_type)\n        .update({ ...stateToRestore, deleted_at: null })\n        .eq(\"id\", snapshot.entity_id)\n        .eq(\"company_id\", companyId);\n\n      if (restoreError) throw restoreError;\n    } else {\n      // For updates, restore the before state\n      const { error: updateError } = await supabase\n        .from(snapshot.entity_type)\n        .update(stateToRestore)\n        .eq(\"id\", snapshot.entity_id)\n        .eq(\"company_id\", companyId);\n\n      if (updateError) throw updateError;\n    }\n\n    // Mark snapshot as reverted\n    await supabase\n      .from(\"ai_action_snapshots\")\n      .update({\n        is_reverted: true,\n        reverted_at: new Date().toISOString(),\n        reverted_by: userId,\n        revert_reason: reason,\n        partial_revert_fields: options?.partialFields,\n      })\n      .eq(\"id\", snapshotId)\n      .eq(\"company_id\", companyId);\n\n    // Record in audit trail\n    const reversalId = await recordReversal(companyId, {\n      auditLogId: snapshotId, // Using snapshot ID as reference\n      reason,\n      reversedBy: userId,\n      reversalMethod: options?.partialFields ? \"partial\" : \"automatic\",\n      partialFields: options?.partialFields,\n    }).catch(() => undefined);\n\n    return {\n      success: true,\n      revertedEntities: [\n        {\n          entityType: snapshot.entity_type,\n          entityId: snapshot.entity_id,\n          revertedFields,\n        },\n      ],\n      failedEntities: [],\n      reversalId,\n    };\n  } catch (error) {\n    console.error(\"Failed to revert snapshot:\", error);\n    return {\n      success: false,\n      revertedEntities: [],\n      failedEntities: [\n        {\n          entityType: snapshot.entity_type,\n          entityId: snapshot.entity_id,\n          error: error instanceof Error ? error.message : \"Unknown error\",\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Revert all actions from a specific message\n */\nexport async function revertMessageActions(\n  companyId: string,\n  messageId: string,\n  userId: string,\n  reason: string\n): Promise<RevertResult> {\n  const snapshots = await getMessageSnapshots(companyId, messageId);\n  const unrevertedSnapshots = snapshots.filter((s) => !s.isReverted);\n\n  if (unrevertedSnapshots.length === 0) {\n    return {\n      success: true,\n      revertedEntities: [],\n      failedEntities: [],\n    };\n  }\n\n  const revertedEntities: RevertResult[\"revertedEntities\"] = [];\n  const failedEntities: RevertResult[\"failedEntities\"] = [];\n\n  // Revert in reverse order (last action first)\n  for (const snapshot of unrevertedSnapshots) {\n    const result = await revertSnapshot(companyId, snapshot.id, userId, reason);\n\n    if (result.success) {\n      revertedEntities.push(...result.revertedEntities);\n    } else {\n      failedEntities.push(...result.failedEntities);\n    }\n  }\n\n  return {\n    success: failedEntities.length === 0,\n    revertedEntities,\n    failedEntities,\n  };\n}\n\n/**\n * Preview what would be reverted without actually doing it\n */\nexport async function previewRevert(\n  companyId: string,\n  snapshotId: string\n): Promise<{\n  entityType: string;\n  entityId: string;\n  operation: string;\n  currentState: Record<string, unknown> | null;\n  willRestoreTo: Record<string, unknown>;\n  changedFields: string[];\n  canRevert: boolean;\n  reason?: string;\n}> {\n  const supabase = createServiceSupabaseClient();\n\n  // Get the snapshot\n  const { data: snapshot, error: fetchError } = await supabase\n    .from(\"ai_action_snapshots\")\n    .select(\"*\")\n    .eq(\"id\", snapshotId)\n    .eq(\"company_id\", companyId)\n    .single();\n\n  if (fetchError || !snapshot) {\n    return {\n      entityType: \"unknown\",\n      entityId: \"unknown\",\n      operation: \"unknown\",\n      currentState: null,\n      willRestoreTo: {},\n      changedFields: [],\n      canRevert: false,\n      reason: \"Snapshot not found\",\n    };\n  }\n\n  if (snapshot.is_reverted) {\n    return {\n      entityType: snapshot.entity_type,\n      entityId: snapshot.entity_id,\n      operation: snapshot.operation,\n      currentState: snapshot.after_state as Record<string, unknown>,\n      willRestoreTo: snapshot.before_state as Record<string, unknown>,\n      changedFields: snapshot.changed_fields as string[],\n      canRevert: false,\n      reason: \"Already reverted\",\n    };\n  }\n\n  // Get current state from database\n  const { data: currentRecord, error: currentError } = await supabase\n    .from(snapshot.entity_type)\n    .select(\"*\")\n    .eq(\"id\", snapshot.entity_id)\n    .eq(\"company_id\", companyId)\n    .single();\n\n  return {\n    entityType: snapshot.entity_type,\n    entityId: snapshot.entity_id,\n    operation: snapshot.operation,\n    currentState: currentError ? null : (currentRecord as Record<string, unknown>),\n    willRestoreTo: snapshot.before_state as Record<string, unknown>,\n    changedFields: snapshot.changed_fields as string[],\n    canRevert: !currentError,\n    reason: currentError ? \"Entity not found in database\" : undefined,\n  };\n}\n\n/**\n * Get revert history for an entity\n */\nexport async function getEntityRevertHistory(\n  companyId: string,\n  entityType: string,\n  entityId: string\n): Promise<\n  Array<{\n    id: string;\n    operation: string;\n    revertedAt: string;\n    revertedBy: string;\n    reason: string;\n    partialFields: string[] | null;\n  }>\n> {\n  const supabase = createServiceSupabaseClient();\n\n  const { data, error } = await supabase\n    .from(\"ai_action_snapshots\")\n    .select(\"id, operation, reverted_at, reverted_by, revert_reason, partial_revert_fields\")\n    .eq(\"company_id\", companyId)\n    .eq(\"entity_type\", entityType)\n    .eq(\"entity_id\", entityId)\n    .eq(\"is_reverted\", true)\n    .order(\"reverted_at\", { ascending: false });\n\n  if (error) {\n    console.error(\"Failed to get entity revert history:\", error);\n    return [];\n  }\n\n  return (data || []).map((r) => ({\n    id: r.id,\n    operation: r.operation,\n    revertedAt: r.reverted_at,\n    revertedBy: r.reverted_by,\n    reason: r.revert_reason,\n    partialFields: r.partial_revert_fields,\n  }));\n}\n\n/**\n * Batch revert multiple snapshots with transaction-like behavior\n */\nexport async function batchRevert(\n  companyId: string,\n  snapshotIds: string[],\n  userId: string,\n  reason: string\n): Promise<RevertResult> {\n  const revertedEntities: RevertResult[\"revertedEntities\"] = [];\n  const failedEntities: RevertResult[\"failedEntities\"] = [];\n\n  for (const snapshotId of snapshotIds) {\n    const result = await revertSnapshot(companyId, snapshotId, userId, reason);\n\n    if (result.success) {\n      revertedEntities.push(...result.revertedEntities);\n    } else {\n      failedEntities.push(...result.failedEntities);\n    }\n  }\n\n  return {\n    success: failedEntities.length === 0,\n    revertedEntities,\n    failedEntities,\n  };\n}\n","export {getCurrentUserRole as '001f005176797ef23488068124fb9a744915a477de'} from 'ACTIONS_MODULE0'\nexport {canDeleteTeamMember as '406f6624261c6dd1a908026fa1408a3f6d507b6e7d'} from 'ACTIONS_MODULE0'\nexport {getPayrixMerchantAccount as '40704f0e856ad801ef93b43436f219a36f7c0efd2c'} from 'ACTIONS_MODULE1'\nexport {getWebRTCCredentials as '000478fbf5363dae5000d525663da13e29908cb952'} from 'ACTIONS_MODULE2'\nexport {transcribeCallRecording as '4002f454c46f4c21ca6e9e26362583ccff69c9f914'} from 'ACTIONS_MODULE2'\nexport {getCompanyPhoneNumbers as '4019cf9f81eb3c06f82b5c2f8eb042f3d95d91e933'} from 'ACTIONS_MODULE2'\nexport {getCallRoutingRules as '40247c617842c31b242455a0961cbd2c3297606a16'} from 'ACTIONS_MODULE2'\nexport {updateCallRoutingRule as '40413bfa888916480edbc33ebb812158fddf960f89'} from 'ACTIONS_MODULE2'\nexport {startCallRecording as '404e47931374ad2a1b54bc11f357703790f6104530'} from 'ACTIONS_MODULE2'\nexport {transferActiveCall as '405a16958f97c37bd4b5711bd8761510bdab55839f'} from 'ACTIONS_MODULE2'\nexport {searchPhoneNumbers as '406864ae05b8b51c66cc2c335999e5011a41cb521f'} from 'ACTIONS_MODULE2'\nexport {makeCall as '40b2df540ec465c5dc19545c96486485bb50b5633b'} from 'ACTIONS_MODULE2'\nexport {sendTextMessage as '40d050abdabe2ee7293436c505c5f27b4408a2f27c'} from 'ACTIONS_MODULE2'\nexport {stopCallRecording as '40d5cc291162e2fd61245bdb851d5e8ed609e4ed19'} from 'ACTIONS_MODULE2'\nexport {sendMMSMessage as '40edd91786b2a482e617fb16f2474d26ec295435e7'} from 'ACTIONS_MODULE2'\nexport {purchasePhoneNumber as '40fd6a80b32792fab749933f98f07503d8e94c0305'} from 'ACTIONS_MODULE2'\nexport {deleteCallRoutingRule as '607d0f958daf66b2a0d5277cdda17600dace5156bb'} from 'ACTIONS_MODULE2'\nexport {toggleCallRoutingRule as '60853f1e409364f7e171e27229217994ff224414e6'} from 'ACTIONS_MODULE2'\nexport {createServiceSupabaseClient as '00a13dbd00149949fc1367d3e76ae7d789e07f5321'} from 'ACTIONS_MODULE3'\nexport {ensureMessagingBranding as '606753f8910b46d5792f4bdeb457cdf29d1a8bbadc'} from 'ACTIONS_MODULE4'\nexport {ensureMessagingCampaign as '70a648f43fa62ae3dcf2070eb90413e96e81591e77'} from 'ACTIONS_MODULE4'\nexport {checkTelnyxVerificationStatus as '007505a78985e53e083a498c97761ed8a463d3d379'} from 'ACTIONS_MODULE5'\nexport {submitAutomatedVerification as '4087f0badccd6aaf6a28b640ab4bbc513f0832d105'} from 'ACTIONS_MODULE5'\nexport {registerCompanyFor10DLC as '40ae25402a089e45aa071d979e8cc6ad136205cc98'} from 'ACTIONS_MODULE5'\nexport {sendVerificationSubmittedEmail as '70f58c5ba46ef02b620d7dc87bae8fc83f6d480755'} from 'ACTIONS_MODULE6'\nexport {sendEmail as '40f8c061cf84f884e77af3425bc24b8a8d72f598fb'} from 'ACTIONS_MODULE7'\nexport {handleComplaintWebhook as '6045f8436f9cdfdadb7bfe3955677adfc5f4102de0'} from 'ACTIONS_MODULE7'\nexport {handleBounceWebhook as '78a8ea4f1cfa571a366adccf36ac04b1c85d61ae2b'} from 'ACTIONS_MODULE7'\nexport {runHealthCheckForAllDomains as '00c53a1f02416c3261983f8096f19a3450bfd51775'} from 'ACTIONS_MODULE8'\nexport {getDomainHealth as '400b8fb96146bfd004a3166563a5ab5536bb610c70'} from 'ACTIONS_MODULE8'\nexport {recordDeliveryEvent as '404d6f2891af89c71d5bde33d110a216bdd3ee4729'} from 'ACTIONS_MODULE8'\nexport {getCompanyDomainsHealth as '405c57a8fed352b8679525b56014eb8c49105c850c'} from 'ACTIONS_MODULE8'\nexport {processResendWebhookEvent as '40ad037af6f6ab1a3004746d3a1b65afa65527002d'} from 'ACTIONS_MODULE8'\nexport {generateDeliverabilityReport as '40ecf2c792e84ef4b898fda98ec27277b4a9dddef2'} from 'ACTIONS_MODULE8'\nexport {resetHourlyCounters as '004cdde5e6ae8991bab4ba61ae40647c2b823200ba'} from 'ACTIONS_MODULE9'\nexport {resetDailyCounters as '006acf41615a2f7795c47b6d7a3016e18300f2ad17'} from 'ACTIONS_MODULE9'\nexport {incrementEmailCounter as '4029b163c1c0acfd806352a72fe8030c8ae4f7f8ac'} from 'ACTIONS_MODULE9'\nexport {getCompanyActiveDomain as '407a5a7d0a7dd7989a963eb2485a3527c1dcb20a70'} from 'ACTIONS_MODULE9'\nexport {checkRateLimit as '40af86a915f04df8d7cc189fe26e45e0cc24663080'} from 'ACTIONS_MODULE9'\nexport {isGmailIntegrationEnabled as '00fe74bdf14126b5ad89e9480e82978d6357f356b3'} from 'ACTIONS_MODULE10'\nexport {getUserGmailTokens as '400ce95360aaffa14a99dfdf969ba5166c69a59eb6'} from 'ACTIONS_MODULE10'\nexport {disconnectCompanyGmail as '401d3d830065dd7c4777fad67f642392f48735c4ab'} from 'ACTIONS_MODULE10'\nexport {disconnectUserGmail as '404575d602ef4c60c0058b592b8c3e42fbcd13fc4c'} from 'ACTIONS_MODULE10'\nexport {getCompanyEmailProvider as '40787b1598849126560f9f0b0f8fe8967338c7bf28'} from 'ACTIONS_MODULE10'\nexport {getCompanyGmailTokens as '40beeb56302a20d27cd8ba7a0988310f855633d7e6'} from 'ACTIONS_MODULE10'\nexport {refreshUserGmailToken as '602fab67313b110e6ccb66e54b1e16450b2a772cc7'} from 'ACTIONS_MODULE10'\nexport {sendCompanyGmailEmail as '60302947fc4caffa53a719728f3c2cebace926098c'} from 'ACTIONS_MODULE10'\nexport {syncUserInbox as '603643b13bf288cc628303bb4d12df0311b11434c7'} from 'ACTIONS_MODULE10'\nexport {checkCompanyGmailHealth as '60856182db5eaec7f85eda2a5a94c5d7d3524325d6'} from 'ACTIONS_MODULE10'\nexport {refreshCompanyGmailToken as '60eeb51685ac265a4ad793a230a515fe6e462f16f4'} from 'ACTIONS_MODULE10'\nexport {fetchUserInbox as '708daa303e36e37247e22b5b828b6aad8c73ac283b'} from 'ACTIONS_MODULE10'\nexport {setCompanyEmailProvider as '70dd3bc4222a87350dc137fa9cbcb849fa1913b397'} from 'ACTIONS_MODULE10'\nexport {storeGmailMessage as '78d41ef818e75fef94d65a87ea1f0faf418132e3c5'} from 'ACTIONS_MODULE10'\nexport {storeUserGmailTokens as '7e3a356960ddd52a3fa4dc6d981ae7202a59eb9a3d'} from 'ACTIONS_MODULE10'\nexport {storeCompanyGmailTokens as '7f06df826c4fff42950e712c0f548254e275be2a52'} from 'ACTIONS_MODULE10'\nexport {getProviderHealthDashboard as '00a122f9d5fe3a1603c636c3a251886129b66154f8'} from 'ACTIONS_MODULE11'\nexport {checkProviderAlert as '40c7885bdc4fe4cdd5f57e78579230c58088adbef4'} from 'ACTIONS_MODULE11'\nexport {cleanupOldEvents as '40d3c4ceeaee653aa257a28ed429a7fd272fa9fb66'} from 'ACTIONS_MODULE11'\nexport {recordProviderEvent as '40e06418f4b93b40c84a25511e0468e1e8a41ddecf'} from 'ACTIONS_MODULE11'\nexport {getProviderStats as '60c643a41ce1a8e6cc8338da6e2f3678c386910460'} from 'ACTIONS_MODULE11'\nexport {recordSendFailure as '78255c3fa8c9facf7c3f353202f2907836e8eb5539'} from 'ACTIONS_MODULE11'\nexport {recordSendSuccess as '783861d25688b32ba086bbe9e45444975c36a1b285'} from 'ACTIONS_MODULE11'\nexport {recordFallbackTriggered as '78766431b437b16f7cb00b4d64a2f3be5e092ed724'} from 'ACTIONS_MODULE11'\nexport {deleteNotification as '40fab1894acc5e3d1fdd8d8c6128a7cecee06e7e6a'} from 'ACTIONS_MODULE12'\nexport {markAllAsRead as '00cf212b0097820096122537beac12e3403b97d564'} from 'ACTIONS_MODULE12'\nexport {markAsRead as '4094cf679b4a10ca0f969f4fc1b55602aac4e0fbc3'} from 'ACTIONS_MODULE12'\nexport {makeCall as '40b2df540ec465c5dc19545c96486485bb50b5633b'} from 'ACTIONS_MODULE2'\nexport {getWebRTCCredentials as '000478fbf5363dae5000d525663da13e29908cb952'} from 'ACTIONS_MODULE2'\nexport {signOut as '0043ae510c3322ea499beb9e1bb77d06afb4ef19bd'} from 'ACTIONS_MODULE13'\nexport {switchCompany as '4097c3c574342661f9a3c8244961d001234449f36f'} from 'ACTIONS_MODULE14'\nexport {updateUserStatus as '4081009dd4dff14ff4ece62648bad23a83f2f9f63c'} from 'ACTIONS_MODULE15'\nexport {getTotalUnreadCountAction as '00ebc03a4ffc993aea7ec2e541686105c2bace2437'} from 'ACTIONS_MODULE16'\nexport {getCompanyPendingActions as '40e9589cb639f2902eb841bedc1247d966486d6fd7'} from 'ACTIONS_MODULE17'\nexport {checkIsCompanyOwner as '001be5cf82b793f19f6a7d010c91c14577fa7a130d'} from 'ACTIONS_MODULE17'\nexport {getCustomerByPhone as '6013add076e3eaed7dc37e8b800ce977d5abb8d49a'} from 'ACTIONS_MODULE18'\nexport {startCallRecording as '404e47931374ad2a1b54bc11f357703790f6104530'} from 'ACTIONS_MODULE2'\nexport {stopCallRecording as '40d5cc291162e2fd61245bdb851d5e8ed609e4ed19'} from 'ACTIONS_MODULE2'\nexport {deleteCustomer as '4082b52123c24a95685a53c36313418a95c259c65b'} from 'ACTIONS_MODULE18'\nexport {searchCustomers as '60193685409a9d118f1b364e14ecf57d05fa5638a9'} from 'ACTIONS_MODULE18'\nexport {getCustomersForDialer as '0077abd0cb1e555f91adaa482ad0b2f565bbd0629a'} from 'ACTIONS_MODULE18'\nexport {getPendingSupportSessions as '000f90f949d6a2f5484d061d5a738a59a8c846aeaa'} from 'ACTIONS_MODULE19'\nexport {getActiveSupportSessions as '00665c1bbcd52d612d5bb4bf3be5e7fc75554132e6'} from 'ACTIONS_MODULE19'\nexport {approveSupportSessionRequest as '602e89ae7ace85fc30cd3b4b1dd865d517c0cb1cd5'} from 'ACTIONS_MODULE19'\nexport {rejectSupportSessionRequest as '60886af124323873afd4d5b64bb4143abbcba2c154'} from 'ACTIONS_MODULE19'\nexport {endActiveSupportSession as '40369e8ea4eced7bdaef8203d369469ee7b630db8c'} from 'ACTIONS_MODULE19'\nexport {createEmailFolderAction as '408d3694fd0dd48e424f53c9bf5083b946ab3ec990'} from 'ACTIONS_MODULE20'\nexport {getEmailFolderCountsAction as '009e962eae57bf128b2023081fd7259048edd8884a'} from 'ACTIONS_MODULE16'\nexport {getEmailFoldersAction as '00235a0ba91f1ba226f33fa40dcf4c93a2c3548c70'} from 'ACTIONS_MODULE20'\nexport {deleteEmailFolderAction as '40c55f8e0922f2c7fd8d502e4c75395bf5f0470430'} from 'ACTIONS_MODULE20'\nexport {searchVendors as '404a3266e0319dbd8c24fec80bb69ecfe029d2a768'} from 'ACTIONS_MODULE21'\nexport {getSmsFolderCountsAction as '0006f7bd89b72f0836ec7bf4db73019f1b32e6c24a'} from 'ACTIONS_MODULE22'\nexport {getActivityLogAction as '40ab9d70d6580ff2961c19a49b16b0d79fb154a980'} from 'ACTIONS_MODULE23'\nexport {getActivityStatsAction as '407af3536fdb297e86672e08c42b1cbcc44605b218'} from 'ACTIONS_MODULE23'\nexport {previewUndoAction as '402e94d78c610a36a4222e56d34f753c7b90de4f2a'} from 'ACTIONS_MODULE23'\nexport {undoActionAction as '605b87bf15aa040b179e0be36b8187647d08cd6ade'} from 'ACTIONS_MODULE23'\n"],"names":[],"mappings":"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"}