{"version":3,"sources":["../../../../../../apps/web/src/lib/ai/memory-service.ts"],"sourcesContent":["/**\n * AI Memory Service - Semantic memory with embeddings (Mem0-style)\n * Based on Mem0 architecture and industry best practices for AI memory systems\n */\n\nimport crypto from \"crypto\";\nimport { createServiceSupabaseClient } from \"@/lib/supabase/service-client\";\nimport { openaiTracker } from \"@/lib/analytics/external-api-tracker\";\n\nexport type MemoryType =\n\t| \"fact\"\n\t| \"preference\"\n\t| \"interaction\"\n\t| \"context\"\n\t| \"entity\"\n\t| \"procedure\"\n\t| \"feedback\";\n\nexport type MemoryScope = \"user\" | \"company\" | \"global\";\n\nexport interface MemoryEntry {\n\tcontent: string;\n\tmemoryType: MemoryType;\n\tscope: MemoryScope;\n\tentityType?: string;\n\tentityId?: string;\n\tsourceMessageId?: string;\n\tsourceChatId?: string;\n\timportance?: number;\n\ttags?: string[];\n\tmetadata?: Record<string, unknown>;\n}\n\nexport interface MemorySearchResult {\n\tid: string;\n\tcontent: string;\n\tmemoryType: string;\n\tsimilarity: number;\n\timportance: number;\n\tcreatedAt: string;\n\taccessCount: number;\n}\n\n/**\n * Generate embeddings using OpenAI API (or other provider)\n * This is a placeholder - replace with actual embedding generation\n */\nasync function generateEmbedding(text: string, companyId?: string): Promise<number[]> {\n\t// In production, call OpenAI or another embedding provider\n\t// For now, we'll use a simple hash-based approach for testing\n\t// This should be replaced with actual embedding generation\n\n\t// Check if we have OpenAI API key configured\n\tconst openaiKey = process.env.OPENAI_API_KEY;\n\n\tif (openaiKey) {\n\t\tconst startTime = Date.now();\n\t\tlet success = false;\n\t\tlet errorMessage: string | undefined;\n\n\t\ttry {\n\t\t\tconst response = await fetch(\"https://api.openai.com/v1/embeddings\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${openaiKey}`,\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\tmodel: \"text-embedding-3-small\",\n\t\t\t\t\tinput: text,\n\t\t\t\t\tdimensions: 1536,\n\t\t\t\t}),\n\t\t\t});\n\n\t\t\tif (response.ok) {\n\t\t\t\tconst data = await response.json();\n\t\t\t\tsuccess = true;\n\n\t\t\t\t// Track the API call\n\t\t\t\tif (companyId) {\n\t\t\t\t\topenaiTracker.track(\"embeddings\", companyId, {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tresponseTimeMs: Date.now() - startTime,\n\t\t\t\t\t\testimatedCostCents: Math.ceil((text.length / 1000) * 0.002), // ~$0.00002 per 1K tokens\n\t\t\t\t\t}).catch(() => {});\n\t\t\t\t}\n\n\t\t\t\treturn data.data[0].embedding;\n\t\t\t} else {\n\t\t\t\terrorMessage = `API returned ${response.status}`;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\terrorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tconsole.error(\"Failed to generate OpenAI embedding:\", error);\n\t\t} finally {\n\t\t\t// Track failed calls\n\t\t\tif (!success && companyId) {\n\t\t\t\topenaiTracker.track(\"embeddings\", companyId, {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tresponseTimeMs: Date.now() - startTime,\n\t\t\t\t\terrorMessage,\n\t\t\t\t}).catch(() => {});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback: generate a deterministic pseudo-embedding for testing\n\t// This allows the system to work without an API key for development\n\tconst hash = crypto.createHash(\"sha256\").update(text).digest(\"hex\");\n\tconst embedding: number[] = [];\n\n\tfor (let i = 0; i < 1536; i++) {\n\t\t// Generate a value between -1 and 1 based on hash\n\t\tconst charCode = hash.charCodeAt(i % hash.length);\n\t\tembedding.push((charCode / 128 - 1) * Math.sin(i));\n\t}\n\n\t// Normalize the vector\n\tconst magnitude = Math.sqrt(\n\t\tembedding.reduce((sum, val) => sum + val * val, 0),\n\t);\n\treturn embedding.map((val) => val / magnitude);\n}\n\n/**\n * Store a new memory with embedding\n */\nexport async function storeMemory(\n\tcompanyId: string,\n\tuserId: string | undefined,\n\tmemory: MemoryEntry,\n): Promise<string> {\n\tconst supabase = createServiceSupabaseClient();\n\tconst memoryId = crypto.randomUUID();\n\n\t// Generate embedding for the content\n\tconst embedding = await generateEmbedding(memory.content, companyId);\n\n\t// Calculate content hash for deduplication\n\tconst contentHash = crypto\n\t\t.createHash(\"sha256\")\n\t\t.update(memory.content)\n\t\t.digest(\"hex\");\n\n\t// Check for duplicate content\n\tconst { data: existing } = await supabase\n\t\t.from(\"ai_memory\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"content_hash\", contentHash)\n\t\t.maybeSingle();\n\n\tif (existing) {\n\t\t// Update access count instead of creating duplicate\n\t\tawait supabase\n\t\t\t.from(\"ai_memory\")\n\t\t\t.update({\n\t\t\t\taccess_count: supabase.rpc(\"increment\", { x: 1 }),\n\t\t\t\tlast_accessed_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", existing.id);\n\n\t\treturn existing.id;\n\t}\n\n\tconst { error } = await supabase.from(\"ai_memory\").insert({\n\t\tid: memoryId,\n\t\tcompany_id: companyId,\n\t\tuser_id: userId,\n\t\tcontent: memory.content,\n\t\tcontent_hash: contentHash,\n\t\tmemory_type: memory.memoryType,\n\t\tscope: memory.scope,\n\t\tentity_type: memory.entityType,\n\t\tentity_id: memory.entityId,\n\t\tsource_message_id: memory.sourceMessageId,\n\t\tsource_chat_id: memory.sourceChatId,\n\t\tembedding,\n\t\timportance: memory.importance || 0.5,\n\t\taccess_count: 0,\n\t\ttags: memory.tags || [],\n\t\tmetadata: memory.metadata || {},\n\t\tcreated_at: new Date().toISOString(),\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Failed to store memory:\", error);\n\t\tthrow error;\n\t}\n\n\treturn memoryId;\n}\n\n/**\n * Store multiple memories efficiently\n */\nexport async function storeMemories(\n\tcompanyId: string,\n\tuserId: string | undefined,\n\tmemories: MemoryEntry[],\n): Promise<string[]> {\n\tconst memoryIds: string[] = [];\n\n\tfor (const memory of memories) {\n\t\ttry {\n\t\t\tconst id = await storeMemory(companyId, userId, memory);\n\t\t\tmemoryIds.push(id);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Failed to store memory:\", error);\n\t\t}\n\t}\n\n\treturn memoryIds;\n}\n\n/**\n * Search memories by semantic similarity\n */\nexport async function searchMemories(\n\tcompanyId: string,\n\tquery: string,\n\toptions?: {\n\t\tuserId?: string;\n\t\tscope?: MemoryScope;\n\t\tmemoryTypes?: MemoryType[];\n\t\tentityType?: string;\n\t\tentityId?: string;\n\t\tlimit?: number;\n\t\tminSimilarity?: number;\n\t},\n): Promise<MemorySearchResult[]> {\n\tconst supabase = createServiceSupabaseClient();\n\tconst limit = options?.limit || 10;\n\tconst minSimilarity = options?.minSimilarity || 0.5;\n\n\t// Generate embedding for the query\n\tconst queryEmbedding = await generateEmbedding(query, companyId);\n\n\t// Use Supabase's vector similarity search\n\t// This requires a custom RPC function in Supabase\n\tconst { data, error } = await supabase.rpc(\"vector_memory_search\", {\n\t\tp_company_id: companyId,\n\t\tp_query_embedding: queryEmbedding,\n\t\tp_user_id: options?.userId || null,\n\t\tp_scope: options?.scope || null,\n\t\tp_memory_types: options?.memoryTypes || null,\n\t\tp_entity_type: options?.entityType || null,\n\t\tp_entity_id: options?.entityId || null,\n\t\tp_limit: limit,\n\t\tp_min_similarity: minSimilarity,\n\t});\n\n\tif (error) {\n\t\tconsole.error(\"Failed to search memories:\", error);\n\n\t\t// Fallback to non-vector search if RPC doesn't exist\n\t\treturn fallbackSearch(companyId, query, options);\n\t}\n\n\t// Update access counts for retrieved memories\n\tif (data && data.length > 0) {\n\t\tconst memoryIds = data.map((m: { id: string }) => m.id);\n\t\tawait updateAccessCounts(companyId, memoryIds);\n\t}\n\n\treturn (data || []).map(\n\t\t(m: {\n\t\t\tid: string;\n\t\t\tcontent: string;\n\t\t\tmemory_type: string;\n\t\t\tsimilarity: number;\n\t\t\timportance: number;\n\t\t\tcreated_at: string;\n\t\t\taccess_count: number;\n\t\t}) => ({\n\t\t\tid: m.id,\n\t\t\tcontent: m.content,\n\t\t\tmemoryType: m.memory_type,\n\t\t\tsimilarity: m.similarity,\n\t\t\timportance: m.importance,\n\t\t\tcreatedAt: m.created_at,\n\t\t\taccessCount: m.access_count,\n\t\t}),\n\t);\n}\n\n/**\n * Fallback search when vector search RPC is not available\n */\nasync function fallbackSearch(\n\tcompanyId: string,\n\tquery: string,\n\toptions?: {\n\t\tuserId?: string;\n\t\tscope?: MemoryScope;\n\t\tmemoryTypes?: MemoryType[];\n\t\tentityType?: string;\n\t\tentityId?: string;\n\t\tlimit?: number;\n\t},\n): Promise<MemorySearchResult[]> {\n\tconst supabase = createServiceSupabaseClient();\n\tconst limit = options?.limit || 10;\n\n\tlet dbQuery = supabase\n\t\t.from(\"ai_memory\")\n\t\t.select(\"id, content, memory_type, importance, created_at, access_count\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.is(\"deleted_at\", null)\n\t\t.order(\"importance\", { ascending: false })\n\t\t.limit(limit);\n\n\tif (options?.userId) {\n\t\tdbQuery = dbQuery.eq(\"user_id\", options.userId);\n\t}\n\n\tif (options?.scope) {\n\t\tdbQuery = dbQuery.eq(\"scope\", options.scope);\n\t}\n\n\tif (options?.memoryTypes && options.memoryTypes.length > 0) {\n\t\tdbQuery = dbQuery.in(\"memory_type\", options.memoryTypes);\n\t}\n\n\tif (options?.entityType) {\n\t\tdbQuery = dbQuery.eq(\"entity_type\", options.entityType);\n\t}\n\n\tif (options?.entityId) {\n\t\tdbQuery = dbQuery.eq(\"entity_id\", options.entityId);\n\t}\n\n\t// Text search fallback\n\tdbQuery = dbQuery.ilike(\"content\", `%${query}%`);\n\n\tconst { data, error } = await dbQuery;\n\n\tif (error) {\n\t\tconsole.error(\"Fallback search failed:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((m) => ({\n\t\tid: m.id,\n\t\tcontent: m.content,\n\t\tmemoryType: m.memory_type,\n\t\tsimilarity: 0.5, // No real similarity score in fallback\n\t\timportance: m.importance,\n\t\tcreatedAt: m.created_at,\n\t\taccessCount: m.access_count,\n\t}));\n}\n\n/**\n * Update access counts for retrieved memories\n */\nasync function updateAccessCounts(\n\tcompanyId: string,\n\tmemoryIds: string[],\n): Promise<void> {\n\tconst supabase = createServiceSupabaseClient();\n\n\t// Update in batches to avoid long-running transactions\n\tfor (const id of memoryIds) {\n\t\tawait supabase\n\t\t\t.from(\"ai_memory\")\n\t\t\t.update({\n\t\t\t\taccess_count: supabase.sql`access_count + 1`,\n\t\t\t\tlast_accessed_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", id)\n\t\t\t.eq(\"company_id\", companyId);\n\t}\n}\n\n/**\n * Get memories for a specific entity\n */\nexport async function getEntityMemories(\n\tcompanyId: string,\n\tentityType: string,\n\tentityId: string,\n\toptions?: { limit?: number; memoryTypes?: MemoryType[] },\n): Promise<\n\tArray<{\n\t\tid: string;\n\t\tcontent: string;\n\t\tmemoryType: string;\n\t\timportance: number;\n\t\tcreatedAt: string;\n\t}>\n> {\n\tconst supabase = createServiceSupabaseClient();\n\tconst limit = options?.limit || 20;\n\n\tlet query = supabase\n\t\t.from(\"ai_memory\")\n\t\t.select(\"id, content, memory_type, importance, created_at\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"entity_type\", entityType)\n\t\t.eq(\"entity_id\", entityId)\n\t\t.is(\"deleted_at\", null)\n\t\t.order(\"importance\", { ascending: false })\n\t\t.limit(limit);\n\n\tif (options?.memoryTypes && options.memoryTypes.length > 0) {\n\t\tquery = query.in(\"memory_type\", options.memoryTypes);\n\t}\n\n\tconst { data, error } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"Failed to get entity memories:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((m) => ({\n\t\tid: m.id,\n\t\tcontent: m.content,\n\t\tmemoryType: m.memory_type,\n\t\timportance: m.importance,\n\t\tcreatedAt: m.created_at,\n\t}));\n}\n\n/**\n * Update memory importance based on usage patterns\n */\nexport async function updateMemoryImportance(\n\tcompanyId: string,\n\tmemoryId: string,\n\timportance: number,\n): Promise<void> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"ai_memory\")\n\t\t.update({ importance: Math.max(0, Math.min(1, importance)) })\n\t\t.eq(\"id\", memoryId)\n\t\t.eq(\"company_id\", companyId);\n\n\tif (error) {\n\t\tconsole.error(\"Failed to update memory importance:\", error);\n\t}\n}\n\n/**\n * Soft delete a memory\n */\nexport async function deleteMemory(\n\tcompanyId: string,\n\tmemoryId: string,\n): Promise<boolean> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { error } = await supabase\n\t\t.from(\"ai_memory\")\n\t\t.update({ deleted_at: new Date().toISOString() })\n\t\t.eq(\"id\", memoryId)\n\t\t.eq(\"company_id\", companyId);\n\n\tif (error) {\n\t\tconsole.error(\"Failed to delete memory:\", error);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Extract and store memories from a conversation\n */\nexport async function extractMemoriesFromConversation(\n\tcompanyId: string,\n\tuserId: string | undefined,\n\tchatId: string,\n\tmessageId: string,\n\tcontent: string,\n\trole: \"user\" | \"assistant\",\n): Promise<string[]> {\n\t// This is a simplified extraction - in production, you might use\n\t// an LLM to extract structured memories from the conversation\n\n\tconst memories: MemoryEntry[] = [];\n\n\t// Store the interaction itself\n\tmemories.push({\n\t\tcontent: content.substring(0, 500), // Limit content length\n\t\tmemoryType: \"interaction\",\n\t\tscope: userId ? \"user\" : \"company\",\n\t\tsourceMessageId: messageId,\n\t\tsourceChatId: chatId,\n\t\timportance: 0.5,\n\t\tmetadata: { role },\n\t});\n\n\t// Extract potential facts (very basic - use LLM in production)\n\tconst factPatterns = [\n\t\t/(?:remember|note|important)[:\\s]+(.+?)(?:\\.|$)/gi,\n\t\t/(?:always|never|usually)[:\\s]+(.+?)(?:\\.|$)/gi,\n\t];\n\n\tfor (const pattern of factPatterns) {\n\t\tconst matches = content.matchAll(pattern);\n\t\tfor (const match of matches) {\n\t\t\tif (match[1] && match[1].length > 10) {\n\t\t\t\tmemories.push({\n\t\t\t\t\tcontent: match[1].trim(),\n\t\t\t\t\tmemoryType: \"fact\",\n\t\t\t\t\tscope: userId ? \"user\" : \"company\",\n\t\t\t\t\tsourceMessageId: messageId,\n\t\t\t\t\tsourceChatId: chatId,\n\t\t\t\t\timportance: 0.7,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn storeMemories(companyId, userId, memories);\n}\n\n/**\n * Get memory statistics for monitoring\n */\nexport async function getMemoryStatistics(companyId: string): Promise<{\n\ttotalMemories: number;\n\tbyType: Record<string, number>;\n\tbyScope: Record<string, number>;\n\taverageImportance: number;\n\ttotalAccessCount: number;\n\tmemoriesLast7Days: number;\n}> {\n\tconst supabase = createServiceSupabaseClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"ai_memory\")\n\t\t.select(\"memory_type, scope, importance, access_count, created_at\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.is(\"deleted_at\", null);\n\n\tif (error || !data) {\n\t\treturn {\n\t\t\ttotalMemories: 0,\n\t\t\tbyType: {},\n\t\t\tbyScope: {},\n\t\t\taverageImportance: 0,\n\t\t\ttotalAccessCount: 0,\n\t\t\tmemoriesLast7Days: 0,\n\t\t};\n\t}\n\n\tconst byType: Record<string, number> = {};\n\tconst byScope: Record<string, number> = {};\n\tlet totalImportance = 0;\n\tlet totalAccessCount = 0;\n\tconst sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n\tlet memoriesLast7Days = 0;\n\n\tfor (const memory of data) {\n\t\tbyType[memory.memory_type] = (byType[memory.memory_type] || 0) + 1;\n\t\tbyScope[memory.scope] = (byScope[memory.scope] || 0) + 1;\n\t\ttotalImportance += memory.importance;\n\t\ttotalAccessCount += memory.access_count;\n\n\t\tif (new Date(memory.created_at as string) > sevenDaysAgo) {\n\t\t\tmemoriesLast7Days++;\n\t\t}\n\t}\n\n\treturn {\n\t\ttotalMemories: data.length,\n\t\tbyType,\n\t\tbyScope,\n\t\taverageImportance: data.length > 0 ? totalImportance / data.length : 0,\n\t\ttotalAccessCount,\n\t\tmemoriesLast7Days,\n\t};\n}\n\n/**\n * Consolidate similar memories to reduce redundancy\n */\nexport async function consolidateMemories(companyId: string): Promise<{\n\tconsolidated: number;\n\tdeleted: number;\n}> {\n\t// This would use vector similarity to find and merge similar memories\n\t// For now, we'll just return zeros - implement with actual consolidation logic\n\tconsole.log(\"Memory consolidation for company:\", companyId);\n\n\treturn { consolidated: 0, deleted: 0 };\n}\n\n/**\n * Decay old, unused memories to free up space\n */\nexport async function decayOldMemories(\n\tcompanyId: string,\n\toptions?: {\n\t\tmaxAge?: number; // days\n\t\tminAccessCount?: number;\n\t\tdryRun?: boolean;\n\t},\n): Promise<{\n\taffected: number;\n\tdeleted: number;\n}> {\n\tconst supabase = createServiceSupabaseClient();\n\tconst maxAge = options?.maxAge || 90; // 90 days default\n\tconst minAccessCount = options?.minAccessCount || 1;\n\tconst cutoffDate = new Date(Date.now() - maxAge * 24 * 60 * 60 * 1000);\n\n\t// Find old, unused memories\n\tconst { data, error } = await supabase\n\t\t.from(\"ai_memory\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.is(\"deleted_at\", null)\n\t\t.lt(\"created_at\", cutoffDate.toISOString())\n\t\t.lte(\"access_count\", minAccessCount);\n\n\tif (error || !data) {\n\t\treturn { affected: 0, deleted: 0 };\n\t}\n\n\tif (options?.dryRun) {\n\t\treturn { affected: data.length, deleted: 0 };\n\t}\n\n\t// Soft delete old memories\n\tconst ids = data.map((m) => m.id);\n\tif (ids.length > 0) {\n\t\tawait supabase\n\t\t\t.from(\"ai_memory\")\n\t\t\t.update({ deleted_at: new Date().toISOString() })\n\t\t\t.in(\"id\", ids)\n\t\t\t.eq(\"company_id\", companyId);\n\t}\n\n\treturn { affected: data.length, deleted: data.length };\n}\n"],"names":[],"mappings":"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"}