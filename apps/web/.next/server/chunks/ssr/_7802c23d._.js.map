{"version":3,"sources":["../../../../../../packages/auth/src/tokens.ts","../../../../../../apps/web/src/lib/auth/tokens.ts","../../../../../../apps/web/src/lib/security/csrf.ts","../../../../../../apps/web/src/actions/emails.ts","../../../../../../apps/web/src/actions/auth.ts"],"sourcesContent":["/**\n * Authentication Token Utilities\n *\n * Features:\n * - Secure token generation for email verification\n * - Token storage and validation\n * - Expiration handling\n * - One-time use tokens\n *\n * Note: Uses Supabase directly instead of Drizzle ORM\n */\n\n\"use server\";\n\nimport { randomBytes } from \"node:crypto\";\nimport { createClient } from \"@stratos/database/server\";\n\n/**\n * Generate a secure random token\n */\nfunction generateSecureToken(): string {\n\t// Generate 32 bytes of random data and convert to hex string (64 characters)\n\treturn randomBytes(32).toString(\"hex\");\n}\n\n/**\n * Create an email verification token\n *\n * @param email - User's email address\n * @param userId - Optional user ID if already created\n * @param expiresInHours - Token expiration in hours (default: 24)\n */\nexport async function createEmailVerificationToken(\n\temail: string,\n\tuserId?: string,\n\texpiresInHours = 24,\n): Promise<{ token: string; expiresAt: Date }> {\n\tconst token = generateSecureToken();\n\tconst expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);\n\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst { error } = await supabase.from(\"verification_tokens\").insert({\n\t\ttoken,\n\t\temail,\n\t\ttype: \"email_verification\",\n\t\tuser_id: userId,\n\t\texpires_at: expiresAt.toISOString(),\n\t\tused: false,\n\t});\n\n\tif (error) {\n\t\tthrow new Error(`Failed to create verification token: ${error.message}`);\n\t}\n\n\treturn { token, expiresAt };\n}\n\n/**\n * Create a password reset token\n *\n * @param email - User's email address\n * @param expiresInHours - Token expiration in hours (default: 1)\n */\nasync function createPasswordResetToken(\n\temail: string,\n\texpiresInHours = 1,\n): Promise<{ token: string; expiresAt: Date }> {\n\tconst token = generateSecureToken();\n\tconst expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);\n\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst { error } = await supabase.from(\"verification_tokens\").insert({\n\t\ttoken,\n\t\temail,\n\t\ttype: \"password_reset\",\n\t\texpires_at: expiresAt.toISOString(),\n\t\tused: false,\n\t});\n\n\tif (error) {\n\t\tthrow new Error(`Failed to create password reset token: ${error.message}`);\n\t}\n\n\treturn { token, expiresAt };\n}\n\n/**\n * Create a magic link token\n *\n * @param email - User's email address\n * @param expiresInMinutes - Token expiration in minutes (default: 15)\n */\nasync function createMagicLinkToken(\n\temail: string,\n\texpiresInMinutes = 15,\n): Promise<{ token: string; expiresAt: Date }> {\n\tconst token = generateSecureToken();\n\tconst expiresAt = new Date(Date.now() + expiresInMinutes * 60 * 1000);\n\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tconst { error } = await supabase.from(\"verification_tokens\").insert({\n\t\ttoken,\n\t\temail,\n\t\ttype: \"magic_link\",\n\t\texpires_at: expiresAt.toISOString(),\n\t\tused: false,\n\t});\n\n\tif (error) {\n\t\tthrow new Error(`Failed to create magic link token: ${error.message}`);\n\t}\n\n\treturn { token, expiresAt };\n}\n\n/**\n * Verify and consume a token\n *\n * @param token - The token to verify\n * @param type - Token type to verify\n * @returns Token data if valid, null if invalid/expired/used\n */\nexport async function verifyAndConsumeToken(\n\ttoken: string,\n\ttype: \"email_verification\" | \"password_reset\" | \"magic_link\",\n) {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\tconst now = new Date().toISOString();\n\n\t// Find unused, non-expired token\n\tconst { data: tokenRecord, error: selectError } = await supabase\n\t\t.from(\"verification_tokens\")\n\t\t.select(\"*\")\n\t\t.eq(\"token\", token)\n\t\t.eq(\"type\", type)\n\t\t.eq(\"used\", false)\n\t\t.gt(\"expires_at\", now)\n\t\t.limit(1)\n\t\t.single();\n\n\tif (selectError || !tokenRecord) {\n\t\treturn null;\n\t}\n\n\t// Mark token as used\n\tconst { error: updateError } = await supabase\n\t\t.from(\"verification_tokens\")\n\t\t.update({\n\t\t\tused: true,\n\t\t\tused_at: now,\n\t\t})\n\t\t.eq(\"id\", tokenRecord.id);\n\n\tif (updateError) {\n\t\tthrow new Error(`Failed to consume token: ${updateError.message}`);\n\t}\n\n\treturn tokenRecord;\n}\n\n/**\n * Delete expired tokens (cleanup)\n */\nasync function cleanupExpiredTokens() {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\tconst now = new Date().toISOString();\n\n\tconst { error } = await supabase\n\t\t.from(\"verification_tokens\")\n\t\t.delete()\n\t\t.lt(\"expires_at\", now);\n\n\tif (error) {\n\t\tthrow new Error(`Failed to cleanup expired tokens: ${error.message}`);\n\t}\n}\n\n/**\n * Delete all tokens for an email\n *\n * @param email - User's email address\n * @param type - Optional: specific token type to delete\n */\nasync function deleteTokensForEmail(\n\temail: string,\n\ttype?: \"email_verification\" | \"password_reset\" | \"magic_link\",\n) {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\n\tlet query = supabase.from(\"verification_tokens\").delete().eq(\"email\", email);\n\n\tif (type) {\n\t\tquery = query.eq(\"type\", type);\n\t}\n\n\tconst { error } = await query;\n\n\tif (error) {\n\t\tthrow new Error(`Failed to delete tokens: ${error.message}`);\n\t}\n}\n","// Re-export from @stratos/auth package for backwards compatibility\nexport * from \"@stratos/auth/tokens\";\n","/**\n * CSRF Protection\n *\n * Cross-Site Request Forgery (CSRF) protection for Server Actions.\n * Generates and validates tokens to prevent unauthorized form submissions.\n *\n * How it works:\n * 1. Server generates a random CSRF token and stores it in HTTP-only cookie\n * 2. Token is also included in form as hidden field or header\n * 3. On form submission, server compares cookie token with submitted token\n * 4. Tokens must match exactly or request is rejected\n *\n * Usage in Server Actions:\n * ```typescript\n * export async function updateSettings(formData: FormData) {\n *   await verifyCSRFToken(formData);\n *   // Your logic here\n * }\n * ```\n *\n * Usage in Forms:\n * ```tsx\n * <form action={updateSettings}>\n *   <CSRFTokenInput />\n *   <input name=\"setting\" />\n *   <button type=\"submit\">Save</button>\n * </form>\n * ```\n */\n\nimport { randomBytes } from \"node:crypto\";\nimport { cookies, headers } from \"next/headers\";\n\nconst CSRF_TOKEN_COOKIE = \"csrf_token\";\nconst CSRF_HEADER = \"x-csrf-token\";\nconst CSRF_FORM_FIELD = \"csrf_token\";\n\n/**\n * CSRF Error\n */\nclass CSRFError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"CSRFError\";\n\t}\n}\n\n/**\n * Generate CSRF Token\n *\n * Creates a secure random token and stores it in an HTTP-only cookie.\n * Call this in Server Components or Server Actions to initialize CSRF protection.\n *\n * @returns The generated CSRF token (for including in forms)\n */\nasync function generateCSRFToken(): Promise<string> {\n\tconst token = randomBytes(32).toString(\"hex\");\n\tconst cookieStore = await cookies();\n\n\tcookieStore.set(CSRF_TOKEN_COOKIE, token, {\n\t\thttpOnly: true,\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\tsameSite: \"strict\",\n\t\tmaxAge: 60 * 60 * 24, // 24 hours\n\t\tpath: \"/\",\n\t});\n\n\treturn token;\n}\n\n/**\n * Get Current CSRF Token\n *\n * Gets the CSRF token from cookies without generating a new one.\n * Generates a new token if none exists.\n *\n * @returns Current CSRF token or new token if none exists\n */\nasync function getCSRFToken(): Promise<string> {\n\tconst cookieStore = await cookies();\n\tconst existingToken = cookieStore.get(CSRF_TOKEN_COOKIE)?.value;\n\n\tif (existingToken) {\n\t\treturn existingToken;\n\t}\n\n\t// Generate new token if none exists\n\treturn generateCSRFToken();\n}\n\n/**\n * Verify CSRF Token\n *\n * Validates the CSRF token from request against the cookie.\n * Supports both header-based and form field-based tokens.\n *\n * @param formData - Optional FormData containing the CSRF token\n * @throws CSRFError if validation fails\n *\n * @example\n * // In Server Action\n * export async function updateUser(formData: FormData) {\n *   await verifyCSRFToken(formData);\n *   // Your logic here\n * }\n */\nasync function verifyCSRFToken(formData?: FormData): Promise<void> {\n\tconst cookieStore = await cookies();\n\tconst headersList = await headers();\n\n\tconst cookieToken = cookieStore.get(CSRF_TOKEN_COOKIE)?.value;\n\n\t// Get token from header or form field\n\tlet submittedToken: string | null = null;\n\n\t// Check header first (for fetch requests)\n\tsubmittedToken = headersList.get(CSRF_HEADER);\n\n\t// Fall back to form field (for form submissions)\n\tif (!submittedToken && formData) {\n\t\tsubmittedToken = formData.get(CSRF_FORM_FIELD) as string | null;\n\t}\n\n\t// Validate\n\tif (!cookieToken) {\n\t\tthrow new CSRFError(\n\t\t\t\"CSRF token missing from cookies. Please refresh the page and try again.\",\n\t\t);\n\t}\n\n\tif (!submittedToken) {\n\t\tthrow new CSRFError(\n\t\t\t\"CSRF token missing from request. Please ensure the form includes a CSRF token.\",\n\t\t);\n\t}\n\n\t// Constant-time comparison to prevent timing attacks\n\tif (!constantTimeCompare(cookieToken, submittedToken)) {\n\t\tthrow new CSRFError(\n\t\t\t\"Invalid CSRF token. This request may be forged. Please refresh the page and try again.\",\n\t\t);\n\t}\n}\n\n/**\n * Constant-Time String Comparison\n *\n * Compares two strings in constant time to prevent timing attacks.\n * Always compares the full length even if strings don't match.\n *\n * @param a - First string\n * @param b - Second string\n * @returns true if strings are equal, false otherwise\n */\nfunction constantTimeCompare(a: string, b: string): boolean {\n\t// If lengths don't match, still do comparison to prevent timing leak\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tlet result = 0;\n\tfor (let i = 0; i < a.length; i++) {\n\t\tresult |= a.charCodeAt(i) ^ b.charCodeAt(i);\n\t}\n\n\treturn result === 0;\n}\n\n/**\n * CSRF Protection Wrapper for Server Actions\n *\n * Wraps a Server Action to automatically verify CSRF token.\n *\n * @param fn - Server Action function to wrap\n * @returns Wrapped function with CSRF protection\n *\n * @example\n * ```typescript\n * export const updateSettings = withCSRFProtection(\n *   async (formData: FormData) => {\n *     // Your logic here - CSRF already verified\n *   }\n * );\n * ```\n */\nfunction withCSRFProtection<T extends any[], R>(\n\tfn: (...args: T) => Promise<R>,\n): (...args: T) => Promise<R> {\n\treturn async (...args: T): Promise<R> => {\n\t\t// Check if first argument is FormData\n\t\tconst formData = args[0] instanceof FormData ? args[0] : undefined;\n\n\t\tawait verifyCSRFToken(formData);\n\t\treturn fn(...args);\n\t};\n}\n\n/**\n * Rotate CSRF Token\n *\n * Generates a new CSRF token, invalidating the old one.\n * Use this after successful form submission or periodically for extra security.\n *\n * @returns New CSRF token\n */\nasync function rotateCSRFToken(): Promise<string> {\n\treturn generateCSRFToken();\n}\n\n/**\n * Clear CSRF Token\n *\n * Removes the CSRF token cookie.\n * Use this on logout.\n */\nexport async function clearCSRFToken(): Promise<void> {\n\tconst cookieStore = await cookies();\n\tcookieStore.delete(CSRF_TOKEN_COOKIE);\n}\n","/**\n * Email Server Actions - Type-safe email sending functions\n *\n * Features:\n * - Server-side email sending via Resend\n * - Type-safe template rendering\n * - Error handling and logging\n * - Development mode support\n */\n\n\"use server\";\n\nimport { sendEmail } from \"@/lib/email/email-sender\";\nimport {\n\ttype AppointmentReminderProps,\n\ttype EmailSendResult,\n\tEmailTemplate,\n\ttype EmailVerificationProps,\n\ttype EstimateSentProps,\n\ttype InvoiceSentProps,\n\ttype JobCompleteProps,\n\ttype JobConfirmationProps,\n\ttype MagicLinkProps,\n\ttype PasswordChangedProps,\n\ttype PasswordResetProps,\n\ttype PaymentReceivedProps,\n\ttype PaymentReminderProps,\n\ttype ReviewRequestProps,\n\ttype ServiceReminderProps,\n\ttype TechEnRouteProps,\n\ttype WelcomeCustomerProps,\n\ttype WelcomeEmailProps,\n} from \"@/lib/email/email-types\";\nimport EmailVerificationEmail from \"../../emails/templates/auth/email-verification\";\nimport MagicLinkEmail from \"../../emails/templates/auth/magic-link\";\nimport PasswordChangedEmail from \"../../emails/templates/auth/password-changed\";\nimport PasswordResetEmail from \"../../emails/templates/auth/password-reset\";\nimport WelcomeEmail from \"../../emails/templates/auth/welcome\";\nimport EstimateSentEmail from \"../../emails/templates/billing/estimate-sent\";\n\nimport InvoiceSentEmail from \"../../emails/templates/billing/invoice-sent\";\nimport PaymentReceivedEmail from \"../../emails/templates/billing/payment-received\";\nimport PaymentReminderEmail from \"../../emails/templates/billing/payment-reminder\";\nimport ReviewRequestEmail from \"../../emails/templates/customer/review-request\";\nimport ServiceReminderEmail from \"../../emails/templates/customer/service-reminder\";\nimport WelcomeCustomerEmail from \"../../emails/templates/customer/welcome-customer\";\nimport AppointmentReminderEmail from \"../../emails/templates/jobs/appointment-reminder\";\nimport JobCompleteEmail from \"../../emails/templates/jobs/job-complete\";\nimport JobConfirmationEmail from \"../../emails/templates/jobs/job-confirmation\";\nimport TechEnRouteEmail from \"../../emails/templates/jobs/tech-en-route\";\n\n// =============================================================================\n// AUTHENTICATION EMAILS\n// =============================================================================\n\n/**\n * Send welcome email to new user\n */\nexport async function sendWelcomeEmail(\n\tto: string,\n\tprops: WelcomeEmailProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Welcome to Thorbis!\",\n\t\ttemplate: WelcomeEmail(props),\n\t\ttemplateType: EmailTemplate.WELCOME,\n\t});\n}\n\n/**\n * Send email verification link\n */\nexport async function sendEmailVerification(\n\tto: string,\n\tprops: EmailVerificationProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Verify your email address\",\n\t\ttemplate: EmailVerificationEmail(props),\n\t\ttemplateType: EmailTemplate.EMAIL_VERIFICATION,\n\t});\n}\n\n/**\n * Send password reset email\n */\nexport async function sendPasswordReset(\n\tto: string,\n\tprops: PasswordResetProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Reset your password\",\n\t\ttemplate: PasswordResetEmail(props),\n\t\ttemplateType: EmailTemplate.PASSWORD_RESET,\n\t});\n}\n\n/**\n * Send password changed confirmation\n */\nexport async function sendPasswordChanged(\n\tto: string,\n\tprops: PasswordChangedProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Your password has been changed\",\n\t\ttemplate: PasswordChangedEmail(props),\n\t\ttemplateType: EmailTemplate.PASSWORD_CHANGED,\n\t});\n}\n\n/**\n * Send magic link for passwordless authentication\n */\nasync function sendMagicLink(\n\tto: string,\n\tprops: MagicLinkProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Sign in to Thorbis\",\n\t\ttemplate: MagicLinkEmail(props),\n\t\ttemplateType: EmailTemplate.MAGIC_LINK,\n\t});\n}\n\n// =============================================================================\n// JOB LIFECYCLE EMAILS\n// =============================================================================\n\n/**\n * Send job confirmation email\n */\nasync function sendJobConfirmation(\n\tto: string,\n\tprops: JobConfirmationProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: `Service Appointment Confirmed - ${props.jobType}`,\n\t\ttemplate: JobConfirmationEmail(props),\n\t\ttemplateType: EmailTemplate.JOB_CONFIRMATION,\n\t\ttags: [{ name: \"job_number\", value: props.jobNumber }],\n\t});\n}\n\n/**\n * Send appointment reminder (24h before)\n */\nasync function sendAppointmentReminder(\n\tto: string,\n\tprops: AppointmentReminderProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Reminder: Your service appointment is tomorrow\",\n\t\ttemplate: AppointmentReminderEmail(props),\n\t\ttemplateType: EmailTemplate.APPOINTMENT_REMINDER,\n\t});\n}\n\n/**\n * Send technician en route notification\n */\nasync function sendTechEnRoute(\n\tto: string,\n\tprops: TechEnRouteProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: `${props.technicianName} is on the way!`,\n\t\ttemplate: TechEnRouteEmail(props),\n\t\ttemplateType: EmailTemplate.TECH_EN_ROUTE,\n\t});\n}\n\n/**\n * Send job completion notification\n */\nasync function sendJobComplete(\n\tto: string,\n\tprops: JobCompleteProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Your service is complete!\",\n\t\ttemplate: JobCompleteEmail(props),\n\t\ttemplateType: EmailTemplate.JOB_COMPLETE,\n\t\ttags: [{ name: \"job_number\", value: props.jobNumber }],\n\t});\n}\n\n// =============================================================================\n// BILLING EMAILS\n// =============================================================================\n\n/**\n * Send invoice to customer\n */\nasync function sendInvoice(\n\tto: string,\n\tprops: InvoiceSentProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: `Invoice ${props.invoiceNumber} from Thorbis`,\n\t\ttemplate: InvoiceSentEmail(props),\n\t\ttemplateType: EmailTemplate.INVOICE_SENT,\n\t\ttags: [\n\t\t\t{ name: \"invoice_number\", value: props.invoiceNumber },\n\t\t\t{ name: \"amount\", value: props.totalAmount },\n\t\t],\n\t});\n}\n\n/**\n * Send payment confirmation\n */\nasync function sendPaymentReceived(\n\tto: string,\n\tprops: PaymentReceivedProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Payment received - Thank you!\",\n\t\ttemplate: PaymentReceivedEmail(props),\n\t\ttemplateType: EmailTemplate.PAYMENT_RECEIVED,\n\t\ttags: [\n\t\t\t{ name: \"invoice_number\", value: props.invoiceNumber },\n\t\t\t{ name: \"amount\", value: props.paymentAmount },\n\t\t],\n\t});\n}\n\n/**\n * Send payment reminder for overdue invoice\n */\nasync function sendPaymentReminder(\n\tto: string,\n\tprops: PaymentReminderProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: `Payment reminder: Invoice ${props.invoiceNumber}`,\n\t\ttemplate: PaymentReminderEmail(props),\n\t\ttemplateType: EmailTemplate.PAYMENT_REMINDER,\n\t\ttags: [\n\t\t\t{ name: \"invoice_number\", value: props.invoiceNumber },\n\t\t\t{ name: \"days_overdue\", value: props.daysOverdue.toString() },\n\t\t],\n\t});\n}\n\n/**\n * Send estimate/quote to customer\n */\nasync function sendEstimate(\n\tto: string,\n\tprops: EstimateSentProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: `Estimate ${props.estimateNumber} from Thorbis`,\n\t\ttemplate: EstimateSentEmail(props),\n\t\ttemplateType: EmailTemplate.ESTIMATE_SENT,\n\t\ttags: [\n\t\t\t{ name: \"estimate_number\", value: props.estimateNumber },\n\t\t\t{ name: \"amount\", value: props.totalAmount },\n\t\t],\n\t});\n}\n\n// =============================================================================\n// CUSTOMER ENGAGEMENT EMAILS\n// =============================================================================\n\n/**\n * Send review request after job completion\n */\nasync function sendReviewRequest(\n\tto: string,\n\tprops: ReviewRequestProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"How was your experience with Thorbis?\",\n\t\ttemplate: ReviewRequestEmail(props),\n\t\ttemplateType: EmailTemplate.REVIEW_REQUEST,\n\t\ttags: [{ name: \"job_number\", value: props.jobNumber }],\n\t});\n}\n\n/**\n * Send service/maintenance reminder\n */\nasync function sendServiceReminder(\n\tto: string,\n\tprops: ServiceReminderProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: `Time for your ${props.serviceName} service`,\n\t\ttemplate: ServiceReminderEmail(props),\n\t\ttemplateType: EmailTemplate.SERVICE_REMINDER,\n\t});\n}\n\n/**\n * Send welcome email to new customer\n */\nasync function sendWelcomeCustomer(\n\tto: string,\n\tprops: WelcomeCustomerProps,\n): Promise<EmailSendResult> {\n\treturn await sendEmail({\n\t\tto,\n\t\tsubject: \"Welcome to Thorbis!\",\n\t\ttemplate: WelcomeCustomerEmail(props),\n\t\ttemplateType: EmailTemplate.WELCOME_CUSTOMER,\n\t});\n}\n","\"use server\";\n\nimport { Buffer } from \"node:buffer\";\nimport { extname } from \"node:path\";\nimport { AuthApiError, AuthUnknownError } from \"@supabase/supabase-js\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { z } from \"zod\";\n// import { checkBotId } from \"botid/server\";\nimport { clearActiveCompany } from \"@/lib/auth/company-context\";\nimport {\n\tcreateEmailVerificationToken,\n\tverifyAndConsumeToken,\n} from \"@/lib/auth/tokens\";\nimport { sendgridConfig } from \"@/lib/email/sendgrid-client\";\nimport { clearCSRFToken } from \"@/lib/security/csrf\";\nimport {\n\tauthRateLimiter,\n\tcheckRateLimit,\n\tpasswordResetRateLimiter,\n\tRateLimitError,\n} from \"@/lib/security/rate-limit\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\tcreateServiceSupabaseClient,\n\ttype ServiceSupabaseClient,\n} from \"@/lib/supabase/service-client\";\nimport {\n\tsendEmailVerification,\n\tsendPasswordChanged,\n\tsendWelcomeEmail,\n} from \"./emails\";\n\nconst NAME_MIN_LENGTH = 2;\nconst NAME_MAX_LENGTH = 100;\nconst COMPANY_NAME_MIN_LENGTH = 2;\nconst COMPANY_NAME_MAX_LENGTH = 200;\nconst PHONE_MIN_DIGITS = 10;\nconst PASSWORD_MIN_LENGTH = 8;\nconst PASSWORD_MAX_LENGTH = 100;\nconst CONFIRMATION_TOKEN_TTL_HOURS = 24;\nconst COUNTRY_CODE_US = \"1\";\nconst NATIONAL_NUMBER_DIGITS = 10;\nconst EXTENDED_US_NUMBER_DIGITS = 11;\nconst BYTES_PER_KILOBYTE = 1024;\nconst BYTES_PER_MEGABYTE = BYTES_PER_KILOBYTE * BYTES_PER_KILOBYTE;\nconst AVATAR_SIZE_LIMIT_MB = 5;\nconst MAX_AVATAR_FILE_SIZE = AVATAR_SIZE_LIMIT_MB * BYTES_PER_MEGABYTE;\n\n/**\n * Authentication Server Actions - Supabase Auth + SendGrid Email Integration\n *\n * Performance optimizations:\n * - Server Actions for secure authentication\n * - Supabase Auth handles password hashing and session management\n * - Custom emails via SendGrid with branded templates\n * - Zod validation for input sanitization\n * - Proper error handling with user-friendly messages\n */\n\n// Validation Schemas\nconst signUpSchema = z.object({\n\tname: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(NAME_MIN_LENGTH, \"Name must be at least 2 characters\")\n\t\t.max(NAME_MAX_LENGTH, \"Name is too long\"),\n\temail: z.string().email(\"Invalid email address\"),\n\tphone: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(PHONE_MIN_DIGITS, \"Phone number is required\")\n\t\t.refine(\n\t\t\t(value) => value.replace(/\\D/g, \"\").length >= PHONE_MIN_DIGITS,\n\t\t\t\"Enter a valid phone number\",\n\t\t),\n\tpassword: z\n\t\t.string()\n\t\t.min(PASSWORD_MIN_LENGTH, \"Password must be at least 8 characters\")\n\t\t.max(PASSWORD_MAX_LENGTH, \"Password is too long\")\n\t\t.regex(\n\t\t\t/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/,\n\t\t\t\"Password must contain uppercase, lowercase, and number\",\n\t\t),\n\tcompanyName: z\n\t\t.string()\n\t\t.trim()\n\t\t.min(COMPANY_NAME_MIN_LENGTH, \"Company name must be at least 2 characters\")\n\t\t.max(COMPANY_NAME_MAX_LENGTH, \"Company name is too long\")\n\t\t.optional(),\n\tterms: z\n\t\t.boolean()\n\t\t.refine((val) => val === true, \"You must accept the terms and conditions\"),\n});\n\nconst signInSchema = z.object({\n\temail: z.string().email(\"Invalid email address\"),\n\tpassword: z.string().min(1, \"Password is required\"),\n});\n\nconst forgotPasswordSchema = z.object({\n\temail: z.string().email(\"Invalid email address\"),\n});\n\nconst resetPasswordSchema = z\n\t.object({\n\t\tpassword: z\n\t\t\t.string()\n\t\t\t.min(PASSWORD_MIN_LENGTH, \"Password must be at least 8 characters\")\n\t\t\t.max(PASSWORD_MAX_LENGTH, \"Password is too long\")\n\t\t\t.regex(\n\t\t\t\t/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/,\n\t\t\t\t\"Password must contain uppercase, lowercase, and number\",\n\t\t\t),\n\t\tconfirmPassword: z.string(),\n\t})\n\t.refine((data) => data.password === data.confirmPassword, {\n\t\tmessage: \"Passwords don't match\",\n\t\tpath: [\"confirmPassword\"],\n\t});\n\nconst AVATAR_STORAGE_BUCKET = \"avatars\";\nconst SUPABASE_RATE_LIMIT_MAX_RETRIES = 3;\nconst SUPABASE_RATE_LIMIT_BACKOFF_MS = 200;\n\nconst delay = (ms: number) =>\n\tnew Promise((resolve) => {\n\t\tsetTimeout(resolve, ms);\n\t});\n\nconst withSupabaseRateLimitRetry = async <T extends { error?: unknown }>(\n\toperation: () => Promise<T>,\n): Promise<T> => {\n\tfor (\n\t\tlet attempt = 1;\n\t\tattempt <= SUPABASE_RATE_LIMIT_MAX_RETRIES;\n\t\tattempt += 1\n\t) {\n\t\ttry {\n\t\t\tconst result = await operation();\n\n\t\t\tif (\n\t\t\t\tresult &&\n\t\t\t\ttypeof result === \"object\" &&\n\t\t\t\t\"error\" in result &&\n\t\t\t\tresult.error instanceof AuthApiError &&\n\t\t\t\tresult.error.code === \"over_request_rate_limit\"\n\t\t\t) {\n\t\t\t\tif (attempt === SUPABASE_RATE_LIMIT_MAX_RETRIES) {\n\t\t\t\t\tthrow result.error;\n\t\t\t\t}\n\n\t\t\t\tawait delay(SUPABASE_RATE_LIMIT_BACKOFF_MS * attempt);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror instanceof AuthApiError &&\n\t\t\t\terror.code === \"over_request_rate_limit\" &&\n\t\t\t\tattempt < SUPABASE_RATE_LIMIT_MAX_RETRIES\n\t\t\t) {\n\t\t\t\tawait delay(SUPABASE_RATE_LIMIT_BACKOFF_MS * attempt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tthrow new Error(\"Supabase auth operation failed after retries\");\n};\n\ntype SignUpFormInput = z.infer<typeof signUpSchema>;\n\ntype SupabaseBrowserClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nfunction normalizePhoneNumber(input: string): string {\n\tconst trimmed = input.trim();\n\tconst digitsOnly = trimmed.replace(/\\D/g, \"\");\n\n\tif (!digitsOnly) {\n\t\treturn trimmed;\n\t}\n\n\tif (trimmed.startsWith(\"+\")) {\n\t\treturn `+${digitsOnly}`;\n\t}\n\n\tif (\n\t\tdigitsOnly.length === EXTENDED_US_NUMBER_DIGITS &&\n\t\tdigitsOnly.startsWith(COUNTRY_CODE_US)\n\t) {\n\t\treturn `+${digitsOnly}`;\n\t}\n\n\tif (digitsOnly.length === NATIONAL_NUMBER_DIGITS) {\n\t\treturn `+${COUNTRY_CODE_US}${digitsOnly}`;\n\t}\n\n\treturn `+${digitsOnly}`;\n}\n\nconst reportAuthIssue = (_message: string, _error?: unknown) => {\n\t// TODO: Integrate structured logging/monitoring\n};\n\nconst getMetadataString = (\n\tmetadata: unknown,\n\tkey: string,\n): string | undefined => {\n\tif (metadata && typeof metadata === \"object\") {\n\t\tconst value = (metadata as Record<string, unknown>)[key];\n\t\tif (typeof value === \"string\") {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn;\n};\n\nasync function uploadAvatarForNewUser(\n\tsupabase: ServiceSupabaseClient,\n\tfile: File,\n\tuserId: string,\n): Promise<string | null> {\n\tif (!supabase) {\n\t\tthrow new Error(\"Supabase client not configured\");\n\t}\n\tif (!file.type.startsWith(\"image/\")) {\n\t\tthrow new Error(\"Avatar must be an image\");\n\t}\n\n\tif (file.size > MAX_AVATAR_FILE_SIZE) {\n\t\tthrow new Error(`Avatar must be smaller than ${AVATAR_SIZE_LIMIT_MB}MB`);\n\t}\n\n\tconst arrayBuffer = await file.arrayBuffer();\n\tconst extension = extname(file.name) || \".jpg\";\n\tconst filePath = `${userId}/profile${extension}`;\n\n\tconst { error: uploadError } = await supabase.storage\n\t\t.from(AVATAR_STORAGE_BUCKET)\n\t\t.upload(filePath, Buffer.from(arrayBuffer), {\n\t\t\tcacheControl: \"3600\",\n\t\t\tcontentType: file.type || \"image/jpeg\",\n\t\t\tupsert: true,\n\t\t});\n\n\tif (uploadError) {\n\t\tthrow new Error(uploadError.message);\n\t}\n\n\tconst {\n\t\tdata: { publicUrl },\n\t} = supabase.storage.from(AVATAR_STORAGE_BUCKET).getPublicUrl(filePath);\n\n\treturn publicUrl;\n}\n\nconst createServiceClientLoader = () => {\n\tlet client: ServiceSupabaseClient | null = null;\n\treturn async () => {\n\t\tif (client) {\n\t\t\treturn client;\n\t\t}\n\t\tclient = await createServiceSupabaseClient();\n\t\treturn client;\n\t};\n};\n\ntype ParsedSignUpForm = {\n\tvalidated: SignUpFormInput;\n\tnormalizedPhone: string;\n\tcompanyName?: string;\n\tavatarFile: File | null;\n};\n\nconst parseSignUpFormData = (formData: FormData): ParsedSignUpForm => {\n\tconst companyNameEntry = formData.get(\"companyName\");\n\tconst normalizedCompanyName =\n\t\ttypeof companyNameEntry === \"string\" && companyNameEntry.trim().length > 0\n\t\t\t? companyNameEntry\n\t\t\t: undefined;\n\n\tconst rawData = {\n\t\tname: (formData.get(\"name\") as string) ?? \"\",\n\t\temail: (formData.get(\"email\") as string) ?? \"\",\n\t\tphone: (formData.get(\"phone\") as string) ?? \"\",\n\t\tpassword: (formData.get(\"password\") as string) ?? \"\",\n\t\tcompanyName: normalizedCompanyName,\n\t\tterms: formData.get(\"terms\") === \"on\" || formData.get(\"terms\") === \"true\",\n\t};\n\n\tconst validated = signUpSchema.parse(rawData);\n\tconst avatarEntry = formData.get(\"avatar\");\n\tconst avatarFile =\n\t\tavatarEntry instanceof File && avatarEntry.size > 0 ? avatarEntry : null;\n\n\treturn {\n\t\tvalidated,\n\t\tnormalizedPhone: normalizePhoneNumber(validated.phone),\n\t\tcompanyName: validated.companyName?.trim() || undefined,\n\t\tavatarFile,\n\t};\n};\n\nconst requireSupabaseBrowserClient =\n\tasync (): Promise<SupabaseBrowserClient> => {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Authentication service is not configured. Please check your environment variables.\",\n\t\t\t);\n\t\t}\n\n\t\treturn supabase as SupabaseBrowserClient;\n\t};\n\ntype RegisterSupabaseUserParams = {\n\tsupabase: SupabaseBrowserClient;\n\tvalidated: SignUpFormInput;\n\tnormalizedPhone: string;\n\tcompanyName?: string;\n};\n\nconst registerSupabaseUser = async ({\n\tsupabase,\n\tvalidated,\n\tnormalizedPhone,\n\tcompanyName,\n}: RegisterSupabaseUserParams) => {\n\tconst { data, error } = await withSupabaseRateLimitRetry(() =>\n\t\tsupabase.auth.signUp({\n\t\t\temail: validated.email,\n\t\t\tpassword: validated.password,\n\t\t\toptions: {\n\t\t\t\tdata: {\n\t\t\t\t\tname: validated.name,\n\t\t\t\t\tphone: normalizedPhone,\n\t\t\t\t\tcompanyName: companyName ?? null,\n\t\t\t\t},\n\t\t\t\temailRedirectTo: `${sendgridConfig.siteUrl}/auth/callback`,\n\t\t\t},\n\t\t}),\n\t);\n\n\tif (error) {\n\t\tthrow new Error(error.message);\n\t}\n\n\tif (!data.user) {\n\t\tthrow new Error(\"Failed to create user account\");\n\t}\n\n\treturn data;\n};\n\ntype SyncSignUpProfileParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tnormalizedPhone: string;\n\tname: string;\n\tcompanyName?: string;\n\tavatarFile: File | null;\n};\n\nconst syncSignUpProfile = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tnormalizedPhone,\n\tname,\n\tcompanyName,\n\tavatarFile,\n}: SyncSignUpProfileParams) => {\n\tlet avatarUrl: string | null = null;\n\n\tif (avatarFile) {\n\t\ttry {\n\t\t\tconst adminClient = await ensureServiceSupabase();\n\t\t\tavatarUrl = await uploadAvatarForNewUser(adminClient, avatarFile, userId);\n\t\t} catch (avatarUploadError) {\n\t\t\treportAuthIssue(\"Avatar upload failed\", avatarUploadError);\n\t\t}\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tconst updatePayload: Record<string, string | null> = {\n\t\t\tphone: normalizedPhone,\n\t\t};\n\n\t\tif (avatarUrl) {\n\t\t\tupdatePayload.avatar_url = avatarUrl;\n\t\t}\n\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tawait adminClient.from(\"profiles\").update(updatePayload).eq(\"id\", userId);\n\t} catch (profileUpdateError) {\n\t\treportAuthIssue(\"Failed to update user profile\", profileUpdateError);\n\t}\n\n\tif (!avatarUrl) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tawait adminClient.auth.admin.updateUserById(userId, {\n\t\t\tuser_metadata: {\n\t\t\t\tname,\n\t\t\t\tphone: normalizedPhone,\n\t\t\t\tcompanyName: companyName ?? null,\n\t\t\t\tavatarUrl,\n\t\t\t},\n\t\t});\n\t} catch (metadataError) {\n\t\treportAuthIssue(\"Failed to sync avatar metadata\", metadataError);\n\t}\n};\n\ntype PostSignUpEmailParams = {\n\temail: string;\n\tname: string;\n\trequiresConfirmation: boolean;\n\tuserId: string;\n};\n\nconst handlePostSignUpEmails = async ({\n\temail,\n\tname,\n\trequiresConfirmation,\n\tuserId,\n}: PostSignUpEmailParams): Promise<AuthActionResult | null> => {\n\tif (requiresConfirmation) {\n\t\tconst { token, expiresAt } = await createEmailVerificationToken(\n\t\t\temail,\n\t\t\tuserId,\n\t\t\tCONFIRMATION_TOKEN_TTL_HOURS,\n\t\t);\n\n\t\tconst verificationUrl = `${sendgridConfig.siteUrl}/auth/verify-email?token=${token}`;\n\t\tconst verificationResult = await sendEmailVerification(email, {\n\t\t\tname,\n\t\t\tverificationUrl,\n\t\t});\n\n\t\tif (!verificationResult.success) {\n\t\t\treportAuthIssue(\n\t\t\t\t\"Failed to send verification email\",\n\t\t\t\tverificationResult.error,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\trequiresEmailConfirmation: true,\n\t\t\t\tmessage:\n\t\t\t\t\t\"Account created! Please check your email to verify your account.\",\n\t\t\t\texpiresAt: expiresAt.toISOString(),\n\t\t\t},\n\t\t};\n\t}\n\n\tconst emailResult = await sendWelcomeEmail(email, {\n\t\tname,\n\t\tloginUrl: `${sendgridConfig.siteUrl}/dashboard/welcome`,\n\t});\n\n\tif (!emailResult.success) {\n\t\treportAuthIssue(\"Failed to send welcome email\", emailResult.error);\n\t}\n\n\treturn null;\n};\n\nconst normalizeOptionalPhone = (phone: string | null): string | null => {\n\tif (!phone) {\n\t\treturn null;\n\t}\n\n\tconst digitsOnly = phone.replace(/\\D/g, \"\");\n\tif (digitsOnly.length < PHONE_MIN_DIGITS) {\n\t\tthrow new Error(\n\t\t\t\"Please enter a valid phone number with at least 10 digits.\",\n\t\t);\n\t}\n\n\treturn normalizePhoneNumber(phone);\n};\n\ntype CompleteProfileForm = {\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarFile: File | null;\n};\n\nconst parseCompleteProfileForm = (formData: FormData): CompleteProfileForm => {\n\tconst avatarEntry = formData.get(\"avatar\");\n\tconst avatarFile =\n\t\tavatarEntry instanceof File && avatarEntry.size > 0 ? avatarEntry : null;\n\n\tconst name = (formData.get(\"name\") as string | null) ?? null;\n\tconst phone = (formData.get(\"phone\") as string | null) ?? null;\n\n\treturn {\n\t\tname,\n\t\tnormalizedPhone: normalizeOptionalPhone(phone),\n\t\tavatarFile,\n\t};\n};\n\nconst requireAuthenticatedUser = async (supabase: SupabaseBrowserClient) => {\n\tconst {\n\t\tdata: { user },\n\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\tif (!user) {\n\t\tthrow new Error(\"You must be signed in to complete your profile.\");\n\t}\n\n\treturn user;\n};\n\ntype UpdateCompleteProfileRecordsParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarFile: File | null;\n\texistingAvatar: string | null;\n\texistingMetadata?: Record<string, unknown>;\n};\n\nconst uploadAvatarWithFallback = async ({\n\tensureServiceSupabase,\n\tavatarFile,\n\tuserId,\n\tfallbackAvatar,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tavatarFile: File | null;\n\tuserId: string;\n\tfallbackAvatar: string | null;\n}): Promise<string | null> => {\n\tif (!avatarFile) {\n\t\treturn fallbackAvatar;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\treturn await uploadAvatarForNewUser(adminClient, avatarFile, userId);\n\t} catch (avatarUploadError) {\n\t\treportAuthIssue(\"Avatar upload failed\", avatarUploadError);\n\t\treturn fallbackAvatar;\n\t}\n};\n\nconst updateUserTableRecord = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarUrl,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarUrl: string | null;\n}): Promise<AuthActionResult | null> => {\n\tconst updatePayload: Record<string, string | null> = {};\n\n\tif (name) {\n\t\tupdatePayload.name = name;\n\t}\n\tif (normalizedPhone) {\n\t\tupdatePayload.phone = normalizedPhone;\n\t}\n\tif (avatarUrl) {\n\t\tupdatePayload.avatar = avatarUrl;\n\t}\n\n\tif (Object.keys(updatePayload).length === 0) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\t\tconst { error } = await adminClient\n\t\t\t.from(\"profiles\")\n\t\t\t.update({\n\t\t\t\tfull_name: name || undefined,\n\t\t\t\tphone: normalizedPhone || undefined,\n\t\t\t\tavatar_url: avatarUrl || undefined,\n\t\t\t})\n\t\t\t.eq(\"id\", userId);\n\n\t\tif (error) {\n\t\t\treportAuthIssue(\"Failed to update user profile\", error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Failed to update your profile: ${error.message}`,\n\t\t\t};\n\t\t}\n\t} catch (profileUpdateError) {\n\t\treportAuthIssue(\"Failed to update user profile\", profileUpdateError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Failed to update your profile. Please try again.\",\n\t\t};\n\t}\n\n\treturn null;\n};\n\nconst syncUserMetadataProfile = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarUrl,\n\texistingMetadata,\n}: {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n\tname: string | null;\n\tnormalizedPhone: string | null;\n\tavatarUrl: string | null;\n\texistingMetadata?: Record<string, unknown>;\n}) => {\n\tconst hasMetadataChanges = Boolean(name || normalizedPhone || avatarUrl);\n\tif (!hasMetadataChanges) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst adminClient = await ensureServiceSupabase();\n\t\tconst metadata: Record<string, string | null> = {\n\t\t\t...(existingMetadata as Record<string, string | null>),\n\t\t};\n\n\t\tif (name) {\n\t\t\tmetadata.name = name;\n\t\t}\n\t\tif (normalizedPhone) {\n\t\t\tmetadata.phone = normalizedPhone;\n\t\t}\n\t\tif (avatarUrl) {\n\t\t\tmetadata.avatarUrl = avatarUrl;\n\t\t}\n\n\t\tif (!adminClient) {\n\t\t\tthrow new Error(\"Admin client not configured\");\n\t\t}\n\n\t\tawait adminClient.auth.admin.updateUserById(userId, {\n\t\t\tuser_metadata: metadata,\n\t\t});\n\t} catch (metadataError) {\n\t\treportAuthIssue(\"Failed to sync user metadata\", metadataError);\n\t}\n};\n\nconst updateCompleteProfileRecords = async ({\n\tensureServiceSupabase,\n\tuserId,\n\tname,\n\tnormalizedPhone,\n\tavatarFile,\n\texistingAvatar,\n\texistingMetadata,\n}: UpdateCompleteProfileRecordsParams): Promise<AuthActionResult | null> => {\n\tconst avatarUrl = await uploadAvatarWithFallback({\n\t\tensureServiceSupabase,\n\t\tavatarFile,\n\t\tuserId,\n\t\tfallbackAvatar: existingAvatar,\n\t});\n\n\tconst userUpdateResult = await updateUserTableRecord({\n\t\tensureServiceSupabase,\n\t\tuserId,\n\t\tname,\n\t\tnormalizedPhone,\n\t\tavatarUrl,\n\t});\n\n\tif (userUpdateResult) {\n\t\treturn userUpdateResult;\n\t}\n\n\tawait syncUserMetadataProfile({\n\t\tensureServiceSupabase,\n\t\tuserId,\n\t\tname,\n\t\tnormalizedPhone,\n\t\tavatarUrl,\n\t\texistingMetadata,\n\t});\n\n\treturn null;\n};\n\ntype ResolveProfileRedirectParams = {\n\tensureServiceSupabase: () => Promise<ServiceSupabaseClient>;\n\tuserId: string;\n};\n\nconst resolveProfileRedirectPath = async ({\n\tensureServiceSupabase,\n\tuserId,\n}: ResolveProfileRedirectParams): Promise<string> => {\n\tconst adminClient = await ensureServiceSupabase();\n\tif (!adminClient) {\n\t\tthrow new Error(\"Admin client not configured\");\n\t}\n\tconst { data: hasCompany } = await adminClient\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.eq(\"status\", \"active\")\n\t\t.limit(1)\n\t\t.maybeSingle();\n\n\treturn hasCompany ? \"/dashboard\" : \"/dashboard/welcome\";\n};\n// Internal return type (not exported - Next.js 16 \"use server\" restriction)\ntype AuthActionResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tdata?: Record<string, unknown>;\n};\n\n/**\n * Sign Up - Create new user account with Supabase Auth + Custom SendGrid Email\n *\n * Features:\n * - Email/password authentication\n * - Custom welcome email via SendGrid with branded template\n * - Creates user profile in users table via database trigger\n * - Validates input with Zod\n * - Disables Supabase's built-in emails (using custom SendGrid templates instead)\n */\nexport async function signUp(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst parsedForm = parseSignUpFormData(formData);\n\n\t\tawait checkRateLimit(parsedForm.validated.email, authRateLimiter);\n\n\t\tconst supabase = await requireSupabaseBrowserClient();\n\t\tconst authResult = await registerSupabaseUser({\n\t\t\tsupabase,\n\t\t\tvalidated: parsedForm.validated,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tcompanyName: parsedForm.companyName,\n\t\t});\n\n\t\tconst userId = authResult.user?.id;\n\t\tif (!userId) {\n\t\t\tthrow new Error(\"Failed to create user account\");\n\t\t}\n\n\t\tconst ensureServiceSupabase = createServiceClientLoader();\n\t\tawait syncSignUpProfile({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tname: parsedForm.validated.name,\n\t\t\tcompanyName: parsedForm.companyName,\n\t\t\tavatarFile: parsedForm.avatarFile,\n\t\t});\n\n\t\tconst postSignUpResult = await handlePostSignUpEmails({\n\t\t\temail: parsedForm.validated.email,\n\t\t\tname: parsedForm.validated.name,\n\t\t\trequiresConfirmation: !authResult.session,\n\t\t\tuserId,\n\t\t});\n\n\t\tif (postSignUpResult) {\n\t\t\treturn postSignUpResult;\n\t\t}\n\n\t\t// Revalidate and redirect to onboarding\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/dashboard\");\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Re-throw redirect errors\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Complete Profile - Update missing user information after OAuth signup\n *\n * Features:\n * - Collects missing required fields (phone, name)\n * - Optional avatar upload\n * - Updates both auth metadata and public.users table\n * - Company name is collected during onboarding, not here\n */\nexport async function completeProfile(\n\tformData: FormData,\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await requireSupabaseBrowserClient();\n\t\tconst user = await requireAuthenticatedUser(supabase);\n\t\tconst parsedForm = parseCompleteProfileForm(formData);\n\t\tconst ensureServiceSupabase = createServiceClientLoader();\n\n\t\tconst profileUpdateResult = await updateCompleteProfileRecords({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId: user.id,\n\t\t\tname: parsedForm.name,\n\t\t\tnormalizedPhone: parsedForm.normalizedPhone,\n\t\t\tavatarFile: parsedForm.avatarFile,\n\t\t\texistingAvatar:\n\t\t\t\tuser.user_metadata?.avatar_url || user.user_metadata?.picture || null,\n\t\t\texistingMetadata: user.user_metadata,\n\t\t});\n\n\t\tif (profileUpdateResult) {\n\t\t\treturn profileUpdateResult;\n\t\t}\n\n\t\tconst redirectPath = await resolveProfileRedirectPath({\n\t\t\tensureServiceSupabase,\n\t\t\tuserId: user.id,\n\t\t}).catch((redirectError) => {\n\t\t\treportAuthIssue(\"Error checking company status\", redirectError);\n\t\t\treturn \"/welcome\";\n\t\t});\n\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(redirectPath);\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign In - Authenticate existing user with Supabase Auth\n *\n * Features:\n * - Email/password authentication\n * - Session management handled by Supabase\n * - Validates input with Zod\n * - Redirects to dashboard on success\n */\nexport async function signIn(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\t// Parse and validate form data\n\t\tconst rawData = {\n\t\t\temail: formData.get(\"email\") as string,\n\t\t\tpassword: formData.get(\"password\") as string,\n\t\t};\n\n\t\tconst validatedData = signInSchema.parse(rawData);\n\n\t\t// Rate limit sign-in attempts by email\n\t\ttry {\n\t\t\tawait checkRateLimit(validatedData.email, authRateLimiter);\n\t\t} catch (rateLimitError) {\n\t\t\tif (rateLimitError instanceof RateLimitError) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitError.message,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow rateLimitError;\n\t\t}\n\n\t\t// Create Supabase client\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Authentication service is not configured. Please check your environment variables.\",\n\t\t\t};\n\t\t}\n\n\t\t// Sign in with Supabase Auth\n\t\tconst { data, error: signInError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signInWithPassword({\n\t\t\t\temail: validatedData.email,\n\t\t\t\tpassword: validatedData.password,\n\t\t\t}),\n\t\t);\n\n\t\tif (signInError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: signInError.message,\n\t\t\t};\n\t\t}\n\n\t\tif (!data.session) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to create session. Please try again.\",\n\t\t\t};\n\t\t}\n\n\t\t// Revalidate and redirect to dashboard\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/dashboard\");\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\t// Handle AuthUnknownError (usually network/service issues)\n\t\tif (caughtError instanceof AuthUnknownError) {\n\t\t\tconsole.error(\"AuthUnknownError during sign in:\", caughtError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Unable to connect to authentication service. Please check your internet connection and try again.\",\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\t// Log non-redirect errors for debugging\n\t\t\tconsole.error(\"Sign in error:\", caughtError);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign Out - End user session\n *\n * Features:\n * - Clears Supabase session (cookie-based)\n * - Clears CSRF token cookie\n * - Clears active company cookie\n * - Revalidates all cached data\n * - Redirects to login page\n *\n * Security:\n * - Ensures all authentication and security cookies are removed\n * - Prevents session reuse or CSRF attacks after logout\n */\nexport async function signOut(): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Sign out from Supabase (clears auth cookies)\n\t\tconst { error: signOutError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signOut(),\n\t\t);\n\n\t\tif (signOutError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: signOutError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Clear all security-related cookies\n\t\tawait clearCSRFToken();\n\t\tawait clearActiveCompany();\n\n\t\t// Revalidate and redirect to login\n\t\trevalidatePath(\"/\", \"layout\");\n\t\tredirect(\"/login\");\n\t} catch (caughtError) {\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Sign In with OAuth - Authenticate with Google or other providers\n *\n * Features:\n * - OAuth provider authentication\n * - Handles both new signups and existing user logins automatically\n * - Supabase determines if user exists and signs them in or creates new account\n * - Redirects to provider login page\n * - After callback, checks if profile is complete (phone, name)\n */\nexport async function signInWithOAuth(\n\tprovider: \"google\" | \"facebook\",\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\tconst siteUrl = process.env.NEXT_PUBLIC_SITE_URL;\n\t\tif (!siteUrl) {\n\t\t\tthrow new Error(\"NEXT_PUBLIC_SITE_URL is not configured\");\n\t\t}\n\n\t\tconst { data, error: oauthError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.signInWithOAuth({\n\t\t\t\tprovider,\n\t\t\t\toptions: {\n\t\t\t\t\tredirectTo: `${siteUrl}/auth/callback`,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\tif (oauthError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: oauthError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Redirect to OAuth provider\n\t\tif (data.url) {\n\t\t\tredirect(data.url);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t} catch (caughtError) {\n\t\tif (\n\t\t\tcaughtError instanceof Error &&\n\t\t\tcaughtError.message !== \"NEXT_REDIRECT\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.message,\n\t\t\t};\n\t\t}\n\n\t\tthrow caughtError;\n\t}\n}\n\n/**\n * Forgot Password - Send custom password reset email via SendGrid\n *\n * Features:\n * - Sends custom branded password reset email via SendGrid\n * - Secure token generation via Supabase\n * - Custom email template with security information\n */\nasync function forgotPassword(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst rawData = {\n\t\t\temail: formData.get(\"email\") as string,\n\t\t};\n\n\t\tconst validatedData = forgotPasswordSchema.parse(rawData);\n\n\t\t// Rate limit password reset requests by email (stricter limit)\n\t\ttry {\n\t\t\tawait checkRateLimit(validatedData.email, passwordResetRateLimiter);\n\t\t} catch (rateLimitError) {\n\t\t\tif (rateLimitError instanceof RateLimitError) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: rateLimitError.message,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow rateLimitError;\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Generate password reset token via Supabase\n\t\tconst { error: resetPasswordError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.resetPasswordForEmail(validatedData.email, {\n\t\t\t\tredirectTo: `${sendgridConfig.siteUrl}/auth/reset-password`,\n\t\t\t}),\n\t\t);\n\n\t\tif (resetPasswordError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: resetPasswordError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Note: Supabase will send its own email with the reset link.\n\t\t// To use custom SendGrid email instead, you need to:\n\t\t// 1. Disable Supabase's password reset email in the dashboard\n\t\t// 2. Generate your own secure token\n\t\t// 3. Send custom email with that token\n\t\t// For now, we're using Supabase's reset flow but you can customize this\n\n\t\t// TODO: Replace with custom token generation + SendGrid email\n\t\t// For full custom implementation, see the commented code below:\n\t\t/*\n    const resetToken = generateSecureToken(); // Implement your own token generation\n    await storeResetToken(validatedData.email, resetToken); // Store in your database\n\n    await sendPasswordReset(validatedData.email, {\n      resetUrl: `${sendgridConfig.siteUrl}/auth/reset-password?token=${resetToken}`,\n      expiresInMinutes: 60,\n    });\n    */\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"Password reset email sent. Please check your inbox.\",\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to send reset email\",\n\t\t};\n\t}\n}\n\n/**\n * Reset Password - Update password with reset token + Send confirmation email\n *\n * Features:\n * - Updates user password\n * - Validates password strength\n * - Invalidates reset token after use\n * - Sends custom password changed confirmation via SendGrid\n */\nasync function resetPassword(formData: FormData): Promise<AuthActionResult> {\n\ttry {\n\t\t// Bot protection check (Vercel BotID)\n\t\t/*\n\t\tconst botCheck = await checkBotId();\n\t\tif (botCheck.isBot) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Unable to process request. Please try again later.\",\n\t\t\t};\n\t\t}\n\t\t*/\n\n\t\tconst rawData = {\n\t\t\tpassword: formData.get(\"password\") as string,\n\t\t\tconfirmPassword: formData.get(\"confirmPassword\") as string,\n\t\t};\n\n\t\tconst validatedData = resetPasswordSchema.parse(rawData);\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Get current user before updating password\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\t\tconst { error: updateUserError } = await withSupabaseRateLimitRetry(() =>\n\t\t\tsupabase.auth.updateUser({\n\t\t\t\tpassword: validatedData.password,\n\t\t\t}),\n\t\t);\n\n\t\tif (updateUserError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: updateUserError.message,\n\t\t\t};\n\t\t}\n\n\t\t// Send password changed confirmation email via SendGrid\n\t\tif (user?.email) {\n\t\t\tconst emailResult = await sendPasswordChanged(user.email, {\n\t\t\t\tname: user.user_metadata?.name || \"User\",\n\t\t\t\tchangedAt: new Date(),\n\t\t\t});\n\n\t\t\t// Log email send failure but don't block password reset\n\t\t\tif (!emailResult.success) {\n\t\t\t\treportAuthIssue(\n\t\t\t\t\t\"Failed to send password changed email\",\n\t\t\t\t\temailResult.error,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage:\n\t\t\t\t\t\"Password updated successfully. A confirmation email has been sent.\",\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\tif (caughtError instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: caughtError.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to reset password\",\n\t\t};\n\t}\n}\n\n/**\n * Get Current User - Retrieve authenticated user data\n *\n * Features:\n * - Returns user session data\n * - Returns null if not authenticated\n * - Can be used in Server Components\n */\nasync function getCurrentUser() {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getUser());\n\n\t\treturn user;\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error getting current user\", caughtError);\n\t\treturn null;\n\t}\n}\n\n/**\n * Get Session - Retrieve current session\n *\n * Features:\n * - Returns session data including access token\n * - Returns null if no active session\n * - Can be used in Server Components\n */\nasync function getSession() {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { session },\n\t\t} = await withSupabaseRateLimitRetry(() => supabase.auth.getSession());\n\n\t\treturn session;\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error getting session\", caughtError);\n\t\treturn null;\n\t}\n}\n\n/**\n * Verify Email - Verify user's email with custom token\n *\n * Features:\n * - Validates custom verification token\n * - Updates Supabase user's email_confirmed_at\n * - One-time use tokens with expiration\n * - Sends welcome email after successful verification\n */\nexport async function verifyEmail(token: string): Promise<AuthActionResult> {\n\ttry {\n\t\t// Verify and consume the token\n\t\tconst tokenRecord = await verifyAndConsumeToken(\n\t\t\ttoken,\n\t\t\t\"email_verification\",\n\t\t);\n\n\t\tif (!tokenRecord) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror:\n\t\t\t\t\t\"Invalid or expired verification link. Please request a new one.\",\n\t\t\t};\n\t\t}\n\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Update Supabase user to mark email as verified\n\t\tif (tokenRecord.userId) {\n\t\t\t// Note: profiles table doesn't have email_verified field\n\t\t\t// Email verification is handled through auth.users.email_confirmed_at\n\t\t\t// which is set automatically by Supabase Auth\n\t\t\t// We don't need to manually update profiles table\n\n\t\t\t// Send welcome email after successful verification\n\t\t\tconst welcomeResult = await sendWelcomeEmail(tokenRecord.email, {\n\t\t\t\tname: getMetadataString(tokenRecord.metadata, \"name\") || \"User\",\n\t\t\t\tloginUrl: `${sendgridConfig.siteUrl}/login`,\n\t\t\t});\n\n\t\t\tif (!welcomeResult.success) {\n\t\t\t\treportAuthIssue(\"Failed to send welcome email\", welcomeResult.error);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"Email verified successfully! You can now sign in.\",\n\t\t\t\temail: tokenRecord.email,\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error verifying email\", caughtError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to verify email\",\n\t\t};\n\t}\n}\n\n/**\n * Resend Verification Email - Send a new verification email\n *\n * Features:\n * - Generates new verification token\n * - Deletes old tokens for the email\n * - Sends fresh verification email\n */\nasync function resendVerificationEmail(\n\temail: string,\n): Promise<AuthActionResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Authentication service is not configured.\",\n\t\t\t};\n\t\t}\n\n\t\t// Check if user exists\n\t\tconst { data: userData } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"id, full_name, email\")\n\t\t\t.eq(\"email\", email)\n\t\t\t.single();\n\n\t\tif (!userData) {\n\t\t\t// Don't reveal if user exists or not for security\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t\"If an account exists with this email, a verification link has been sent.\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t// Generate new verification token\n\t\tconst { token, expiresAt } = await createEmailVerificationToken(\n\t\t\temail,\n\t\t\tuserData.id,\n\t\t\tCONFIRMATION_TOKEN_TTL_HOURS,\n\t\t);\n\n\t\t// Send verification email\n\t\tconst verificationUrl = `${sendgridConfig.siteUrl}/auth/verify-email?token=${token}`;\n\n\t\tconst emailResult = await sendEmailVerification(email, {\n\t\t\tname: userData.full_name || \"User\",\n\t\t\tverificationUrl,\n\t\t});\n\n\t\tif (!emailResult.success) {\n\t\t\treportAuthIssue(\"Failed to send verification email\", emailResult.error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to send verification email. Please try again.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tmessage: \"A new verification link has been sent to your email.\",\n\t\t\t\texpiresAt: expiresAt.toISOString(),\n\t\t\t},\n\t\t};\n\t} catch (caughtError) {\n\t\treportAuthIssue(\"Error resending verification email\", caughtError);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror:\n\t\t\t\tcaughtError instanceof Error\n\t\t\t\t\t? caughtError.message\n\t\t\t\t\t: \"Failed to resend verification email\",\n\t\t};\n\t}\n}\n\n/**\n * Get Active Company ID Action\n *\n * Server action to get the currently active company ID for client components.\n */\nexport async function getCompanyIdAction(): Promise<{\n\tsuccess: boolean;\n\tcompanyId?: string;\n\terror?: string;\n}> {\n\t\"use server\";\n\n\ttry {\n\t\tconst { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n\t\tconst companyId = await getActiveCompanyId();\n\n\t\tif (!companyId) {\n\t\t\treturn { success: false, error: \"No active company found\" };\n\t\t}\n\n\t\treturn { success: true, companyId };\n\t} catch (error) {\n\t\tconsole.error(\"Error getting company ID:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":"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"}