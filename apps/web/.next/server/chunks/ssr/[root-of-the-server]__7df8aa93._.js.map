{"version":3,"sources":["../../../../../../apps/web/src/lib/communication/sms-service.ts","../../../../../../apps/web/src/actions/sms-actions.ts","../../../../../../apps/web/src/actions/entity-tags.ts","../../../../../../apps/web/src/lib/payments/processor.ts","../../../../../../apps/web/src/lib/payments/stripe-server.ts","../../../../../../apps/web/src/actions/payment-methods.ts","../../../../../../apps/web/src/actions/payments.ts"],"sourcesContent":["/**\n * SMS Service\n * \n * Handles fetching and managing SMS messages from the communications table\n * Similar structure to email-service.ts but for SMS type communications\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type { TypedSupabaseClient } from \"@/types/supabase\";\n\nexport type CompanySms = {\n\tid: string;\n\tfrom_address: string | null;\n\tfrom_name: string | null;\n\tto_address: string | null;\n\tbody: string;\n\tbody_html: string | null;\n\tcreated_at: string;\n\tread_at: string | null;\n\tdirection: \"inbound\" | \"outbound\";\n\tcustomer_id: string | null;\n\tcustomer?: {\n\t\tid: string;\n\t\tfirst_name: string | null;\n\t\tlast_name: string | null;\n\t\tdisplay_name: string | null;\n\t\temail: string | null;\n\t\tphone: string | null;\n\t\tcompany_name: string | null;\n\t} | null;\n\tsent_at: string | null;\n\tdelivered_at: string | null;\n\tstatus: string;\n\tchannel: string | null;\n\tprovider_metadata: Record<string, unknown> | null;\n\tis_archived: boolean;\n\tsnoozed_until: string | null;\n\tcategory: string | null;\n\ttags: string[] | null;\n\ttelnyx_message_id: string | null;\n};\n\nexport type GetCompanySmsInput = {\n\tlimit?: number;\n\toffset?: number;\n\ttype?: \"sent\" | \"received\" | \"all\";\n\tfolder?: \"inbox\" | \"sent\" | \"archive\" | \"trash\" | \"bin\";\n\tlabel?: string;\n\tsearch?: string | null;\n\tsortBy?: \"created_at\" | \"sent_at\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\nexport type GetCompanySmsResult = {\n\tsms: CompanySms[];\n\ttotal: number;\n\thasMore: boolean;\n};\n\nexport async function getCompanySms(\n\tcompanyId: string,\n\tinput: GetCompanySmsInput = {},\n): Promise<GetCompanySmsResult> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tconst {\n\t\tlimit = 50,\n\t\toffset = 0,\n\t\ttype = \"all\",\n\t\tfolder,\n\t\tlabel,\n\t\tsearch,\n\t\tsortBy = \"created_at\",\n\t\tsortOrder = \"desc\",\n\t} = input;\n\n\t// Build the query - get all SMS messages\n\tlet query = supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t\t{ count: \"exact\" },\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\");\n\n\t// Apply folder filtering\n\tif (folder) {\n\t\tswitch (folder) {\n\t\t\tcase \"inbox\":\n\t\t\t\t// Inbox: inbound, not archived, not deleted, not snoozed (or snooze expired)\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"inbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.or(\"snoozed_until.is.null,snoozed_until.lt.now()\");\n\t\t\t\tbreak;\n\t\t\tcase \"sent\":\n\t\t\t\t// Sent: outbound, not archived, not deleted\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"outbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"archive\":\n\t\t\t\t// Archive: is_archived = true, not deleted\n\t\t\t\tquery = query.eq(\"is_archived\", true).is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"trash\":\n\t\t\tcase \"bin\":\n\t\t\t\t// Trash: deleted_at is not null\n\t\t\t\tquery = query.not(\"deleted_at\", \"is\", null);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Custom folder or label filtering - done in memory after fetch\n\t\t\t\t// (JSONB array containment not supported by PostgREST cs operator)\n\t\t\t\tquery = query.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t// Default: exclude deleted SMS\n\t\tquery = query.is(\"deleted_at\", null);\n\t}\n\n\t// Apply direction filter\n\tif (type === \"sent\") {\n\t\tquery = query.eq(\"direction\", \"outbound\");\n\t} else if (type === \"received\") {\n\t\tquery = query.eq(\"direction\", \"inbound\");\n\t}\n\n\t// Apply search filter\n\tif (search) {\n\t\tconst searchLower = search.toLowerCase();\n\t\tquery = query.or(\n\t\t\t`from_address.ilike.%${searchLower}%,to_address.ilike.%${searchLower}%,body.ilike.%${searchLower}%`,\n\t\t);\n\t}\n\n\t// Apply sorting\n\tconst ascending = sortOrder === \"asc\";\n\tif (sortBy === \"sent_at\") {\n\t\tquery = query.order(\"sent_at\", { ascending, nullsFirst: false });\n\t} else {\n\t\tquery = query.order(\"created_at\", { ascending });\n\t}\n\n\t// Apply pagination\n\tquery = query.range(offset, offset + limit - 1);\n\n\tconst { data, error, count } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS messages:\", error);\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tlet sms = (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n\n\t// Post-process custom folder/label filtering (JSONB array containment not supported by PostgREST)\n\tconst standardFolders = [\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"];\n\tconst folderName = label || folder;\n\tif (folderName && !standardFolders.includes(folderName)) {\n\t\tsms = sms.filter((msg) => {\n\t\t\tconst msgTags = msg.tags || [];\n\t\t\treturn Array.isArray(msgTags) && msgTags.includes(folderName);\n\t\t});\n\t\treturn {\n\t\t\tsms,\n\t\t\ttotal: sms.length,\n\t\t\thasMore: false,\n\t\t};\n\t}\n\n\tconst total = count || 0;\n\tconst hasMore = offset + sms.length < total;\n\n\treturn {\n\t\tsms,\n\t\ttotal,\n\t\thasMore,\n\t};\n}\n\nexport async function getSmsById(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<CompanySms | null> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\t...data,\n\t\ttags: (data.tags as string[]) || null,\n\t\tprovider_metadata: (data.provider_metadata as Record<string, unknown>) || null,\n\t} as CompanySms;\n}\n\nexport async function markSmsAsRead(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tconsole.error(\"❌ markSmsAsRead: Missing supabase\");\n\t\treturn false;\n\t}\n\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.select(\"id, read_at\")\n\t\t.single();\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tif (!data) {\n\t\tconsole.error(\"❌ markSmsAsRead: No data returned\");\n\t\treturn false;\n\t}\n\n\tconsole.log(\"✅ markSmsAsRead success:\", { smsId, read_at: data.read_at });\n\treturn true;\n}\n\n/**\n * Get all SMS messages for a conversation thread (by phone number)\n */\nexport async function getSmsConversation(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<CompanySms[]> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn [];\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Fetch all messages where this phone number is either from or to\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.order(\"created_at\", { ascending: true });\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS conversation:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsRead(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn false;\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Mark all unread inbound messages in this conversation as read\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.eq(\"direction\", \"inbound\")\n\t\t.is(\"read_at\", null)\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.select(\"id, read_at\");\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsConversationAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tconsole.log(`✅ markSmsConversationAsRead success: Marked ${data?.length || 0} messages as read`);\n\treturn true;\n}\n\n","\"use server\";\n\nimport {\n    getCompanySms,\n    getSmsById,\n    markSmsAsRead,\n    markSmsConversationAsRead,\n    type CompanySms,\n} from \"@/lib/communication/sms-service\";\nimport { z } from \"zod\";\n\nconst getSmsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  folder: z.enum([\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst markSmsReadSchema = z.object({\n  smsId: z.string().min(1),\n});\n\nexport type GetSmsInput = z.infer<typeof getSmsSchema>;\nexport type MarkSmsReadInput = z.infer<typeof markSmsReadSchema>;\n\n// Re-export SMS types from sms-service\nexport type { CompanySms };\n\nexport type GetSmsResult = Awaited<ReturnType<typeof getCompanySms>>;\n\n/**\n * Get SMS messages for the active company\n */\nexport async function getSmsAction(\n  input: GetSmsInput\n): Promise<GetSmsResult> {\n  try {\n    const parseResult = getSmsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      throw new Error(`Invalid input parameters: ${parseResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getCompanySms(companyId, validatedInput);\n  } catch (error) {\n    console.error(\"❌ getSmsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get a specific SMS by ID\n */\nexport async function getSmsByIdAction(smsId: string): Promise<{\n  success: boolean;\n  sms?: CompanySms;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const sms = await getSmsById(companyId, smsId);\n    \n    if (!sms) {\n      return { success: false, error: \"SMS not found\" };\n    }\n\n    return { success: true, sms };\n  } catch (error) {\n    console.error(\"Error getting SMS by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an SMS as read\n */\nexport async function markSmsAsReadAction(\n  input: MarkSmsReadInput\n): Promise<boolean> {\n  try {\n    const validatedInput = markSmsReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"Invalid input parameters\");\n    }\n\n    return await markSmsAsRead(companyId, validatedInput.smsId);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsReadAction(phoneNumber: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const success = await markSmsConversationAsRead(companyId, phoneNumber);\n    return { success };\n  } catch (error) {\n    console.error(\"Error marking SMS conversation as read:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS conversation thread by phone number\n */\nexport async function getSmsConversationAction(phoneNumber: string): Promise<{\n  success: boolean;\n  messages?: CompanySms[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getSmsConversation } = await import(\"@/lib/sms/sms-service\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const messages = await getSmsConversation(companyId, phoneNumber);\n    return { success: true, messages };\n  } catch (error) {\n    console.error(\"Error fetching SMS conversation:\", error);\n    // Handle cookies() error gracefully\n    if (error instanceof Error && error.message.includes(\"cookies\")) {\n      return {\n        success: false,\n        error: \"Request context not available. Please refresh the page.\",\n      };\n    }\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS folder counts\n */\nexport async function getSmsFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    inbox: number;\n    sent: number;\n    archive: number;\n    trash: number;\n    [label: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const baseQuery = supabase\n      .from(\"communications\")\n      .select(\"*\", { count: \"exact\", head: true })\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"sms\");\n    \n    // Get counts for each folder\n    const [inboxResult, sentResult, archiveResult, trashResult] = await Promise.all([\n      // Inbox\n      baseQuery\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n      // Sent\n      baseQuery\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null),\n      // Archive\n      baseQuery.eq(\"is_archived\", true).is(\"deleted_at\", null),\n      // Trash\n      baseQuery.not(\"deleted_at\", \"is\", null),\n    ]);\n    \n    const counts = {\n      inbox: inboxResult.count || 0,\n      sent: sentResult.count || 0,\n      archive: archiveResult.count || 0,\n      trash: trashResult.count || 0,\n    };\n    \n    return { success: true, counts };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Upload SMS attachments to storage\n */\nexport async function uploadSmsAttachments(\n  files: File[]\n): Promise<{\n  success: boolean;\n  urls?: string[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const supabase = await createClient();\n    \n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const urls: string[] = [];\n    \n      // Upload each file to Supabase Storage\n      // Use company-files bucket which has proper RLS policies for company members\n      for (const file of files) {\n        const fileExt = file.name.split('.').pop();\n        const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;\n        // Path structure: companyId must be at index [0] for RLS policy (matches document-manager pattern)\n        // Format: companyId/folder/filename (storage.foldername(name))[0] = companyId\n        const filePath = `${companyId}/sms-attachments/${fileName}`;\n        \n        // Convert file to array buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const { data, error: uploadError } = await supabase.storage\n          .from('company-files') // Use company-files bucket with proper RLS\n          .upload(filePath, arrayBuffer, {\n            contentType: file.type,\n            upsert: false,\n          });\n        \n        if (uploadError) {\n          console.error(\"Upload error:\", uploadError);\n          return { success: false, error: `Failed to upload ${file.name}: ${uploadError.message}` };\n        }\n        \n        // Get public URL (or signed URL for private bucket)\n        const { data: { publicUrl } } = supabase.storage\n          .from('company-files')\n          .getPublicUrl(filePath);\n        \n        urls.push(publicUrl);\n      }\n    \n    return { success: true, urls };\n  } catch (error) {\n    console.error(\"Error uploading SMS attachments:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * SMS Template Context Type\n * Data available for auto-filling SMS templates\n */\nexport type SmsTemplateContext = {\n  companyName?: string;\n  companyPhone?: string;\n  companyEmail?: string;\n};\n\n/**\n * Get company context for SMS templates\n * Returns company info for auto-filling template messages\n */\nexport async function getCompanyContextAction(): Promise<{\n  success: boolean;\n  context?: SmsTemplateContext;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { getActiveCompany } = await import(\"@/lib/auth/company-context\");\n\n    const company = await getActiveCompany();\n    if (!company) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    return {\n      success: true,\n      context: {\n        companyName: company.name,\n        companyPhone: company.phone || undefined,\n        companyEmail: company.email || undefined,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting company context:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n","/**\n * Entity Tags Actions - Server Actions\n * Generic tag management for any entity type\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { withErrorHandling } from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nexport type TagWithColor = {\n\tlabel: string;\n\tcolor?: string;\n};\n\nexport type EntityTag = string | TagWithColor;\n\ntype EntityType =\n\t| \"customer\"\n\t| \"job\"\n\t| \"property\"\n\t| \"invoice\"\n\t| \"estimate\"\n\t| \"equipment\"\n\t| \"appointment\"\n\t| \"material\"\n\t| \"vendor\";\n\nconst ENTITY_TAG_FIELD_MAP: Record<\n\tEntityType,\n\t{ table: string; field: string; useMetadata: boolean }\n> = {\n\tcustomer: { table: \"customers\", field: \"tags\", useMetadata: false },\n\tjob: { table: \"jobs\", field: \"metadata\", useMetadata: true },\n\tproperty: { table: \"properties\", field: \"metadata\", useMetadata: true },\n\tinvoice: { table: \"invoices\", field: \"metadata\", useMetadata: true },\n\testimate: { table: \"estimates\", field: \"metadata\", useMetadata: true },\n\tequipment: { table: \"equipment\", field: \"metadata\", useMetadata: true },\n\tappointment: { table: \"appointments\", field: \"metadata\", useMetadata: true },\n\tmaterial: { table: \"job_materials\", field: \"metadata\", useMetadata: true },\n\tvendor: { table: \"vendors\", field: \"tags\", useMetadata: false },\n};\n\n/**\n * Update tags for any entity type\n */\nexport async function updateEntityTags(\n\tentityType: EntityType,\n\tentityId: string,\n\ttags: EntityTag[],\n) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst typedSupabase = supabase as SupabaseServerClient;\n\t\tawait requireAuthenticatedUser(typedSupabase);\n\n\t\tconst config = ENTITY_TAG_FIELD_MAP[entityType];\n\t\tif (!config) {\n\t\t\tthrow new Error(`Unsupported entity type: ${entityType}`);\n\t\t}\n\n\t\tconst updateData = await buildTagsUpdateData({\n\t\t\tsupabase: typedSupabase,\n\t\t\tconfig,\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\ttags,\n\t\t});\n\n\t\tawait applyTagUpdate({\n\t\t\tsupabase: typedSupabase,\n\t\t\tconfig,\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\tupdateData,\n\t\t});\n\n\t\trevalidateEntityPaths(entityType, entityId);\n\n\t\treturn { entityId, entityType, tags };\n\t});\n}\n\n/**\n * Get the base path for an entity type\n */\nfunction getPathForEntity(entityType: EntityType): string | null {\n\tconst pathMap: Record<EntityType, string | null> = {\n\t\tcustomer: \"customers\",\n\t\tjob: \"work\",\n\t\tproperty: \"work/properties\",\n\t\tinvoice: \"work/invoices\",\n\t\testimate: \"work/estimates\",\n\t\tequipment: \"work/equipment\",\n\t\tappointment: \"schedule\",\n\t\tmaterial: null,\n\t\tvendor: \"work/vendors\",\n\t};\n\treturn pathMap[entityType] ?? null;\n}\n\nconst requireAuthenticatedUser = async (supabase: SupabaseServerClient) => {\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tif (!user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\treturn user;\n};\n\ntype TagUpdateConfig = (typeof ENTITY_TAG_FIELD_MAP)[EntityType];\n\ntype BuildTagsUpdateDataParams = {\n\tsupabase: SupabaseServerClient;\n\tconfig: TagUpdateConfig;\n\tentityId: string;\n\tentityType: EntityType;\n\ttags: EntityTag[];\n};\n\nconst buildTagsUpdateData = async ({\n\tsupabase,\n\tconfig,\n\tentityId,\n\tentityType,\n\ttags,\n}: BuildTagsUpdateDataParams): Promise<Record<string, unknown>> => {\n\tif (!config.useMetadata) {\n\t\treturn {\n\t\t\ttags,\n\t\t\tupdated_at: new Date().toISOString(),\n\t\t};\n\t}\n\n\tconst { data: existingRecord, error: fetchError } = await supabase\n\t\t.from(config.table)\n\t\t.select(\"metadata\")\n\t\t.eq(\"id\", entityId)\n\t\t.single();\n\n\tif (fetchError) {\n\t\tthrow new Error(\n\t\t\t`Failed to load ${entityType} metadata: ${fetchError.message}`,\n\t\t);\n\t}\n\n\tconst existingMetadata =\n\t\texistingRecord &&\n\t\ttypeof existingRecord.metadata === \"object\" &&\n\t\texistingRecord.metadata !== null\n\t\t\t? (existingRecord.metadata as Record<string, unknown>)\n\t\t\t: {};\n\n\treturn {\n\t\tmetadata: {\n\t\t\t...existingMetadata,\n\t\t\ttags,\n\t\t},\n\t\tupdated_at: new Date().toISOString(),\n\t};\n};\n\ntype ApplyTagUpdateParams = {\n\tsupabase: SupabaseServerClient;\n\tconfig: TagUpdateConfig;\n\tentityId: string;\n\tentityType: EntityType;\n\tupdateData: Record<string, unknown>;\n};\n\nconst applyTagUpdate = async ({\n\tsupabase,\n\tconfig,\n\tentityId,\n\tentityType,\n\tupdateData,\n}: ApplyTagUpdateParams) => {\n\tconst { error } = await supabase\n\t\t.from(config.table)\n\t\t.update(updateData)\n\t\t.eq(\"id\", entityId);\n\n\tif (error) {\n\t\tthrow new Error(`Failed to update ${entityType} tags: ${error.message}`);\n\t}\n};\n\nconst revalidateEntityPaths = (entityType: EntityType, entityId: string) => {\n\tconst basePath = getPathForEntity(entityType);\n\tif (basePath) {\n\t\trevalidatePath(`/dashboard/${basePath}/${entityId}`);\n\t\trevalidatePath(`/dashboard/${basePath}`);\n\t}\n\n\trevalidatePath(\"/dashboard\");\n};\n","/**\n * Payment Processor Abstraction Layer\n *\n * Provides a unified interface for multiple payment processors:\n * - Stripe: For platform billing (subscriptions)\n * - Adyen: For high-value contractor payments (card-present, ACH)\n * - Plaid: For bank account linking and ACH\n * - ProfitStars: For ACH/check processing\n *\n * This abstraction allows contractors to process high-value payments\n * without Stripe's limitations while maintaining a consistent API.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type {\n\tPaymentChannel,\n\tPaymentProcessor,\n\tPaymentProcessorConfig,\n\tPaymentProcessorType,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n} from \"./processor-types\";\n\n// Re-export all types to maintain API compatibility\nexport type {\n\tPaymentProcessorType,\n\tPaymentChannel,\n\tPaymentProcessorConfig,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n\tPaymentProcessor,\n};\n\n/**\n * Get the appropriate payment processor for a company\n *\n * Determines which processor to use based on:\n * 1. Company's configured processor\n * 2. Payment amount (high-value payments use Adyen)\n * 3. Payment channel (card-present uses Adyen, ACH uses Plaid/ProfitStars)\n */\nexport async function getPaymentProcessor(\n\tcompanyId: string,\n\toptions?: {\n\t\tamount?: number;\n\t\tchannel?: PaymentChannel;\n\t\tforceProcessor?: PaymentProcessorType;\n\t},\n): Promise<PaymentProcessor | null> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\t// Check if company has at least one bank account (required for payments)\n\tconst { data: bankAccounts } = await supabase\n\t\t.from(\"finance_bank_accounts\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"is_active\", true)\n\t\t.limit(1);\n\n\tif (!bankAccounts || bankAccounts.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Get company's payment processor configuration\n\tconst { data: processors } = await supabase\n\t\t.from(\"company_payment_processors\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (!processors || processors.length === 0) {\n\t\treturn null;\n\t}\n\n\t// If force processor specified, use it\n\tif (options?.forceProcessor) {\n\t\tconst processor = processors.find(\n\t\t\t(p) => p.processor_type === options.forceProcessor,\n\t\t);\n\t\tif (processor) {\n\t\t\treturn createProcessorInstance(processor);\n\t\t}\n\t}\n\n\t// Determine processor based on payment characteristics\n\tconst amount = options?.amount || 0;\n\tconst channel = options?.channel || \"online\";\n\n\t// High-value payments (>$10k) should use Adyen\n\tif (\n\t\tamount > 1_000_000 &&\n\t\tprocessors.some((p) => p.processor_type === \"adyen\")\n\t) {\n\t\tconst adyenProcessor = processors.find((p) => p.processor_type === \"adyen\");\n\t\tif (adyenProcessor) {\n\t\t\treturn createProcessorInstance(adyenProcessor);\n\t\t}\n\t}\n\n\t// Card-present or tap-to-pay should use Adyen\n\tif (\n\t\t(channel === \"card_present\" || channel === \"tap_to_pay\") &&\n\t\tprocessors.some((p) => p.processor_type === \"adyen\")\n\t) {\n\t\tconst adyenProcessor = processors.find((p) => p.processor_type === \"adyen\");\n\t\tif (adyenProcessor) {\n\t\t\treturn createProcessorInstance(adyenProcessor);\n\t\t}\n\t}\n\n\t// ACH payments should use Plaid or ProfitStars\n\tif (channel === \"ach\") {\n\t\tconst plaidProcessor = processors.find((p) => p.processor_type === \"plaid\");\n\t\tif (plaidProcessor) {\n\t\t\treturn createProcessorInstance(plaidProcessor);\n\t\t}\n\t\tconst profitstarsProcessor = processors.find(\n\t\t\t(p) => p.processor_type === \"profitstars\",\n\t\t);\n\t\tif (profitstarsProcessor) {\n\t\t\treturn createProcessorInstance(profitstarsProcessor);\n\t\t}\n\t}\n\n\t// Default to first active processor\n\treturn createProcessorInstance(processors[0]);\n}\n\n/**\n * Create a processor instance from database configuration\n */\nasync function createProcessorInstance(\n\tconfig: any,\n): Promise<PaymentProcessor | null> {\n\tswitch (config.processor_type) {\n\t\tcase \"adyen\": {\n\t\t\tconst { AdyenProcessor } = await import(\"./processors/adyen\");\n\t\t\treturn new AdyenProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\taccountId: config.adyen_account_id,\n\t\t\t\tapiKey: config.adyen_api_key_encrypted, // Will need decryption\n\t\t\t\tmerchantAccount: config.adyen_merchant_account,\n\t\t\t\tliveMode: config.adyen_live_mode,\n\t\t\t});\n\t\t}\n\t\tcase \"plaid\": {\n\t\t\tconst { PlaidProcessor } = await import(\"./processors/plaid\");\n\t\t\treturn new PlaidProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tclientId: config.plaid_client_id,\n\t\t\t\tsecret: config.plaid_secret_encrypted, // Will need decryption\n\t\t\t\tenvironment: config.plaid_environment || \"sandbox\",\n\t\t\t});\n\t\t}\n\t\tcase \"profitstars\": {\n\t\t\tconst { ProfitStarsProcessor } = await import(\"./processors/profitstars\");\n\t\t\treturn new ProfitStarsProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tmerchantId: config.profitstars_merchant_id,\n\t\t\t\tapiKey: config.profitstars_api_key_encrypted, // Will need decryption\n\t\t\t\troutingNumber: config.profitstars_routing_number,\n\t\t\t});\n\t\t}\n\t\tcase \"stripe\": {\n\t\t\tconst { StripeProcessor } = await import(\"./processors/stripe\");\n\t\t\treturn new StripeProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tliveMode: config.adyen_live_mode,\n\t\t\t});\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Calculate trust score for a payment\n *\n * Higher trust scores allow larger payments without flagging\n */\nexport async function calculatePaymentTrustScore(\n\tcompanyId: string,\n\tamount: number,\n): Promise<{\n\tscore: number;\n\tallowed: boolean;\n\trequiresApproval: boolean;\n\treason?: string;\n}> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn {\n\t\t\tscore: 0,\n\t\t\tallowed: false,\n\t\t\trequiresApproval: true,\n\t\t\treason: \"Database unavailable\",\n\t\t};\n\t}\n\n\t// Get company's trust score\n\tconst { data: trustScore } = await supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!trustScore) {\n\t\treturn {\n\t\t\tscore: 50,\n\t\t\tallowed: false,\n\t\t\trequiresApproval: true,\n\t\t\treason: \"No trust score found\",\n\t\t};\n\t}\n\n\tconst score = Number(trustScore.overall_score);\n\n\t// Get processor configuration\n\tconst { data: processor } = await supabase\n\t\t.from(\"company_payment_processors\")\n\t\t.select(\"max_payment_amount, requires_approval_above\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.single();\n\n\tconst maxAmount = processor?.max_payment_amount || 100_000; // Default $1,000\n\tconst approvalThreshold = processor?.requires_approval_above || 50_000; // Default $500\n\n\t// Calculate if payment is allowed based on trust score\n\t// Trust score 90+: Allow up to configured max\n\t// Trust score 70-89: Allow up to 50% of max\n\t// Trust score 50-69: Allow up to 25% of max\n\t// Trust score <50: Require approval for any payment > $100\n\n\tlet allowedAmount = maxAmount;\n\tif (score >= 90) {\n\t\tallowedAmount = maxAmount;\n\t} else if (score >= 70) {\n\t\tallowedAmount = Math.floor(maxAmount * 0.5);\n\t} else if (score >= 50) {\n\t\tallowedAmount = Math.floor(maxAmount * 0.25);\n\t} else {\n\t\tallowedAmount = 10_000; // $100 minimum\n\t}\n\n\tconst allowed = amount <= allowedAmount;\n\tconst requiresApproval = amount > approvalThreshold || score < 70;\n\n\treturn {\n\t\tscore,\n\t\tallowed,\n\t\trequiresApproval,\n\t\treason: allowed\n\t\t\t? requiresApproval\n\t\t\t\t? \"Payment requires manual approval\"\n\t\t\t\t: undefined\n\t\t\t: `Payment amount exceeds allowed limit for trust score. Max allowed: $${allowedAmount / 100}`,\n\t};\n}\n\n/**\n * Update trust score after payment\n */\nexport async function updateTrustScoreAfterPayment(\n\tcompanyId: string,\n\tsuccess: boolean,\n\tamount: number,\n): Promise<void> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn;\n\t}\n\n\tconst { data: trustScore } = await supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!trustScore) {\n\t\treturn;\n\t}\n\n\t// Update metrics\n\tconst updates: any = {\n\t\ttotal_payments_count: (trustScore.total_payments_count || 0) + 1,\n\t\ttotal_payments_volume: (trustScore.total_payments_volume || 0) + amount,\n\t\tlast_calculated_at: new Date().toISOString(),\n\t};\n\n\tif (success) {\n\t\tupdates.successful_payments_count =\n\t\t\t(trustScore.successful_payments_count || 0) + 1;\n\t} else {\n\t\tupdates.failed_payments_count = (trustScore.failed_payments_count || 0) + 1;\n\t}\n\n\t// Update largest payment\n\tif (amount > (trustScore.largest_payment_amount || 0)) {\n\t\tupdates.largest_payment_amount = amount;\n\t}\n\n\t// Recalculate overall score\n\tconst totalPayments = updates.total_payments_count;\n\tconst successfulPayments =\n\t\tupdates.successful_payments_count ||\n\t\ttrustScore.successful_payments_count ||\n\t\t0;\n\tconst _failedPayments =\n\t\tupdates.failed_payments_count || trustScore.failed_payments_count || 0;\n\n\t// Success rate (0-100)\n\tconst successRate =\n\t\ttotalPayments > 0 ? (successfulPayments / totalPayments) * 100 : 50;\n\n\t// Volume factor (higher volume = higher trust, capped at 100)\n\tconst volumeFactor = Math.min(\n\t\t100,\n\t\tMath.log10((updates.total_payments_volume || 0) / 100 + 1) * 20,\n\t);\n\n\t// Account age factor (older accounts = higher trust)\n\tconst accountAgeDays = trustScore.account_age_days || 0;\n\tconst ageFactor = Math.min(100, (accountAgeDays / 30) * 10); // 100 points after 300 days\n\n\t// Calculate weighted overall score\n\tconst overallScore =\n\t\tsuccessRate * 0.4 + // 40% weight on success rate\n\t\tvolumeFactor * 0.3 + // 30% weight on volume\n\t\tageFactor * 0.2 + // 20% weight on account age\n\t\t(trustScore.business_verified ? 10 : 0) + // 10% for verification\n\t\t(trustScore.bank_account_verified ? 5 : 0) +\n\t\t(trustScore.identity_verified ? 5 : 0);\n\n\tupdates.overall_score = Math.min(100, Math.max(0, overallScore));\n\tupdates.refund_rate =\n\t\ttotalPayments > 0\n\t\t\t? ((trustScore.refunded_amount || 0) / updates.total_payments_volume) *\n\t\t\t\t100\n\t\t\t: 0;\n\n\tawait supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.update(updates)\n\t\t.eq(\"company_id\", companyId);\n}\n","/**\n * Stripe Server - Server-side Stripe utilities\n *\n * Features:\n * - Secure Stripe API client initialization\n * - Multi-organization subscription management\n * - Billing portal session creation\n * - Subscription lifecycle management\n *\n * Performance optimizations:\n * - Server-side only (uses secret key)\n * - Type-safe with TypeScript\n * - Proper error handling\n */\n\nimport Stripe from \"stripe\";\n\n/**\n * Initialize Stripe server client\n *\n * SECURITY: This uses the secret key and must only be called server-side\n */\nfunction getStripeServer(): Stripe | null {\n\tconst secretKey = process.env.STRIPE_SECRET_KEY;\n\n\tif (!secretKey) {\n\t\treturn null;\n\t}\n\n\treturn new Stripe(secretKey, {\n\t\tapiVersion: \"2025-10-29.clover\",\n\t\ttypescript: true,\n\t});\n}\n\n// Export singleton instance\nexport const stripe = getStripeServer();\n\n/**\n * Create or retrieve Stripe customer for a user\n *\n * Creates a customer in Stripe if they don't have one yet\n * Links customer to user via metadata\n */\nasync function getOrCreateStripeCustomer(\n\tuserId: string,\n\temail: string,\n\tname?: string,\n): Promise<string | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\t// Check if customer already exists\n\t\tconst customers = await stripe.customers.list({\n\t\t\temail,\n\t\t\tlimit: 1,\n\t\t});\n\n\t\tif (customers.data.length > 0) {\n\t\t\treturn customers.data[0].id;\n\t\t}\n\n\t\t// Create new customer\n\t\tconst customer = await stripe.customers.create({\n\t\t\temail,\n\t\t\tname,\n\t\t\tmetadata: {\n\t\t\t\tuser_id: userId,\n\t\t\t},\n\t\t});\n\n\t\treturn customer.id;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Create checkout session for new subscription\n *\n * For first organization: Base plan\n * For additional organizations: Base plan + Additional org addon\n */\nasync function createCheckoutSession({\n\tcustomerId,\n\tcompanyId,\n\tisAdditionalOrg,\n\tsuccessUrl,\n\tcancelUrl,\n\tphoneNumber,\n}: {\n\tcustomerId: string;\n\tcompanyId: string;\n\tisAdditionalOrg: boolean;\n\tsuccessUrl: string;\n\tcancelUrl: string;\n\tphoneNumber?: string;\n}): Promise<string | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst basePriceId = process.env.STRIPE_PRICE_ID_BASE_PLAN;\n\t\tconst additionalOrgPriceId = process.env.STRIPE_PRICE_ID_ADDITIONAL_ORG;\n\n\t\tif (!basePriceId) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Build line items\n\t\tconst lineItems: Stripe.Checkout.SessionCreateParams.LineItem[] = [\n\t\t\t{\n\t\t\t\tprice: basePriceId,\n\t\t\t\tquantity: 1,\n\t\t\t},\n\t\t];\n\n\t\t// Add additional organization fee if this is not the first org\n\t\tif (isAdditionalOrg && additionalOrgPriceId) {\n\t\t\tlineItems.push({\n\t\t\t\tprice: additionalOrgPriceId,\n\t\t\t\tquantity: 1,\n\t\t\t});\n\t\t}\n\n\t\tconst session = await stripe.checkout.sessions.create({\n\t\t\tcustomer: customerId,\n\t\t\tmode: \"subscription\",\n\t\t\tline_items: lineItems,\n\t\t\tsuccess_url: successUrl,\n\t\t\tcancel_url: cancelUrl,\n\t\t\tmetadata: {\n\t\t\t\tcompany_id: companyId,\n\t\t\t\tis_additional_org: isAdditionalOrg.toString(),\n\t\t\t\t...(phoneNumber && { phone_number: phoneNumber }),\n\t\t\t},\n\t\t\tsubscription_data: {\n\t\t\t\tmetadata: {\n\t\t\t\t\tcompany_id: companyId,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\treturn session.url;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Create billing portal session\n *\n * Allows users to manage their subscription, payment methods, and billing history\n */\nasync function createBillingPortalSession(\n\tcustomerId: string,\n\treturnUrl: string,\n): Promise<string | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst session = await stripe.billingPortal.sessions.create({\n\t\t\tcustomer: customerId,\n\t\t\treturn_url: returnUrl,\n\t\t});\n\n\t\treturn session.url;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * Cancel subscription\n *\n * Cancels subscription at the end of the current billing period\n */\nasync function cancelSubscription(\n\tsubscriptionId: string,\n): Promise<boolean> {\n\tif (!stripe) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tawait stripe.subscriptions.update(subscriptionId, {\n\t\t\tcancel_at_period_end: true,\n\t\t});\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Reactivate subscription\n *\n * Removes the cancellation flag from a subscription\n */\nasync function reactivateSubscription(\n\tsubscriptionId: string,\n): Promise<boolean> {\n\tif (!stripe) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tawait stripe.subscriptions.update(subscriptionId, {\n\t\t\tcancel_at_period_end: false,\n\t\t});\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Get subscription details\n */\nasync function getSubscription(\n\tsubscriptionId: string,\n): Promise<Stripe.Subscription | null> {\n\tif (!stripe) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst subscription = await stripe.subscriptions.retrieve(subscriptionId);\n\t\treturn subscription;\n\t} catch (_error) {\n\t\treturn null;\n\t}\n}\n\n/**\n * List all subscriptions for a customer\n */\nasync function listCustomerSubscriptions(\n\tcustomerId: string,\n): Promise<Stripe.Subscription[]> {\n\tif (!stripe) {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\tconst subscriptions = await stripe.subscriptions.list({\n\t\t\tcustomer: customerId,\n\t\t\tstatus: \"all\",\n\t\t});\n\n\t\treturn subscriptions.data;\n\t} catch (_error) {\n\t\treturn [];\n\t}\n}\n\n/**\n * Attach payment method to customer\n *\n * Attaches a payment method collected via Stripe Elements to a customer\n * and sets it as the default payment method\n */\nasync function attachPaymentMethodToCustomer(\n\tpaymentMethodId: string,\n\tcustomerId: string,\n): Promise<boolean> {\n\tif (!stripe) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\t// Attach payment method to customer\n\t\tawait stripe.paymentMethods.attach(paymentMethodId, {\n\t\t\tcustomer: customerId,\n\t\t});\n\n\t\t// Set as default payment method\n\t\tawait stripe.customers.update(customerId, {\n\t\t\tinvoice_settings: {\n\t\t\t\tdefault_payment_method: paymentMethodId,\n\t\t\t},\n\t\t});\n\n\t\treturn true;\n\t} catch (_error) {\n\t\treturn false;\n\t}\n}\n","\"use server\";\n\n/**\n * Payment Methods Server Actions\n *\n * Handles payment method management:\n * - Save payment methods\n * - Set default payment methods\n * - Remove payment methods\n * - List payment methods\n *\n * Security:\n * - All actions verify user authentication\n * - All actions use RLS policies\n * - Stripe API calls are server-side only\n */\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { stripe } from \"@/lib/payments/stripe-server\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// Validation schemas\nconst savePaymentMethodSchema = z.object({\n\tpaymentMethodId: z.string().min(1),\n\tisDefault: z.boolean().optional().default(false),\n\tisDefaultForSubscription: z.boolean().optional().default(false),\n});\n\nconst setDefaultSchema = z.object({\n\tpaymentMethodId: z.string().uuid(),\n\tforSubscription: z.boolean().optional().default(false),\n});\n\nconst removePaymentMethodSchema = z.object({\n\tpaymentMethodId: z.string().uuid(),\n});\n\n/**\n * Save a payment method to the database\n * Called after Stripe payment is complete\n */\nasync function savePaymentMethod(formData: FormData) {\n\ttry {\n\t\t// Get authenticated user\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tif (!stripe) {\n\t\t\treturn { success: false, error: \"Payment service unavailable\" };\n\t\t}\n\n\t\t// Validate input\n\t\tconst data = savePaymentMethodSchema.parse({\n\t\t\tpaymentMethodId: formData.get(\"paymentMethodId\"),\n\t\t\tisDefault: formData.get(\"isDefault\") === \"true\",\n\t\t\tisDefaultForSubscription:\n\t\t\t\tformData.get(\"isDefaultForSubscription\") === \"true\",\n\t\t});\n\n\t\t// Get payment method from Stripe\n\t\tconst paymentMethod = await stripe.paymentMethods.retrieve(\n\t\t\tdata.paymentMethodId,\n\t\t);\n\n\t\t// Extract payment method details\n\t\tconst type = paymentMethod.type;\n\t\tlet brand: string | undefined;\n\t\tlet last4: string | undefined;\n\t\tlet expMonth: number | undefined;\n\t\tlet expYear: number | undefined;\n\t\tlet walletType: string | undefined;\n\t\tlet displayName: string;\n\n\t\tif (paymentMethod.card) {\n\t\t\tbrand = paymentMethod.card.brand;\n\t\t\tlast4 = paymentMethod.card.last4;\n\t\t\texpMonth = paymentMethod.card.exp_month;\n\t\t\texpYear = paymentMethod.card.exp_year;\n\t\t\tdisplayName = `${brand?.toUpperCase()} •••• ${last4}`;\n\n\t\t\t// Check if card came from a wallet\n\t\t\tif (paymentMethod.card.wallet) {\n\t\t\t\twalletType = paymentMethod.card.wallet.type;\n\t\t\t\tif (walletType === \"apple_pay\") {\n\t\t\t\t\tdisplayName = `Apple Pay (${brand?.toUpperCase()} •••• ${last4})`;\n\t\t\t\t} else if (walletType === \"google_pay\") {\n\t\t\t\t\tdisplayName = `Google Pay (${brand?.toUpperCase()} •••• ${last4})`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdisplayName = type\n\t\t\t\t.replace(\"_\", \" \")\n\t\t\t\t.replace(/\\b\\w/g, (l) => l.toUpperCase());\n\t\t}\n\n\t\t// Save to database\n\t\tconst { error: insertError } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.insert({\n\t\t\t\tuser_id: user.id,\n\t\t\t\tstripe_payment_method_id: data.paymentMethodId,\n\t\t\t\ttype: walletType || type,\n\t\t\t\tbrand,\n\t\t\t\tlast4,\n\t\t\t\texp_month: expMonth,\n\t\t\t\texp_year: expYear,\n\t\t\t\twallet_type: walletType,\n\t\t\t\tdisplay_name: displayName,\n\t\t\t\tis_default: data.isDefault,\n\t\t\t\tis_default_for_subscription: data.isDefaultForSubscription,\n\t\t\t\tbilling_details: paymentMethod.billing_details,\n\t\t\t\tallow_redisplay: \"always\", // Allow prefilling for future purchases\n\t\t\t});\n\n\t\tif (insertError) {\n\t\t\treturn { success: false, error: \"Failed to save payment method\" };\n\t\t}\n\n\t\t// Attach payment method to Stripe customer if not already attached\n\t\tconst { data: userData } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"stripe_customer_id\")\n\t\t\t.eq(\"id\", user.id)\n\t\t\t.single();\n\n\t\tif (userData?.stripe_customer_id) {\n\t\t\ttry {\n\t\t\t\tawait stripe.paymentMethods.attach(data.paymentMethodId, {\n\t\t\t\t\tcustomer: userData.stripe_customer_id,\n\t\t\t\t});\n\n\t\t\t\t// If this is the default, update Stripe customer default payment method\n\t\t\t\tif (data.isDefault) {\n\t\t\t\t\tawait stripe.customers.update(userData.stripe_customer_id, {\n\t\t\t\t\t\tinvoice_settings: {\n\t\t\t\t\t\t\tdefault_payment_method: data.paymentMethodId,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (_stripeError) {\n\t\t\t\t// Don't fail - payment method is saved in our DB\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/billing\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn { success: false, error: \"An error occurred\" };\n\t}\n}\n\n/**\n * Set a payment method as default\n */\nasync function setDefaultPaymentMethod(formData: FormData) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tif (!stripe) {\n\t\t\treturn { success: false, error: \"Payment service unavailable\" };\n\t\t}\n\n\t\tconst data = setDefaultSchema.parse({\n\t\t\tpaymentMethodId: formData.get(\"paymentMethodId\"),\n\t\t\tforSubscription: formData.get(\"forSubscription\") === \"true\",\n\t\t});\n\n\t\t// Update database - the trigger will automatically unset others\n\t\tconst updateField = data.forSubscription\n\t\t\t? \"is_default_for_subscription\"\n\t\t\t: \"is_default\";\n\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.update({ [updateField]: true })\n\t\t\t.eq(\"id\", data.paymentMethodId)\n\t\t\t.eq(\"user_id\", user.id);\n\n\t\tif (updateError) {\n\t\t\treturn { success: false, error: \"Failed to set default payment method\" };\n\t\t}\n\n\t\t// Update Stripe customer default payment method\n\t\tconst { data: paymentMethodData } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.select(\"stripe_payment_method_id\")\n\t\t\t.eq(\"id\", data.paymentMethodId)\n\t\t\t.single();\n\n\t\tconst { data: userData } = await supabase\n\t\t\t.from(\"profiles\")\n\t\t\t.select(\"stripe_customer_id\")\n\t\t\t.eq(\"id\", user.id)\n\t\t\t.single();\n\n\t\tif (\n\t\t\tuserData?.stripe_customer_id &&\n\t\t\tpaymentMethodData?.stripe_payment_method_id\n\t\t) {\n\t\t\ttry {\n\t\t\t\tawait stripe.customers.update(userData.stripe_customer_id, {\n\t\t\t\t\tinvoice_settings: {\n\t\t\t\t\t\tdefault_payment_method: paymentMethodData.stripe_payment_method_id,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} catch (_stripeError) {\n\t\t\t\t// Don't fail - default is set in our DB\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/billing\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn { success: false, error: \"An error occurred\" };\n\t}\n}\n\n/**\n * Remove a payment method\n */\nasync function removePaymentMethod(formData: FormData) {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Service unavailable\" };\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tif (!stripe) {\n\t\t\treturn { success: false, error: \"Payment service unavailable\" };\n\t\t}\n\n\t\tconst data = removePaymentMethodSchema.parse({\n\t\t\tpaymentMethodId: formData.get(\"paymentMethodId\"),\n\t\t});\n\n\t\t// Get payment method details before deleting\n\t\tconst { data: paymentMethodData } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.select(\n\t\t\t\t\"stripe_payment_method_id, is_default, is_default_for_subscription\",\n\t\t\t)\n\t\t\t.eq(\"id\", data.paymentMethodId)\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.single();\n\n\t\tif (!paymentMethodData) {\n\t\t\treturn { success: false, error: \"Payment method not found\" };\n\t\t}\n\n\t\t// Check if this is the only payment method\n\t\tconst { count } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.select(\"*\", { count: \"exact\", head: true })\n\t\t\t.eq(\"user_id\", user.id);\n\n\t\tif (\n\t\t\tcount === 1 &&\n\t\t\t(paymentMethodData.is_default ||\n\t\t\t\tpaymentMethodData.is_default_for_subscription)\n\t\t) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Cannot remove your only payment method. Add another one first.\",\n\t\t\t};\n\t\t}\n\n\t\t// Delete from database\n\t\tconst { error: deleteError } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.delete()\n\t\t\t.eq(\"id\", data.paymentMethodId)\n\t\t\t.eq(\"user_id\", user.id);\n\n\t\tif (deleteError) {\n\t\t\treturn { success: false, error: \"Failed to remove payment method\" };\n\t\t}\n\n\t\t// Detach from Stripe customer\n\t\ttry {\n\t\t\tawait stripe.paymentMethods.detach(\n\t\t\t\tpaymentMethodData.stripe_payment_method_id,\n\t\t\t);\n\t\t} catch (_stripeError) {\n\t\t\t// Don't fail - payment method is already removed from our DB\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/billing\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.issues[0]?.message || \"Validation error\",\n\t\t\t};\n\t\t}\n\n\t\treturn { success: false, error: \"An error occurred\" };\n\t}\n}\n\n/**\n * Get all payment methods for the current user\n */\nexport async function getPaymentMethods() {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Service unavailable\",\n\t\t\t\tpaymentMethods: [],\n\t\t\t};\n\t\t}\n\t\tconst {\n\t\t\tdata: { user },\n\t\t\terror: authError,\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (authError || !user) {\n\t\t\treturn { success: false, error: \"Unauthorized\", paymentMethods: [] };\n\t\t}\n\n\t\tconst { data: paymentMethods, error } = await supabase\n\t\t\t.from(\"payment_methods\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"user_id\", user.id)\n\t\t\t.order(\"is_default\", { ascending: false })\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Failed to fetch payment methods\",\n\t\t\t\tpaymentMethods: [],\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, paymentMethods: paymentMethods || [] };\n\t} catch (_error) {\n\t\treturn { success: false, error: \"An error occurred\", paymentMethods: [] };\n\t}\n}\n","\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notifyPaymentReceived } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype PaymentInsert,\n\ttype PaymentUpdate,\n\tpaymentInsertSchema,\n\tpaymentUpdateSchema,\n} from \"@/lib/validations/database-schemas\";\n\n/**\n * Server Actions for Payment Management\n *\n * Handles payment transactions with:\n * - Server-side validation using Zod\n * - Supabase database operations\n * - Refund support\n * - Reconciliation tracking\n * - Company-based multi-tenancy via RLS\n */\n\n// ============================================================================\n// CREATE\n// ============================================================================\n\ntype CreatePaymentResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tpaymentId?: string;\n};\n\nexport async function createPayment(\n\tinput: PaymentInsert | FormData,\n): Promise<CreatePaymentResult> {\n\tif (input instanceof FormData) {\n\t\treturn createPaymentFromForm(input);\n\t}\n\n\treturn createPaymentWithData(input);\n}\n\nasync function createPaymentWithData(\n\tdata: PaymentInsert,\n\texistingSupabase?: Awaited<ReturnType<typeof createClient>> | null,\n): Promise<CreatePaymentResult> {\n\ttry {\n\t\tconst validated = paymentInsertSchema.parse(data);\n\t\tconst supabase = existingSupabase ?? (await createClient());\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { data: payment, error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.insert(validated)\n\t\t\t.select(\"id, amount, company_id, customer_id, invoice_id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// Fetch customer info for notification\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", payment.customer_id)\n\t\t\t.single();\n\n\t\t// Get company owner/managers to notify about payment\n\t\tconst { data: companyUsers } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"company_id\", payment.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.limit(5);\n\n\t\t// PERFORMANCE OPTIMIZED: Pattern #4 Fix - Batch notification inserts\n\t\t// BEFORE: 5 sequential INSERT queries (1 per team member)\n\t\t// AFTER: 1 batch INSERT query\n\t\t// Performance gain: ~3 seconds saved (80% reduction)\n\n\t\t// Send notification to company users about payment received\n\t\tif (customer && companyUsers && companyUsers.length > 0) {\n\t\t\tconst notifications = companyUsers.map((teamMember) => ({\n\t\t\t\tuser_id: teamMember.user_id,\n\t\t\t\tcompany_id: payment.company_id,\n\t\t\t\ttype: \"payment\",\n\t\t\t\ttitle: \"Payment Received\",\n\t\t\t\tmessage: `Payment of $${(payment.amount / 100).toFixed(2)} received from ${customer.name}`,\n\t\t\t\tpriority: \"high\",\n\t\t\t\taction_url: \"/dashboard/finance/invoices\",\n\t\t\t\taction_label: \"View Invoice\",\n\t\t\t\tmetadata: {\n\t\t\t\t\tpayment_id: payment.id,\n\t\t\t\t\tcustomer_id: payment.customer_id,\n\t\t\t\t\tinvoice_id: payment.invoice_id,\n\t\t\t\t\tamount: payment.amount,\n\t\t\t\t},\n\t\t\t\tis_read: false,\n\t\t\t\tis_archived: false,\n\t\t\t}));\n\n\t\t\t// Batch insert all notifications\n\t\t\tawait supabase.from(\"notifications\").insert(notifications);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\treturn { success: true, paymentId: payment.id };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to create payment\" };\n\t}\n}\n\nasync function createPaymentFromForm(\n\tformData: FormData,\n): Promise<CreatePaymentResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst invoiceId = formData.get(\"invoiceId\")?.toString();\n\t\tif (!invoiceId) {\n\t\t\treturn { success: false, error: \"Invoice is required\" };\n\t\t}\n\n\t\tconst rawAmount = formData.get(\"amount\");\n\t\tconst amountNumber = Number.parseFloat(rawAmount as string);\n\t\tif (!Number.isFinite(amountNumber) || amountNumber <= 0) {\n\t\t\treturn { success: false, error: \"Payment amount must be greater than 0\" };\n\t\t}\n\t\tconst amount = Math.round(amountNumber * 100);\n\n\t\tconst { data: invoice, error: invoiceError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"id, company_id, customer_id, job_id, invoice_number, currency\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tif (invoiceError || !invoice) {\n\t\t\treturn { success: false, error: \"Invoice not found\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tconst paymentMethod =\n\t\t\t(formData.get(\"paymentMethod\") as PaymentInsert[\"payment_method\"]) ||\n\t\t\t\"cash\";\n\t\tconst paymentDateValue = formData.get(\"paymentDate\")?.toString();\n\t\tconst checkNumber = formData.get(\"checkNumber\")?.toString() || null;\n\t\tconst notes = formData.get(\"notes\")?.toString() || null;\n\n\t\tconst paymentNumber = `PAY-${Date.now()}`;\n\n\t\tconst paymentData: PaymentInsert = {\n\t\t\tcompany_id: invoice.company_id,\n\t\t\tcustomer_id: invoice.customer_id,\n\t\t\tinvoice_id: invoice.id,\n\t\t\tjob_id: invoice.job_id ?? null,\n\t\t\tpayment_number: paymentNumber,\n\t\t\tamount,\n\t\t\tcurrency: (invoice.currency || \"USD\") as PaymentInsert[\"currency\"],\n\t\t\tpayment_method: paymentMethod,\n\t\t\tpayment_type: \"payment\",\n\t\t\tstatus: \"completed\",\n\t\t\tcheck_number: checkNumber,\n\t\t\tnotes,\n\t\t\tnet_amount: amount,\n\t\t\tprocessor_fee: 0,\n\t\t\trefunded_amount: 0,\n\t\t\tis_reconciled: false,\n\t\t\tprocessed_at: paymentDateValue ? new Date(paymentDateValue) : new Date(),\n\t\t\tprocessed_by: user?.id ?? null,\n\t\t};\n\n\t\treturn createPaymentWithData(paymentData, supabase);\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to create payment\" };\n\t}\n}\n\n// ============================================================================\n// READ\n// ============================================================================\n\nasync function getPayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string; payment?: any }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { data: payment, error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"*, customer:customers(*), invoice:invoices(*)\")\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, payment };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to get payment\" };\n\t}\n}\n\nasync function getPayments(filters?: {\n\tpaymentMethod?: string;\n\tstatus?: string;\n\tcustomerId?: string;\n\tisReconciled?: boolean;\n\tdateFrom?: string;\n\tdateTo?: string;\n}): Promise<{ success: boolean; error?: string; payments?: any[] }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tlet query = supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"*, customer:customers(first_name, last_name, email)\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (filters?.paymentMethod && filters.paymentMethod !== \"all\") {\n\t\t\tquery = query.eq(\"payment_method\", filters.paymentMethod);\n\t\t}\n\t\tif (filters?.status && filters.status !== \"all\") {\n\t\t\tquery = query.eq(\"status\", filters.status);\n\t\t}\n\t\tif (filters?.customerId) {\n\t\t\tquery = query.eq(\"customer_id\", filters.customerId);\n\t\t}\n\t\tif (filters?.isReconciled !== undefined) {\n\t\t\tquery = query.eq(\"is_reconciled\", filters.isReconciled);\n\t\t}\n\t\tif (filters?.dateFrom) {\n\t\t\tquery = query.gte(\"created_at\", filters.dateFrom);\n\t\t}\n\t\tif (filters?.dateTo) {\n\t\t\tquery = query.lte(\"created_at\", filters.dateTo);\n\t\t}\n\n\t\tconst { data: payments, error } = await query;\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, payments };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to get payments\" };\n\t}\n}\n\n// ============================================================================\n// UPDATE\n// ============================================================================\n\nasync function updatePayment(\n\tpaymentId: string,\n\tdata: PaymentUpdate,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst validated = paymentUpdateSchema.parse(data);\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update(validated)\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to update payment\" };\n\t}\n}\n\n// ============================================================================\n// REFUND\n// ============================================================================\n\nasync function refundPayment(\n\tpaymentId: string,\n\trefundAmount: number,\n\trefundReason?: string,\n): Promise<{ success: boolean; error?: string; refundId?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\t// Get original payment\n\t\tconst { data: originalPayment, error: fetchError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !originalPayment) {\n\t\t\treturn { success: false, error: \"Payment not found\" };\n\t\t}\n\n\t\t// Validate refund amount\n\t\tconst alreadyRefunded = originalPayment.refunded_amount || 0;\n\t\tconst maxRefundable = originalPayment.amount - alreadyRefunded;\n\n\t\tif (refundAmount > maxRefundable) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Cannot refund more than ${maxRefundable / 100} (already refunded ${alreadyRefunded / 100})`,\n\t\t\t};\n\t\t}\n\n\t\t// Create refund record\n\t\tconst refundData = {\n\t\t\tcompany_id: originalPayment.company_id,\n\t\t\tcustomer_id: originalPayment.customer_id,\n\t\t\tinvoice_id: originalPayment.invoice_id,\n\t\t\tpayment_number: `REFUND-${originalPayment.payment_number}`,\n\t\t\tamount: refundAmount,\n\t\t\tcurrency: originalPayment.currency,\n\t\t\tpayment_method: originalPayment.payment_method,\n\t\t\tpayment_type: \"refund\",\n\t\t\tstatus: \"completed\",\n\t\t\toriginal_payment_id: paymentId,\n\t\t\trefund_reason: refundReason,\n\t\t\tprocessed_at: new Date().toISOString(),\n\t\t};\n\n\t\tconst { data: refund, error: refundError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.insert(refundData)\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (refundError) {\n\t\t\treturn { success: false, error: refundError.message };\n\t\t}\n\n\t\t// Update original payment\n\t\tconst newRefundedAmount = alreadyRefunded + refundAmount;\n\t\tconst newStatus =\n\t\t\tnewRefundedAmount === originalPayment.amount\n\t\t\t\t? \"refunded\"\n\t\t\t\t: \"partially_refunded\";\n\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\trefunded_amount: newRefundedAmount,\n\t\t\t\tstatus: newStatus,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (updateError) {\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true, refundId: refund.id };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to refund payment\" };\n\t}\n}\n\n// ============================================================================\n// RECONCILIATION\n// ============================================================================\n\nasync function reconcilePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\tis_reconciled: true,\n\t\t\t\treconciled_at: new Date().toISOString(),\n\t\t\t\treconciled_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to reconcile payment\" };\n\t}\n}\n\nasync function unreconcilePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\tis_reconciled: false,\n\t\t\t\treconciled_at: null,\n\t\t\t\treconciled_by: null,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to unreconcile payment\" };\n\t}\n}\n\n// ============================================================================\n// DELETE\n// ============================================================================\n\nasync function deletePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(\"/dashboard/work/payments\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to delete payment\" };\n\t}\n}\n\n/**\n * Archive payment (alias for deletePayment - uses soft delete)\n */\nexport async function archivePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\treturn deletePayment(paymentId);\n}\n\n/**\n * Unlink payment from job\n * Removes the job association (sets job_id to NULL)\n * Bidirectional operation - updates both payment and job views\n */\nexport async function unlinkPaymentFromJob(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\t// Get current payment to verify exists and get job_id for revalidation\n\t\tconst { data: payment, error: fetchError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !payment) {\n\t\t\treturn { success: false, error: \"Payment not found\" };\n\t\t}\n\n\t\tconst previousJobId = payment.job_id;\n\n\t\t// Unlink payment from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (unlinkError) {\n\t\t\treturn { success: false, error: unlinkError.message };\n\t\t}\n\n\t\t// Revalidate both pages\n\t\trevalidatePath(`/dashboard/work/payments/${paymentId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/payments\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to unlink payment from job\" };\n\t}\n}\n"],"names":[],"mappings":"0DAOA,EAAA,EAAA,CAAA,CAAA,QAoDO,eAAe,EACrB,CAAiB,CACjB,EAA4B,CAAC,CAAC,EAE9B,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IAEnC,GAAI,CAAC,EACJ,MAAO,CAAE,CADK,GACA,EAAE,CAAE,MAAO,EAAG,SAAS,CAAM,EAG5C,GAAM,OACL,EAAQ,EAAE,QACV,EAAS,CAAC,MACV,EAAO,KAAK,QACZ,CAAM,OACN,CAAK,QACL,CAAM,QACN,EAAS,YAAY,WACrB,EAAY,MAAM,CAClB,CAAG,EAGA,EAAQ,EACV,IAAI,CAAC,kBACL,MAAM,CACN,CAAC;;;;;;;;;;;;;;;;;;;;;;EAsBF,CAAC,CACA,CAAE,MAAO,OAAQ,GAEjB,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,OAAQ,OAGb,GAAI,EACH,MADW,CACH,GACP,IAAK,QAEJ,EAAQ,EACN,EAAE,CAAC,YAAa,WAChB,EAAE,CAAC,eAAe,GAClB,EAAE,CAAC,aAAc,MACjB,EAAE,CAAC,gDACL,KACD,KAAK,OAEJ,EAAQ,EACN,EAAE,CAAC,YAAa,YAChB,EAAE,CAAC,eAAe,GAClB,EAAE,CAAC,aAAc,MACnB,KACD,KAAK,UAEJ,EAAQ,EAAM,EAAE,CAAC,cAAe,IAAM,EAAE,CAAC,aAAc,MACvD,KACD,KAAK,QACL,IAAK,MAEJ,EAAQ,EAAM,GAAG,CAAC,aAAc,KAAM,MACtC,KACD,SAGC,EAAQ,EAAM,EAAE,CAAC,aAAc,KAEjC,MAGA,EAAQ,EAAM,EAAE,CAAC,aAAc,MAWhC,GAPa,QAAQ,CAAjB,EACH,EAAQ,EAAM,EAAE,CAAC,YAAa,YACX,YAAY,CAArB,IACV,EAAQ,EAAM,EAAE,CAAC,YAAa,UAAA,EAI3B,EAAQ,CACX,IAAM,EAAc,EAAO,WAAW,GACtC,EAAQ,EAAM,EAAE,CACf,CAAC,oBAAoB,EAAE,EAAY,oBAAoB,EAAE,EAAY,cAAc,EAAE,EAAY,CAAC,CAAC,CAErG,CAGA,IAAM,EAA0B,QAAd,EAQlB,EAAQ,CANP,EADc,WAAW,CAAtB,EACK,EAAM,KAAK,CAAC,UAAW,WAAE,EAAW,YAAY,CAAM,GAEtD,EAAM,KAAK,CAAC,aAAc,CAAE,WAAU,IAIjC,KAAK,CAAC,EAAQ,EAAS,EAAQ,GAE7C,GAAM,MAAE,CAAI,OAAE,CAAK,OAAE,CAAK,CAAE,CAAG,MAAM,EAErC,GAAI,EAEH,KAFU,EACV,QAAQ,KAAK,CAAC,+BAAgC,GACvC,CAAE,IAAK,EAAE,CAAE,MAAO,EAAG,SAAS,CAAM,EAG5C,IAAI,EAAM,CAAC,GAAQ,EAAA,AAAE,EAAE,GAAG,CAAC,AAAC,IAAS,CACpC,CADmC,EAChC,CAAG,CACN,KAAO,EAAI,IAAI,EAAiB,KAChC,kBAAoB,EAAI,iBAAiB,EAAgC,KAC1E,CAAC,EAIK,EAAa,GAAS,EAC5B,GAAI,GAAc,CAFM,AAEL,CAFM,QAAS,OAAQ,UAAW,QAAS,MAAM,CAEjC,QAAQ,CAAC,GAK3C,MAAO,CACN,GANuD,CACxD,EAAM,EAAI,MAAM,CAAC,AAAC,IACjB,IAAM,EAAU,EAAI,IAAI,EAAI,EAAE,CAC9B,OAAO,MAAM,OAAO,CAAC,IAAY,EAAQ,QAAQ,CAAC,EACnD,GAGC,MAAO,EAAI,MAAM,CACjB,SAAS,CACV,EAGD,IAAM,EAAQ,GAAS,EACjB,EAAU,EAAS,EAAI,MAAM,CAAG,EAEtC,MAAO,KACN,QACA,UACA,CACD,CACD,CAEO,eAAe,EACrB,CAAiB,CACjB,CAAa,EAEb,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IAEnC,GAAI,CAAC,EACJ,OAAO,CADO,IAIf,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC5B,IAAI,CAAC,kBACL,MAAM,CACN,CAAC;;;;;;;;;;;;;;;;;;;;;;EAsBF,CAAC,EAEA,EAAE,CAAC,KAAM,GACT,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,OAAQ,OACX,MAAM,UAER,AAAI,GAAS,CAAC,EACN,IADY,CAIb,CACN,GAAG,CAAI,CACP,KAAO,EAAK,IAAI,EAAiB,KACjC,kBAAoB,EAAK,iBAAiB,EAAgC,IAC3E,CACD,CAEO,eAAe,EACrB,CAAiB,CACjB,CAAa,EAEb,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IAEnC,GAAI,CAAC,EAEJ,OADA,CADc,OACN,KAAK,CAAC,sCACP,EAGR,IAAM,EAAS,IAAI,OAAO,WAAW,GAC/B,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC5B,IAAI,CAAC,kBACL,MAAM,CAAC,CAAE,QAAS,CAAO,GACzB,EAAE,CAAC,KAAM,GACT,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,OAAQ,OACX,MAAM,CAAC,eACP,MAAM,UAER,AAAI,GACH,IADU,IACF,KAAK,CAAC,yBAA0B,IACjC,IAGJ,CAAC,IACJ,EADU,MACF,KAAK,CAAC,sCACP,EAKT,CA8EO,eAAe,EACrB,CAAiB,CACjB,CAAmB,EAEnB,IAQO,EARD,EAAW,MAAM,CAAA,EAAA,EAAA,YAAY,AAAZ,IAEvB,GAAI,CAAC,EACJ,OAAO,CADO,CAgBf,IAAM,EATiB,KAAlB,GASkC,AAVvB,EAAM,MAUE,CAVK,CAAC,UAAW,KAC7B,MAAM,EAAW,EAAO,UAAU,CAAC,KACtC,CAD4C,AAC3C,CAAC,EAAE,EAAA,CAAQ,CAEE,IAAI,CAAtB,EAAO,MAAM,CACT,CAAC,EAAE,EAAE,EAAA,CAAQ,CAEd,EAAM,UAAU,CAAC,OAAO,AAAQ,CAAC,CAAC,EAAE,EAAA,CAAO,CAM7C,EAAS,IAAI,OAAO,WAAW,GAC/B,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC5B,IAAI,CAAC,kBACL,MAAM,CAAC,CAAE,QAAS,CAAO,GACzB,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,OAAQ,OACX,EAAE,CAAC,YAAa,WAChB,EAAE,CAAC,UAAW,MACd,EAAE,CAAC,aAAc,MACjB,EAAE,CAAC,CAAC,gBAAgB,EAAE,EAAgB,eAAe,EAAE,EAAA,CAAiB,EACxE,MAAM,CAAC,qBAET,CAAI,IACH,GADU,KACF,KAAK,CAAC,qCAAsC,IAC7C,EAKT,CC7ZA,IAAA,EAAA,EAAA,CAAA,CAAA,sBAEA,IAAM,EAAe,EAAA,CAAC,CAAC,MAAM,CAAC,CAC5B,MAAO,EAAA,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,QAAQ,GAAG,OAAO,CAAC,IAC5D,OAAQ,EAAA,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,QAAQ,GAAG,OAAO,CAAC,GACpD,KAAM,EAAA,CAAC,CAAC,IAAI,CAAC,CAAC,OAAQ,WAAY,MAAM,EAAE,QAAQ,GAAG,OAAO,CAAC,OAC7D,OAAQ,EAAA,CAAC,CAAC,IAAI,CAAC,CAAC,QAAS,OAAQ,UAAW,QAAS,MAAM,EAAE,QAAQ,GACrE,MAAO,EAAA,CAAC,CAAC,MAAM,GAAG,QAAQ,GAC1B,OAAQ,EAAA,CAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,GACtC,OAAQ,EAAA,CAAC,CAAC,IAAI,CAAC,CAAC,aAAc,UAAU,EAAE,QAAQ,GAAG,OAAO,CAAC,cAC7D,UAAW,EAAA,CAAC,CAAC,IAAI,CAAC,CAAC,MAAO,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,OACxD,GAAG,WAAW,GAER,EAAoB,EAAA,CAAC,CAAC,MAAM,CAAC,CACjC,MAAO,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,EACxB,GAaO,eAAe,EACpB,CAAkB,EAElB,GAAI,CACF,IAAM,EAAc,EAAa,SAAS,CAAC,GAE3C,GAAI,CAAC,EAAY,OAAO,CACtB,CADwB,KAClB,AAAI,MAAM,CAAC,0BAA0B,EAAE,EAAY,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,GAAK,CAAA,EAAG,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,OAAO,CAAA,CAAE,EAAE,IAAI,CAAC,MAAA,CAAO,EAGlI,IAAM,EAAiB,EAAY,IAAI,CACjC,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACzB,EAAY,MAAM,IAExB,GAAI,CAAC,EACH,MAAM,AAAI,GADI,GACE,2BAGlB,OAAO,MAAM,EAAc,EAAW,EACxC,CAAE,MAAO,EAAO,CAEd,MADA,QAAQ,KAAK,CAAC,wBAAyB,GACjC,CACR,CACF,CAKO,eAAe,EAAiB,CAAa,EAKlD,GAAI,CACF,GAAM,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACzB,EAAY,MAAM,IAExB,GAAI,CAAC,EACH,MAAO,CAAE,EADK,OACI,EAAO,MAAO,yBAA0B,EAG5D,IAAM,EAAM,MAAM,EAAW,EAAW,GAExC,GAAI,CAAC,EACH,GADQ,GACD,CAAE,SAAS,EAAO,MAAO,eAAgB,EAGlD,MAAO,CAAE,SAAS,MAAM,CAAI,CAC9B,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,2BAA4B,GACnC,CACL,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,eAClD,CACF,CACF,CAKO,eAAe,EACpB,CAAuB,EAEvB,GAAI,CACF,IAAM,EAAiB,EAAkB,KAAK,CAAC,GACzC,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACzB,EAAY,MAAM,IAExB,GAAI,CAAC,EACH,MAAM,AAAI,GADI,GACE,4BAGlB,OAAO,MAAM,EAAc,EAAW,EAAe,KAAK,CAC5D,CAAE,MAAO,EAAO,CACd,GAAI,aAAiB,EAAA,CAAC,CAAC,QAAQ,CAC7B,CAD+B,KACzB,AAAI,MAAM,2BAElB,OAAM,CACR,CACF,CAKO,eAAe,EAAgC,CAAmB,EAMvE,GAAI,CACF,GAAM,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACzB,EAAY,MAAM,IAExB,GAAI,CAAC,EACH,MAAO,CAAE,EADK,OACI,EAAO,MAAO,yBAA0B,EAI5D,MAAO,CAAE,QADO,MAAM,EAA0B,EAAW,EAC1C,CACnB,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,0CAA2C,GAClD,CACL,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,eAClD,CACF,CACF,CAKO,eAAe,EAAyB,CAAmB,EAOhE,GAAI,CACF,GAAM,CAAE,oBAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QACzB,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAEzB,EAAY,MAAM,IACxB,GAAI,CAAC,EACH,MAAO,CAAE,EADK,MACI,GAAO,MAAO,yBAA0B,EAG5D,IAAM,EAAW,MAAM,EAAmB,EAAW,GACrD,MAAO,CAAE,SAAS,WAAM,CAAS,CACnC,CAAE,MAAO,EAAO,CAGd,GAFA,QAAQ,KAAK,CAAC,mCAAoC,GAE9C,aAAiB,OAAS,EAAM,OAAO,CAAC,QAAQ,CAAC,WACnD,CAD+D,KACxD,CACL,SAAS,EACT,MAAO,yDACT,EAEF,MAAO,CACL,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,eAClD,CACF,CACF,CAKO,eAAe,IAapB,GAAI,CACF,GAAM,cAAE,CAAY,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QACnB,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAEzB,EAAY,MAAM,IACxB,GAAI,CAAC,EACH,MAAO,CAAE,EADK,OACI,EAAO,MAAO,yBAA0B,EAG5D,IAAM,EAAW,MAAM,IACvB,GAAI,CAAC,EACH,MAAO,CAAE,CADI,QACK,EAAO,MAAO,4BAA6B,EAG/D,IAAM,EAAY,EACf,IAAI,CAAC,kBACL,MAAM,CAAC,IAAK,CAAE,MAAO,QAAS,MAAM,CAAK,GACzC,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,OAAQ,OAGR,CAAC,EAAa,EAAY,EAAe,EAAY,CAAG,MAAM,QAAQ,GAAG,CAAC,CAE9E,EACG,EAAE,CAAC,YAAa,WAChB,EAAE,CAAC,eAAe,GAClB,EAAE,CAAC,aAAc,MACjB,EAAE,CAAC,gDAEN,EACG,EAAE,CAAC,YAAa,YAChB,EAAE,CAAC,eAAe,GAClB,EAAE,CAAC,aAAc,MAEpB,EAAU,EAAE,CAAC,eAAe,GAAM,EAAE,CAAC,aAAc,MAEnD,EAAU,GAAG,CAAC,aAAc,KAAM,MACnC,EAEK,EAAS,CACb,MAAO,EAAY,KAAK,EAAI,EAC5B,KAAM,EAAW,KAAK,EAAI,EAC1B,QAAS,EAAc,KAAK,EAAI,EAChC,MAAO,EAAY,KAAK,EAAI,CAC9B,EAEA,MAAO,CAAE,SAAS,SAAM,CAAO,CACjC,CAAE,MAAO,EAAO,CACd,MAAO,CAAE,SAAS,EAAO,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,eAAgB,CAC3F,CACF,CAKO,eAAe,EACpB,CAAa,EAQb,GAAI,CACF,GAAM,oBAAE,CAAkB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACzB,EAAY,MAAM,IAExB,GAAI,CAAC,EACH,MAAO,CAAE,EADK,OACI,EAAO,MAAO,yBAA0B,EAG5D,GAAM,cAAE,CAAY,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QACnB,EAAW,MAAM,IAEvB,GAAI,CAAC,EACH,MAAO,CAAE,CADI,QACK,EAAO,MAAO,4BAA6B,EAG/D,IAAM,EAAiB,EAAE,CAIvB,IAAK,IAAM,KAAQ,EAAO,CACxB,IAAM,EAAU,EAAK,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAClC,EAAW,CAAA,EAAG,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE,EAAA,CAAS,CAGhF,EAAW,CAAA,EAAG,EAAU,iBAAiB,EAAE,EAAA,CAAU,CAGrD,EAAc,MAAM,EAAK,WAAW,GACpC,MAAE,CAAI,CAAE,MAAO,CAAW,CAAE,CAAG,MAAM,EAAS,OAAO,CACxD,IAAI,CAAC,iBAAiB,AACtB,MAAM,CAAC,EAAU,EAAa,CAC7B,YAAa,EAAK,IAAI,CACtB,QAAQ,CACV,GAEF,AANoE,GAMhE,EAEF,OADA,IADe,IACP,KAAK,CAAC,gBAAiB,GACxB,CAAE,SAAS,EAAO,MAAO,CAAC,iBAAiB,EAAE,EAAK,IAAI,CAAC,EAAE,EAAE,EAAY,OAAO,CAAA,CAAE,AAAC,EAI1F,GAAM,CAAE,KAAM,WAAE,CAAS,CAAE,CAAE,CAAG,EAAS,OAAO,CAC7C,IAAI,CAAC,iBACL,YAAY,CAAC,GAEhB,EAAK,IAAI,CAAC,EACZ,CAEF,MAAO,CAAE,SAAS,OAAM,CAAK,CAC/B,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,mCAAoC,GAC3C,CACL,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,eAClD,CACF,CACF,CAgBO,eAAe,IAOpB,GAAI,CACF,GAAM,kBAAE,CAAgB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAEvB,EAAU,MAAM,IACtB,GAAI,CAAC,EACH,MAAO,CADK,AACH,SAAS,EAAO,MAAO,yBAA0B,EAG5D,MAAO,CACL,SAAS,EACT,QAAS,CACP,YAAa,EAAQ,IAAI,CACzB,aAAc,EAAQ,KAAK,OAAI,EAC/B,aAAc,EAAQ,KAAK,OAAI,CACjC,CACF,CACF,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,iCAAkC,GACzC,CACL,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,eAClD,CACF,CACF,iCAxUsB,EA4BA,EAgCA,EAwBA,EA4BA,EAqCA,EAoEA,EAiFA,IA1SA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MA4BA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAgCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAwBA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MA4BA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAqCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAoEA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAiFA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,siBC5UrB,IAAA,EAAA,EAAA,CAAA,CAAA,QAID,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,sBAyBA,IAAM,EAGF,CACH,SAAU,CAAE,MAAO,YAAa,MAAO,OAAQ,aAAa,CAAM,EAClE,IAAK,CAAE,MAAO,OAAQ,MAAO,WAAY,aAAa,CAAK,EAC3D,SAAU,CAAE,MAAO,aAAc,MAAO,WAAY,aAAa,CAAK,EACtE,QAAS,CAAE,MAAO,WAAY,MAAO,WAAY,aAAa,CAAK,EACnE,SAAU,CAAE,MAAO,YAAa,MAAO,WAAY,YAAa,EAAK,EACrE,UAAW,CAAE,MAAO,YAAa,MAAO,WAAY,aAAa,CAAK,EACtE,YAAa,CAAE,MAAO,eAAgB,MAAO,WAAY,aAAa,CAAK,EAC3E,SAAU,CAAE,MAAO,gBAAiB,MAAO,WAAY,YAAa,EAAK,EACzE,OAAQ,CAAE,MAAO,UAAW,MAAO,OAAQ,aAAa,CAAM,CAC/D,EAKO,eAAe,EACrB,CAAsB,CACtB,CAAgB,CAChB,CAAiB,EAEjB,MAAO,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,UACxB,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,MAAM,AAAI,EADI,IACE,oCAIjB,OAAM,KAEN,IAAM,EAAS,CAAoB,CAAC,EAAW,CAC/C,GAAI,CAAC,EACJ,GAJ8B,GAGlB,AACN,AAAI,MAAM,CAAC,yBAAyB,EAAE,EAAA,CAAY,EAGzD,IAAM,EAAa,MAAM,EAAoB,CAC5C,UAAU,QACV,WACA,aACA,OACA,CACD,GAYA,OAVA,MAAM,EAAe,CACpB,SAjBqB,CAiBX,CACV,kBACA,aACA,aACA,CACD,GAEA,EAAsB,EAAY,GAE3B,UAAE,aAAU,OAAY,CAAK,CACrC,EACD,CAoBA,IAAM,EAA2B,MAAO,IACvC,GAAM,CACL,KAAM,MAAE,CAAI,CAAE,CACd,CAAG,MAAM,EAAS,IAAI,CAAC,OAAO,GAC/B,GAAI,CAAC,EACJ,IADU,EACJ,AAAI,MAAM,qBAEjB,OAAO,CACR,EAYM,EAAsB,MAAO,UAClC,CAAQ,QACR,CAAM,CACN,UAAQ,YACR,CAAU,MACV,CAAI,CACuB,IAC3B,GAAI,CAAC,EAAO,WAAW,CACtB,CADwB,KACjB,MACN,EACA,WAAY,IAAI,OAAO,WAAW,EACnC,EAGD,GAAM,CAAE,KAAM,CAAc,CAAE,MAAO,CAAU,CAAE,CAAG,MAAM,EACxD,IAAI,CAAC,EAAO,KAAK,EACjB,MAAM,CAAC,YACP,EAAE,CAAC,KAAM,GACT,MAAM,GAER,GAAI,EACH,MAAM,AAAI,IADK,EAEd,CAAC,eAAe,EAAE,EAAW,WAAW,EAAE,EAAW,OAAO,CAAA,CAAE,EAWhE,MAAO,CACN,SAAU,CAHN,GAJJ,GACmC,UAAnC,OAAO,EAAe,QAAQ,EACF,OAA5B,EAAe,QAAQ,CACnB,EAAe,QAAQ,CACxB,CAAC,CAIH,GAAG,GACH,CACD,EACA,UAHoB,CAGR,IAAI,OAAO,WAAW,EACnC,CACD,EAUM,EAAiB,MAAO,UAC7B,CAAQ,QACR,CAAM,UACN,CAAQ,YACR,CAAU,YACV,CAAU,CACY,IACtB,GAAM,OAAE,CAAK,CAAE,CAAG,MAAM,EACtB,IAAI,CAAC,EAAO,KAAK,EACjB,MAAM,CAAC,GACP,EAAE,CAAC,KAAM,GAEX,GAAI,EACH,KADU,CACJ,AAAI,MAAM,CAAC,iBAAiB,EAAE,EAAW,OAAO,EAAE,EAAM,OAAO,CAAA,CAAE,CAEzE,EAEM,EAAwB,CAAC,EAAwB,KACtD,IAAM,EA3FC,AAX4C,CAClD,QAqGgB,CArGN,YACV,IAAK,OACL,SAAU,kBACV,QAAS,gBACT,SAAU,iBACV,UAAW,iBACX,YAAa,WACb,SAAU,KACV,OAAQ,cACT,CACc,CAAC,AA2FmB,EA3FR,EAAI,KA4F1B,IACH,CAAA,EAAA,EAAA,CADa,aACb,AAAc,EAAC,CAAC,WAAW,EAAE,EAAS,CAAC,EAAE,EAAA,CAAU,EACnD,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,CAAC,WAAW,EAAE,EAAA,CAAU,GAGxC,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,aAChB,kCA1JsB,IAAA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,+DCvCtB,IAAA,EAAA,EAAA,CAAA,CAAA,QAgCO,eAAe,EACrB,CAAiB,CACjB,CAIC,EAED,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,OAAO,CADO,IAKf,GAAM,CAAE,KAAM,CAAY,CAAE,CAAG,MAAM,EACnC,IAAI,CAAC,yBACL,MAAM,CAAC,MACP,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,aAAa,GAChB,KAAK,CAAC,GAER,GAAI,CAAC,GAAwC,GAAG,CAA3B,EAAa,MAAM,CACvC,OAAO,KAIR,GAAM,CAAE,KAAM,CAAU,CAAE,CAAG,MAAM,EACjC,IAAI,CAAC,8BACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,SAAU,UACb,KAAK,CAAC,aAAc,CAAE,WAAW,CAAM,GAEzC,GAAI,CAAC,GAAoC,GAAG,CAAzB,EAAW,MAAM,CACnC,OAAO,KAIR,GAAI,GAAS,eAAgB,CAC5B,IAAM,EAAY,EAAW,IAAI,CAChC,AAAC,GAAM,EAAE,cAAc,GAAK,EAAQ,cAAc,EAEnD,GAAI,EACH,OAAO,EADO,AACiB,EAEjC,CAGA,IAAM,EAAS,GAAS,QAAU,EAC5B,EAAU,GAAS,SAAW,SAGpC,GACC,EAAS,KACT,EAAW,IAAI,CAAC,AAAC,GAA2B,UAArB,EAAE,cAAc,EACtC,CACD,IAAM,EAAiB,EAAW,IAAI,CAAC,AAAC,GAA2B,UAArB,EAAE,cAAc,EAC9D,GAAI,EACH,OAAO,EAAwB,EAEjC,CAGA,EANqB,CAOpB,CAAa,iBAAZ,GAA0C,eAAZ,CAAY,CAAY,EACvD,EAAW,IAAI,CAAC,AAAC,GAAM,AAAqB,YAAnB,cAAc,EACtC,CACD,IAAM,EAAiB,EAAW,IAAI,CAAE,AAAD,GAA4B,UAArB,EAAE,cAAc,EAC9D,GAAI,EACH,OAAO,EAAwB,EAEjC,CAGA,EANqB,CAMjB,AAAY,UAAO,CACtB,IAAM,EAAiB,EAAW,IAAI,CAAC,AAAC,GAA2B,UAArB,EAAE,cAAc,EAC9D,GAAI,EACH,OAAO,EAAwB,GAEhC,EAHoB,EAGd,EAAuB,EAAW,IAAI,CAC3C,AAAC,GAA2B,gBAArB,EAAE,cAAc,EAExB,GAAI,EACH,OAAO,EAAwB,EAEjC,CAGA,OAAO,CANoB,CAMI,CAAU,CAAC,EAAE,CAC7C,CAKA,eAAe,EACd,CAAW,EAEX,OAAQ,EAAO,cAAc,EAC5B,IAAK,QAAS,CACb,GAAM,gBAAE,CAAc,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QAC3B,OAAO,IAAI,EAAe,CACzB,UAAW,EAAO,UAAU,CAC5B,UAAW,EAAO,gBAAgB,CAClC,OAAQ,EAAO,uBAAuB,CACtC,gBAAiB,EAAO,sBAAsB,CAC9C,SAAU,EAAO,eAAe,AACjC,EACD,CACA,IAAK,QAAS,CACb,GAAM,gBAAE,CAAc,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QAC3B,OAAO,IAAI,EAAe,CACzB,UAAW,EAAO,UAAU,CAC5B,SAAU,EAAO,eAAe,CAChC,OAAQ,EAAO,sBAAsB,CACrC,YAAa,EAAO,iBAAiB,EAAI,SAC1C,EACD,CACA,IAAK,cAAe,CACnB,GAAM,sBAAE,CAAoB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QACjC,OAAO,IAAI,EAAqB,CAC/B,UAAW,EAAO,UAAU,CAC5B,WAAY,EAAO,uBAAuB,CAC1C,OAAQ,EAAO,6BAA6B,CAC5C,cAAe,EAAO,0BAA0B,AACjD,EACD,CACA,IAAK,SAAU,CACd,GAAM,iBAAE,CAAe,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QAC5B,OAAO,IAAI,EAAgB,CAC1B,UAAW,EAAO,UAAU,CAC5B,SAAU,EAAO,eAAe,AACjC,EACD,CACA,QACC,OAAO,IACT,CACD,CAOO,eAAe,EACrB,CAAiB,CACjB,CAAc,EAOd,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,MAAO,CACN,CAFa,KAEN,EACP,SAAS,EACT,kBAAkB,EAClB,OAAQ,sBACT,EAID,GAAM,CAAE,KAAM,CAAU,CAAE,CAAG,MAAM,EACjC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAc,GACjB,MAAM,GAER,GAAI,CAAC,EACJ,MAAO,CACN,GAFe,GAER,GACP,QAAS,GACT,kBAAkB,EAClB,OAAQ,sBACT,EAGD,IAAM,EAAQ,OAAO,EAAW,aAAa,EAGvC,CAAE,KAAM,CAAS,CAAE,CAAG,MAAM,EAChC,IAAI,CAAC,8BACL,MAAM,CAAC,+CACP,EAAE,CAAC,aAAc,GACjB,EAAE,CAAC,SAAU,UACb,MAAM,GAEF,EAAY,GAAW,oBAAsB,IAC7C,EAAoB,GAAW,AADuB,iBAAiB,QACb,IAQ5D,EAAgB,EARoD,AAmBlE,EAAU,IATf,EADG,GAAS,CAUa,EATT,CAVsE,AAStE,CAEN,GAAS,GACH,CADO,IACF,KAAK,CAAa,GAAZ,GACjB,GAAS,GACH,CADO,IACF,KAAK,CAAa,IAAZ,GAEX,KAIX,EAAmB,CAJA,CAIS,GAAqB,EAAQ,GAE/D,MAAO,AANiC,OAOvC,UACA,mBACA,EACA,OAAQ,EACL,EACC,wCACA,EACD,CAAC,oEAAoE,EAAE,EAAgB,IAAA,CAAK,AAChG,CACD,CAKO,eAAe,EACrB,CAAiB,CACjB,CAAgB,CAChB,CAAc,EAEd,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,OAGD,CAJe,EAIT,CAAE,KAAM,CAAU,CAAE,CAAG,MAAM,EACjC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAc,GACjB,MAAM,GAER,GAAI,CAAC,EACJ,OAID,GALiB,CAKX,EAAe,CACpB,qBAAsB,CAAC,EAAW,oBAAoB,GAAI,CAAC,CAAI,EAC/D,sBAAuB,CAAC,EAAW,qBAAqB,GAAI,CAAC,CAAI,EACjE,mBAAoB,IAAI,OAAO,WAAW,EAC3C,EAEI,EACH,EAAQ,KADI,oBACqB,CAChC,CAAC,EAAW,yBAAyB,GAAI,CAAC,CAAI,EAE/C,EAAQ,qBAAqB,CAAG,CAAC,EAAW,qBAAqB,GAAI,CAAC,CAAI,EAIvE,GAAU,EAAW,IAAZ,kBAAkC,GAAI,CAAC,EACnD,CADsD,EAC9C,sBAAsB,CAAG,CAAA,EAIlC,IAAM,EAAgB,EAAQ,oBAAoB,CAC5C,EACL,EAAQ,yBAAyB,EACjC,EAAW,yBAAyB,EACpC,EAEA,EAAQ,qBAAqB,EAAI,EAAW,qBAAqB,CAOlE,GAPsE,CAOhE,EAAe,KAAK,GAAG,CAC5B,IAC6D,GAA7D,KAAK,KAAK,CAAC,CAAC,EAAQ,qBAAqB,GAAI,CAAC,CAAI,IAAM,IAgBzD,EAAQ,aAAa,CAAG,KAAK,GAAG,CAAC,IAAK,KAAK,GAAG,CAAC,EAP9C,AAAc,CAOmC,GArBjD,EAcoB,AAdJ,EAAK,EAAqB,EAAiB,IAAM,EAAA,EAejE,AAAe,KACf,AAAY,CADS,EALJ,GAMC,EANI,EAI2B,CAJxB,CAAC,IAAM,CADV,EAAW,KAMW,UACE,CAPG,GAAI,EACJ,GAAM,IAOvB,CAP4B,IAO3D,AAAoC,CAAC,CAA1B,GAA8B,cAAb,CACO,IARoD,AAQvF,AAAuC,CAAC,CAA7B,EADqD,CAEjE,kBADiC,CACD,IAAI,AAAnC,CAAoC,CAAzB,iBAAiB,GAG9B,EAAQ,WAAW,CAClB,EAAgB,EACZ,AAAC,GAAW,eAAe,EAAI,CAAC,EAAI,EAAQ,qBAAqB,CACnE,IACC,EAEJ,MAAM,EACJ,IAAI,CAAC,wBACL,MAAM,CAAC,GACP,EAAE,CAAC,aAAc,EACpB,yIC1UO,EARP,IAAA,EAAA,EAAA,CAAA,CAAA,OAqBO,IAAM,KAbM,IAaG,IAbK,GAAG,CAAC,iBAAiB,EAMxC,IAAI,EAAA,OAAM,CAAC,EAAW,CAC5B,WAAY,oBACZ,WAAY,EACb,GANQ,oECTT,EAAA,CAAA,CAAA,QACA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,CAAA,CAAA,QACA,IAAA,EAAA,EAAA,CAAA,CAAA,sBAuUO,eAAe,IACrB,GAAI,CACH,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,MAAO,CACN,CAFa,QAEJ,EACT,MAAO,sBACP,eAAgB,EAAE,AACnB,EAED,GAAM,CACL,KAAM,MAAE,CAAI,CAAE,CACd,MAAO,CAAS,CAChB,CAAG,MAAM,EAAS,IAAI,CAAC,OAAO,GAE/B,GAAI,GAAa,CAAC,EACjB,IADuB,EAChB,CAAE,SAAS,EAAO,MAAO,eAAgB,eAAgB,EAAE,AAAC,EAGpE,GAAM,CAAE,KAAM,CAAc,CAAE,OAAK,CAAE,CAAG,MAAM,EAC5C,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,UAAW,EAAK,EAAE,EACrB,KAAK,CAAC,aAAc,CAAE,WAAW,CAAM,GACvC,KAAK,CAAC,aAAc,CAAE,WAAW,CAAM,GAEzC,GAAI,EACH,KADU,CACH,CACN,SAAS,EACT,MAAO,kCACP,eAAgB,EAAE,AACnB,EAGD,MAAO,CAAE,SAAS,EAAM,eAAgB,GAAkB,EAAE,AAAC,CAC9D,CAAE,MAAO,EAAQ,CAChB,MAAO,CAAE,SAAS,EAAO,MAAO,oBAAqB,eAAgB,EAAE,AAAC,CACzE,CACD,CA1WgC,EAAA,CAAC,CAAC,MAAM,CAAC,CACxC,gBAAiB,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAChC,UAAW,EAAA,CAAC,CAAC,OAAO,GAAG,QAAQ,GAAG,OAAO,EAAC,GAC1C,yBAA0B,EAAA,CAAC,CAAC,OAAO,GAAG,QAAQ,GAAG,OAAO,EAAC,EAC1D,GAEyB,EAAA,CAAC,CAAC,MAAM,CAAC,CACjC,gBAAiB,EAAA,CAAC,CAAC,MAAM,GAAG,IAAI,GAChC,gBAAiB,EAAA,CAAC,CAAC,OAAO,GAAG,QAAQ,GAAG,OAAO,EAAC,EACjD,GAEkC,EAAA,CAAC,CAAC,MAAM,CAAC,CAC1C,gBAAiB,EAAA,CAAC,CAAC,MAAM,GAAG,IAAI,EACjC,mCAuTsB,IAAA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,kFCzVtB,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QA4BO,eAAe,EACrB,CAA+B,SAE/B,AAAI,aAAiB,SACb,CADuB,CACD,GAGvB,EAAsB,EAC9B,CAEA,eAAe,EACd,CAAmB,CACnB,CAAkE,EAElE,GAAI,CACH,IAAM,EAAY,EAAA,mBAAmB,CAAC,KAAK,CAAC,GACtC,EAAW,GAAqB,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IAExD,GAAI,CAAC,EACJ,MAAO,CAAE,CADK,OACI,GAAO,MAAO,mCAAoC,EAGrE,GAAM,CAAE,KAAM,CAAO,OAAE,CAAK,CAAE,CAAG,MAAM,EACrC,IAAI,CAAC,YACL,MAAM,CAAC,GACP,MAAM,CAAC,mDACP,MAAM,GAER,GAAI,EACH,KADU,CACH,CAAE,SAAS,EAAO,MAAO,EAAM,OAAO,AAAC,EAI/C,GAAM,CAAE,KAAM,CAAQ,CAAE,CAAG,MAAM,EAC/B,IAAI,CAAC,aACL,MAAM,CAAC,QACP,EAAE,CAAC,KAAM,EAAQ,WAAW,EAC5B,MAAM,GAGF,CAAE,KAAM,CAAY,CAAE,CAAG,MAAM,EACnC,IAAI,CAAC,uBACL,MAAM,CAAC,WACP,EAAE,CAAC,aAAc,EAAQ,UAAU,EACnC,EAAE,CAAC,SAAU,UACb,KAAK,CAAC,GAQR,GAAI,GAAY,GAAgB,EAAa,MAAM,CAAG,EAAG,CACxD,IAAM,EAAgB,EAAa,GAAG,CAAC,AAAC,IAAgB,CACvD,QADsD,AAC7C,EAAW,OAAO,CAC3B,WAAY,EAAQ,UAAU,CAC9B,KAAM,UACN,MAAO,mBACP,QAAS,CAAC,YAAY,EAAE,CAAC,EAAQ,MAAM,CAAG,GAAA,CAAG,CAAE,OAAO,CAAC,GAAG,eAAe,EAAE,EAAS,IAAI,CAAA,CAAE,CAC1F,SAAU,OACV,WAAY,8BACZ,aAAc,eACd,SAAU,CACT,WAAY,EAAQ,EAAE,CACtB,YAAa,EAAQ,WAAW,CAChC,WAAY,EAAQ,UAAU,CAC9B,OAAQ,EAAQ,MAAM,AACvB,EACA,SAAS,EACT,aAAa,EACd,CAAC,CAGD,OAAM,EAAS,IAAI,CAAC,iBAAiB,MAAM,CAAC,EAC7C,CAGA,MADA,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,+BACR,CAAE,SAAS,EAAM,UAAW,EAAQ,EAAE,AAAC,CAC/C,CAAE,MAAO,EAAO,CACf,GAAI,aAAiB,MACpB,CAD2B,KACpB,CAAE,SAAS,EAAO,MAAO,EAAM,OAAQ,AAAD,EAE9C,MAAO,CAAE,SAAS,EAAO,MAAO,0BAA2B,CAC5D,CACD,CAEA,eAAe,EACd,CAAkB,EAElB,GAAI,CACH,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IACnC,GAAI,CAAC,EACJ,MAAO,CAAE,CADK,QACI,EAAO,MAAO,mCAAoC,EAGrE,IAAM,EAAY,EAAS,GAAG,CAAC,cAAc,WAC7C,GAAI,CAAC,EACJ,MAAO,CAAE,EADM,OACG,EAAO,MAAO,qBAAsB,EAGvD,IAAM,EAAY,EAAS,GAAG,CAAC,UACzB,EAAe,OAAO,UAAU,CAAC,GACvC,GAAI,CAAC,OAAO,QAAQ,CAAC,IAAiB,GAAgB,EACrD,CADwD,KACjD,CAAE,SAAS,EAAO,MAAO,uCAAwC,EAEzE,IAAM,EAAS,KAAK,KAAK,CAAgB,IAAf,GAEpB,CAAE,KAAM,CAAO,CAAE,MAAO,CAAY,CAAE,CAAG,MAAM,EACnD,IAAI,CAAC,YACL,MAAM,CAAC,iEACP,EAAE,CAAC,KAAM,GACT,MAAM,GAER,GAAI,GAAgB,CAAC,EACpB,MAAO,CADsB,AACpB,SAAS,EAAO,MAAO,mBAAoB,EAGrD,GAAM,CACL,KAAM,MAAE,CAAI,CAAE,CACd,CAAG,MAAM,EAAS,IAAI,CAAC,OAAO,GAEzB,EACJ,EAAS,GAAG,CAAC,kBACd,OACK,EAAmB,EAAS,GAAG,CAAC,gBAAgB,WAChD,EAAc,EAAS,GAAG,CAAC,gBAAgB,YAAc,KACzD,EAAQ,EAAS,GAAG,CAAC,UAAU,YAAc,KAE7C,EAAgB,CAAC,IAAI,EAAE,KAAK,GAAG,GAAA,CAAI,CAEnC,EAA6B,CAClC,WAAY,EAAQ,UAAU,CAC9B,YAAa,EAAQ,WAAW,CAChC,WAAY,EAAQ,EAAE,CACtB,OAAQ,EAAQ,MAAM,EAAI,KAC1B,eAAgB,SAChB,EACA,SAAW,EAAQ,QAAQ,EAAI,MAC/B,eAAgB,EAChB,aAAc,UACd,OAAQ,YACR,aAAc,QACd,EACA,WAAY,EACZ,cAAe,EACf,gBAAiB,EACjB,cAAe,GACf,aAAc,EAAmB,IAAI,KAAK,GAAoB,IAAI,KAClE,aAAc,GAAM,IAAM,IAC3B,EAEA,OAAO,EAAsB,EAAa,EAC3C,CAAE,MAAO,EAAO,CACf,GAAI,aAAiB,MACpB,CAD2B,KACpB,CAAE,SAAS,EAAO,MAAO,EAAM,OAAO,AAAC,EAE/C,MAAO,CAAE,SAAS,EAAO,MAAO,0BAA2B,CAC5D,CACD,CAmTA,eAAe,EACd,CAAiB,EAEjB,GAAI,CACH,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAY,AAAZ,IAEvB,GAAI,CAAC,EACJ,MAAO,CAAE,CADK,QACI,EAAO,MAAO,mCAAoC,EAGrE,GAAM,CACL,KAAM,MAAE,CAAI,CAAE,CACd,CAAG,MAAM,EAAS,IAAI,CAAC,OAAO,GAE/B,GAAI,CAAC,EACJ,IADU,EACH,CAAE,SAAS,EAAO,MAAO,cAAe,EAGhD,GAAM,OAAE,CAAK,CAAE,CAAG,MAAM,EACtB,IAAI,CAAC,YACL,MAAM,CAAC,CACP,WAAY,IAAI,OAAO,WAAW,GAClC,WAAY,EAAK,EAAE,AACpB,GACC,EAAE,CAAC,KAAM,GAEX,GAAI,EACH,KADU,CACH,CAAE,SAAS,EAAO,MAAO,EAAM,OAAO,AAAC,EAK/C,MAFA,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,+BACf,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,4BACR,CAAE,SAAS,CAAK,CACxB,CAAE,MAAO,EAAO,CACf,GAAI,aAAiB,MACpB,CAD2B,KACpB,CAAE,SAAS,EAAO,MAAO,EAAM,OAAO,AAAC,EAE/C,MAAO,CAAE,SAAS,EAAO,MAAO,0BAA2B,CAC5D,CACD,CAKO,eAAe,EACrB,CAAiB,EAEjB,OAAO,EAAc,EACtB,CAOO,eAAe,EACrB,CAAiB,EAEjB,GAAI,CACH,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAY,AAAZ,IAEvB,GAAI,CAAC,EACJ,MAAO,CAAE,CADK,QACI,EAAO,MAAO,mCAAoC,EAIrE,GAAM,CAAE,KAAM,CAAO,CAAE,MAAO,CAAU,CAAE,CAAG,MAAM,EACjD,IAAI,CAAC,YACL,MAAM,CAAC,cACP,EAAE,CAAC,KAAM,GACT,EAAE,CAAC,aAAc,MACjB,MAAM,GAER,GAAI,GAAc,CAAC,EAClB,MAAO,CADoB,AAClB,SAAS,EAAO,MAAO,mBAAoB,EAGrD,IAAM,EAAgB,EAAQ,MAAM,CAG9B,CAAE,MAAO,CAAW,CAAE,CAAG,MAAM,EACnC,IAAI,CAAC,YACL,MAAM,CAAC,CAAE,OAAQ,IAAK,GACtB,EAAE,CAAC,KAAM,GAEX,GAAI,EACH,MAAO,CAAE,IADO,KACE,EAAO,MAAO,EAAY,OAAQ,AAAD,EAUpD,MANA,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,CAAC,yBAAyB,EAAE,EAAA,CAAW,EAClD,GACH,CAAA,EAAA,EAAA,OADkB,OAClB,AAAc,EAAC,CAAC,gBAAgB,EAAE,EAAA,CAAe,EAElD,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,4BAER,CAAE,SAAS,CAAK,CACxB,CAAE,MAAO,EAAO,CACf,GAAI,aAAiB,MACpB,CAD2B,KACpB,CAAE,SAAS,EAAO,MAAO,EAAM,OAAO,AAAC,EAE/C,MAAO,CAAE,SAAS,EAAO,MAAO,mCAAoC,CACrE,CACD,2CAzjBsB,EA8fA,EAWA,IAzgBA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MA8fA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAWA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA"}