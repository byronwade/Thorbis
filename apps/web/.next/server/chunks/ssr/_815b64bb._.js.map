{"version":3,"sources":["../../../../../../apps/web/src/lib/communication/sms-service.ts","../../../../../../apps/web/src/actions/sms-actions.ts","../../../../../../apps/web/src/actions/entity-tags.ts","../../../../../../apps/web/src/lib/payments/processor.ts"],"sourcesContent":["/**\n * SMS Service\n * \n * Handles fetching and managing SMS messages from the communications table\n * Similar structure to email-service.ts but for SMS type communications\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type { TypedSupabaseClient } from \"@/types/supabase\";\n\nexport type CompanySms = {\n\tid: string;\n\tfrom_address: string | null;\n\tfrom_name: string | null;\n\tto_address: string | null;\n\tbody: string;\n\tbody_html: string | null;\n\tcreated_at: string;\n\tread_at: string | null;\n\tdirection: \"inbound\" | \"outbound\";\n\tcustomer_id: string | null;\n\tcustomer?: {\n\t\tid: string;\n\t\tfirst_name: string | null;\n\t\tlast_name: string | null;\n\t\tdisplay_name: string | null;\n\t\temail: string | null;\n\t\tphone: string | null;\n\t\tcompany_name: string | null;\n\t} | null;\n\tsent_at: string | null;\n\tdelivered_at: string | null;\n\tstatus: string;\n\tchannel: string | null;\n\tprovider_metadata: Record<string, unknown> | null;\n\tis_archived: boolean;\n\tsnoozed_until: string | null;\n\tcategory: string | null;\n\ttags: string[] | null;\n\ttelnyx_message_id: string | null;\n};\n\nexport type GetCompanySmsInput = {\n\tlimit?: number;\n\toffset?: number;\n\ttype?: \"sent\" | \"received\" | \"all\";\n\tfolder?: \"inbox\" | \"sent\" | \"archive\" | \"trash\" | \"bin\";\n\tlabel?: string;\n\tsearch?: string | null;\n\tsortBy?: \"created_at\" | \"sent_at\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\nexport type GetCompanySmsResult = {\n\tsms: CompanySms[];\n\ttotal: number;\n\thasMore: boolean;\n};\n\nexport async function getCompanySms(\n\tcompanyId: string,\n\tinput: GetCompanySmsInput = {},\n): Promise<GetCompanySmsResult> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tconst {\n\t\tlimit = 50,\n\t\toffset = 0,\n\t\ttype = \"all\",\n\t\tfolder,\n\t\tlabel,\n\t\tsearch,\n\t\tsortBy = \"created_at\",\n\t\tsortOrder = \"desc\",\n\t} = input;\n\n\t// Build the query - get all SMS messages\n\tlet query = supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t\t{ count: \"exact\" },\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\");\n\n\t// Apply folder filtering\n\tif (folder) {\n\t\tswitch (folder) {\n\t\t\tcase \"inbox\":\n\t\t\t\t// Inbox: inbound, not archived, not deleted, not snoozed (or snooze expired)\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"inbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.or(\"snoozed_until.is.null,snoozed_until.lt.now()\");\n\t\t\t\tbreak;\n\t\t\tcase \"sent\":\n\t\t\t\t// Sent: outbound, not archived, not deleted\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"outbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"archive\":\n\t\t\t\t// Archive: is_archived = true, not deleted\n\t\t\t\tquery = query.eq(\"is_archived\", true).is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"trash\":\n\t\t\tcase \"bin\":\n\t\t\t\t// Trash: deleted_at is not null\n\t\t\t\tquery = query.not(\"deleted_at\", \"is\", null);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Custom folder or label filtering - done in memory after fetch\n\t\t\t\t// (JSONB array containment not supported by PostgREST cs operator)\n\t\t\t\tquery = query.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t// Default: exclude deleted SMS\n\t\tquery = query.is(\"deleted_at\", null);\n\t}\n\n\t// Apply direction filter\n\tif (type === \"sent\") {\n\t\tquery = query.eq(\"direction\", \"outbound\");\n\t} else if (type === \"received\") {\n\t\tquery = query.eq(\"direction\", \"inbound\");\n\t}\n\n\t// Apply search filter\n\tif (search) {\n\t\tconst searchLower = search.toLowerCase();\n\t\tquery = query.or(\n\t\t\t`from_address.ilike.%${searchLower}%,to_address.ilike.%${searchLower}%,body.ilike.%${searchLower}%`,\n\t\t);\n\t}\n\n\t// Apply sorting\n\tconst ascending = sortOrder === \"asc\";\n\tif (sortBy === \"sent_at\") {\n\t\tquery = query.order(\"sent_at\", { ascending, nullsFirst: false });\n\t} else {\n\t\tquery = query.order(\"created_at\", { ascending });\n\t}\n\n\t// Apply pagination\n\tquery = query.range(offset, offset + limit - 1);\n\n\tconst { data, error, count } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS messages:\", error);\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tlet sms = (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n\n\t// Post-process custom folder/label filtering (JSONB array containment not supported by PostgREST)\n\tconst standardFolders = [\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"];\n\tconst folderName = label || folder;\n\tif (folderName && !standardFolders.includes(folderName)) {\n\t\tsms = sms.filter((msg) => {\n\t\t\tconst msgTags = msg.tags || [];\n\t\t\treturn Array.isArray(msgTags) && msgTags.includes(folderName);\n\t\t});\n\t\treturn {\n\t\t\tsms,\n\t\t\ttotal: sms.length,\n\t\t\thasMore: false,\n\t\t};\n\t}\n\n\tconst total = count || 0;\n\tconst hasMore = offset + sms.length < total;\n\n\treturn {\n\t\tsms,\n\t\ttotal,\n\t\thasMore,\n\t};\n}\n\nexport async function getSmsById(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<CompanySms | null> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\t...data,\n\t\ttags: (data.tags as string[]) || null,\n\t\tprovider_metadata: (data.provider_metadata as Record<string, unknown>) || null,\n\t} as CompanySms;\n}\n\nexport async function markSmsAsRead(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tconsole.error(\"❌ markSmsAsRead: Missing supabase\");\n\t\treturn false;\n\t}\n\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.select(\"id, read_at\")\n\t\t.single();\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tif (!data) {\n\t\tconsole.error(\"❌ markSmsAsRead: No data returned\");\n\t\treturn false;\n\t}\n\n\tconsole.log(\"✅ markSmsAsRead success:\", { smsId, read_at: data.read_at });\n\treturn true;\n}\n\n/**\n * Get all SMS messages for a conversation thread (by phone number)\n */\nexport async function getSmsConversation(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<CompanySms[]> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn [];\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Fetch all messages where this phone number is either from or to\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.order(\"created_at\", { ascending: true });\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS conversation:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsRead(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn false;\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Mark all unread inbound messages in this conversation as read\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.eq(\"direction\", \"inbound\")\n\t\t.is(\"read_at\", null)\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.select(\"id, read_at\");\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsConversationAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tconsole.log(`✅ markSmsConversationAsRead success: Marked ${data?.length || 0} messages as read`);\n\treturn true;\n}\n\n","\"use server\";\n\nimport {\n    getCompanySms,\n    getSmsById,\n    markSmsAsRead,\n    markSmsConversationAsRead,\n    type CompanySms,\n} from \"@/lib/communication/sms-service\";\nimport { z } from \"zod\";\n\nconst getSmsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  folder: z.enum([\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst markSmsReadSchema = z.object({\n  smsId: z.string().min(1),\n});\n\nexport type GetSmsInput = z.infer<typeof getSmsSchema>;\nexport type MarkSmsReadInput = z.infer<typeof markSmsReadSchema>;\n\n// Re-export SMS types from sms-service\nexport type { CompanySms };\n\nexport type GetSmsResult = Awaited<ReturnType<typeof getCompanySms>>;\n\n/**\n * Get SMS messages for the active company\n */\nexport async function getSmsAction(\n  input: GetSmsInput\n): Promise<GetSmsResult> {\n  try {\n    const parseResult = getSmsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      throw new Error(`Invalid input parameters: ${parseResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getCompanySms(companyId, validatedInput);\n  } catch (error) {\n    console.error(\"❌ getSmsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get a specific SMS by ID\n */\nexport async function getSmsByIdAction(smsId: string): Promise<{\n  success: boolean;\n  sms?: CompanySms;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const sms = await getSmsById(companyId, smsId);\n    \n    if (!sms) {\n      return { success: false, error: \"SMS not found\" };\n    }\n\n    return { success: true, sms };\n  } catch (error) {\n    console.error(\"Error getting SMS by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an SMS as read\n */\nexport async function markSmsAsReadAction(\n  input: MarkSmsReadInput\n): Promise<boolean> {\n  try {\n    const validatedInput = markSmsReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"Invalid input parameters\");\n    }\n\n    return await markSmsAsRead(companyId, validatedInput.smsId);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsReadAction(phoneNumber: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const success = await markSmsConversationAsRead(companyId, phoneNumber);\n    return { success };\n  } catch (error) {\n    console.error(\"Error marking SMS conversation as read:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS conversation thread by phone number\n */\nexport async function getSmsConversationAction(phoneNumber: string): Promise<{\n  success: boolean;\n  messages?: CompanySms[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getSmsConversation } = await import(\"@/lib/sms/sms-service\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const messages = await getSmsConversation(companyId, phoneNumber);\n    return { success: true, messages };\n  } catch (error) {\n    console.error(\"Error fetching SMS conversation:\", error);\n    // Handle cookies() error gracefully\n    if (error instanceof Error && error.message.includes(\"cookies\")) {\n      return {\n        success: false,\n        error: \"Request context not available. Please refresh the page.\",\n      };\n    }\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS folder counts\n */\nexport async function getSmsFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    inbox: number;\n    sent: number;\n    archive: number;\n    trash: number;\n    [label: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const baseQuery = supabase\n      .from(\"communications\")\n      .select(\"*\", { count: \"exact\", head: true })\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"sms\");\n    \n    // Get counts for each folder\n    const [inboxResult, sentResult, archiveResult, trashResult] = await Promise.all([\n      // Inbox\n      baseQuery\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n      // Sent\n      baseQuery\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null),\n      // Archive\n      baseQuery.eq(\"is_archived\", true).is(\"deleted_at\", null),\n      // Trash\n      baseQuery.not(\"deleted_at\", \"is\", null),\n    ]);\n    \n    const counts = {\n      inbox: inboxResult.count || 0,\n      sent: sentResult.count || 0,\n      archive: archiveResult.count || 0,\n      trash: trashResult.count || 0,\n    };\n    \n    return { success: true, counts };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Upload SMS attachments to storage\n */\nexport async function uploadSmsAttachments(\n  files: File[]\n): Promise<{\n  success: boolean;\n  urls?: string[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const supabase = await createClient();\n    \n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const urls: string[] = [];\n    \n      // Upload each file to Supabase Storage\n      // Use company-files bucket which has proper RLS policies for company members\n      for (const file of files) {\n        const fileExt = file.name.split('.').pop();\n        const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;\n        // Path structure: companyId must be at index [0] for RLS policy (matches document-manager pattern)\n        // Format: companyId/folder/filename (storage.foldername(name))[0] = companyId\n        const filePath = `${companyId}/sms-attachments/${fileName}`;\n        \n        // Convert file to array buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const { data, error: uploadError } = await supabase.storage\n          .from('company-files') // Use company-files bucket with proper RLS\n          .upload(filePath, arrayBuffer, {\n            contentType: file.type,\n            upsert: false,\n          });\n        \n        if (uploadError) {\n          console.error(\"Upload error:\", uploadError);\n          return { success: false, error: `Failed to upload ${file.name}: ${uploadError.message}` };\n        }\n        \n        // Get public URL (or signed URL for private bucket)\n        const { data: { publicUrl } } = supabase.storage\n          .from('company-files')\n          .getPublicUrl(filePath);\n        \n        urls.push(publicUrl);\n      }\n    \n    return { success: true, urls };\n  } catch (error) {\n    console.error(\"Error uploading SMS attachments:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * SMS Template Context Type\n * Data available for auto-filling SMS templates\n */\nexport type SmsTemplateContext = {\n  companyName?: string;\n  companyPhone?: string;\n  companyEmail?: string;\n};\n\n/**\n * Get company context for SMS templates\n * Returns company info for auto-filling template messages\n */\nexport async function getCompanyContextAction(): Promise<{\n  success: boolean;\n  context?: SmsTemplateContext;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { getActiveCompany } = await import(\"@/lib/auth/company-context\");\n\n    const company = await getActiveCompany();\n    if (!company) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    return {\n      success: true,\n      context: {\n        companyName: company.name,\n        companyPhone: company.phone || undefined,\n        companyEmail: company.email || undefined,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting company context:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n","/**\n * Entity Tags Actions - Server Actions\n * Generic tag management for any entity type\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { withErrorHandling } from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nexport type TagWithColor = {\n\tlabel: string;\n\tcolor?: string;\n};\n\nexport type EntityTag = string | TagWithColor;\n\ntype EntityType =\n\t| \"customer\"\n\t| \"job\"\n\t| \"property\"\n\t| \"invoice\"\n\t| \"estimate\"\n\t| \"equipment\"\n\t| \"appointment\"\n\t| \"material\"\n\t| \"vendor\";\n\nconst ENTITY_TAG_FIELD_MAP: Record<\n\tEntityType,\n\t{ table: string; field: string; useMetadata: boolean }\n> = {\n\tcustomer: { table: \"customers\", field: \"tags\", useMetadata: false },\n\tjob: { table: \"jobs\", field: \"metadata\", useMetadata: true },\n\tproperty: { table: \"properties\", field: \"metadata\", useMetadata: true },\n\tinvoice: { table: \"invoices\", field: \"metadata\", useMetadata: true },\n\testimate: { table: \"estimates\", field: \"metadata\", useMetadata: true },\n\tequipment: { table: \"equipment\", field: \"metadata\", useMetadata: true },\n\tappointment: { table: \"appointments\", field: \"metadata\", useMetadata: true },\n\tmaterial: { table: \"job_materials\", field: \"metadata\", useMetadata: true },\n\tvendor: { table: \"vendors\", field: \"tags\", useMetadata: false },\n};\n\n/**\n * Update tags for any entity type\n */\nexport async function updateEntityTags(\n\tentityType: EntityType,\n\tentityId: string,\n\ttags: EntityTag[],\n) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst typedSupabase = supabase as SupabaseServerClient;\n\t\tawait requireAuthenticatedUser(typedSupabase);\n\n\t\tconst config = ENTITY_TAG_FIELD_MAP[entityType];\n\t\tif (!config) {\n\t\t\tthrow new Error(`Unsupported entity type: ${entityType}`);\n\t\t}\n\n\t\tconst updateData = await buildTagsUpdateData({\n\t\t\tsupabase: typedSupabase,\n\t\t\tconfig,\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\ttags,\n\t\t});\n\n\t\tawait applyTagUpdate({\n\t\t\tsupabase: typedSupabase,\n\t\t\tconfig,\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\tupdateData,\n\t\t});\n\n\t\trevalidateEntityPaths(entityType, entityId);\n\n\t\treturn { entityId, entityType, tags };\n\t});\n}\n\n/**\n * Get the base path for an entity type\n */\nfunction getPathForEntity(entityType: EntityType): string | null {\n\tconst pathMap: Record<EntityType, string | null> = {\n\t\tcustomer: \"customers\",\n\t\tjob: \"work\",\n\t\tproperty: \"work/properties\",\n\t\tinvoice: \"work/invoices\",\n\t\testimate: \"work/estimates\",\n\t\tequipment: \"work/equipment\",\n\t\tappointment: \"schedule\",\n\t\tmaterial: null,\n\t\tvendor: \"work/vendors\",\n\t};\n\treturn pathMap[entityType] ?? null;\n}\n\nconst requireAuthenticatedUser = async (supabase: SupabaseServerClient) => {\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tif (!user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\treturn user;\n};\n\ntype TagUpdateConfig = (typeof ENTITY_TAG_FIELD_MAP)[EntityType];\n\ntype BuildTagsUpdateDataParams = {\n\tsupabase: SupabaseServerClient;\n\tconfig: TagUpdateConfig;\n\tentityId: string;\n\tentityType: EntityType;\n\ttags: EntityTag[];\n};\n\nconst buildTagsUpdateData = async ({\n\tsupabase,\n\tconfig,\n\tentityId,\n\tentityType,\n\ttags,\n}: BuildTagsUpdateDataParams): Promise<Record<string, unknown>> => {\n\tif (!config.useMetadata) {\n\t\treturn {\n\t\t\ttags,\n\t\t\tupdated_at: new Date().toISOString(),\n\t\t};\n\t}\n\n\tconst { data: existingRecord, error: fetchError } = await supabase\n\t\t.from(config.table)\n\t\t.select(\"metadata\")\n\t\t.eq(\"id\", entityId)\n\t\t.single();\n\n\tif (fetchError) {\n\t\tthrow new Error(\n\t\t\t`Failed to load ${entityType} metadata: ${fetchError.message}`,\n\t\t);\n\t}\n\n\tconst existingMetadata =\n\t\texistingRecord &&\n\t\ttypeof existingRecord.metadata === \"object\" &&\n\t\texistingRecord.metadata !== null\n\t\t\t? (existingRecord.metadata as Record<string, unknown>)\n\t\t\t: {};\n\n\treturn {\n\t\tmetadata: {\n\t\t\t...existingMetadata,\n\t\t\ttags,\n\t\t},\n\t\tupdated_at: new Date().toISOString(),\n\t};\n};\n\ntype ApplyTagUpdateParams = {\n\tsupabase: SupabaseServerClient;\n\tconfig: TagUpdateConfig;\n\tentityId: string;\n\tentityType: EntityType;\n\tupdateData: Record<string, unknown>;\n};\n\nconst applyTagUpdate = async ({\n\tsupabase,\n\tconfig,\n\tentityId,\n\tentityType,\n\tupdateData,\n}: ApplyTagUpdateParams) => {\n\tconst { error } = await supabase\n\t\t.from(config.table)\n\t\t.update(updateData)\n\t\t.eq(\"id\", entityId);\n\n\tif (error) {\n\t\tthrow new Error(`Failed to update ${entityType} tags: ${error.message}`);\n\t}\n};\n\nconst revalidateEntityPaths = (entityType: EntityType, entityId: string) => {\n\tconst basePath = getPathForEntity(entityType);\n\tif (basePath) {\n\t\trevalidatePath(`/dashboard/${basePath}/${entityId}`);\n\t\trevalidatePath(`/dashboard/${basePath}`);\n\t}\n\n\trevalidatePath(\"/dashboard\");\n};\n","/**\n * Payment Processor Abstraction Layer\n *\n * Provides a unified interface for multiple payment processors:\n * - Stripe: For platform billing (subscriptions)\n * - Adyen: For high-value contractor payments (card-present, ACH)\n * - Plaid: For bank account linking and ACH\n * - ProfitStars: For ACH/check processing\n *\n * This abstraction allows contractors to process high-value payments\n * without Stripe's limitations while maintaining a consistent API.\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type {\n\tPaymentChannel,\n\tPaymentProcessor,\n\tPaymentProcessorConfig,\n\tPaymentProcessorType,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n} from \"./processor-types\";\n\n// Re-export all types to maintain API compatibility\nexport type {\n\tPaymentProcessorType,\n\tPaymentChannel,\n\tPaymentProcessorConfig,\n\tProcessPaymentRequest,\n\tProcessPaymentResponse,\n\tRefundPaymentRequest,\n\tRefundPaymentResponse,\n\tPaymentProcessor,\n};\n\n/**\n * Get the appropriate payment processor for a company\n *\n * Determines which processor to use based on:\n * 1. Company's configured processor\n * 2. Payment amount (high-value payments use Adyen)\n * 3. Payment channel (card-present uses Adyen, ACH uses Plaid/ProfitStars)\n */\nexport async function getPaymentProcessor(\n\tcompanyId: string,\n\toptions?: {\n\t\tamount?: number;\n\t\tchannel?: PaymentChannel;\n\t\tforceProcessor?: PaymentProcessorType;\n\t},\n): Promise<PaymentProcessor | null> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\t// Check if company has at least one bank account (required for payments)\n\tconst { data: bankAccounts } = await supabase\n\t\t.from(\"finance_bank_accounts\")\n\t\t.select(\"id\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"is_active\", true)\n\t\t.limit(1);\n\n\tif (!bankAccounts || bankAccounts.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Get company's payment processor configuration\n\tconst { data: processors } = await supabase\n\t\t.from(\"company_payment_processors\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (!processors || processors.length === 0) {\n\t\treturn null;\n\t}\n\n\t// If force processor specified, use it\n\tif (options?.forceProcessor) {\n\t\tconst processor = processors.find(\n\t\t\t(p) => p.processor_type === options.forceProcessor,\n\t\t);\n\t\tif (processor) {\n\t\t\treturn createProcessorInstance(processor);\n\t\t}\n\t}\n\n\t// Determine processor based on payment characteristics\n\tconst amount = options?.amount || 0;\n\tconst channel = options?.channel || \"online\";\n\n\t// High-value payments (>$10k) should use Adyen\n\tif (\n\t\tamount > 1_000_000 &&\n\t\tprocessors.some((p) => p.processor_type === \"adyen\")\n\t) {\n\t\tconst adyenProcessor = processors.find((p) => p.processor_type === \"adyen\");\n\t\tif (adyenProcessor) {\n\t\t\treturn createProcessorInstance(adyenProcessor);\n\t\t}\n\t}\n\n\t// Card-present or tap-to-pay should use Adyen\n\tif (\n\t\t(channel === \"card_present\" || channel === \"tap_to_pay\") &&\n\t\tprocessors.some((p) => p.processor_type === \"adyen\")\n\t) {\n\t\tconst adyenProcessor = processors.find((p) => p.processor_type === \"adyen\");\n\t\tif (adyenProcessor) {\n\t\t\treturn createProcessorInstance(adyenProcessor);\n\t\t}\n\t}\n\n\t// ACH payments should use Plaid or ProfitStars\n\tif (channel === \"ach\") {\n\t\tconst plaidProcessor = processors.find((p) => p.processor_type === \"plaid\");\n\t\tif (plaidProcessor) {\n\t\t\treturn createProcessorInstance(plaidProcessor);\n\t\t}\n\t\tconst profitstarsProcessor = processors.find(\n\t\t\t(p) => p.processor_type === \"profitstars\",\n\t\t);\n\t\tif (profitstarsProcessor) {\n\t\t\treturn createProcessorInstance(profitstarsProcessor);\n\t\t}\n\t}\n\n\t// Default to first active processor\n\treturn createProcessorInstance(processors[0]);\n}\n\n/**\n * Create a processor instance from database configuration\n */\nasync function createProcessorInstance(\n\tconfig: any,\n): Promise<PaymentProcessor | null> {\n\tswitch (config.processor_type) {\n\t\tcase \"adyen\": {\n\t\t\tconst { AdyenProcessor } = await import(\"./processors/adyen\");\n\t\t\treturn new AdyenProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\taccountId: config.adyen_account_id,\n\t\t\t\tapiKey: config.adyen_api_key_encrypted, // Will need decryption\n\t\t\t\tmerchantAccount: config.adyen_merchant_account,\n\t\t\t\tliveMode: config.adyen_live_mode,\n\t\t\t});\n\t\t}\n\t\tcase \"plaid\": {\n\t\t\tconst { PlaidProcessor } = await import(\"./processors/plaid\");\n\t\t\treturn new PlaidProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tclientId: config.plaid_client_id,\n\t\t\t\tsecret: config.plaid_secret_encrypted, // Will need decryption\n\t\t\t\tenvironment: config.plaid_environment || \"sandbox\",\n\t\t\t});\n\t\t}\n\t\tcase \"profitstars\": {\n\t\t\tconst { ProfitStarsProcessor } = await import(\"./processors/profitstars\");\n\t\t\treturn new ProfitStarsProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tmerchantId: config.profitstars_merchant_id,\n\t\t\t\tapiKey: config.profitstars_api_key_encrypted, // Will need decryption\n\t\t\t\troutingNumber: config.profitstars_routing_number,\n\t\t\t});\n\t\t}\n\t\tcase \"stripe\": {\n\t\t\tconst { StripeProcessor } = await import(\"./processors/stripe\");\n\t\t\treturn new StripeProcessor({\n\t\t\t\tcompanyId: config.company_id,\n\t\t\t\tliveMode: config.adyen_live_mode,\n\t\t\t});\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Calculate trust score for a payment\n *\n * Higher trust scores allow larger payments without flagging\n */\nexport async function calculatePaymentTrustScore(\n\tcompanyId: string,\n\tamount: number,\n): Promise<{\n\tscore: number;\n\tallowed: boolean;\n\trequiresApproval: boolean;\n\treason?: string;\n}> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn {\n\t\t\tscore: 0,\n\t\t\tallowed: false,\n\t\t\trequiresApproval: true,\n\t\t\treason: \"Database unavailable\",\n\t\t};\n\t}\n\n\t// Get company's trust score\n\tconst { data: trustScore } = await supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!trustScore) {\n\t\treturn {\n\t\t\tscore: 50,\n\t\t\tallowed: false,\n\t\t\trequiresApproval: true,\n\t\t\treason: \"No trust score found\",\n\t\t};\n\t}\n\n\tconst score = Number(trustScore.overall_score);\n\n\t// Get processor configuration\n\tconst { data: processor } = await supabase\n\t\t.from(\"company_payment_processors\")\n\t\t.select(\"max_payment_amount, requires_approval_above\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"status\", \"active\")\n\t\t.single();\n\n\tconst maxAmount = processor?.max_payment_amount || 100_000; // Default $1,000\n\tconst approvalThreshold = processor?.requires_approval_above || 50_000; // Default $500\n\n\t// Calculate if payment is allowed based on trust score\n\t// Trust score 90+: Allow up to configured max\n\t// Trust score 70-89: Allow up to 50% of max\n\t// Trust score 50-69: Allow up to 25% of max\n\t// Trust score <50: Require approval for any payment > $100\n\n\tlet allowedAmount = maxAmount;\n\tif (score >= 90) {\n\t\tallowedAmount = maxAmount;\n\t} else if (score >= 70) {\n\t\tallowedAmount = Math.floor(maxAmount * 0.5);\n\t} else if (score >= 50) {\n\t\tallowedAmount = Math.floor(maxAmount * 0.25);\n\t} else {\n\t\tallowedAmount = 10_000; // $100 minimum\n\t}\n\n\tconst allowed = amount <= allowedAmount;\n\tconst requiresApproval = amount > approvalThreshold || score < 70;\n\n\treturn {\n\t\tscore,\n\t\tallowed,\n\t\trequiresApproval,\n\t\treason: allowed\n\t\t\t? requiresApproval\n\t\t\t\t? \"Payment requires manual approval\"\n\t\t\t\t: undefined\n\t\t\t: `Payment amount exceeds allowed limit for trust score. Max allowed: $${allowedAmount / 100}`,\n\t};\n}\n\n/**\n * Update trust score after payment\n */\nexport async function updateTrustScoreAfterPayment(\n\tcompanyId: string,\n\tsuccess: boolean,\n\tamount: number,\n): Promise<void> {\n\tconst supabase = await createClient();\n\tif (!supabase) {\n\t\treturn;\n\t}\n\n\tconst { data: trustScore } = await supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.single();\n\n\tif (!trustScore) {\n\t\treturn;\n\t}\n\n\t// Update metrics\n\tconst updates: any = {\n\t\ttotal_payments_count: (trustScore.total_payments_count || 0) + 1,\n\t\ttotal_payments_volume: (trustScore.total_payments_volume || 0) + amount,\n\t\tlast_calculated_at: new Date().toISOString(),\n\t};\n\n\tif (success) {\n\t\tupdates.successful_payments_count =\n\t\t\t(trustScore.successful_payments_count || 0) + 1;\n\t} else {\n\t\tupdates.failed_payments_count = (trustScore.failed_payments_count || 0) + 1;\n\t}\n\n\t// Update largest payment\n\tif (amount > (trustScore.largest_payment_amount || 0)) {\n\t\tupdates.largest_payment_amount = amount;\n\t}\n\n\t// Recalculate overall score\n\tconst totalPayments = updates.total_payments_count;\n\tconst successfulPayments =\n\t\tupdates.successful_payments_count ||\n\t\ttrustScore.successful_payments_count ||\n\t\t0;\n\tconst _failedPayments =\n\t\tupdates.failed_payments_count || trustScore.failed_payments_count || 0;\n\n\t// Success rate (0-100)\n\tconst successRate =\n\t\ttotalPayments > 0 ? (successfulPayments / totalPayments) * 100 : 50;\n\n\t// Volume factor (higher volume = higher trust, capped at 100)\n\tconst volumeFactor = Math.min(\n\t\t100,\n\t\tMath.log10((updates.total_payments_volume || 0) / 100 + 1) * 20,\n\t);\n\n\t// Account age factor (older accounts = higher trust)\n\tconst accountAgeDays = trustScore.account_age_days || 0;\n\tconst ageFactor = Math.min(100, (accountAgeDays / 30) * 10); // 100 points after 300 days\n\n\t// Calculate weighted overall score\n\tconst overallScore =\n\t\tsuccessRate * 0.4 + // 40% weight on success rate\n\t\tvolumeFactor * 0.3 + // 30% weight on volume\n\t\tageFactor * 0.2 + // 20% weight on account age\n\t\t(trustScore.business_verified ? 10 : 0) + // 10% for verification\n\t\t(trustScore.bank_account_verified ? 5 : 0) +\n\t\t(trustScore.identity_verified ? 5 : 0);\n\n\tupdates.overall_score = Math.min(100, Math.max(0, overallScore));\n\tupdates.refund_rate =\n\t\ttotalPayments > 0\n\t\t\t? ((trustScore.refunded_amount || 0) / updates.total_payments_volume) *\n\t\t\t\t100\n\t\t\t: 0;\n\n\tawait supabase\n\t\t.from(\"payment_trust_scores\")\n\t\t.update(updates)\n\t\t.eq(\"company_id\", companyId);\n}\n"],"names":[],"mappings":"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"}