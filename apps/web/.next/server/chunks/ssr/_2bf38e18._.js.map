{"version":3,"sources":["../../../../../../packages/auth/src/permissions.ts","../../../../../../apps/web/src/lib/auth/permissions.ts","../../../../../../apps/web/src/actions/roles.ts","../../../../../../apps/web/src/lib/telnyx/logger.ts","../../../../../../apps/web/src/lib/telnyx/retry.ts"],"sourcesContent":["/**\n * Permission System - Server-Side Utilities\n *\n * Provides type-safe permission checking for role-based access control (RBAC).\n * Uses database functions for secure, centralized permission logic.\n *\n * Performance optimizations:\n * - Database functions are cached by Postgres\n * - Single query permission checks\n * - Prepared statements for security\n *\n * @example\n * ```typescript\n * // Check if user can delete jobs\n * const canDelete = await hasPermission(supabase, userId, \"delete_jobs\", companyId);\n *\n * // Check if user has manager role\n * const isManager = await hasRole(supabase, userId, \"manager\", companyId);\n *\n * // Get user's role\n * const role = await getUserRole(supabase, userId, companyId);\n * ```\n */\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * User roles in the system\n * Matches the user_role ENUM in database\n */\nexport type UserRole =\n\t| \"owner\"\n\t| \"admin\"\n\t| \"manager\"\n\t| \"dispatcher\"\n\t| \"technician\"\n\t| \"csr\";\n\n/**\n * Permission keys for fine-grained access control\n */\nexport type Permission =\n\t// Manager permissions\n\t| \"view_reports\"\n\t| \"manage_team\"\n\t| \"approve_estimates\"\n\t| \"handle_escalations\"\n\t// Dispatcher permissions\n\t| \"dispatch_jobs\"\n\t| \"manage_schedule\"\n\t| \"view_tech_locations\"\n\t// Technician permissions\n\t| \"update_job_status\"\n\t| \"create_invoices\"\n\t| \"upload_photos\"\n\t// CSR permissions\n\t| \"create_jobs\"\n\t| \"schedule_appointments\"\n\t| \"send_communications\"\n\t// View permissions\n\t| \"view_customers\"\n\t| \"view_jobs\"\n\t| \"view_schedule\"\n\t// Delete permissions\n\t| \"delete_jobs\"\n\t| \"delete_customers\"\n\t| \"delete_team_members\";\n\n/**\n * Role configuration with permissions and metadata\n */\nexport type RoleConfig = {\n\tid: UserRole;\n\tlabel: string;\n\tdescription: string;\n\tpermissions: Permission[];\n\tdashboardFeatures: string[];\n};\n\n// ============================================================================\n// Role Definitions\n// ============================================================================\n\n/**\n * Complete role configurations with their permissions\n * Used for UI display and permission reference\n */\nconst ROLES: Record<UserRole, RoleConfig> = {\n\towner: {\n\t\tid: \"owner\",\n\t\tlabel: \"Owner\",\n\t\tdescription:\n\t\t\t\"Full system access with focus on business financials and growth\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"manage_team\",\n\t\t\t\"approve_estimates\",\n\t\t\t\"handle_escalations\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t\t\"delete_jobs\",\n\t\t\t\"delete_customers\",\n\t\t\t\"delete_team_members\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"financial-overview\",\n\t\t\t\"profit-margins\",\n\t\t\t\"cash-flow\",\n\t\t\t\"business-growth\",\n\t\t\t\"payroll-overview\",\n\t\t\t\"all-reports\",\n\t\t],\n\t},\n\tadmin: {\n\t\tid: \"admin\",\n\t\tlabel: \"Admin\",\n\t\tdescription: \"System administration and configuration\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"manage_team\",\n\t\t\t\"approve_estimates\",\n\t\t\t\"handle_escalations\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t\t\"delete_jobs\",\n\t\t\t\"delete_customers\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"system-settings\",\n\t\t\t\"user-management\",\n\t\t\t\"integrations\",\n\t\t\t\"audit-logs\",\n\t\t],\n\t},\n\tmanager: {\n\t\tid: \"manager\",\n\t\tlabel: \"Manager\",\n\t\tdescription:\n\t\t\t\"Oversee team performance, customer satisfaction, and operations\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"manage_team\",\n\t\t\t\"approve_estimates\",\n\t\t\t\"handle_escalations\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t\t\"delete_jobs\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"team-performance\",\n\t\t\t\"customer-satisfaction\",\n\t\t\t\"callback-queue\",\n\t\t\t\"review-alerts\",\n\t\t\t\"kpi-tracking\",\n\t\t\t\"inventory-management\",\n\t\t],\n\t},\n\tdispatcher: {\n\t\tid: \"dispatcher\",\n\t\tlabel: \"Dispatcher\",\n\t\tdescription:\n\t\t\t\"Manage technician schedules, job assignments, and real-time operations\",\n\t\tpermissions: [\n\t\t\t\"view_reports\",\n\t\t\t\"dispatch_jobs\",\n\t\t\t\"manage_schedule\",\n\t\t\t\"view_tech_locations\",\n\t\t\t\"update_job_status\",\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"dispatch-map\",\n\t\t\t\"technician-locations\",\n\t\t\t\"unassigned-jobs\",\n\t\t\t\"emergency-queue\",\n\t\t\t\"quick-dispatch\",\n\t\t\t\"tech-status\",\n\t\t],\n\t},\n\ttechnician: {\n\t\tid: \"technician\",\n\t\tlabel: \"Technician\",\n\t\tdescription:\n\t\t\t\"View assigned jobs, update job status, and track personal performance\",\n\t\tpermissions: [\n\t\t\t\"update_job_status\",\n\t\t\t\"create_invoices\",\n\t\t\t\"upload_photos\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"my-schedule\",\n\t\t\t\"active-job\",\n\t\t\t\"my-earnings\",\n\t\t\t\"my-performance\",\n\t\t\t\"parts-inventory\",\n\t\t\t\"time-tracking\",\n\t\t],\n\t},\n\tcsr: {\n\t\tid: \"csr\",\n\t\tlabel: \"Customer Service Rep\",\n\t\tdescription:\n\t\t\t\"Handle customer calls, schedule appointments, and manage customer relationships\",\n\t\tpermissions: [\n\t\t\t\"create_jobs\",\n\t\t\t\"schedule_appointments\",\n\t\t\t\"send_communications\",\n\t\t\t\"create_invoices\",\n\t\t\t\"view_customers\",\n\t\t\t\"view_jobs\",\n\t\t\t\"view_schedule\",\n\t\t],\n\t\tdashboardFeatures: [\n\t\t\t\"call-queue\",\n\t\t\t\"booking-calendar\",\n\t\t\t\"customer-search\",\n\t\t\t\"follow-up-queue\",\n\t\t\t\"estimate-pipeline\",\n\t\t\t\"call-scripts\",\n\t\t],\n\t},\n};\n\n// ============================================================================\n// Permission Check Functions\n// ============================================================================\n\n/**\n * Check if user has a specific role in a company\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param role - Role to check for\n * @param companyId - Company ID\n * @returns true if user has the role\n *\n * @example\n * ```typescript\n * const isManager = await hasRole(supabase, userId, \"manager\", companyId);\n * if (!isManager) {\n *   throw new Error(\"Access denied: Manager role required\");\n * }\n * ```\n */\nexport async function hasRole(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\trole: UserRole,\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"has_role\", {\n\t\tuser_uuid: userId,\n\t\trequired_role: role,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Check if user has ANY of the specified roles\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param roles - Array of roles to check\n * @param companyId - Company ID\n * @returns true if user has any of the roles\n *\n * @example\n * ```typescript\n * const canManage = await hasAnyRole(\n *   supabase,\n *   userId,\n *   [\"owner\", \"manager\", \"admin\"],\n *   companyId\n * );\n * ```\n */\nasync function hasAnyRole(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\troles: UserRole[],\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"has_any_role\", {\n\t\tuser_uuid: userId,\n\t\trequired_roles: roles,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Get user's role in a company\n *\n * @param supabase - Supabase client\n * @param userId - User ID\n * @param companyId - Company ID\n * @returns User's role or null if not found\n *\n * @example\n * ```typescript\n * const role = await getUserRole(supabase, userId, companyId);\n * console.log(`User role: ${role}`); // \"manager\"\n * ```\n */\nexport async function getUserRole(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\tcompanyId: string,\n): Promise<UserRole | null> {\n\tconst { data, error } = await supabase.rpc(\"get_user_role\", {\n\t\tuser_uuid: userId,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn null;\n\t}\n\n\treturn data as UserRole | null;\n}\n\n/**\n * Check if user has a specific permission\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param permission - Permission key to check\n * @param companyId - Company ID\n * @returns true if user has the permission\n *\n * @example\n * ```typescript\n * const canDelete = await hasPermission(supabase, userId, \"delete_jobs\", companyId);\n * if (!canDelete) {\n *   return { error: \"You don't have permission to delete jobs\" };\n * }\n * ```\n */\nexport async function hasPermission(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\tpermission: Permission,\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"has_permission\", {\n\t\tuser_uuid: userId,\n\t\tpermission_key: permission,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n/**\n * Check if user is the company owner\n *\n * @param supabase - Supabase client\n * @param userId - User ID to check\n * @param companyId - Company ID\n * @returns true if user is the owner\n *\n * @example\n * ```typescript\n * const isOwner = await isCompanyOwner(supabase, userId, companyId);\n * if (!isOwner) {\n *   throw new Error(\"Only company owner can perform this action\");\n * }\n * ```\n */\nexport async function isCompanyOwner(\n\tsupabase: SupabaseClient,\n\tuserId: string,\n\tcompanyId: string,\n): Promise<boolean> {\n\tconst { data, error } = await supabase.rpc(\"is_company_owner\", {\n\t\tuser_uuid: userId,\n\t\tcompany_uuid: companyId,\n\t});\n\n\tif (error) {\n\t\treturn false;\n\t}\n\n\treturn data === true;\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get all permissions for a role\n *\n * @param role - Role to get permissions for\n * @returns Array of permission keys\n *\n * @example\n * ```typescript\n * const managerPerms = getRolePermissions(\"manager\");\n * console.log(managerPerms); // [\"view_reports\", \"manage_team\", ...]\n * ```\n */\nfunction getRolePermissions(role: UserRole): Permission[] {\n\treturn ROLES[role]?.permissions || [];\n}\n\n/**\n * Check if a role has a specific permission (client-side check only)\n *\n * @param role - Role to check\n * @param permission - Permission to check for\n * @returns true if role has the permission\n *\n * @example\n * ```typescript\n * const canDelete = roleHasPermission(\"manager\", \"delete_jobs\");\n * ```\n */\nfunction roleHasPermission(\n\trole: UserRole,\n\tpermission: Permission,\n): boolean {\n\treturn ROLES[role]?.permissions.includes(permission);\n}\n\n/**\n * Get role configuration\n *\n * @param role - Role to get config for\n * @returns Role configuration\n *\n * @example\n * ```typescript\n * const config = getRoleConfig(\"manager\");\n * console.log(config.label); // \"Manager\"\n * ```\n */\nfunction getRoleConfig(role: UserRole): RoleConfig {\n\treturn ROLES[role];\n}\n","// Re-export from @stratos/auth package for backwards compatibility\nexport * from \"@stratos/auth/permissions\";\n","/**\n * Role Actions - Server Actions\n *\n * Server-side actions for role management and permission checks.\n * Uses Supabase RLS and database functions for security.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport { getActiveCompanyId } from \"@/lib/auth/company-context\";\nimport {\n\tgetUserRole,\n\thasPermission,\n\thasRole,\n\tisCompanyOwner,\n\ttype Permission,\n\ttype UserRole,\n} from \"@/lib/auth/permissions\";\nimport { withErrorHandling } from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n// ============================================================================\n// Validation Schemas\n// ============================================================================\n\nconst updateRoleSchema = z.object({\n\tteamMemberId: z.string().uuid(),\n\tnewRole: z.enum([\n\t\t\"owner\",\n\t\t\"admin\",\n\t\t\"manager\",\n\t\t\"dispatcher\",\n\t\t\"technician\",\n\t\t\"csr\",\n\t]),\n\treason: z.string().optional(),\n});\n\nconst updatePermissionsSchema = z.object({\n\tteamMemberId: z.string().uuid(),\n\tpermissions: z.record(z.string(), z.boolean()),\n});\n\n// ============================================================================\n// Query Actions\n// ============================================================================\n\n/**\n * Get current user's role in active company\n *\n * @returns User's role or null\n *\n * @example\n * ```typescript\n * const role = await getCurrentUserRole();\n * if (role.success && role.data === \"manager\") {\n *   // Show manager dashboard\n * }\n * ```\n */\nexport async function getCurrentUserRole() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst role = await getUserRole(supabase, user.id, companyId);\n\n\t\treturn role;\n\t});\n}\n\n/**\n * Check if current user has a specific permission\n *\n * @param permission - Permission to check\n * @returns true if user has permission\n *\n * @example\n * ```typescript\n * const result = await checkPermission(\"delete_jobs\");\n * if (!result.success || !result.data) {\n *   return { error: \"Access denied\" };\n * }\n * ```\n */\nasync function checkPermission(permission: Permission) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst hasPerm = await hasPermission(\n\t\t\tsupabase,\n\t\t\tuser.id,\n\t\t\tpermission,\n\t\t\tcompanyId,\n\t\t);\n\n\t\treturn hasPerm;\n\t});\n}\n\n/**\n * Check if current user has a specific role\n *\n * @param role - Role to check\n * @returns true if user has role\n *\n * @example\n * ```typescript\n * const result = await checkRole(\"manager\");\n * if (!result.success || !result.data) {\n *   redirect(\"/dashboard\");\n * }\n * ```\n */\nasync function checkRole(role: UserRole) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst hasRoleResult = await hasRole(supabase, user.id, role, companyId);\n\n\t\treturn hasRoleResult;\n\t});\n}\n\n/**\n * Check if current user is company owner\n *\n * @returns true if user is owner\n */\nasync function checkIsOwner() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst isOwner = await isCompanyOwner(supabase, user.id, companyId);\n\n\t\treturn isOwner;\n\t});\n}\n\n// ============================================================================\n// Mutation Actions\n// ============================================================================\n\n/**\n * Update team member's role\n * Only owners and admins can change roles\n *\n * @param input - Team member ID, new role, and optional reason\n * @returns Updated team member\n *\n * @example\n * ```typescript\n * const result = await updateTeamMemberRole({\n *   teamMemberId: \"123...\",\n *   newRole: \"manager\",\n *   reason: \"Promoted to management\"\n * });\n * ```\n */\nasync function updateTeamMemberRole(\n\tinput: z.infer<typeof updateRoleSchema>,\n) {\n\treturn withErrorHandling(async () => {\n\t\t// Validate input\n\t\tconst validated = updateRoleSchema.parse(input);\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Check permission - only owners and admins can change roles\n\t\tconst canManageRoles =\n\t\t\t(await isCompanyOwner(supabase, user.id, companyId)) ||\n\t\t\t(await hasRole(supabase, user.id, \"admin\", companyId));\n\n\t\tif (!canManageRoles) {\n\t\t\tthrow new Error(\"Only owners and admins can change roles\");\n\t\t}\n\n\t\t// Get current role for audit log\n\t\tconst { data: currentMember } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"role\")\n\t\t\t.eq(\"id\", validated.teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (!currentMember) {\n\t\t\tthrow new Error(\"Team member not found\");\n\t\t}\n\n\t\t// Update role\n\t\tconst { data: updatedMember, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.update({ role: validated.newRole })\n\t\t\t.eq(\"id\", validated.teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\t// Log role change\n\t\tawait supabase.from(\"role_change_log\").insert({\n\t\t\tteam_member_id: validated.teamMemberId,\n\t\t\tchanged_by: user.id,\n\t\t\told_role: currentMember.role,\n\t\t\tnew_role: validated.newRole,\n\t\t\treason: validated.reason,\n\t\t});\n\n\t\trevalidatePath(\"/dashboard/settings/team\");\n\t\trevalidatePath(`/dashboard/settings/team/${validated.teamMemberId}`);\n\n\t\treturn updatedMember;\n\t});\n}\n\n/**\n * Update team member's custom permissions\n * Only owners and admins can change permissions\n *\n * @param input - Team member ID and permissions object\n * @returns Updated team member\n *\n * @example\n * ```typescript\n * const result = await updateTeamMemberPermissions({\n *   teamMemberId: \"123...\",\n *   permissions: {\n *     \"delete_jobs\": true,\n *     \"approve_estimates\": true\n *   }\n * });\n * ```\n */\nasync function updateTeamMemberPermissions(\n\tinput: z.infer<typeof updatePermissionsSchema>,\n) {\n\treturn withErrorHandling(async () => {\n\t\t// Validate input\n\t\tconst validated = updatePermissionsSchema.parse(input);\n\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Check permission\n\t\tconst canManagePermissions =\n\t\t\t(await isCompanyOwner(supabase, user.id, companyId)) ||\n\t\t\t(await hasRole(supabase, user.id, \"admin\", companyId));\n\n\t\tif (!canManagePermissions) {\n\t\t\tthrow new Error(\"Only owners and admins can change permissions\");\n\t\t}\n\n\t\t// Update permissions\n\t\tconst { data: updatedMember, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.update({ permissions: validated.permissions })\n\t\t\t.eq(\"id\", validated.teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.select()\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/settings/team\");\n\t\trevalidatePath(`/dashboard/settings/team/${validated.teamMemberId}`);\n\n\t\treturn updatedMember;\n\t});\n}\n\n/**\n * Get team members with their roles\n *\n * @returns List of team members with roles\n */\nasync function getTeamMembersWithRoles() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        users (\n          id,\n          name,\n          email,\n          avatar\n        )\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n// ============================================================================\n// Owner Protection Actions\n// ============================================================================\n\n/**\n * Transfer company ownership to another team member\n * Requires password verification and extensive validation\n *\n * @param input - Transfer details including new owner, password, and reason\n * @returns Transfer ID for audit\n *\n * @example\n * ```typescript\n * const result = await transferOwnership({\n *   newOwnerId: \"user-uuid\",\n *   password: \"current-password\",\n *   reason: \"Retiring from business\"\n * });\n * ```\n */\nasync function transferOwnership(input: {\n\tnewOwnerId: string;\n\tpassword: string;\n\treason?: string;\n\tipAddress?: string;\n\tuserAgent?: string;\n}) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Verify user is current owner\n\t\tconst isOwner = await isCompanyOwner(supabase, user.id, companyId);\n\t\tif (!isOwner) {\n\t\t\tthrow new Error(\"Only the current owner can transfer ownership\");\n\t\t}\n\n\t\t// Verify password\n\t\tconst { error: signInError } = await supabase.auth.signInWithPassword({\n\t\t\temail: user.email || \"\",\n\t\t\tpassword: input.password,\n\t\t});\n\n\t\tif (signInError) {\n\t\t\tthrow new Error(\"Password verification failed\");\n\t\t}\n\n\t\t// Call database function to transfer ownership\n\t\tconst { data: transferId, error } = await supabase.rpc(\n\t\t\t\"transfer_company_ownership\",\n\t\t\t{\n\t\t\t\tp_company_id: companyId,\n\t\t\t\tp_current_owner_id: user.id,\n\t\t\t\tp_new_owner_id: input.newOwnerId,\n\t\t\t\tp_reason: input.reason,\n\t\t\t\tp_ip_address: input.ipAddress,\n\t\t\t\tp_user_agent: input.userAgent,\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message || \"Failed to transfer ownership\");\n\t\t}\n\n\t\t// Revalidate all relevant paths\n\t\trevalidatePath(\"/dashboard/settings/team\");\n\t\trevalidatePath(\"/dashboard\");\n\n\t\treturn transferId;\n\t});\n}\n\n/**\n * Get ownership transfer history for the company\n * Shows audit trail of all ownership changes\n *\n * @returns List of ownership transfers\n */\nasync function getOwnershipTransferHistory() {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\t// Only owners and admins can view transfer history\n\t\tconst canView =\n\t\t\t(await isCompanyOwner(supabase, user.id, companyId)) ||\n\t\t\t(await hasRole(supabase, user.id, \"admin\", companyId));\n\n\t\tif (!canView) {\n\t\t\tthrow new Error(\"Only owners and admins can view transfer history\");\n\t\t}\n\n\t\tconst { data, error } = await supabase\n\t\t\t.from(\"ownership_transfers\")\n\t\t\t.select(\n\t\t\t\t`\n        *,\n        previous_owner:users!ownership_transfers_previous_owner_id_fkey(id, name, email),\n        new_owner:users!ownership_transfers_new_owner_id_fkey(id, name, email),\n        initiated_by_user:users!ownership_transfers_initiated_by_fkey(id, name, email)\n      `,\n\t\t\t)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\tif (error) {\n\t\t\tthrow new Error(error.message);\n\t\t}\n\n\t\treturn data;\n\t});\n}\n\n/**\n * Check if a team member can be deleted\n * Prevents deletion of company owner\n *\n * @param teamMemberId - Team member to check\n * @returns Object with canDelete boolean and reason if not allowed\n */\nexport async function canDeleteTeamMember(teamMemberId: string) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst companyId = await getActiveCompanyId();\n\t\tif (!companyId) {\n\t\t\tthrow new Error(\"No active company\");\n\t\t}\n\n\t\t// Get team member details\n\t\tconst { data: teamMember, error } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id, role\")\n\t\t\t.eq(\"id\", teamMemberId)\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.single();\n\n\t\tif (error || !teamMember) {\n\t\t\tthrow new Error(\"Team member not found\");\n\t\t}\n\n\t\t// Check if user is company owner\n\t\tconst { data: company } = await supabase\n\t\t\t.from(\"companies\")\n\t\t\t.select(\"owner_id\")\n\t\t\t.eq(\"id\", companyId)\n\t\t\t.single();\n\n\t\tif (company && company.owner_id === teamMember.user_id) {\n\t\t\treturn {\n\t\t\t\tcanDelete: false,\n\t\t\t\treason:\n\t\t\t\t\t\"Cannot delete company owner. Transfer ownership first before removing this team member.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tcanDelete: true,\n\t\t};\n\t});\n}\n","/**\n * Telnyx Structured Logger\n *\n * Provides structured JSON logging with PII redaction,\n * log levels, and correlation ID support.\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nexport interface LogContext {\n\tcorrelationId?: string;\n\tendpoint?: string;\n\tcompanyId?: string;\n\tphoneNumber?: string;\n\tcallControlId?: string;\n\tmessageSid?: string;\n\tattempt?: number;\n\tdelayMs?: number;\n\tlatencyMs?: number;\n\tstatusCode?: number;\n\terror?: string;\n\t[key: string]: unknown;\n}\n\nexport interface LogEntry {\n\ttimestamp: string;\n\tlevel: LogLevel;\n\tservice: string;\n\tmessage: string;\n\tcontext?: LogContext;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n\tdebug: 0,\n\tinfo: 1,\n\twarn: 2,\n\terror: 3,\n};\n\n// Default to 'info' in production, 'debug' in development\nconst currentLogLevel: LogLevel =\n\t(process.env.TELNYX_LOG_LEVEL as LogLevel) ||\n\t(process.env.NODE_ENV === \"production\" ? \"info\" : \"debug\");\n\n// PII patterns to redact\nconst PII_PATTERNS = [\n\t// Phone numbers (various formats)\n\t/\\+?1?\\d{10,15}/g,\n\t// Email addresses\n\t/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n];\n\n// Fields that should be redacted\nconst SENSITIVE_FIELDS = [\n\t\"phone\",\n\t\"phoneNumber\",\n\t\"phone_number\",\n\t\"from\",\n\t\"to\",\n\t\"fromNumber\",\n\t\"toNumber\",\n\t\"from_number\",\n\t\"to_number\",\n\t\"apiKey\",\n\t\"api_key\",\n\t\"authToken\",\n\t\"auth_token\",\n\t\"password\",\n\t\"secret\",\n\t\"token\",\n];\n\n// =============================================================================\n// PII REDACTION\n// =============================================================================\n\n/**\n * Mask a phone number, keeping last 4 digits\n */\nfunction maskPhoneNumber(phone: string): string {\n\tconst digits = phone.replace(/\\D/g, \"\");\n\tif (digits.length < 4) return \"****\";\n\treturn `***${digits.slice(-4)}`;\n}\n\n/**\n * Mask an email address\n */\nfunction maskEmail(email: string): string {\n\tconst [local, domain] = email.split(\"@\");\n\tif (!domain) return \"***@***\";\n\tconst maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length - 1]}` : \"***\";\n\treturn `${maskedLocal}@${domain}`;\n}\n\n/**\n * Redact PII from a string\n */\nfunction redactString(value: string): string {\n\tlet result = value;\n\n\t// Redact phone numbers\n\tresult = result.replace(/\\+?1?\\d{10,15}/g, (match) => maskPhoneNumber(match));\n\n\t// Redact email addresses\n\tresult = result.replace(\n\t\t/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n\t\t(match) => maskEmail(match)\n\t);\n\n\treturn result;\n}\n\n/**\n * Recursively redact PII from an object\n */\nfunction redactPII(obj: unknown, depth = 0): unknown {\n\t// Prevent infinite recursion\n\tif (depth > 10) return \"[MAX_DEPTH]\";\n\n\tif (obj === null || obj === undefined) {\n\t\treturn obj;\n\t}\n\n\tif (typeof obj === \"string\") {\n\t\treturn redactString(obj);\n\t}\n\n\tif (typeof obj === \"number\" || typeof obj === \"boolean\") {\n\t\treturn obj;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => redactPII(item, depth + 1));\n\t}\n\n\tif (typeof obj === \"object\") {\n\t\tconst result: Record<string, unknown> = {};\n\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\t// Check if this is a sensitive field\n\t\t\tconst isSensitive = SENSITIVE_FIELDS.some(\n\t\t\t\t(field) => key.toLowerCase().includes(field.toLowerCase())\n\t\t\t);\n\n\t\t\tif (isSensitive) {\n\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t// Mask the value\n\t\t\t\t\tif (value.includes(\"@\")) {\n\t\t\t\t\t\tresult[key] = maskEmail(value);\n\t\t\t\t\t} else if (/\\d/.test(value)) {\n\t\t\t\t\t\tresult[key] = maskPhoneNumber(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[key] = \"[REDACTED]\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = \"[REDACTED]\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[key] = redactPII(value, depth + 1);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treturn obj;\n}\n\n// =============================================================================\n// LOGGER CLASS\n// =============================================================================\n\nclass TelnyxLogger {\n\tprivate service = \"telnyx\";\n\tprivate defaultContext: LogContext = {};\n\n\t/**\n\t * Set default context for all log entries\n\t */\n\tsetDefaultContext(context: LogContext): void {\n\t\tthis.defaultContext = { ...this.defaultContext, ...context };\n\t}\n\n\t/**\n\t * Clear default context\n\t */\n\tclearDefaultContext(): void {\n\t\tthis.defaultContext = {};\n\t}\n\n\t/**\n\t * Check if a log level should be output\n\t */\n\tprivate shouldLog(level: LogLevel): boolean {\n\t\treturn LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel];\n\t}\n\n\t/**\n\t * Format and output a log entry\n\t */\n\tprivate log(level: LogLevel, message: string, context?: LogContext): void {\n\t\tif (!this.shouldLog(level)) return;\n\n\t\tconst entry: LogEntry = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tlevel,\n\t\t\tservice: this.service,\n\t\t\tmessage,\n\t\t};\n\n\t\t// Merge default context with provided context\n\t\tconst fullContext = { ...this.defaultContext, ...context };\n\n\t\tif (Object.keys(fullContext).length > 0) {\n\t\t\t// Redact PII from context\n\t\t\tentry.context = redactPII(fullContext) as LogContext;\n\t\t}\n\n\t\t// Output as JSON in production, pretty print in development\n\t\tif (process.env.NODE_ENV === \"production\") {\n\t\t\tconst output = JSON.stringify(entry);\n\n\t\t\tswitch (level) {\n\t\t\t\tcase \"error\":\n\t\t\t\t\tconsole.error(output);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"warn\":\n\t\t\t\t\tconsole.warn(output);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(output);\n\t\t\t}\n\t\t} else {\n\t\t\t// Development: more readable format\n\t\t\tconst contextStr = entry.context\n\t\t\t\t? ` ${JSON.stringify(entry.context, null, 2)}`\n\t\t\t\t: \"\";\n\n\t\t\tconst prefix = `[${entry.timestamp}] [${level.toUpperCase()}] [${this.service}]`;\n\n\t\t\tswitch (level) {\n\t\t\t\tcase \"error\":\n\t\t\t\t\tconsole.error(`${prefix} ${message}${contextStr}`);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"warn\":\n\t\t\t\t\tconsole.warn(`${prefix} ${message}${contextStr}`);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"debug\":\n\t\t\t\t\tconsole.debug(`${prefix} ${message}${contextStr}`);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`${prefix} ${message}${contextStr}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Log at debug level\n\t */\n\tdebug(message: string, context?: LogContext): void {\n\t\tthis.log(\"debug\", message, context);\n\t}\n\n\t/**\n\t * Log at info level\n\t */\n\tinfo(message: string, context?: LogContext): void {\n\t\tthis.log(\"info\", message, context);\n\t}\n\n\t/**\n\t * Log at warn level\n\t */\n\twarn(message: string, context?: LogContext): void {\n\t\tthis.log(\"warn\", message, context);\n\t}\n\n\t/**\n\t * Log at error level\n\t */\n\terror(message: string, context?: LogContext): void {\n\t\tthis.log(\"error\", message, context);\n\t}\n\n\t/**\n\t * Create a child logger with additional default context\n\t */\n\tchild(context: LogContext): TelnyxChildLogger {\n\t\treturn new TelnyxChildLogger(this, context);\n\t}\n\n\t/**\n\t * Log a request start\n\t */\n\tlogRequestStart(\n\t\tmethod: string,\n\t\tendpoint: string,\n\t\tcontext?: LogContext\n\t): { correlationId: string; startTime: number } {\n\t\tconst correlationId =\n\t\t\tcontext?.correlationId ||\n\t\t\t`tlx_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n\t\tconst startTime = Date.now();\n\n\t\tthis.debug(`${method} ${endpoint} started`, {\n\t\t\t...context,\n\t\t\tcorrelationId,\n\t\t\tendpoint,\n\t\t});\n\n\t\treturn { correlationId, startTime };\n\t}\n\n\t/**\n\t * Log a request completion\n\t */\n\tlogRequestEnd(\n\t\tmethod: string,\n\t\tendpoint: string,\n\t\tstatusCode: number,\n\t\tstartTime: number,\n\t\tcontext?: LogContext\n\t): void {\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tconst logFn = statusCode >= 400 ? this.warn.bind(this) : this.info.bind(this);\n\n\t\tlogFn(`${method} ${endpoint} completed`, {\n\t\t\t...context,\n\t\t\tendpoint,\n\t\t\tstatusCode,\n\t\t\tlatencyMs,\n\t\t});\n\t}\n\n\t/**\n\t * Log a request error\n\t */\n\tlogRequestError(\n\t\tmethod: string,\n\t\tendpoint: string,\n\t\terror: Error,\n\t\tstartTime: number,\n\t\tcontext?: LogContext\n\t): void {\n\t\tconst latencyMs = Date.now() - startTime;\n\n\t\tthis.error(`${method} ${endpoint} failed`, {\n\t\t\t...context,\n\t\t\tendpoint,\n\t\t\terror: error.message,\n\t\t\tlatencyMs,\n\t\t});\n\t}\n}\n\n/**\n * Child logger with inherited context\n */\nclass TelnyxChildLogger {\n\tconstructor(\n\t\tprivate parent: TelnyxLogger,\n\t\tprivate context: LogContext\n\t) {}\n\n\tdebug(message: string, context?: LogContext): void {\n\t\tthis.parent.debug(message, { ...this.context, ...context });\n\t}\n\n\tinfo(message: string, context?: LogContext): void {\n\t\tthis.parent.info(message, { ...this.context, ...context });\n\t}\n\n\twarn(message: string, context?: LogContext): void {\n\t\tthis.parent.warn(message, { ...this.context, ...context });\n\t}\n\n\terror(message: string, context?: LogContext): void {\n\t\tthis.parent.error(message, { ...this.context, ...context });\n\t}\n}\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\n/**\n * Singleton logger instance\n */\nexport const telnyxLogger = new TelnyxLogger();\n\n/**\n * Create a request-scoped logger\n */\nexport function createRequestLogger(correlationId: string): TelnyxChildLogger {\n\treturn telnyxLogger.child({ correlationId });\n}\n\n/**\n * Utility to redact PII from any object (exported for testing)\n */\nexport { redactPII };\n","/**\n * Telnyx Retry Logic\n *\n * Implements exponential backoff with jitter and circuit breaker pattern\n * for resilient API calls to Telnyx.\n */\n\nimport { telnyxLogger } from \"./logger\";\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nexport interface RetryConfig {\n\tmaxRetries: number;\n\tbaseDelayMs: number;\n\tmaxDelayMs: number;\n\tjitterFactor: number; // 0-1, adds randomness to delay\n\tretryableStatusCodes: number[];\n\tretryableErrorCodes: string[];\n}\n\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n\tmaxRetries: 5,\n\tbaseDelayMs: 1000, // 1 second\n\tmaxDelayMs: 32000, // 32 seconds max\n\tjitterFactor: 0.3, // 30% jitter\n\tretryableStatusCodes: [408, 429, 500, 502, 503, 504],\n\tretryableErrorCodes: [\n\t\t\"ECONNRESET\",\n\t\t\"ETIMEDOUT\",\n\t\t\"ECONNREFUSED\",\n\t\t\"EPIPE\",\n\t\t\"ENOTFOUND\",\n\t\t\"ENETUNREACH\",\n\t\t\"EAI_AGAIN\",\n\t],\n};\n\n// =============================================================================\n// CIRCUIT BREAKER\n// =============================================================================\n\nexport interface CircuitBreakerConfig {\n\tfailureThreshold: number; // Failures before opening circuit\n\tresetTimeoutMs: number; // Time before trying again\n\thalfOpenRequests: number; // Requests to allow in half-open state\n}\n\nexport const DEFAULT_CIRCUIT_BREAKER_CONFIG: CircuitBreakerConfig = {\n\tfailureThreshold: 5,\n\tresetTimeoutMs: 60000, // 1 minute\n\thalfOpenRequests: 3,\n};\n\ntype CircuitState = \"closed\" | \"open\" | \"half-open\";\n\ninterface CircuitBreakerState {\n\tstate: CircuitState;\n\tfailures: number;\n\tlastFailureTime: number;\n\thalfOpenSuccesses: number;\n\thalfOpenFailures: number;\n}\n\n// Per-endpoint circuit breakers\nconst circuitBreakers = new Map<string, CircuitBreakerState>();\n\nfunction getCircuitBreaker(endpoint: string): CircuitBreakerState {\n\tif (!circuitBreakers.has(endpoint)) {\n\t\tcircuitBreakers.set(endpoint, {\n\t\t\tstate: \"closed\",\n\t\t\tfailures: 0,\n\t\t\tlastFailureTime: 0,\n\t\t\thalfOpenSuccesses: 0,\n\t\t\thalfOpenFailures: 0,\n\t\t});\n\t}\n\treturn circuitBreakers.get(endpoint)!;\n}\n\nfunction updateCircuitState(\n\tendpoint: string,\n\tsuccess: boolean,\n\tconfig: CircuitBreakerConfig = DEFAULT_CIRCUIT_BREAKER_CONFIG\n): void {\n\tconst breaker = getCircuitBreaker(endpoint);\n\tconst now = Date.now();\n\n\tif (success) {\n\t\tif (breaker.state === \"half-open\") {\n\t\t\tbreaker.halfOpenSuccesses++;\n\t\t\tif (breaker.halfOpenSuccesses >= config.halfOpenRequests) {\n\t\t\t\t// Enough successes, close the circuit\n\t\t\t\tbreaker.state = \"closed\";\n\t\t\t\tbreaker.failures = 0;\n\t\t\t\tbreaker.halfOpenSuccesses = 0;\n\t\t\t\tbreaker.halfOpenFailures = 0;\n\t\t\t\ttelnyxLogger.info(\"Circuit breaker closed\", { endpoint });\n\t\t\t}\n\t\t} else if (breaker.state === \"closed\") {\n\t\t\t// Reset failure count on success\n\t\t\tbreaker.failures = 0;\n\t\t}\n\t} else {\n\t\tbreaker.lastFailureTime = now;\n\n\t\tif (breaker.state === \"half-open\") {\n\t\t\tbreaker.halfOpenFailures++;\n\t\t\t// Any failure in half-open reopens the circuit\n\t\t\tbreaker.state = \"open\";\n\t\t\tbreaker.halfOpenSuccesses = 0;\n\t\t\tbreaker.halfOpenFailures = 0;\n\t\t\ttelnyxLogger.warn(\"Circuit breaker reopened\", { endpoint });\n\t\t} else if (breaker.state === \"closed\") {\n\t\t\tbreaker.failures++;\n\t\t\tif (breaker.failures >= config.failureThreshold) {\n\t\t\t\tbreaker.state = \"open\";\n\t\t\t\ttelnyxLogger.error(\"Circuit breaker opened\", {\n\t\t\t\t\tendpoint,\n\t\t\t\t\tfailures: breaker.failures,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction canAttempt(\n\tendpoint: string,\n\tconfig: CircuitBreakerConfig = DEFAULT_CIRCUIT_BREAKER_CONFIG\n): boolean {\n\tconst breaker = getCircuitBreaker(endpoint);\n\tconst now = Date.now();\n\n\tif (breaker.state === \"closed\") {\n\t\treturn true;\n\t}\n\n\tif (breaker.state === \"open\") {\n\t\t// Check if reset timeout has passed\n\t\tif (now - breaker.lastFailureTime >= config.resetTimeoutMs) {\n\t\t\tbreaker.state = \"half-open\";\n\t\t\tbreaker.halfOpenSuccesses = 0;\n\t\t\tbreaker.halfOpenFailures = 0;\n\t\t\ttelnyxLogger.info(\"Circuit breaker half-open\", { endpoint });\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Half-open: allow limited requests\n\treturn true;\n}\n\n// =============================================================================\n// RETRY LOGIC\n// =============================================================================\n\nexport interface RetryError extends Error {\n\tstatusCode?: number;\n\terrorCode?: string;\n\tretryable: boolean;\n\tattempts: number;\n\tlastError?: Error;\n}\n\nexport function createRetryError(\n\tmessage: string,\n\toptions: {\n\t\tstatusCode?: number;\n\t\terrorCode?: string;\n\t\tretryable: boolean;\n\t\tattempts: number;\n\t\tlastError?: Error;\n\t}\n): RetryError {\n\tconst error = new Error(message) as RetryError;\n\terror.name = \"RetryError\";\n\terror.statusCode = options.statusCode;\n\terror.errorCode = options.errorCode;\n\terror.retryable = options.retryable;\n\terror.attempts = options.attempts;\n\terror.lastError = options.lastError;\n\treturn error;\n}\n\n/**\n * Check if an error is retryable\n */\nexport function isRetryable(\n\terror: unknown,\n\tconfig: RetryConfig = DEFAULT_RETRY_CONFIG\n): boolean {\n\tif (!error) return false;\n\n\t// Check for network errors\n\tif (error instanceof Error) {\n\t\tconst errorCode = (error as NodeJS.ErrnoException).code;\n\t\tif (errorCode && config.retryableErrorCodes.includes(errorCode)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for fetch/network errors\n\t\tif (\n\t\t\terror.message.includes(\"fetch failed\") ||\n\t\t\terror.message.includes(\"network\") ||\n\t\t\terror.message.includes(\"timeout\") ||\n\t\t\terror.message.includes(\"ECONNRESET\")\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Check for HTTP status codes\n\tif (typeof error === \"object\" && error !== null) {\n\t\tconst statusCode = (error as { statusCode?: number; status?: number })\n\t\t\t.statusCode ||\n\t\t\t(error as { statusCode?: number; status?: number }).status;\n\t\tif (statusCode && config.retryableStatusCodes.includes(statusCode)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Calculate delay with exponential backoff and jitter\n */\nexport function calculateDelay(\n\tattempt: number,\n\tconfig: RetryConfig = DEFAULT_RETRY_CONFIG\n): number {\n\t// Exponential backoff: baseDelay * 2^attempt\n\tconst exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\n\n\t// Cap at max delay\n\tconst cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\n\n\t// Add jitter (randomness to spread out retries)\n\tconst jitter = cappedDelay * config.jitterFactor * Math.random();\n\n\treturn Math.floor(cappedDelay + jitter);\n}\n\n/**\n * Sleep for specified milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Extract Retry-After header value in milliseconds\n */\nexport function parseRetryAfter(response: Response): number | null {\n\tconst retryAfter = response.headers.get(\"Retry-After\");\n\tif (!retryAfter) return null;\n\n\t// Check if it's a number (seconds)\n\tconst seconds = parseInt(retryAfter, 10);\n\tif (!isNaN(seconds)) {\n\t\treturn seconds * 1000;\n\t}\n\n\t// Check if it's a date\n\tconst date = Date.parse(retryAfter);\n\tif (!isNaN(date)) {\n\t\treturn Math.max(0, date - Date.now());\n\t}\n\n\treturn null;\n}\n\n// =============================================================================\n// RETRY WRAPPER\n// =============================================================================\n\nexport interface RetryOptions {\n\tendpoint?: string; // For circuit breaker tracking\n\tconfig?: Partial<RetryConfig>;\n\tcircuitBreakerConfig?: Partial<CircuitBreakerConfig>;\n\tonRetry?: (attempt: number, error: Error, delayMs: number) => void;\n\tcorrelationId?: string;\n}\n\n/**\n * Execute a function with retry logic and circuit breaker\n */\nexport async function withRetry<T>(\n\tfn: () => Promise<T>,\n\toptions: RetryOptions = {}\n): Promise<T> {\n\tconst config = { ...DEFAULT_RETRY_CONFIG, ...options.config };\n\tconst circuitConfig = {\n\t\t...DEFAULT_CIRCUIT_BREAKER_CONFIG,\n\t\t...options.circuitBreakerConfig,\n\t};\n\tconst endpoint = options.endpoint || \"default\";\n\tconst correlationId = options.correlationId || generateCorrelationId();\n\n\t// Check circuit breaker\n\tif (!canAttempt(endpoint, circuitConfig)) {\n\t\tconst error = createRetryError(\n\t\t\t`Circuit breaker open for endpoint: ${endpoint}`,\n\t\t\t{\n\t\t\t\tretryable: false,\n\t\t\t\tattempts: 0,\n\t\t\t}\n\t\t);\n\t\ttelnyxLogger.warn(\"Request blocked by circuit breaker\", {\n\t\t\tendpoint,\n\t\t\tcorrelationId,\n\t\t});\n\t\tthrow error;\n\t}\n\n\tlet lastError: Error | undefined;\n\tlet attempt = 0;\n\n\twhile (attempt <= config.maxRetries) {\n\t\ttry {\n\t\t\tconst result = await fn();\n\n\t\t\t// Success - update circuit breaker\n\t\t\tupdateCircuitState(endpoint, true, circuitConfig);\n\n\t\t\tif (attempt > 0) {\n\t\t\t\ttelnyxLogger.info(\"Request succeeded after retry\", {\n\t\t\t\t\tendpoint,\n\t\t\t\t\tattempt,\n\t\t\t\t\tcorrelationId,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\n\t\t\tconst retryable = isRetryable(error, config);\n\n\t\t\ttelnyxLogger.warn(\"Request failed\", {\n\t\t\t\tendpoint,\n\t\t\t\tattempt,\n\t\t\t\tretryable,\n\t\t\t\terror: lastError.message,\n\t\t\t\tcorrelationId,\n\t\t\t});\n\n\t\t\t// Update circuit breaker on failure\n\t\t\tupdateCircuitState(endpoint, false, circuitConfig);\n\n\t\t\t// Don't retry if not retryable or max retries reached\n\t\t\tif (!retryable || attempt >= config.maxRetries) {\n\t\t\t\tthrow createRetryError(\n\t\t\t\t\t`Request failed after ${attempt + 1} attempt(s): ${lastError.message}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tretryable,\n\t\t\t\t\t\tattempts: attempt + 1,\n\t\t\t\t\t\tlastError,\n\t\t\t\t\t\tstatusCode: (error as { statusCode?: number }).statusCode,\n\t\t\t\t\t\terrorCode: (error as { code?: string }).code,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Calculate delay\n\t\t\tlet delayMs = calculateDelay(attempt, config);\n\n\t\t\t// Check for Retry-After header (if error has response)\n\t\t\tif (\n\t\t\t\ttypeof error === \"object\" &&\n\t\t\t\terror !== null &&\n\t\t\t\t\"response\" in error\n\t\t\t) {\n\t\t\t\tconst response = (error as { response?: Response }).response;\n\t\t\t\tif (response) {\n\t\t\t\t\tconst retryAfter = parseRetryAfter(response);\n\t\t\t\t\tif (retryAfter) {\n\t\t\t\t\t\tdelayMs = Math.min(retryAfter, config.maxDelayMs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call onRetry callback\n\t\t\tif (options.onRetry) {\n\t\t\t\toptions.onRetry(attempt, lastError, delayMs);\n\t\t\t}\n\n\t\t\ttelnyxLogger.info(\"Retrying request\", {\n\t\t\t\tendpoint,\n\t\t\t\tattempt: attempt + 1,\n\t\t\t\tdelayMs,\n\t\t\t\tcorrelationId,\n\t\t\t});\n\n\t\t\tawait sleep(delayMs);\n\t\t\tattempt++;\n\t\t}\n\t}\n\n\t// Should never reach here, but just in case\n\tthrow createRetryError(\n\t\t`Request failed after ${config.maxRetries + 1} attempts`,\n\t\t{\n\t\t\tretryable: false,\n\t\t\tattempts: config.maxRetries + 1,\n\t\t\tlastError,\n\t\t}\n\t);\n}\n\n// =============================================================================\n// BULK RETRY (for rate-limited batch operations)\n// =============================================================================\n\nexport interface BulkRetryOptions<T, R> {\n\titems: T[];\n\toperation: (item: T) => Promise<R>;\n\tconcurrency?: number;\n\tretryOptions?: RetryOptions;\n\tonProgress?: (completed: number, total: number, failed: number) => void;\n}\n\nexport interface BulkRetryResult<T, R> {\n\tsuccessful: Array<{ item: T; result: R }>;\n\tfailed: Array<{ item: T; error: Error }>;\n}\n\n/**\n * Process items in bulk with retry logic and concurrency control\n */\nexport async function withBulkRetry<T, R>(\n\toptions: BulkRetryOptions<T, R>\n): Promise<BulkRetryResult<T, R>> {\n\tconst { items, operation, concurrency = 10, retryOptions, onProgress } = options;\n\n\tconst successful: Array<{ item: T; result: R }> = [];\n\tconst failed: Array<{ item: T; error: Error }> = [];\n\tlet completed = 0;\n\n\t// Process in batches\n\tfor (let i = 0; i < items.length; i += concurrency) {\n\t\tconst batch = items.slice(i, i + concurrency);\n\n\t\tconst results = await Promise.allSettled(\n\t\t\tbatch.map(async (item) => {\n\t\t\t\tconst result = await withRetry(\n\t\t\t\t\t() => operation(item),\n\t\t\t\t\tretryOptions\n\t\t\t\t);\n\t\t\t\treturn { item, result };\n\t\t\t})\n\t\t);\n\n\t\tfor (const result of results) {\n\t\t\tcompleted++;\n\n\t\t\tif (result.status === \"fulfilled\") {\n\t\t\t\tsuccessful.push(result.value);\n\t\t\t} else {\n\t\t\t\tconst item = batch[results.indexOf(result)];\n\t\t\t\tfailed.push({\n\t\t\t\t\titem,\n\t\t\t\t\terror:\n\t\t\t\t\t\tresult.reason instanceof Error\n\t\t\t\t\t\t\t? result.reason\n\t\t\t\t\t\t\t: new Error(String(result.reason)),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (onProgress) {\n\t\t\tonProgress(completed, items.length, failed.length);\n\t\t}\n\n\t\t// Small delay between batches to avoid rate limiting\n\t\tif (i + concurrency < items.length) {\n\t\t\tawait sleep(100);\n\t\t}\n\t}\n\n\treturn { successful, failed };\n}\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Generate a correlation ID for request tracking\n */\nexport function generateCorrelationId(): string {\n\treturn `tlx_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Get circuit breaker status for monitoring\n */\nexport function getCircuitBreakerStatus(endpoint?: string): {\n\tendpoints: Record<string, CircuitBreakerState>;\n\tsummary: {\n\t\ttotal: number;\n\t\topen: number;\n\t\thalfOpen: number;\n\t\tclosed: number;\n\t};\n} {\n\tconst endpoints: Record<string, CircuitBreakerState> = {};\n\n\tif (endpoint) {\n\t\tconst breaker = circuitBreakers.get(endpoint);\n\t\tif (breaker) {\n\t\t\tendpoints[endpoint] = breaker;\n\t\t}\n\t} else {\n\t\tcircuitBreakers.forEach((state, ep) => {\n\t\t\tendpoints[ep] = state;\n\t\t});\n\t}\n\n\tconst states = Object.values(endpoints);\n\treturn {\n\t\tendpoints,\n\t\tsummary: {\n\t\t\ttotal: states.length,\n\t\t\topen: states.filter((s) => s.state === \"open\").length,\n\t\t\thalfOpen: states.filter((s) => s.state === \"half-open\").length,\n\t\t\tclosed: states.filter((s) => s.state === \"closed\").length,\n\t\t},\n\t};\n}\n\n/**\n * Reset circuit breaker for an endpoint (for testing/manual reset)\n */\nexport function resetCircuitBreaker(endpoint: string): void {\n\tcircuitBreakers.delete(endpoint);\n\ttelnyxLogger.info(\"Circuit breaker reset\", { endpoint });\n}\n\n/**\n * Reset all circuit breakers\n */\nexport function resetAllCircuitBreakers(): void {\n\tcircuitBreakers.clear();\n\ttelnyxLogger.info(\"All circuit breakers reset\");\n}\n"],"names":[],"mappings":"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"}