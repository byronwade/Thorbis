{"version":3,"sources":["../../../../../../apps/web/src/lib/communication/sms-service.ts","../../../../../../apps/web/src/actions/sms-actions.ts","../../../../../../apps/web/src/actions/entity-tags.ts","../../../../../../apps/web/src/actions/payments.ts","../../../../../../apps/web/src/actions/job-tags.ts"],"sourcesContent":["/**\n * SMS Service\n * \n * Handles fetching and managing SMS messages from the communications table\n * Similar structure to email-service.ts but for SMS type communications\n */\n\nimport { createClient } from \"@/lib/supabase/server\";\nimport type { TypedSupabaseClient } from \"@/types/supabase\";\n\nexport type CompanySms = {\n\tid: string;\n\tfrom_address: string | null;\n\tfrom_name: string | null;\n\tto_address: string | null;\n\tbody: string;\n\tbody_html: string | null;\n\tcreated_at: string;\n\tread_at: string | null;\n\tdirection: \"inbound\" | \"outbound\";\n\tcustomer_id: string | null;\n\tcustomer?: {\n\t\tid: string;\n\t\tfirst_name: string | null;\n\t\tlast_name: string | null;\n\t\tdisplay_name: string | null;\n\t\temail: string | null;\n\t\tphone: string | null;\n\t\tcompany_name: string | null;\n\t} | null;\n\tsent_at: string | null;\n\tdelivered_at: string | null;\n\tstatus: string;\n\tchannel: string | null;\n\tprovider_metadata: Record<string, unknown> | null;\n\tis_archived: boolean;\n\tsnoozed_until: string | null;\n\tcategory: string | null;\n\ttags: string[] | null;\n\ttelnyx_message_id: string | null;\n};\n\nexport type GetCompanySmsInput = {\n\tlimit?: number;\n\toffset?: number;\n\ttype?: \"sent\" | \"received\" | \"all\";\n\tfolder?: \"inbox\" | \"sent\" | \"archive\" | \"trash\" | \"bin\";\n\tlabel?: string;\n\tsearch?: string | null;\n\tsortBy?: \"created_at\" | \"sent_at\";\n\tsortOrder?: \"asc\" | \"desc\";\n};\n\nexport type GetCompanySmsResult = {\n\tsms: CompanySms[];\n\ttotal: number;\n\thasMore: boolean;\n};\n\nexport async function getCompanySms(\n\tcompanyId: string,\n\tinput: GetCompanySmsInput = {},\n): Promise<GetCompanySmsResult> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tconst {\n\t\tlimit = 50,\n\t\toffset = 0,\n\t\ttype = \"all\",\n\t\tfolder,\n\t\tlabel,\n\t\tsearch,\n\t\tsortBy = \"created_at\",\n\t\tsortOrder = \"desc\",\n\t} = input;\n\n\t// Build the query - get all SMS messages\n\tlet query = supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t\t{ count: \"exact\" },\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\");\n\n\t// Apply folder filtering\n\tif (folder) {\n\t\tswitch (folder) {\n\t\t\tcase \"inbox\":\n\t\t\t\t// Inbox: inbound, not archived, not deleted, not snoozed (or snooze expired)\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"inbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null)\n\t\t\t\t\t.or(\"snoozed_until.is.null,snoozed_until.lt.now()\");\n\t\t\t\tbreak;\n\t\t\tcase \"sent\":\n\t\t\t\t// Sent: outbound, not archived, not deleted\n\t\t\t\tquery = query\n\t\t\t\t\t.eq(\"direction\", \"outbound\")\n\t\t\t\t\t.eq(\"is_archived\", false)\n\t\t\t\t\t.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"archive\":\n\t\t\t\t// Archive: is_archived = true, not deleted\n\t\t\t\tquery = query.eq(\"is_archived\", true).is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t\tcase \"trash\":\n\t\t\tcase \"bin\":\n\t\t\t\t// Trash: deleted_at is not null\n\t\t\t\tquery = query.not(\"deleted_at\", \"is\", null);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Custom folder or label filtering - done in memory after fetch\n\t\t\t\t// (JSONB array containment not supported by PostgREST cs operator)\n\t\t\t\tquery = query.is(\"deleted_at\", null);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t// Default: exclude deleted SMS\n\t\tquery = query.is(\"deleted_at\", null);\n\t}\n\n\t// Apply direction filter\n\tif (type === \"sent\") {\n\t\tquery = query.eq(\"direction\", \"outbound\");\n\t} else if (type === \"received\") {\n\t\tquery = query.eq(\"direction\", \"inbound\");\n\t}\n\n\t// Apply search filter\n\tif (search) {\n\t\tconst searchLower = search.toLowerCase();\n\t\tquery = query.or(\n\t\t\t`from_address.ilike.%${searchLower}%,to_address.ilike.%${searchLower}%,body.ilike.%${searchLower}%`,\n\t\t);\n\t}\n\n\t// Apply sorting\n\tconst ascending = sortOrder === \"asc\";\n\tif (sortBy === \"sent_at\") {\n\t\tquery = query.order(\"sent_at\", { ascending, nullsFirst: false });\n\t} else {\n\t\tquery = query.order(\"created_at\", { ascending });\n\t}\n\n\t// Apply pagination\n\tquery = query.range(offset, offset + limit - 1);\n\n\tconst { data, error, count } = await query;\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS messages:\", error);\n\t\treturn { sms: [], total: 0, hasMore: false };\n\t}\n\n\tlet sms = (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n\n\t// Post-process custom folder/label filtering (JSONB array containment not supported by PostgREST)\n\tconst standardFolders = [\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"];\n\tconst folderName = label || folder;\n\tif (folderName && !standardFolders.includes(folderName)) {\n\t\tsms = sms.filter((msg) => {\n\t\t\tconst msgTags = msg.tags || [];\n\t\t\treturn Array.isArray(msgTags) && msgTags.includes(folderName);\n\t\t});\n\t\treturn {\n\t\t\tsms,\n\t\t\ttotal: sms.length,\n\t\t\thasMore: false,\n\t\t};\n\t}\n\n\tconst total = count || 0;\n\tconst hasMore = offset + sms.length < total;\n\n\treturn {\n\t\tsms,\n\t\ttotal,\n\t\thasMore,\n\t};\n}\n\nexport async function getSmsById(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<CompanySms | null> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn null;\n\t}\n\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\t...data,\n\t\ttags: (data.tags as string[]) || null,\n\t\tprovider_metadata: (data.provider_metadata as Record<string, unknown>) || null,\n\t} as CompanySms;\n}\n\nexport async function markSmsAsRead(\n\tcompanyId: string,\n\tsmsId: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\tconsole.error(\"❌ markSmsAsRead: Missing supabase\");\n\t\treturn false;\n\t}\n\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"id\", smsId)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.select(\"id, read_at\")\n\t\t.single();\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tif (!data) {\n\t\tconsole.error(\"❌ markSmsAsRead: No data returned\");\n\t\treturn false;\n\t}\n\n\tconsole.log(\"✅ markSmsAsRead success:\", { smsId, read_at: data.read_at });\n\treturn true;\n}\n\n/**\n * Get all SMS messages for a conversation thread (by phone number)\n */\nexport async function getSmsConversation(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<CompanySms[]> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn [];\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Fetch all messages where this phone number is either from or to\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.select(\n\t\t\t`\n\t\t\tid,\n\t\t\tfrom_address,\n\t\t\tfrom_name,\n\t\t\tto_address,\n\t\t\tbody,\n\t\t\tbody_html,\n\t\t\tcreated_at,\n\t\t\tread_at,\n\t\t\tdirection,\n\t\t\tcustomer_id,\n\t\t\tcustomer:customers!left(id, first_name, last_name, display_name, email, phone, company_name),\n\t\t\tsent_at,\n\t\t\tdelivered_at,\n\t\t\tstatus,\n\t\t\tchannel,\n\t\t\tprovider_metadata,\n\t\t\tis_archived,\n\t\t\tsnoozed_until,\n\t\t\tcategory,\n\t\t\ttags,\n\t\t\ttelnyx_message_id\n\t\t`,\n\t\t)\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.order(\"created_at\", { ascending: true });\n\n\tif (error) {\n\t\tconsole.error(\"Error fetching SMS conversation:\", error);\n\t\treturn [];\n\t}\n\n\treturn (data || []).map((msg) => ({\n\t\t...msg,\n\t\ttags: (msg.tags as string[]) || null,\n\t\tprovider_metadata: (msg.provider_metadata as Record<string, unknown>) || null,\n\t})) as CompanySms[];\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsRead(\n\tcompanyId: string,\n\tphoneNumber: string,\n): Promise<boolean> {\n\tconst supabase = await createClient();\n\n\tif (!supabase) {\n\t\treturn false;\n\t}\n\n\t// Normalize phone number for matching\n\tconst normalizePhone = (phone: string) => {\n\t\tconst digits = phone.replace(/[^0-9]/g, \"\");\n\t\tif (digits.length === 11 && digits.startsWith(\"1\")) {\n\t\t\treturn `+${digits}`;\n\t\t}\n\t\tif (digits.length === 10) {\n\t\t\treturn `+1${digits}`;\n\t\t}\n\t\treturn phone.startsWith(\"+\") ? phone : `+${phone}`;\n\t};\n\n\tconst normalizedPhone = normalizePhone(phoneNumber);\n\n\t// Mark all unread inbound messages in this conversation as read\n\tconst readAt = new Date().toISOString();\n\tconst { data, error } = await supabase\n\t\t.from(\"communications\")\n\t\t.update({ read_at: readAt })\n\t\t.eq(\"company_id\", companyId)\n\t\t.eq(\"type\", \"sms\")\n\t\t.eq(\"direction\", \"inbound\")\n\t\t.is(\"read_at\", null)\n\t\t.is(\"deleted_at\", null)\n\t\t.or(`from_address.eq.${normalizedPhone},to_address.eq.${normalizedPhone}`)\n\t\t.select(\"id, read_at\");\n\n\tif (error) {\n\t\tconsole.error(\"❌ markSmsConversationAsRead error:\", error);\n\t\treturn false;\n\t}\n\n\tconsole.log(`✅ markSmsConversationAsRead success: Marked ${data?.length || 0} messages as read`);\n\treturn true;\n}\n\n","\"use server\";\n\nimport {\n    getCompanySms,\n    getSmsById,\n    markSmsAsRead,\n    markSmsConversationAsRead,\n    type CompanySms,\n} from \"@/lib/communication/sms-service\";\nimport { z } from \"zod\";\n\nconst getSmsSchema = z.object({\n  limit: z.coerce.number().min(1).max(500).optional().default(50),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum([\"sent\", \"received\", \"all\"]).optional().default(\"all\"),\n  folder: z.enum([\"inbox\", \"sent\", \"archive\", \"trash\", \"bin\"]).optional(),\n  label: z.string().optional(),\n  search: z.string().optional().nullable(),\n  sortBy: z.enum([\"created_at\", \"sent_at\"]).optional().default(\"created_at\"),\n  sortOrder: z.enum([\"asc\", \"desc\"]).optional().default(\"desc\"),\n}).passthrough();\n\nconst markSmsReadSchema = z.object({\n  smsId: z.string().min(1),\n});\n\nexport type GetSmsInput = z.infer<typeof getSmsSchema>;\nexport type MarkSmsReadInput = z.infer<typeof markSmsReadSchema>;\n\n// Re-export SMS types from sms-service\nexport type { CompanySms };\n\nexport type GetSmsResult = Awaited<ReturnType<typeof getCompanySms>>;\n\n/**\n * Get SMS messages for the active company\n */\nexport async function getSmsAction(\n  input: GetSmsInput\n): Promise<GetSmsResult> {\n  try {\n    const parseResult = getSmsSchema.safeParse(input);\n    \n    if (!parseResult.success) {\n      throw new Error(`Invalid input parameters: ${parseResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`);\n    }\n    \n    const validatedInput = parseResult.data;\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"No active company found\");\n    }\n\n    return await getCompanySms(companyId, validatedInput);\n  } catch (error) {\n    console.error(\"❌ getSmsAction error:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get a specific SMS by ID\n */\nexport async function getSmsByIdAction(smsId: string): Promise<{\n  success: boolean;\n  sms?: CompanySms;\n  error?: string;\n}> {\n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const sms = await getSmsById(companyId, smsId);\n    \n    if (!sms) {\n      return { success: false, error: \"SMS not found\" };\n    }\n\n    return { success: true, sms };\n  } catch (error) {\n    console.error(\"Error getting SMS by ID:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Mark an SMS as read\n */\nexport async function markSmsAsReadAction(\n  input: MarkSmsReadInput\n): Promise<boolean> {\n  try {\n    const validatedInput = markSmsReadSchema.parse(input);\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n\n    if (!companyId) {\n      throw new Error(\"Invalid input parameters\");\n    }\n\n    return await markSmsAsRead(companyId, validatedInput.smsId);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\"Invalid input parameters\");\n    }\n    throw error;\n  }\n}\n\n/**\n * Mark all unread messages in an SMS conversation as read\n */\nexport async function markSmsConversationAsReadAction(phoneNumber: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const success = await markSmsConversationAsRead(companyId, phoneNumber);\n    return { success };\n  } catch (error) {\n    console.error(\"Error marking SMS conversation as read:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS conversation thread by phone number\n */\nexport async function getSmsConversationAction(phoneNumber: string): Promise<{\n  success: boolean;\n  messages?: CompanySms[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getSmsConversation } = await import(\"@/lib/sms/sms-service\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    const messages = await getSmsConversation(companyId, phoneNumber);\n    return { success: true, messages };\n  } catch (error) {\n    console.error(\"Error fetching SMS conversation:\", error);\n    // Handle cookies() error gracefully\n    if (error instanceof Error && error.message.includes(\"cookies\")) {\n      return {\n        success: false,\n        error: \"Request context not available. Please refresh the page.\",\n      };\n    }\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * Get SMS folder counts\n */\nexport async function getSmsFolderCountsAction(): Promise<{\n  success: boolean;\n  counts?: {\n    inbox: number;\n    sent: number;\n    archive: number;\n    trash: number;\n    [label: string]: number;\n  };\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    \n    const companyId = await getActiveCompanyId();\n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const supabase = await createClient();\n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n    \n    const baseQuery = supabase\n      .from(\"communications\")\n      .select(\"*\", { count: \"exact\", head: true })\n      .eq(\"company_id\", companyId)\n      .eq(\"type\", \"sms\");\n    \n    // Get counts for each folder\n    const [inboxResult, sentResult, archiveResult, trashResult] = await Promise.all([\n      // Inbox\n      baseQuery\n        .eq(\"direction\", \"inbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null)\n        .or(\"snoozed_until.is.null,snoozed_until.lt.now()\"),\n      // Sent\n      baseQuery\n        .eq(\"direction\", \"outbound\")\n        .eq(\"is_archived\", false)\n        .is(\"deleted_at\", null),\n      // Archive\n      baseQuery.eq(\"is_archived\", true).is(\"deleted_at\", null),\n      // Trash\n      baseQuery.not(\"deleted_at\", \"is\", null),\n    ]);\n    \n    const counts = {\n      inbox: inboxResult.count || 0,\n      sent: sentResult.count || 0,\n      archive: archiveResult.count || 0,\n      trash: trashResult.count || 0,\n    };\n    \n    return { success: true, counts };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown error\" };\n  }\n}\n\n/**\n * Upload SMS attachments to storage\n */\nexport async function uploadSmsAttachments(\n  files: File[]\n): Promise<{\n  success: boolean;\n  urls?: string[];\n  error?: string;\n}> {\n  \"use server\";\n  \n  try {\n    const { getActiveCompanyId } = await import(\"@/lib/auth/company-context\");\n    const companyId = await getActiveCompanyId();\n    \n    if (!companyId) {\n      return { success: false, error: \"No active company found\" };\n    }\n    \n    const { createClient } = await import(\"@/lib/supabase/server\");\n    const supabase = await createClient();\n    \n    if (!supabase) {\n      return { success: false, error: \"Database connection failed\" };\n    }\n\n    const urls: string[] = [];\n    \n      // Upload each file to Supabase Storage\n      // Use company-files bucket which has proper RLS policies for company members\n      for (const file of files) {\n        const fileExt = file.name.split('.').pop();\n        const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;\n        // Path structure: companyId must be at index [0] for RLS policy (matches document-manager pattern)\n        // Format: companyId/folder/filename (storage.foldername(name))[0] = companyId\n        const filePath = `${companyId}/sms-attachments/${fileName}`;\n        \n        // Convert file to array buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const { data, error: uploadError } = await supabase.storage\n          .from('company-files') // Use company-files bucket with proper RLS\n          .upload(filePath, arrayBuffer, {\n            contentType: file.type,\n            upsert: false,\n          });\n        \n        if (uploadError) {\n          console.error(\"Upload error:\", uploadError);\n          return { success: false, error: `Failed to upload ${file.name}: ${uploadError.message}` };\n        }\n        \n        // Get public URL (or signed URL for private bucket)\n        const { data: { publicUrl } } = supabase.storage\n          .from('company-files')\n          .getPublicUrl(filePath);\n        \n        urls.push(publicUrl);\n      }\n    \n    return { success: true, urls };\n  } catch (error) {\n    console.error(\"Error uploading SMS attachments:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n/**\n * SMS Template Context Type\n * Data available for auto-filling SMS templates\n */\nexport type SmsTemplateContext = {\n  companyName?: string;\n  companyPhone?: string;\n  companyEmail?: string;\n};\n\n/**\n * Get company context for SMS templates\n * Returns company info for auto-filling template messages\n */\nexport async function getCompanyContextAction(): Promise<{\n  success: boolean;\n  context?: SmsTemplateContext;\n  error?: string;\n}> {\n  \"use server\";\n\n  try {\n    const { getActiveCompany } = await import(\"@/lib/auth/company-context\");\n\n    const company = await getActiveCompany();\n    if (!company) {\n      return { success: false, error: \"No active company found\" };\n    }\n\n    return {\n      success: true,\n      context: {\n        companyName: company.name,\n        companyPhone: company.phone || undefined,\n        companyEmail: company.email || undefined,\n      },\n    };\n  } catch (error) {\n    console.error(\"Error getting company context:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\n","/**\n * Entity Tags Actions - Server Actions\n * Generic tag management for any entity type\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { withErrorHandling } from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\ntype SupabaseServerClient = Exclude<\n\tAwaited<ReturnType<typeof createClient>>,\n\tnull\n>;\n\nexport type TagWithColor = {\n\tlabel: string;\n\tcolor?: string;\n};\n\nexport type EntityTag = string | TagWithColor;\n\ntype EntityType =\n\t| \"customer\"\n\t| \"job\"\n\t| \"property\"\n\t| \"invoice\"\n\t| \"estimate\"\n\t| \"equipment\"\n\t| \"appointment\"\n\t| \"material\"\n\t| \"vendor\";\n\nconst ENTITY_TAG_FIELD_MAP: Record<\n\tEntityType,\n\t{ table: string; field: string; useMetadata: boolean }\n> = {\n\tcustomer: { table: \"customers\", field: \"tags\", useMetadata: false },\n\tjob: { table: \"jobs\", field: \"metadata\", useMetadata: true },\n\tproperty: { table: \"properties\", field: \"metadata\", useMetadata: true },\n\tinvoice: { table: \"invoices\", field: \"metadata\", useMetadata: true },\n\testimate: { table: \"estimates\", field: \"metadata\", useMetadata: true },\n\tequipment: { table: \"equipment\", field: \"metadata\", useMetadata: true },\n\tappointment: { table: \"appointments\", field: \"metadata\", useMetadata: true },\n\tmaterial: { table: \"job_materials\", field: \"metadata\", useMetadata: true },\n\tvendor: { table: \"vendors\", field: \"tags\", useMetadata: false },\n};\n\n/**\n * Update tags for any entity type\n */\nexport async function updateEntityTags(\n\tentityType: EntityType,\n\tentityId: string,\n\ttags: EntityTag[],\n) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst typedSupabase = supabase as SupabaseServerClient;\n\t\tawait requireAuthenticatedUser(typedSupabase);\n\n\t\tconst config = ENTITY_TAG_FIELD_MAP[entityType];\n\t\tif (!config) {\n\t\t\tthrow new Error(`Unsupported entity type: ${entityType}`);\n\t\t}\n\n\t\tconst updateData = await buildTagsUpdateData({\n\t\t\tsupabase: typedSupabase,\n\t\t\tconfig,\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\ttags,\n\t\t});\n\n\t\tawait applyTagUpdate({\n\t\t\tsupabase: typedSupabase,\n\t\t\tconfig,\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\tupdateData,\n\t\t});\n\n\t\trevalidateEntityPaths(entityType, entityId);\n\n\t\treturn { entityId, entityType, tags };\n\t});\n}\n\n/**\n * Get the base path for an entity type\n */\nfunction getPathForEntity(entityType: EntityType): string | null {\n\tconst pathMap: Record<EntityType, string | null> = {\n\t\tcustomer: \"customers\",\n\t\tjob: \"work\",\n\t\tproperty: \"work/properties\",\n\t\tinvoice: \"work/invoices\",\n\t\testimate: \"work/estimates\",\n\t\tequipment: \"work/equipment\",\n\t\tappointment: \"schedule\",\n\t\tmaterial: null,\n\t\tvendor: \"work/vendors\",\n\t};\n\treturn pathMap[entityType] ?? null;\n}\n\nconst requireAuthenticatedUser = async (supabase: SupabaseServerClient) => {\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\tif (!user) {\n\t\tthrow new Error(\"Not authenticated\");\n\t}\n\treturn user;\n};\n\ntype TagUpdateConfig = (typeof ENTITY_TAG_FIELD_MAP)[EntityType];\n\ntype BuildTagsUpdateDataParams = {\n\tsupabase: SupabaseServerClient;\n\tconfig: TagUpdateConfig;\n\tentityId: string;\n\tentityType: EntityType;\n\ttags: EntityTag[];\n};\n\nconst buildTagsUpdateData = async ({\n\tsupabase,\n\tconfig,\n\tentityId,\n\tentityType,\n\ttags,\n}: BuildTagsUpdateDataParams): Promise<Record<string, unknown>> => {\n\tif (!config.useMetadata) {\n\t\treturn {\n\t\t\ttags,\n\t\t\tupdated_at: new Date().toISOString(),\n\t\t};\n\t}\n\n\tconst { data: existingRecord, error: fetchError } = await supabase\n\t\t.from(config.table)\n\t\t.select(\"metadata\")\n\t\t.eq(\"id\", entityId)\n\t\t.single();\n\n\tif (fetchError) {\n\t\tthrow new Error(\n\t\t\t`Failed to load ${entityType} metadata: ${fetchError.message}`,\n\t\t);\n\t}\n\n\tconst existingMetadata =\n\t\texistingRecord &&\n\t\ttypeof existingRecord.metadata === \"object\" &&\n\t\texistingRecord.metadata !== null\n\t\t\t? (existingRecord.metadata as Record<string, unknown>)\n\t\t\t: {};\n\n\treturn {\n\t\tmetadata: {\n\t\t\t...existingMetadata,\n\t\t\ttags,\n\t\t},\n\t\tupdated_at: new Date().toISOString(),\n\t};\n};\n\ntype ApplyTagUpdateParams = {\n\tsupabase: SupabaseServerClient;\n\tconfig: TagUpdateConfig;\n\tentityId: string;\n\tentityType: EntityType;\n\tupdateData: Record<string, unknown>;\n};\n\nconst applyTagUpdate = async ({\n\tsupabase,\n\tconfig,\n\tentityId,\n\tentityType,\n\tupdateData,\n}: ApplyTagUpdateParams) => {\n\tconst { error } = await supabase\n\t\t.from(config.table)\n\t\t.update(updateData)\n\t\t.eq(\"id\", entityId);\n\n\tif (error) {\n\t\tthrow new Error(`Failed to update ${entityType} tags: ${error.message}`);\n\t}\n};\n\nconst revalidateEntityPaths = (entityType: EntityType, entityId: string) => {\n\tconst basePath = getPathForEntity(entityType);\n\tif (basePath) {\n\t\trevalidatePath(`/dashboard/${basePath}/${entityId}`);\n\t\trevalidatePath(`/dashboard/${basePath}`);\n\t}\n\n\trevalidatePath(\"/dashboard\");\n};\n","\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notifyPaymentReceived } from \"@/lib/notifications/triggers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport {\n\ttype PaymentInsert,\n\ttype PaymentUpdate,\n\tpaymentInsertSchema,\n\tpaymentUpdateSchema,\n} from \"@/lib/validations/database-schemas\";\n\n/**\n * Server Actions for Payment Management\n *\n * Handles payment transactions with:\n * - Server-side validation using Zod\n * - Supabase database operations\n * - Refund support\n * - Reconciliation tracking\n * - Company-based multi-tenancy via RLS\n */\n\n// ============================================================================\n// CREATE\n// ============================================================================\n\ntype CreatePaymentResult = {\n\tsuccess: boolean;\n\terror?: string;\n\tpaymentId?: string;\n};\n\nexport async function createPayment(\n\tinput: PaymentInsert | FormData,\n): Promise<CreatePaymentResult> {\n\tif (input instanceof FormData) {\n\t\treturn createPaymentFromForm(input);\n\t}\n\n\treturn createPaymentWithData(input);\n}\n\nasync function createPaymentWithData(\n\tdata: PaymentInsert,\n\texistingSupabase?: Awaited<ReturnType<typeof createClient>> | null,\n): Promise<CreatePaymentResult> {\n\ttry {\n\t\tconst validated = paymentInsertSchema.parse(data);\n\t\tconst supabase = existingSupabase ?? (await createClient());\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { data: payment, error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.insert(validated)\n\t\t\t.select(\"id, amount, company_id, customer_id, invoice_id\")\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\t// Fetch customer info for notification\n\t\tconst { data: customer } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"name\")\n\t\t\t.eq(\"id\", payment.customer_id)\n\t\t\t.single();\n\n\t\t// Get company owner/managers to notify about payment\n\t\tconst { data: companyUsers } = await supabase\n\t\t\t.from(\"company_memberships\")\n\t\t\t.select(\"user_id\")\n\t\t\t.eq(\"company_id\", payment.company_id)\n\t\t\t.eq(\"status\", \"active\")\n\t\t\t.limit(5);\n\n\t\t// PERFORMANCE OPTIMIZED: Pattern #4 Fix - Batch notification inserts\n\t\t// BEFORE: 5 sequential INSERT queries (1 per team member)\n\t\t// AFTER: 1 batch INSERT query\n\t\t// Performance gain: ~3 seconds saved (80% reduction)\n\n\t\t// Send notification to company users about payment received\n\t\tif (customer && companyUsers && companyUsers.length > 0) {\n\t\t\tconst notifications = companyUsers.map((teamMember) => ({\n\t\t\t\tuser_id: teamMember.user_id,\n\t\t\t\tcompany_id: payment.company_id,\n\t\t\t\ttype: \"payment\",\n\t\t\t\ttitle: \"Payment Received\",\n\t\t\t\tmessage: `Payment of $${(payment.amount / 100).toFixed(2)} received from ${customer.name}`,\n\t\t\t\tpriority: \"high\",\n\t\t\t\taction_url: \"/dashboard/finance/invoices\",\n\t\t\t\taction_label: \"View Invoice\",\n\t\t\t\tmetadata: {\n\t\t\t\t\tpayment_id: payment.id,\n\t\t\t\t\tcustomer_id: payment.customer_id,\n\t\t\t\t\tinvoice_id: payment.invoice_id,\n\t\t\t\t\tamount: payment.amount,\n\t\t\t\t},\n\t\t\t\tis_read: false,\n\t\t\t\tis_archived: false,\n\t\t\t}));\n\n\t\t\t// Batch insert all notifications\n\t\t\tawait supabase.from(\"notifications\").insert(notifications);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\treturn { success: true, paymentId: payment.id };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to create payment\" };\n\t}\n}\n\nasync function createPaymentFromForm(\n\tformData: FormData,\n): Promise<CreatePaymentResult> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst invoiceId = formData.get(\"invoiceId\")?.toString();\n\t\tif (!invoiceId) {\n\t\t\treturn { success: false, error: \"Invoice is required\" };\n\t\t}\n\n\t\tconst rawAmount = formData.get(\"amount\");\n\t\tconst amountNumber = Number.parseFloat(rawAmount as string);\n\t\tif (!Number.isFinite(amountNumber) || amountNumber <= 0) {\n\t\t\treturn { success: false, error: \"Payment amount must be greater than 0\" };\n\t\t}\n\t\tconst amount = Math.round(amountNumber * 100);\n\n\t\tconst { data: invoice, error: invoiceError } = await supabase\n\t\t\t.from(\"invoices\")\n\t\t\t.select(\"id, company_id, customer_id, job_id, invoice_number, currency\")\n\t\t\t.eq(\"id\", invoiceId)\n\t\t\t.single();\n\n\t\tif (invoiceError || !invoice) {\n\t\t\treturn { success: false, error: \"Invoice not found\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tconst paymentMethod =\n\t\t\t(formData.get(\"paymentMethod\") as PaymentInsert[\"payment_method\"]) ||\n\t\t\t\"cash\";\n\t\tconst paymentDateValue = formData.get(\"paymentDate\")?.toString();\n\t\tconst checkNumber = formData.get(\"checkNumber\")?.toString() || null;\n\t\tconst notes = formData.get(\"notes\")?.toString() || null;\n\n\t\tconst paymentNumber = `PAY-${Date.now()}`;\n\n\t\tconst paymentData: PaymentInsert = {\n\t\t\tcompany_id: invoice.company_id,\n\t\t\tcustomer_id: invoice.customer_id,\n\t\t\tinvoice_id: invoice.id,\n\t\t\tjob_id: invoice.job_id ?? null,\n\t\t\tpayment_number: paymentNumber,\n\t\t\tamount,\n\t\t\tcurrency: (invoice.currency || \"USD\") as PaymentInsert[\"currency\"],\n\t\t\tpayment_method: paymentMethod,\n\t\t\tpayment_type: \"payment\",\n\t\t\tstatus: \"completed\",\n\t\t\tcheck_number: checkNumber,\n\t\t\tnotes,\n\t\t\tnet_amount: amount,\n\t\t\tprocessor_fee: 0,\n\t\t\trefunded_amount: 0,\n\t\t\tis_reconciled: false,\n\t\t\tprocessed_at: paymentDateValue ? new Date(paymentDateValue) : new Date(),\n\t\t\tprocessed_by: user?.id ?? null,\n\t\t};\n\n\t\treturn createPaymentWithData(paymentData, supabase);\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to create payment\" };\n\t}\n}\n\n// ============================================================================\n// READ\n// ============================================================================\n\nasync function getPayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string; payment?: any }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { data: payment, error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"*, customer:customers(*), invoice:invoices(*)\")\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, payment };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to get payment\" };\n\t}\n}\n\nasync function getPayments(filters?: {\n\tpaymentMethod?: string;\n\tstatus?: string;\n\tcustomerId?: string;\n\tisReconciled?: boolean;\n\tdateFrom?: string;\n\tdateTo?: string;\n}): Promise<{ success: boolean; error?: string; payments?: any[] }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tlet query = supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"*, customer:customers(first_name, last_name, email)\")\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.order(\"created_at\", { ascending: false });\n\n\t\t// Apply filters\n\t\tif (filters?.paymentMethod && filters.paymentMethod !== \"all\") {\n\t\t\tquery = query.eq(\"payment_method\", filters.paymentMethod);\n\t\t}\n\t\tif (filters?.status && filters.status !== \"all\") {\n\t\t\tquery = query.eq(\"status\", filters.status);\n\t\t}\n\t\tif (filters?.customerId) {\n\t\t\tquery = query.eq(\"customer_id\", filters.customerId);\n\t\t}\n\t\tif (filters?.isReconciled !== undefined) {\n\t\t\tquery = query.eq(\"is_reconciled\", filters.isReconciled);\n\t\t}\n\t\tif (filters?.dateFrom) {\n\t\t\tquery = query.gte(\"created_at\", filters.dateFrom);\n\t\t}\n\t\tif (filters?.dateTo) {\n\t\t\tquery = query.lte(\"created_at\", filters.dateTo);\n\t\t}\n\n\t\tconst { data: payments, error } = await query;\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\treturn { success: true, payments };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to get payments\" };\n\t}\n}\n\n// ============================================================================\n// UPDATE\n// ============================================================================\n\nasync function updatePayment(\n\tpaymentId: string,\n\tdata: PaymentUpdate,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst validated = paymentUpdateSchema.parse(data);\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update(validated)\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.is(\"deleted_at\", null);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to update payment\" };\n\t}\n}\n\n// ============================================================================\n// REFUND\n// ============================================================================\n\nasync function refundPayment(\n\tpaymentId: string,\n\trefundAmount: number,\n\trefundReason?: string,\n): Promise<{ success: boolean; error?: string; refundId?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\t// Get original payment\n\t\tconst { data: originalPayment, error: fetchError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.single();\n\n\t\tif (fetchError || !originalPayment) {\n\t\t\treturn { success: false, error: \"Payment not found\" };\n\t\t}\n\n\t\t// Validate refund amount\n\t\tconst alreadyRefunded = originalPayment.refunded_amount || 0;\n\t\tconst maxRefundable = originalPayment.amount - alreadyRefunded;\n\n\t\tif (refundAmount > maxRefundable) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: `Cannot refund more than ${maxRefundable / 100} (already refunded ${alreadyRefunded / 100})`,\n\t\t\t};\n\t\t}\n\n\t\t// Create refund record\n\t\tconst refundData = {\n\t\t\tcompany_id: originalPayment.company_id,\n\t\t\tcustomer_id: originalPayment.customer_id,\n\t\t\tinvoice_id: originalPayment.invoice_id,\n\t\t\tpayment_number: `REFUND-${originalPayment.payment_number}`,\n\t\t\tamount: refundAmount,\n\t\t\tcurrency: originalPayment.currency,\n\t\t\tpayment_method: originalPayment.payment_method,\n\t\t\tpayment_type: \"refund\",\n\t\t\tstatus: \"completed\",\n\t\t\toriginal_payment_id: paymentId,\n\t\t\trefund_reason: refundReason,\n\t\t\tprocessed_at: new Date().toISOString(),\n\t\t};\n\n\t\tconst { data: refund, error: refundError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.insert(refundData)\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (refundError) {\n\t\t\treturn { success: false, error: refundError.message };\n\t\t}\n\n\t\t// Update original payment\n\t\tconst newRefundedAmount = alreadyRefunded + refundAmount;\n\t\tconst newStatus =\n\t\t\tnewRefundedAmount === originalPayment.amount\n\t\t\t\t? \"refunded\"\n\t\t\t\t: \"partially_refunded\";\n\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\trefunded_amount: newRefundedAmount,\n\t\t\t\tstatus: newStatus,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (updateError) {\n\t\t\treturn { success: false, error: updateError.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true, refundId: refund.id };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to refund payment\" };\n\t}\n}\n\n// ============================================================================\n// RECONCILIATION\n// ============================================================================\n\nasync function reconcilePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\tis_reconciled: true,\n\t\t\t\treconciled_at: new Date().toISOString(),\n\t\t\t\treconciled_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to reconcile payment\" };\n\t}\n}\n\nasync function unreconcilePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\tis_reconciled: false,\n\t\t\t\treconciled_at: null,\n\t\t\t\treconciled_by: null,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(`/dashboard/finance/payments/${paymentId}`);\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to unreconcile payment\" };\n\t}\n}\n\n// ============================================================================\n// DELETE\n// ============================================================================\n\nasync function deletePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\n\t\tif (!user) {\n\t\t\treturn { success: false, error: \"Unauthorized\" };\n\t\t}\n\n\t\tconst { error } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: new Date().toISOString(),\n\t\t\t\tdeleted_by: user.id,\n\t\t\t})\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/finance/payments\");\n\t\trevalidatePath(\"/dashboard/work/payments\");\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to delete payment\" };\n\t}\n}\n\n/**\n * Archive payment (alias for deletePayment - uses soft delete)\n */\nexport async function archivePayment(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\treturn deletePayment(paymentId);\n}\n\n/**\n * Unlink payment from job\n * Removes the job association (sets job_id to NULL)\n * Bidirectional operation - updates both payment and job views\n */\nexport async function unlinkPaymentFromJob(\n\tpaymentId: string,\n): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\n\t\tif (!supabase) {\n\t\t\treturn { success: false, error: \"Database connection not available\" };\n\t\t}\n\n\t\t// Get current payment to verify exists and get job_id for revalidation\n\t\tconst { data: payment, error: fetchError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", paymentId)\n\t\t\t.is(\"deleted_at\", null)\n\t\t\t.single();\n\n\t\tif (fetchError || !payment) {\n\t\t\treturn { success: false, error: \"Payment not found\" };\n\t\t}\n\n\t\tconst previousJobId = payment.job_id;\n\n\t\t// Unlink payment from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"payments\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", paymentId);\n\n\t\tif (unlinkError) {\n\t\t\treturn { success: false, error: unlinkError.message };\n\t\t}\n\n\t\t// Revalidate both pages\n\t\trevalidatePath(`/dashboard/work/payments/${paymentId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/payments\");\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn { success: false, error: error.message };\n\t\t}\n\t\treturn { success: false, error: \"Failed to unlink payment from job\" };\n\t}\n}\n","/**\n * Job Tags Actions - Server Actions\n * Handle tag management for jobs and customers\n * Supports both legacy string tags and new object tags with colors\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { withErrorHandling } from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport type TagWithColor = {\n\tlabel: string;\n\tcolor?: string;\n};\n\nexport type Tag = string | TagWithColor;\n\n/**\n * Update job tags\n */\nexport async function updateJobTags(jobId: string, tags: Tag[]) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\t// Update job metadata with tags\n\t\tconst { error } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.update({\n\t\t\t\tmetadata: {\n\t\t\t\t\ttags,\n\t\t\t\t},\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", jobId);\n\n\t\tif (error) {\n\t\t\tthrow new Error(`Failed to update job tags: ${error.message}`);\n\t\t}\n\n\t\trevalidatePath(`/dashboard/work/${jobId}`);\n\t\trevalidatePath(\"/dashboard/work\");\n\n\t\treturn { jobId, tags };\n\t});\n}\n\n/**\n * Update customer tags\n */\nexport async function updateCustomerTags(customerId: string, tags: Tag[]) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\t// Update customer tags\n\t\tconst { error } = await supabase\n\t\t\t.from(\"customers\")\n\t\t\t.update({\n\t\t\t\ttags,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", customerId);\n\n\t\tif (error) {\n\t\t\tthrow new Error(`Failed to update customer tags: ${error.message}`);\n\t\t}\n\n\t\t// Revalidate all pages that might show this customer\n\t\trevalidatePath(`/dashboard/customers/${customerId}`);\n\t\trevalidatePath(\"/dashboard/customers\");\n\t\trevalidatePath(\"/dashboard/work\");\n\n\t\treturn { customerId, tags };\n\t});\n}\n\nconst COMMON_TAGS_LIMIT = 20;\n\n/**\n * Get commonly used tags for a company\n */\nasync function getCommonTags(companyId: string) {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new Error(\"Database connection not available\");\n\t\t}\n\n\t\tconst user = await getAuthenticatedUserId(supabase);\n\t\tif (!user) {\n\t\t\tthrow new Error(\"Not authenticated\");\n\t\t}\n\n\t\tconst { customers, jobs } = await fetchTagSources(supabase, companyId);\n\t\tconst tagCounts = aggregateTagCounts(customers, jobs);\n\n\t\treturn getTopTags(tagCounts, COMMON_TAGS_LIMIT);\n\t});\n}\n\ntype SupabaseClientType = Awaited<ReturnType<typeof createClient>>;\n\nasync function getAuthenticatedUserId(\n\tsupabase: SupabaseClientType,\n): Promise<string | null> {\n\tconst {\n\t\tdata: { user },\n\t} = await supabase.auth.getUser();\n\treturn user?.id ?? null;\n}\n\nasync function fetchTagSources(\n\tsupabase: SupabaseClientType,\n\tcompanyId: string,\n): Promise<{\n\tcustomers: { tags: unknown }[] | null;\n\tjobs: { metadata: unknown }[] | null;\n}> {\n\tconst [{ data: customers }, { data: jobs }] = await Promise.all([\n\t\tsupabase\n\t\t\t.from(\"customers\")\n\t\t\t.select(\"tags\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.not(\"tags\", \"is\", null),\n\t\tsupabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"metadata\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.not(\"metadata\", \"is\", null),\n\t]);\n\n\treturn { customers: customers ?? null, jobs: jobs ?? null };\n}\n\nfunction aggregateTagCounts(\n\tcustomers: { tags: unknown }[] | null,\n\tjobs: { metadata: unknown }[] | null,\n): Record<string, number> {\n\tconst tagCounts: Record<string, number> = {};\n\n\taccumulateCustomerTagCounts(customers, tagCounts);\n\taccumulateJobTagCounts(jobs, tagCounts);\n\n\treturn tagCounts;\n}\n\nfunction accumulateCustomerTagCounts(\n\tcustomers: { tags: unknown }[] | null,\n\ttagCounts: Record<string, number>,\n) {\n\tif (!customers) {\n\t\treturn;\n\t}\n\n\tfor (const customer of customers) {\n\t\tconst customerTags = customer.tags as string[] | null;\n\t\tif (!customerTags) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (const tag of customerTags) {\n\t\t\ttagCounts[tag] = (tagCounts[tag] || 0) + 1;\n\t\t}\n\t}\n}\n\nfunction accumulateJobTagCounts(\n\tjobs: { metadata: unknown }[] | null,\n\ttagCounts: Record<string, number>,\n) {\n\tif (!jobs) {\n\t\treturn;\n\t}\n\n\tfor (const job of jobs) {\n\t\tconst metadata = job.metadata as { tags?: string[] } | null;\n\t\tconst jobTags = metadata?.tags;\n\t\tif (!jobTags) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (const tag of jobTags) {\n\t\t\ttagCounts[tag] = (tagCounts[tag] || 0) + 1;\n\t\t}\n\t}\n}\n\nfunction getTopTags(\n\ttagCounts: Record<string, number>,\n\tlimit: number,\n): string[] {\n\treturn Object.entries(tagCounts)\n\t\t.sort(([, a], [, b]) => b - a)\n\t\t.slice(0, limit)\n\t\t.map(([tag]) => tag);\n}\n"],"names":[],"mappings":"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"}