{"version":3,"sources":["../../../../../../apps/web/src/actions/estimates.ts"],"sourcesContent":["/**\n * Estimates Server Actions\n *\n * Handles estimate/quote management with CRUD operations, status transitions,\n * customer interactions, and conversion to jobs.\n */\n\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport {\n\tActionError,\n\tERROR_CODES,\n\tERROR_MESSAGES,\n} from \"@/lib/errors/action-error\";\nimport {\n\ttype ActionResult,\n\tassertAuthenticated,\n\tassertExists,\n\tassertSupabase,\n\twithErrorHandling,\n} from \"@/lib/errors/with-error-handling\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { sendEstimateEmail } from \"./invoice-communications\";\n\n// Validation Schemas\nconst MIN_LINE_ITEM_QUANTITY = 0.01;\nconst MAX_TAX_RATE_PERCENT = 100;\nconst DEFAULT_VALID_DAYS = 30;\nconst ESTIMATE_NUMBER_PADDING_LENGTH = 3;\nconst JOB_NUMBER_PADDING_LENGTH = 3;\nconst PERCENT_DENOMINATOR = 100;\nconst CENTS_PER_DOLLAR = 100;\nconst HTTP_STATUS_FORBIDDEN = 403;\nconst ARCHIVE_RETENTION_DAYS = 90;\nconst SECONDS_PER_DAY = 24 * 60 * 60;\nconst MS_TO_SECONDS = 1000;\nconst MS_PER_DAY = SECONDS_PER_DAY * MS_TO_SECONDS;\n\nconst ESTIMATE_NUMBER_REGEX = /EST-\\d{4}-(\\d+)/;\nconst JOB_NUMBER_REGEX = /JOB-\\d{4}-(\\d+)/;\n\nconst lineItemSchema = z.object({\n\tdescription: z.string().min(1, \"Description is required\"),\n\tquantity: z\n\t\t.number()\n\t\t.min(MIN_LINE_ITEM_QUANTITY, \"Quantity must be greater than 0\"),\n\tunitPrice: z.number().min(0, \"Price must be positive\"),\n\ttotal: z.number().min(0, \"Total must be positive\"),\n});\n\nconst createEstimateSchema = z.object({\n\tcustomerId: z.string().uuid(\"Invalid customer ID\"),\n\tpropertyId: z.string().uuid(\"Invalid property ID\").optional(),\n\ttitle: z.string().min(1, \"Estimate title is required\"),\n\tdescription: z.string().optional(),\n\tlineItems: z\n\t\t.array(lineItemSchema)\n\t\t.min(1, \"At least one line item is required\"),\n\ttaxRate: z.number().min(0).max(MAX_TAX_RATE_PERCENT).default(0),\n\tdiscountAmount: z.number().min(0).default(0),\n\tvalidDays: z.number().min(1).default(DEFAULT_VALID_DAYS),\n\tterms: z.string().optional(),\n\tnotes: z.string().optional(),\n});\n\nconst updateEstimateSchema = z.object({\n\ttitle: z.string().min(1, \"Estimate title is required\").optional(),\n\tdescription: z.string().optional(),\n\tlineItems: z.array(lineItemSchema).optional(),\n\ttaxRate: z.number().min(0).max(MAX_TAX_RATE_PERCENT).optional(),\n\tdiscountAmount: z.number().min(0).optional(),\n\tvalidDays: z.number().min(1).optional(),\n\tterms: z.string().optional(),\n\tnotes: z.string().optional(),\n});\n\n/**\n * Generate unique estimate number\n */\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nasync function generateEstimateNumber(\n\tsupabase: SupabaseClient,\n\tcompanyId: string,\n): Promise<string> {\n\tconst { data: latestEstimate } = await supabase\n\t\t.from(\"estimates\")\n\t\t.select(\"estimate_number\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false })\n\t\t.limit(1)\n\t\t.single();\n\n\tif (!latestEstimate) {\n\t\treturn `EST-${new Date().getFullYear()}-001`;\n\t}\n\n\tconst match = latestEstimate.estimate_number.match(ESTIMATE_NUMBER_REGEX);\n\tif (match) {\n\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\treturn `EST-${new Date().getFullYear()}-${nextNumber.toString().padStart(ESTIMATE_NUMBER_PADDING_LENGTH, \"0\")}`;\n\t}\n\n\treturn `EST-${new Date().getFullYear()}-${Date.now().toString().slice(-ESTIMATE_NUMBER_PADDING_LENGTH)}`;\n}\n\n/**\n * Calculate estimate totals\n */\nfunction calculateTotals(\n\tlineItems: { total: number }[],\n\ttaxRate: number,\n\tdiscountAmount: number,\n) {\n\tconst subtotal = lineItems.reduce((sum, item) => sum + item.total, 0);\n\tconst taxAmount = Math.round((subtotal * taxRate) / PERCENT_DENOMINATOR);\n\tconst totalAmount = subtotal + taxAmount - discountAmount;\n\n\treturn {\n\t\tsubtotal: Math.round(subtotal * CENTS_PER_DOLLAR), // Convert to cents\n\t\ttaxAmount: Math.round(taxAmount * CENTS_PER_DOLLAR),\n\t\tdiscountAmount: Math.round(discountAmount * CENTS_PER_DOLLAR),\n\t\ttotalAmount: Math.round(totalAmount * CENTS_PER_DOLLAR),\n\t};\n}\n\n/**\n * Create a new estimate\n */\nasync function createEstimate(\n\tformData: FormData,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await requireEstimateCompanyId(supabase, user.id);\n\t\tconst lineItems = parseEstimateLineItems(formData.get(\"lineItems\")) || [];\n\t\tconst data = parseCreateEstimateFormData(formData, lineItems);\n\n\t\tconst totals = calculateTotals(\n\t\t\tdata.lineItems,\n\t\t\tdata.taxRate,\n\t\t\tdata.discountAmount,\n\t\t);\n\n\t\tconst validUntilIso = calculateValidUntilIso(data.validDays);\n\t\tconst estimateNumber = await generateEstimateNumber(supabase, companyId);\n\n\t\tconst insertPayload = buildCreateEstimateInsertPayload({\n\t\t\tcompanyId,\n\t\t\tdata,\n\t\t\ttotals,\n\t\t\tvalidUntilIso,\n\t\t\testimateNumber,\n\t\t});\n\n\t\tconst { data: newEstimate, error: createError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.insert(insertPayload)\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\treturn newEstimate.id;\n\t});\n}\n\n/**\n * Update an estimate\n */\nasync function updateEstimate(\n\testimateId: string,\n\tformData: FormData,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await requireEstimateCompanyId(supabase, user.id);\n\t\tconst existingEstimate = await getEstimateForCompanyOrThrow(\n\t\t\tsupabase,\n\t\t\testimateId,\n\t\t\tcompanyId,\n\t\t);\n\n\t\tif (existingEstimate.status !== \"draft\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only draft estimates can be edited\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\tconst lineItems = parseEstimateLineItems(formData.get(\"lineItems\"), true);\n\t\tconst data = parseUpdateEstimateFormData(formData, lineItems);\n\n\t\tconst updateData = buildUpdateEstimatePayload(data);\n\n\t\t// Update estimate\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update(updateData)\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"update estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(`/dashboard/work/estimates/${estimateId}`);\n\t});\n}\n\ntype CreateEstimateParsed = z.infer<typeof createEstimateSchema>;\ntype UpdateEstimateParsed = z.infer<typeof updateEstimateSchema>;\n\nasync function requireEstimateCompanyId(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\tuserId: string,\n): Promise<string> {\n\tconst { data: teamMember } = await supabase\n\t\t.from(\"company_memberships\")\n\t\t.select(\"company_id\")\n\t\t.eq(\"user_id\", userId)\n\t\t.single();\n\n\tif (!teamMember?.company_id) {\n\t\tthrow new ActionError(\n\t\t\t\"You must be part of a company\",\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn teamMember.company_id;\n}\n\nfunction parseEstimateLineItems(\n\tvalue: FormDataEntryValue | null,\n\toptional = false,\n): { total: number }[] | undefined {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn optional ? undefined : [];\n\t}\n\n\ttry {\n\t\treturn JSON.parse(value) as { total: number }[];\n\t} catch {\n\t\tthrow new ActionError(\n\t\t\t\"Invalid line items data\",\n\t\t\tERROR_CODES.VALIDATION_FAILED,\n\t\t);\n\t}\n}\n\nfunction parseCreateEstimateFormData(\n\tformData: FormData,\n\tlineItems: { total: number }[],\n): CreateEstimateParsed {\n\treturn createEstimateSchema.parse({\n\t\tcustomerId: formData.get(\"customerId\"),\n\t\tpropertyId: formData.get(\"propertyId\") || undefined,\n\t\ttitle: formData.get(\"title\"),\n\t\tdescription: formData.get(\"description\") || undefined,\n\t\tlineItems,\n\t\ttaxRate: formData.get(\"taxRate\")\n\t\t\t? Number.parseFloat(formData.get(\"taxRate\") as string)\n\t\t\t: 0,\n\t\tdiscountAmount: formData.get(\"discountAmount\")\n\t\t\t? Number.parseFloat(formData.get(\"discountAmount\") as string)\n\t\t\t: 0,\n\t\tvalidDays: formData.get(\"validDays\")\n\t\t\t? Number.parseInt(formData.get(\"validDays\") as string, 10)\n\t\t\t: DEFAULT_VALID_DAYS,\n\t\tterms: formData.get(\"terms\") || undefined,\n\t\tnotes: formData.get(\"notes\") || undefined,\n\t});\n}\n\nfunction calculateValidUntilIso(validDays: number): string {\n\tconst validUntil = new Date();\n\tvalidUntil.setDate(validUntil.getDate() + validDays);\n\treturn validUntil.toISOString();\n}\n\ntype CreateEstimateInsertParams = {\n\tcompanyId: string;\n\tdata: CreateEstimateParsed;\n\ttotals: ReturnType<typeof calculateTotals>;\n\tvalidUntilIso: string;\n\testimateNumber: string;\n};\n\nfunction buildCreateEstimateInsertPayload(\n\tparams: CreateEstimateInsertParams,\n): Record<string, unknown> {\n\tconst { companyId, data, totals, validUntilIso, estimateNumber } = params;\n\n\treturn {\n\t\tcompany_id: companyId,\n\t\tcustomer_id: data.customerId,\n\t\tproperty_id: data.propertyId,\n\t\testimate_number: estimateNumber,\n\t\ttitle: data.title,\n\t\tdescription: data.description,\n\t\tstatus: \"draft\",\n\t\tsubtotal: totals.subtotal,\n\t\ttax_amount: totals.taxAmount,\n\t\tdiscount_amount: totals.discountAmount,\n\t\ttotal_amount: totals.totalAmount,\n\t\tvalid_until: validUntilIso,\n\t\tline_items: data.lineItems,\n\t\tterms: data.terms,\n\t\tnotes: data.notes,\n\t};\n}\n\nasync function getEstimateForCompanyOrThrow(\n\tsupabase: NonNullable<Awaited<ReturnType<typeof createClient>>>,\n\testimateId: string,\n\tcompanyId: string,\n) {\n\tconst { data: existingEstimate } = await supabase\n\t\t.from(\"estimates\")\n\t\t.select(\"company_id, status\")\n\t\t.eq(\"id\", estimateId)\n\t\t.single();\n\n\tassertExists(existingEstimate, \"Estimate\");\n\n\tif (existingEstimate.company_id !== companyId) {\n\t\tthrow new ActionError(\n\t\t\tERROR_MESSAGES.forbidden(\"estimate\"),\n\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t);\n\t}\n\n\treturn existingEstimate;\n}\n\nfunction parseUpdateEstimateFormData(\n\tformData: FormData,\n\tlineItems: { total: number }[] | undefined,\n): UpdateEstimateParsed {\n\treturn updateEstimateSchema.parse({\n\t\ttitle: formData.get(\"title\") || undefined,\n\t\tdescription: formData.get(\"description\") || undefined,\n\t\tlineItems,\n\t\ttaxRate: formData.get(\"taxRate\")\n\t\t\t? Number.parseFloat(formData.get(\"taxRate\") as string)\n\t\t\t: undefined,\n\t\tdiscountAmount: formData.get(\"discountAmount\")\n\t\t\t? Number.parseFloat(formData.get(\"discountAmount\") as string)\n\t\t\t: undefined,\n\t\tvalidDays: formData.get(\"validDays\")\n\t\t\t? Number.parseInt(formData.get(\"validDays\") as string, 10)\n\t\t\t: undefined,\n\t\tterms: formData.get(\"terms\") || undefined,\n\t\tnotes: formData.get(\"notes\") || undefined,\n\t});\n}\n\nfunction buildUpdateEstimatePayload(\n\tdata: UpdateEstimateParsed,\n): Record<string, unknown> {\n\tconst updateData: Record<string, unknown> = {};\n\tif (data.title) {\n\t\tupdateData.title = data.title;\n\t}\n\tif (data.description !== undefined) {\n\t\tupdateData.description = data.description;\n\t}\n\tif (data.terms !== undefined) {\n\t\tupdateData.terms = data.terms;\n\t}\n\tif (data.notes !== undefined) {\n\t\tupdateData.notes = data.notes;\n\t}\n\n\tif (data.lineItems) {\n\t\tconst taxRate = data.taxRate ?? 0;\n\t\tconst discountAmount = data.discountAmount ?? 0;\n\t\tconst totals = calculateTotals(data.lineItems, taxRate, discountAmount);\n\n\t\tupdateData.line_items = data.lineItems;\n\t\tupdateData.subtotal = totals.subtotal;\n\t\tupdateData.tax_amount = totals.taxAmount;\n\t\tupdateData.discount_amount = totals.discountAmount;\n\t\tupdateData.total_amount = totals.totalAmount;\n\t}\n\n\tif (data.validDays) {\n\t\tupdateData.valid_until = calculateValidUntilIso(data.validDays);\n\t}\n\n\treturn updateData;\n}\n\n/**\n * Send estimate to customer\n */\nasync function sendEstimate(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await requireEstimateCompanyId(supabase, user.id);\n\n\t\t// Verify estimate belongs to company\n\t\tconst { data: existingEstimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"company_id, status, customer_id\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(existingEstimate, \"Estimate\");\n\n\t\tif (existingEstimate.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"estimate\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Can only send draft or rejected estimates\n\t\tif (\n\t\t\texistingEstimate.status !== \"draft\" &&\n\t\t\texistingEstimate.status !== \"rejected\"\n\t\t) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Estimate has already been sent\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Send email to customer with estimate PDF\n\t\tconst emailResult = await sendEstimateEmail(estimateId);\n\t\tif (!emailResult.success) {\n\t\t\tconsole.error(\"Failed to send estimate email:\", emailResult.error);\n\t\t\t// Continue with status update even if email fails - don't block the workflow\n\t\t}\n\n\t\t// Update status to sent\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({\n\t\t\t\tstatus: \"sent\",\n\t\t\t\tsent_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"send estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(`/dashboard/work/estimates/${estimateId}`);\n\t});\n}\n\n/**\n * Mark estimate as viewed (customer opened it)\n */\nasync function markEstimateViewed(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// This can be called publicly by customer, so no auth check\n\t\t// Just verify estimate exists\n\t\tconst { data: estimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"status, viewed_at\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(estimate, \"Estimate\");\n\n\t\t// Only mark as viewed if sent and not already viewed\n\t\tif (estimate.status === \"sent\" && !estimate.viewed_at) {\n\t\t\tconst { error: updateError } = await supabase\n\t\t\t\t.from(\"estimates\")\n\t\t\t\t.update({\n\t\t\t\t\tstatus: \"viewed\",\n\t\t\t\t\tviewed_at: new Date().toISOString(),\n\t\t\t\t})\n\t\t\t\t.eq(\"id\", estimateId);\n\n\t\t\tif (updateError) {\n\t\t\t\tthrow new ActionError(\n\t\t\t\t\tERROR_MESSAGES.operationFailed(\"mark estimate as viewed\"),\n\t\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(`/dashboard/work/estimates/${estimateId}`);\n\t});\n}\n\n/**\n * Accept estimate (customer approval)\n */\nasync function acceptEstimate(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Verify estimate exists and can be accepted\n\t\tconst { data: estimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"status, valid_until\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(estimate, \"Estimate\");\n\n\t\t// Can only accept sent or viewed estimates\n\t\tif (estimate.status !== \"sent\" && estimate.status !== \"viewed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Estimate cannot be accepted\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Check if estimate is expired\n\t\tif (estimate.valid_until && new Date(estimate.valid_until) < new Date()) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Estimate has expired\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Update status to accepted\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({\n\t\t\t\tstatus: \"accepted\",\n\t\t\t\taccepted_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"accept estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(`/dashboard/work/estimates/${estimateId}`);\n\t});\n}\n\n/**\n * Reject estimate (customer rejection)\n */\nasync function rejectEstimate(\n\testimateId: string,\n\treason?: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Verify estimate exists\n\t\tconst { data: estimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"status, notes\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(estimate, \"Estimate\");\n\n\t\t// Can only reject sent or viewed estimates\n\t\tif (estimate.status !== \"sent\" && estimate.status !== \"viewed\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Estimate cannot be rejected\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Add rejection reason to notes\n\t\tconst updatedNotes = reason\n\t\t\t? `${estimate.notes || \"\"}\\n\\n[REJECTED]: ${reason}`.trim()\n\t\t\t: estimate.notes;\n\n\t\t// Update status to rejected\n\t\tconst { error: updateError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\tnotes: updatedNotes,\n\t\t\t})\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (updateError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"reject estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(`/dashboard/work/estimates/${estimateId}`);\n\t});\n}\n\n/**\n * Convert estimate to job\n */\nasync function convertEstimateToJob(\n\testimateId: string,\n): Promise<ActionResult<string>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await requireEstimateCompanyId(supabase, user.id);\n\n\t\t// Get estimate\n\t\tconst { data: estimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\n\t\t\t\t\"company_id, customer_id, property_id, title, description, total_amount, status\",\n\t\t\t)\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(estimate, \"Estimate\");\n\n\t\tif (estimate.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"estimate\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Only accepted estimates can be converted\n\t\tif (estimate.status !== \"accepted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Only accepted estimates can be converted to jobs\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Generate job number\n\t\tconst { data: latestJob } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.select(\"job_number\")\n\t\t\t.eq(\"company_id\", companyId)\n\t\t\t.order(\"created_at\", { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.single();\n\n\t\tlet jobNumber: string;\n\t\tif (latestJob) {\n\t\t\tconst match = latestJob.job_number.match(JOB_NUMBER_REGEX);\n\t\t\tif (match) {\n\t\t\t\tconst nextNumber = Number.parseInt(match[1], 10) + 1;\n\t\t\t\tjobNumber = `JOB-${new Date().getFullYear()}-${nextNumber.toString().padStart(JOB_NUMBER_PADDING_LENGTH, \"0\")}`;\n\t\t\t} else {\n\t\t\t\tjobNumber = `JOB-${new Date().getFullYear()}-${Date.now().toString().slice(-JOB_NUMBER_PADDING_LENGTH)}`;\n\t\t\t}\n\t\t} else {\n\t\t\tjobNumber = `JOB-${new Date().getFullYear()}-001`;\n\t\t}\n\n\t\t// Create job from estimate\n\t\t// NOTE: Job must be created first (core table), then financial domain record created separately\n\t\tconst { data: newJob, error: createError } = await supabase\n\t\t\t.from(\"jobs\")\n\t\t\t.insert({\n\t\t\t\tcompany_id: estimate.company_id,\n\t\t\t\tcustomer_id: estimate.customer_id,\n\t\t\t\tproperty_id: estimate.property_id,\n\t\t\t\tjob_number: jobNumber,\n\t\t\t\ttitle: estimate.title,\n\t\t\t\tdescription: estimate.description,\n\t\t\t\tstatus: \"scheduled\",\n\t\t\t\tpriority: \"medium\",\n\t\t\t})\n\t\t\t.select(\"id\")\n\t\t\t.single();\n\n\t\tif (!createError && newJob) {\n\t\t\t// Create financial domain record with total_amount from estimate\n\t\t\tawait supabase.from(\"job_financial\").insert({\n\t\t\t\tjob_id: newJob.id,\n\t\t\t\ttotal_amount: estimate.total_amount,\n\t\t\t\tpaid_amount: 0,\n\t\t\t});\n\t\t}\n\n\t\tif (createError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"create job from estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Link estimate to job\n\t\tconst { error: linkError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({ job_id: newJob.id })\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (linkError) {\n\t\t\t// Job created but linking failed - return error while keeping job\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"link estimate to job\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(\"/dashboard/work/jobs\");\n\t\treturn newJob.id;\n\t});\n}\n\n/**\n * Archive estimate (soft delete)\n *\n * Replaces deleteEstimate - now archives instead of permanently deleting.\n * Archived estimates can be restored within 90 days.\n */\nexport async function archiveEstimate(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await requireEstimateCompanyId(supabase, user.id);\n\n\t\t// Verify estimate belongs to company\n\t\tconst { data: estimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"company_id, status\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(estimate, \"Estimate\");\n\n\t\tif (estimate.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"estimate\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\t// Cannot archive accepted estimates (business rule)\n\t\tif (estimate.status === \"accepted\") {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Cannot archive accepted estimates. Accepted estimates must be retained for records.\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Archive estimate (soft delete)\n\t\tconst now = new Date().toISOString();\n\t\tconst scheduledDeletion = new Date(\n\t\t\tDate.now() + ARCHIVE_RETENTION_DAYS * MS_PER_DAY,\n\t\t).toISOString();\n\n\t\tconst { error: archiveError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: now,\n\t\t\t\tdeleted_by: user.id,\n\t\t\t\tarchived_at: now,\n\t\t\t\tpermanent_delete_scheduled_at: scheduledDeletion,\n\t\t\t\tstatus: \"archived\",\n\t\t\t})\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (archiveError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"archive estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Restore archived estimate\n */\nasync function restoreEstimate(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tif (!supabase) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Database connection failed\",\n\t\t\t\tERROR_CODES.DB_CONNECTION_ERROR,\n\t\t\t);\n\t\t}\n\n\t\tconst {\n\t\t\tdata: { user },\n\t\t} = await supabase.auth.getUser();\n\t\tassertAuthenticated(user?.id);\n\n\t\tconst companyId = await requireEstimateCompanyId(supabase, user.id);\n\n\t\t// Verify estimate belongs to company and is archived\n\t\tconst { data: estimate } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"company_id, deleted_at, status\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tassertExists(estimate, \"Estimate\");\n\n\t\tif (estimate.company_id !== companyId) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.forbidden(\"estimate\"),\n\t\t\t\tERROR_CODES.AUTH_FORBIDDEN,\n\t\t\t\tHTTP_STATUS_FORBIDDEN,\n\t\t\t);\n\t\t}\n\n\t\tif (!estimate.deleted_at) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Estimate is not archived\",\n\t\t\t\tERROR_CODES.OPERATION_NOT_ALLOWED,\n\t\t\t);\n\t\t}\n\n\t\t// Restore estimate\n\t\tconst { error: restoreError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({\n\t\t\t\tdeleted_at: null,\n\t\t\t\tdeleted_by: null,\n\t\t\t\tarchived_at: null,\n\t\t\t\tpermanent_delete_scheduled_at: null,\n\t\t\t\tstatus: estimate.status === \"archived\" ? \"draft\" : estimate.status,\n\t\t\t})\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (restoreError) {\n\t\t\tthrow new ActionError(\n\t\t\t\tERROR_MESSAGES.operationFailed(\"restore estimate\"),\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t\trevalidatePath(\"/dashboard/settings/archive\");\n\t});\n}\n\n/**\n * Unlink estimate from job\n * Removes the job association from the estimate (sets job_id to NULL)\n * This is a bidirectional operation - estimate no longer shows on job, job no longer shows on estimate\n */\nexport async function unlinkEstimateFromJob(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn withErrorHandling(async () => {\n\t\tconst supabase = await createClient();\n\t\tassertSupabase(supabase);\n\n\t\t// Get current estimate to verify it exists and get job_id for revalidation\n\t\tconst { data: estimate, error: fetchError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.select(\"id, job_id\")\n\t\t\t.eq(\"id\", estimateId)\n\t\t\t.single();\n\n\t\tif (fetchError || !estimate) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Estimate not found\",\n\t\t\t\tERROR_CODES.DB_RECORD_NOT_FOUND,\n\t\t\t);\n\t\t}\n\n\t\tconst previousJobId = estimate.job_id;\n\n\t\t// Unlink estimate from job (set job_id to NULL)\n\t\tconst { error: unlinkError } = await supabase\n\t\t\t.from(\"estimates\")\n\t\t\t.update({ job_id: null })\n\t\t\t.eq(\"id\", estimateId);\n\n\t\tif (unlinkError) {\n\t\t\tthrow new ActionError(\n\t\t\t\t\"Failed to unlink estimate from job\",\n\t\t\t\tERROR_CODES.DB_QUERY_ERROR,\n\t\t\t);\n\t\t}\n\n\t\t// Revalidate both the estimate and the job pages\n\t\trevalidatePath(`/dashboard/work/estimates/${estimateId}`);\n\t\tif (previousJobId) {\n\t\t\trevalidatePath(`/dashboard/work/${previousJobId}`);\n\t\t}\n\t\trevalidatePath(\"/dashboard/work/estimates\");\n\t});\n}\n\n/**\n * Unlink job from estimate (convenience wrapper)\n *\n * This is a convenience function that calls unlinkEstimateFromJob.\n * Provided for clearer naming when calling from the estimate detail page.\n * The implementation is the same - it removes the job_id from the estimate.\n *\n * @param estimateId - ID of the estimate to unlink from its job\n * @returns Promise<ActionResult<void>>\n */\nexport async function unlinkJobFromEstimate(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\t// Just call the main function - same implementation\n\treturn unlinkEstimateFromJob(estimateId);\n}\n\n/**\n * Delete estimate (legacy - deprecated)\n * @deprecated Use archiveEstimate() instead\n */\nasync function deleteEstimate(\n\testimateId: string,\n): Promise<ActionResult<void>> {\n\treturn archiveEstimate(estimateId);\n}\n"],"names":[],"mappings":"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"}