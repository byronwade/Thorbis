{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/supabase/admin-client.ts"],"sourcesContent":["import { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\n\n/**\n * Admin Database Client (Server-Side Only)\n *\n * This client connects to the ADMIN Supabase database (separate from web database).\n *\n * Database: Admin database (iwudmixxoozwskgolqlz)\n * Tables: admin_users, admin_sessions, companies_registry, support_tickets,\n *         email_campaigns, platform_settings, admin_audit_logs, waitlist\n *\n * ⚠️ SECURITY WARNING:\n * - ONLY use this on the server side (Server Components, Server Actions, API Routes)\n * - NEVER expose this client or its credentials to the browser\n * - NEVER use in Client Components\n * - Uses service role key for full access (bypasses RLS)\n *\n * Use cases:\n * - Admin user authentication and management\n * - Session management\n * - Audit logging\n * - Platform settings\n * - Email campaigns\n * - Support tickets\n * - Company registry (metadata only)\n *\n * Note: For accessing CUSTOMER DATA (jobs, invoices, payments, etc.),\n * use createWebClient() from \"./web-client.ts\" instead.\n */\nexport function createAdminClient() {\n\tconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\n\tconst serviceRoleKey = process.env.ADMIN_SUPABASE_SERVICE_ROLE_KEY;\n\n\tif (!supabaseUrl) {\n\t\tthrow new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n\t}\n\n\tif (!serviceRoleKey) {\n\t\tthrow new Error(\n\t\t\t\"Missing ADMIN_SUPABASE_SERVICE_ROLE_KEY environment variable. \" +\n\t\t\t\t\"Get this from Supabase dashboard -> Settings -> API -> service_role key\"\n\t\t);\n\t}\n\n\treturn createSupabaseClient(supabaseUrl, serviceRoleKey, {\n\t\tauth: {\n\t\t\tautoRefreshToken: false,\n\t\t\tpersistSession: false,\n\t\t},\n\t});\n}\n\n/**\n * Type-safe admin client singleton for repeated use\n */\nlet adminClientInstance: ReturnType<typeof createAdminClient> | null = null;\n\nexport function getAdminClient() {\n\tif (!adminClientInstance) {\n\t\tadminClientInstance = createAdminClient();\n\t}\n\treturn adminClientInstance;\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AA6BO,SAAS;IACf,MAAM;IACN,MAAM,iBAAiB,QAAQ,GAAG,CAAC,+BAA+B;IAElE;;IAIA,IAAI,CAAC,gBAAgB;QACpB,MAAM,IAAI,MACT,mEACC;IAEH;IAEA,OAAO,IAAA,iRAAoB,EAAC,aAAa,gBAAgB;QACxD,MAAM;YACL,kBAAkB;YAClB,gBAAgB;QACjB;IACD;AACD;AAEA;;CAEC,GACD,IAAI,sBAAmE;AAEhE,SAAS;IACf,IAAI,CAAC,qBAAqB;QACzB,sBAAsB;IACvB;IACA,OAAO;AACR","debugId":null}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/supabase/web-reader.ts"],"sourcesContent":["import { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\n\n/**\n * Web Database Reader Client (Server-Side Only)\n *\n * This client connects to the WEB Supabase project for READ-ONLY access to:\n * - Companies (customer businesses)\n * - Users (customer employees)\n * - Jobs, Invoices, Estimates\n * - Customers (customer's clients)\n * - Properties, Equipment\n * - All other business data\n *\n * This is used by admin for:\n * - Support/debugging customer issues\n * - Viewing company data for support tickets\n * - Accessing customer data when needed\n *\n * IMPORTANT: This should only be used for READ operations.\n * Never write to the web database from the admin app.\n */\nexport function createWebReaderClient() {\n\tconst supabaseUrl = process.env.WEB_SUPABASE_URL;\n\tconst serviceRoleKey = process.env.WEB_SUPABASE_SERVICE_ROLE_KEY;\n\n\tif (!supabaseUrl) {\n\t\tthrow new Error(\"Missing WEB_SUPABASE_URL environment variable\");\n\t}\n\n\tif (!serviceRoleKey) {\n\t\tthrow new Error(\"Missing WEB_SUPABASE_SERVICE_ROLE_KEY environment variable\");\n\t}\n\n\treturn createSupabaseClient(supabaseUrl, serviceRoleKey, {\n\t\tauth: {\n\t\t\tautoRefreshToken: false,\n\t\t\tpersistSession: false,\n\t\t},\n\t});\n}\n\n/**\n * Type-safe web reader client singleton for repeated use\n */\nlet webReaderInstance: ReturnType<typeof createWebReaderClient> | null = null;\n\nexport function getWebReaderClient() {\n\tif (!webReaderInstance) {\n\t\twebReaderInstance = createWebReaderClient();\n\t}\n\treturn webReaderInstance;\n}\n\n// =============================================================================\n// READ-ONLY HELPER FUNCTIONS\n// =============================================================================\n// These functions provide convenient access to web database tables\n\n/**\n * Get a company from the web database by ID\n */\nexport async function getWebCompany(companyId: string) {\n\tconst client = getWebReaderClient();\n\tconst { data, error } = await client\n\t\t.from(\"companies\")\n\t\t.select(\"*\")\n\t\t.eq(\"id\", companyId)\n\t\t.single();\n\n\tif (error) throw error;\n\treturn data;\n}\n\n/**\n * Get all companies from the web database\n */\nexport async function getWebCompanies(options?: {\n\tlimit?: number;\n\toffset?: number;\n\tstatus?: string;\n}) {\n\tconst client = getWebReaderClient();\n\tlet query = client.from(\"companies\").select(\"*\", { count: \"exact\" });\n\n\tif (options?.status) {\n\t\tquery = query.eq(\"status\", options.status);\n\t}\n\n\tif (options?.limit) {\n\t\tquery = query.limit(options.limit);\n\t}\n\n\tif (options?.offset) {\n\t\tquery = query.range(options.offset, options.offset + (options.limit || 50) - 1);\n\t}\n\n\tconst { data, error, count } = await query.order(\"created_at\", { ascending: false });\n\n\tif (error) throw error;\n\treturn { data, count };\n}\n\n/**\n * Get users for a company from the web database\n */\nexport async function getWebCompanyUsers(companyId: string) {\n\tconst client = getWebReaderClient();\n\tconst { data, error } = await client\n\t\t.from(\"team_members\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (error) throw error;\n\treturn data;\n}\n\n/**\n * Get jobs for a company from the web database\n */\nexport async function getWebCompanyJobs(companyId: string, options?: { limit?: number }) {\n\tconst client = getWebReaderClient();\n\tlet query = client\n\t\t.from(\"jobs\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (options?.limit) {\n\t\tquery = query.limit(options.limit);\n\t}\n\n\tconst { data, error } = await query;\n\n\tif (error) throw error;\n\treturn data;\n}\n\n/**\n * Get customers for a company from the web database\n */\nexport async function getWebCompanyCustomers(companyId: string, options?: { limit?: number }) {\n\tconst client = getWebReaderClient();\n\tlet query = client\n\t\t.from(\"customers\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (options?.limit) {\n\t\tquery = query.limit(options.limit);\n\t}\n\n\tconst { data, error } = await query;\n\n\tif (error) throw error;\n\treturn data;\n}\n\n/**\n * Get invoices for a company from the web database\n */\nexport async function getWebCompanyInvoices(companyId: string, options?: { limit?: number }) {\n\tconst client = getWebReaderClient();\n\tlet query = client\n\t\t.from(\"invoices\")\n\t\t.select(\"*\")\n\t\t.eq(\"company_id\", companyId)\n\t\t.order(\"created_at\", { ascending: false });\n\n\tif (options?.limit) {\n\t\tquery = query.limit(options.limit);\n\t}\n\n\tconst { data, error } = await query;\n\n\tif (error) throw error;\n\treturn data;\n}\n\n/**\n * Search across web database (for support purposes)\n */\nexport async function searchWebDatabase(searchTerm: string, options?: { limit?: number }) {\n\tconst client = getWebReaderClient();\n\tconst limit = options?.limit || 10;\n\n\t// Search companies\n\tconst { data: companies } = await client\n\t\t.from(\"companies\")\n\t\t.select(\"id, name, slug\")\n\t\t.or(`name.ilike.%${searchTerm}%,slug.ilike.%${searchTerm}%`)\n\t\t.limit(limit);\n\n\t// Search customers\n\tconst { data: customers } = await client\n\t\t.from(\"customers\")\n\t\t.select(\"id, first_name, last_name, email, company_id\")\n\t\t.or(`first_name.ilike.%${searchTerm}%,last_name.ilike.%${searchTerm}%,email.ilike.%${searchTerm}%`)\n\t\t.limit(limit);\n\n\treturn {\n\t\tcompanies: companies || [],\n\t\tcustomers: customers || [],\n\t};\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/supabase/server.ts"],"sourcesContent":["import { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\nimport { cookies } from \"next/headers\";\n\n/**\n * Admin Database Server Client\n *\n * This client connects to the ADMIN Supabase project.\n * Used for admin-specific operations like:\n * - Admin user management\n * - Support tickets\n * - Email campaigns\n * - Platform settings\n *\n * NOTE: This uses the service role key for server-side operations.\n * For session-based auth, use the session management in auth/session.ts\n */\nexport async function createClient() {\n\tconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n\tconst serviceRoleKey = process.env.ADMIN_SUPABASE_SERVICE_ROLE_KEY;\n\tconst anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n\n\t// Use service role key if available, otherwise fall back to anon key\n\tconst key = serviceRoleKey || anonKey;\n\n\treturn createSupabaseClient(supabaseUrl, key, {\n\t\tauth: {\n\t\t\tautoRefreshToken: false,\n\t\t\tpersistSession: false,\n\t\t},\n\t});\n}\n\n/**\n * Get the current admin session from cookies\n */\nexport async function getAdminSession() {\n\tconst cookieStore = await cookies();\n\tconst sessionToken = cookieStore.get(\"admin_session\")?.value;\n\n\tif (!sessionToken) {\n\t\treturn null;\n\t}\n\n\t// Verify and decode the session token\n\tconst { verifySessionToken } = await import(\"@/lib/auth/session\");\n\treturn verifySessionToken(sessionToken);\n}\n\n/**\n * Get the current admin user from the session\n */\nexport async function getCurrentAdminUser() {\n\tconst session = await getAdminSession();\n\n\tif (!session) {\n\t\treturn null;\n\t}\n\n\tconst supabase = await createClient();\n\tconst { data, error } = await supabase\n\t\t.from(\"admin_users\")\n\t\t.select(\"*\")\n\t\t.eq(\"id\", session.userId)\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\treturn data;\n}\n\n// Re-export the admin client for convenience\nexport { createAdminClient, getAdminClient } from \"./admin-client\";\nexport { createWebReaderClient, getWebReaderClient } from \"./web-reader\";\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AAuEA,6CAA6C;AAC7C;AACA;;;AA1DO,eAAe;IACrB,MAAM;IACN,MAAM,iBAAiB,QAAQ,GAAG,CAAC,+BAA+B;IAClE,MAAM;IAEN,qEAAqE;IACrE,MAAM,MAAM,kBAAkB;IAE9B,OAAO,IAAA,iRAAoB,EAAC,aAAa,KAAK;QAC7C,MAAM;YACL,kBAAkB;YAClB,gBAAgB;QACjB;IACD;AACD;AAKO,eAAe;IACrB,MAAM,cAAc,MAAM,IAAA,iTAAO;IACjC,MAAM,eAAe,YAAY,GAAG,CAAC,kBAAkB;IAEvD,IAAI,CAAC,cAAc;QAClB,OAAO;IACR;IAEA,sCAAsC;IACtC,MAAM,EAAE,kBAAkB,EAAE,GAAG;IAC/B,OAAO,mBAAmB;AAC3B;AAKO,eAAe;IACrB,MAAM,UAAU,MAAM;IAEtB,IAAI,CAAC,SAAS;QACb,OAAO;IACR;IAEA,MAAM,WAAW,MAAM;IACvB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC5B,IAAI,CAAC,eACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,QAAQ,MAAM,EACvB,MAAM;IAER,IAAI,SAAS,CAAC,MAAM;QACnB,OAAO;IACR;IAEA,OAAO;AACR","debugId":null}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/auth/session.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from \"jose\";\nimport { cookies } from \"next/headers\";\nimport { createClient } from \"@/lib/supabase/server\";\n\n/**\n * Admin Session Management\n *\n * Uses JWT tokens stored in HTTP-only cookies for authentication.\n * Sessions are also tracked in the database for revocation support.\n */\n\nconst SESSION_COOKIE_NAME = \"admin_session\";\nconst SESSION_DURATION_DAYS = 7;\n\ninterface SessionPayload {\n\tuserId: string;\n\temail: string;\n\trole: string;\n\tsessionId: string;\n\tiat: number;\n\texp: number;\n}\n\n/**\n * Get the JWT secret from environment\n */\nfunction getJwtSecret(): Uint8Array {\n\tconst secret = process.env.ADMIN_JWT_SECRET;\n\tif (!secret) {\n\t\tthrow new Error(\"Missing ADMIN_JWT_SECRET environment variable\");\n\t}\n\treturn new TextEncoder().encode(secret);\n}\n\n/**\n * Create a new session for an admin user\n */\nexport async function createSession(\n\tuserId: string,\n\temail: string,\n\trole: string,\n\tipAddress?: string,\n\tuserAgent?: string\n): Promise<string> {\n\tconst supabase = await createClient();\n\n\t// Calculate expiration\n\tconst expiresAt = new Date();\n\texpiresAt.setDate(expiresAt.getDate() + SESSION_DURATION_DAYS);\n\n\t// Generate session ID\n\tconst sessionId = crypto.randomUUID();\n\n\t// Create JWT token\n\tconst token = await new SignJWT({\n\t\tuserId,\n\t\temail,\n\t\trole,\n\t\tsessionId,\n\t})\n\t\t.setProtectedHeader({ alg: \"HS256\" })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(expiresAt)\n\t\t.sign(getJwtSecret());\n\n\t// Hash the token for storage\n\tconst tokenHash = await hashToken(token);\n\n\t// Store session in database\n\tconst { error } = await supabase.from(\"admin_sessions\").insert({\n\t\tid: sessionId,\n\t\tadmin_user_id: userId,\n\t\ttoken_hash: tokenHash,\n\t\tip_address: ipAddress,\n\t\tuser_agent: userAgent,\n\t\texpires_at: expiresAt.toISOString(),\n\t});\n\n\tif (error) {\n\t\tthrow new Error(`Failed to create session: ${error.message}`);\n\t}\n\n\t// Set cookie\n\tconst cookieStore = await cookies();\n\tcookieStore.set(SESSION_COOKIE_NAME, token, {\n\t\thttpOnly: true,\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\tsameSite: \"lax\",\n\t\tpath: \"/\",\n\t\texpires: expiresAt,\n\t});\n\n\treturn token;\n}\n\n/**\n * Verify a session token and return the payload\n */\nexport async function verifySessionToken(token: string): Promise<SessionPayload | null> {\n\ttry {\n\t\tconst { payload } = await jwtVerify(token, getJwtSecret());\n\n\t\t// Check if session exists and is not revoked\n\t\tconst supabase = await createClient();\n\t\tconst { data: session, error } = await supabase\n\t\t\t.from(\"admin_sessions\")\n\t\t\t.select(\"*\")\n\t\t\t.eq(\"id\", payload.sessionId)\n\t\t\t.is(\"revoked_at\", null)\n\t\t\t.single();\n\n\t\tif (error || !session) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check expiration\n\t\tif (new Date(session.expires_at) < new Date()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn payload as unknown as SessionPayload;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\n/**\n * Get the current session from cookies\n */\nexport async function getSession(): Promise<SessionPayload | null> {\n\tconst cookieStore = await cookies();\n\tconst token = cookieStore.get(SESSION_COOKIE_NAME)?.value;\n\n\tif (!token) {\n\t\treturn null;\n\t}\n\n\treturn verifySessionToken(token);\n}\n\n/**\n * Alias for getSession for backwards compatibility\n */\nexport const getAdminSession = getSession;\n\n/**\n * Destroy the current session\n */\nexport async function destroySession(): Promise<void> {\n\tconst session = await getSession();\n\n\tif (session) {\n\t\t// Revoke session in database\n\t\tconst supabase = await createClient();\n\t\tawait supabase\n\t\t\t.from(\"admin_sessions\")\n\t\t\t.update({ revoked_at: new Date().toISOString() })\n\t\t\t.eq(\"id\", session.sessionId);\n\t}\n\n\t// Clear cookie\n\tconst cookieStore = await cookies();\n\tcookieStore.delete(SESSION_COOKIE_NAME);\n}\n\n/**\n * Revoke all sessions for a user (e.g., on password change)\n */\nexport async function revokeAllUserSessions(userId: string): Promise<void> {\n\tconst supabase = await createClient();\n\n\tawait supabase\n\t\t.from(\"admin_sessions\")\n\t\t.update({ revoked_at: new Date().toISOString() })\n\t\t.eq(\"admin_user_id\", userId)\n\t\t.is(\"revoked_at\", null);\n}\n\n/**\n * Hash a token for storage\n */\nasync function hashToken(token: string): Promise<string> {\n\tconst encoder = new TextEncoder();\n\tconst data = encoder.encode(token);\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\treturn hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n/**\n * Clean up expired sessions (run periodically)\n */\nexport async function cleanupExpiredSessions(): Promise<number> {\n\tconst supabase = await createClient();\n\n\tconst { data, error } = await supabase\n\t\t.from(\"admin_sessions\")\n\t\t.delete()\n\t\t.lt(\"expires_at\", new Date().toISOString())\n\t\t.select(\"id\");\n\n\tif (error) {\n\t\tthrow new Error(`Failed to cleanup sessions: ${error.message}`);\n\t}\n\n\treturn data?.length || 0;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/security/rate-limit.ts"],"sourcesContent":["/**\n * Admin Rate Limiting\n *\n * Protects against brute force attacks on admin login.\n * More restrictive than contractor app due to higher privileges.\n *\n * Limits:\n * - Auth: 3 attempts per 30 minutes per email\n * - Auth: 10 attempts per 30 minutes per IP\n * - After lockout: exponential backoff\n */\n\ninterface RateLimitRecord {\n\tcount: number;\n\trequests: number[];\n\tlockedUntil?: number;\n}\n\nclass AdminRateLimiter {\n\tprivate requests: Map<string, RateLimitRecord>;\n\tprivate readonly maxRequests: number;\n\tprivate readonly windowMs: number;\n\tprivate readonly lockoutMultiplier: number;\n\n\tconstructor(maxRequests: number, windowMs: number, lockoutMultiplier = 2) {\n\t\tthis.requests = new Map();\n\t\tthis.maxRequests = maxRequests;\n\t\tthis.windowMs = windowMs;\n\t\tthis.lockoutMultiplier = lockoutMultiplier;\n\n\t\t// Cleanup old entries every minute\n\t\tif (typeof setInterval !== \"undefined\") {\n\t\t\tsetInterval(() => this.cleanup(), 60_000);\n\t\t}\n\t}\n\n\tasync limit(identifier: string): Promise<{\n\t\tsuccess: boolean;\n\t\tlimit: number;\n\t\tremaining: number;\n\t\treset: number;\n\t\tlocked: boolean;\n\t\tlockoutEnds?: number;\n\t}> {\n\t\tconst now = Date.now();\n\t\tconst key = identifier.toLowerCase(); // Normalize for case-insensitive matching\n\n\t\tlet record = this.requests.get(key);\n\n\t\t// Initialize if doesn't exist\n\t\tif (!record) {\n\t\t\trecord = {\n\t\t\t\tcount: 0,\n\t\t\t\trequests: [],\n\t\t\t};\n\t\t\tthis.requests.set(key, record);\n\t\t}\n\n\t\t// Check if currently locked out\n\t\tif (record.lockedUntil && now < record.lockedUntil) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tlimit: this.maxRequests,\n\t\t\t\tremaining: 0,\n\t\t\t\treset: record.lockedUntil,\n\t\t\t\tlocked: true,\n\t\t\t\tlockoutEnds: record.lockedUntil,\n\t\t\t};\n\t\t}\n\n\t\t// Clear lockout if expired\n\t\tif (record.lockedUntil && now >= record.lockedUntil) {\n\t\t\trecord.lockedUntil = undefined;\n\t\t}\n\n\t\t// Remove requests outside the sliding window\n\t\trecord.requests = record.requests.filter(\n\t\t\t(timestamp) => timestamp > now - this.windowMs,\n\t\t);\n\n\t\t// Check if limit exceeded\n\t\tif (record.requests.length >= this.maxRequests) {\n\t\t\t// Apply lockout with exponential backoff\n\t\t\tconst lockoutDuration =\n\t\t\t\tthis.windowMs *\n\t\t\t\tMath.pow(\n\t\t\t\t\tthis.lockoutMultiplier,\n\t\t\t\t\tMath.floor(record.requests.length / this.maxRequests),\n\t\t\t\t);\n\t\t\trecord.lockedUntil = now + lockoutDuration;\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tlimit: this.maxRequests,\n\t\t\t\tremaining: 0,\n\t\t\t\treset: record.lockedUntil,\n\t\t\t\tlocked: true,\n\t\t\t\tlockoutEnds: record.lockedUntil,\n\t\t\t};\n\t\t}\n\n\t\t// Add new request\n\t\trecord.requests.push(now);\n\t\trecord.count = record.requests.length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tlimit: this.maxRequests,\n\t\t\tremaining: this.maxRequests - record.count,\n\t\t\treset: now + this.windowMs,\n\t\t\tlocked: false,\n\t\t};\n\t}\n\n\tprivate cleanup() {\n\t\tconst now = Date.now();\n\t\tfor (const [key, record] of this.requests.entries()) {\n\t\t\trecord.requests = record.requests.filter(\n\t\t\t\t(timestamp) => timestamp > now - this.windowMs,\n\t\t\t);\n\t\t\t// Remove if no recent requests and no active lockout\n\t\t\tif (\n\t\t\t\trecord.requests.length === 0 &&\n\t\t\t\t(!record.lockedUntil || now >= record.lockedUntil)\n\t\t\t) {\n\t\t\t\tthis.requests.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\treset(identifier: string) {\n\t\tthis.requests.delete(identifier.toLowerCase());\n\t}\n\n\tclear() {\n\t\tthis.requests.clear();\n\t}\n}\n\n// Admin auth rate limiter - stricter than contractor app\n// 3 attempts per 30 minutes, with exponential lockout\nconst adminAuthByEmailLimiter = new AdminRateLimiter(\n\t3, // 3 attempts\n\t30 * 60 * 1000, // per 30 minutes\n\t2, // double lockout each time\n);\n\n// IP-based limiter to prevent distributed attacks\nconst adminAuthByIPLimiter = new AdminRateLimiter(\n\t10, // 10 attempts\n\t30 * 60 * 1000, // per 30 minutes\n\t2,\n);\n\n/**\n * Rate Limit Error\n */\nexport class RateLimitError extends Error {\n\tpublic readonly retryAfter: number;\n\tpublic readonly locked: boolean;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tretryAfter: number,\n\t\tlocked: boolean,\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"RateLimitError\";\n\t\tthis.retryAfter = retryAfter;\n\t\tthis.locked = locked;\n\t}\n}\n\n/**\n * Check Admin Auth Rate Limit\n *\n * Checks both email and IP-based limits.\n * Throws RateLimitError if either limit exceeded.\n *\n * @param email - User's email address\n * @param ip - Client IP address\n */\nexport async function checkAdminAuthRateLimit(\n\temail: string,\n\tip: string,\n): Promise<void> {\n\t// Check email-based limit\n\tconst emailResult = await adminAuthByEmailLimiter.limit(email);\n\tif (!emailResult.success) {\n\t\tconst retryAfterMs = emailResult.reset - Date.now();\n\t\tconst retryAfterSec = Math.ceil(retryAfterMs / 1000);\n\t\tconst minutes = Math.ceil(retryAfterSec / 60);\n\n\t\tthrow new RateLimitError(\n\t\t\temailResult.locked\n\t\t\t\t? `Account temporarily locked. Try again in ${minutes} minute${minutes === 1 ? \"\" : \"s\"}.`\n\t\t\t\t: `Too many login attempts. Try again in ${minutes} minute${minutes === 1 ? \"\" : \"s\"}.`,\n\t\t\tretryAfterMs,\n\t\t\temailResult.locked,\n\t\t);\n\t}\n\n\t// Check IP-based limit\n\tconst ipResult = await adminAuthByIPLimiter.limit(ip);\n\tif (!ipResult.success) {\n\t\tconst retryAfterMs = ipResult.reset - Date.now();\n\t\tconst retryAfterSec = Math.ceil(retryAfterMs / 1000);\n\t\tconst minutes = Math.ceil(retryAfterSec / 60);\n\n\t\tthrow new RateLimitError(\n\t\t\t`Too many requests from this location. Try again in ${minutes} minute${minutes === 1 ? \"\" : \"s\"}.`,\n\t\t\tretryAfterMs,\n\t\t\tipResult.locked,\n\t\t);\n\t}\n}\n\n/**\n * Reset Rate Limit for Email\n *\n * Call this after successful login to reset the counter.\n * This prevents legitimate users from being locked out after a typo.\n */\nexport function resetRateLimitForEmail(email: string): void {\n\tadminAuthByEmailLimiter.reset(email);\n}\n\n/**\n * Get Client IP Address\n *\n * Extracts IP from request headers for rate limiting.\n */\nexport function getClientIP(headers: Headers): string {\n\t// Check common proxy headers in order of preference\n\tconst forwarded = headers.get(\"x-forwarded-for\");\n\tif (forwarded) {\n\t\treturn forwarded.split(\",\")[0].trim();\n\t}\n\n\tconst realIP = headers.get(\"x-real-ip\");\n\tif (realIP) {\n\t\treturn realIP;\n\t}\n\n\tconst cfIP = headers.get(\"cf-connecting-ip\"); // Cloudflare\n\tif (cfIP) {\n\t\treturn cfIP;\n\t}\n\n\tconst vercelIP = headers.get(\"x-vercel-forwarded-for\");\n\tif (vercelIP) {\n\t\treturn vercelIP.split(\",\")[0].trim();\n\t}\n\n\treturn \"unknown\";\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/security/audit-log.ts"],"sourcesContent":["/**\n * Admin Audit Logging\n *\n * Logs all authentication and security events for the admin dashboard.\n * Critical for compliance, security monitoring, and incident response.\n *\n * Events logged:\n * - Login attempts (success/failure)\n * - Logout events\n * - Session refreshes\n * - Unauthorized access attempts\n * - Rate limit violations\n * - Domain validation failures\n */\n\nexport type AuditEventType =\n\t| \"LOGIN_ATTEMPT\"\n\t| \"LOGIN_SUCCESS\"\n\t| \"LOGIN_FAILURE\"\n\t| \"LOGOUT\"\n\t| \"SESSION_REFRESH\"\n\t| \"UNAUTHORIZED_ACCESS\"\n\t| \"RATE_LIMIT_EXCEEDED\"\n\t| \"INVALID_DOMAIN\"\n\t| \"SUSPICIOUS_ACTIVITY\";\n\nexport type AuditEventSeverity = \"INFO\" | \"WARN\" | \"ERROR\" | \"CRITICAL\";\n\nexport interface AuditEvent {\n\ttimestamp: string;\n\teventType: AuditEventType;\n\tseverity: AuditEventSeverity;\n\temail?: string;\n\tip?: string;\n\tuserAgent?: string;\n\tdetails?: Record<string, unknown>;\n\tsuccess: boolean;\n}\n\n/**\n * Determine severity based on event type\n */\nfunction getSeverity(eventType: AuditEventType, success: boolean): AuditEventSeverity {\n\tswitch (eventType) {\n\t\tcase \"LOGIN_SUCCESS\":\n\t\tcase \"LOGOUT\":\n\t\tcase \"SESSION_REFRESH\":\n\t\t\treturn \"INFO\";\n\n\t\tcase \"LOGIN_ATTEMPT\":\n\t\t\treturn \"INFO\";\n\n\t\tcase \"LOGIN_FAILURE\":\n\t\t\treturn \"WARN\";\n\n\t\tcase \"RATE_LIMIT_EXCEEDED\":\n\t\tcase \"INVALID_DOMAIN\":\n\t\t\treturn \"WARN\";\n\n\t\tcase \"UNAUTHORIZED_ACCESS\":\n\t\t\treturn \"ERROR\";\n\n\t\tcase \"SUSPICIOUS_ACTIVITY\":\n\t\t\treturn \"CRITICAL\";\n\n\t\tdefault:\n\t\t\treturn success ? \"INFO\" : \"WARN\";\n\t}\n}\n\n/**\n * Log Admin Auth Event\n *\n * Logs authentication events with structured data.\n * Persists to both console and the admin_audit_logs database table.\n *\n * @param eventType - Type of authentication event\n * @param options - Event details\n */\nexport async function logAdminAuthEvent(\n\teventType: AuditEventType,\n\toptions: {\n\t\temail?: string;\n\t\tip?: string;\n\t\tuserAgent?: string;\n\t\tsuccess: boolean;\n\t\tdetails?: Record<string, unknown>;\n\t},\n): Promise<void> {\n\tconst event: AuditEvent = {\n\t\ttimestamp: new Date().toISOString(),\n\t\teventType,\n\t\tseverity: getSeverity(eventType, options.success),\n\t\temail: options.email ? maskEmail(options.email) : undefined,\n\t\tip: options.ip,\n\t\tuserAgent: options.userAgent,\n\t\tdetails: options.details,\n\t\tsuccess: options.success,\n\t};\n\n\t// Log to console in structured format\n\tconst logMessage = formatLogMessage(event);\n\n\tswitch (event.severity) {\n\t\tcase \"CRITICAL\":\n\t\tcase \"ERROR\":\n\t\t\tconsole.error(logMessage);\n\t\t\tbreak;\n\t\tcase \"WARN\":\n\t\t\tconsole.warn(logMessage);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.log(logMessage);\n\t}\n\n\t// Persist to database\n\ttry {\n\t\tconst { createClient } = await import(\"@/lib/supabase/server\");\n\t\tconst supabase = await createClient();\n\n\t\tawait supabase.from(\"admin_audit_logs\").insert({\n\t\t\taction: eventType,\n\t\t\tadmin_email: options.email,\n\t\t\tip_address: options.ip,\n\t\t\tuser_agent: options.userAgent,\n\t\t\tdetails: {\n\t\t\t\t...options.details,\n\t\t\t\tsuccess: options.success,\n\t\t\t\tseverity: event.severity,\n\t\t\t},\n\t\t});\n\t} catch (error) {\n\t\t// Don't fail the main operation if audit logging fails\n\t\tconsole.error(\"[AUDIT_LOG] Failed to persist audit log:\", error);\n\t}\n}\n\n/**\n * Format log message for structured logging\n */\nfunction formatLogMessage(event: AuditEvent): string {\n\tconst base = `[ADMIN_AUTH] [${event.severity}] ${event.eventType}`;\n\tconst details = [\n\t\tevent.email && `email=${event.email}`,\n\t\tevent.ip && `ip=${event.ip}`,\n\t\t`success=${event.success}`,\n\t\tevent.details && `details=${JSON.stringify(event.details)}`,\n\t]\n\t\t.filter(Boolean)\n\t\t.join(\" \");\n\n\treturn `${base} ${details}`;\n}\n\n/**\n * Mask email for privacy in logs\n * user@domain.com -> u***@domain.com\n */\nfunction maskEmail(email: string): string {\n\tconst [local, domain] = email.split(\"@\");\n\tif (!local || !domain) return \"***@***\";\n\n\tif (local.length <= 2) {\n\t\treturn `${local[0]}***@${domain}`;\n\t}\n\n\treturn `${local[0]}***${local[local.length - 1]}@${domain}`;\n}\n\n/**\n * Log successful admin login\n */\nexport async function logAdminLoginSuccess(\n\temail: string,\n\tip: string,\n\tuserAgent?: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"LOGIN_SUCCESS\", {\n\t\temail,\n\t\tip,\n\t\tuserAgent,\n\t\tsuccess: true,\n\t});\n}\n\n/**\n * Log failed admin login attempt\n */\nexport async function logAdminLoginFailure(\n\temail: string,\n\tip: string,\n\treason: string,\n\tuserAgent?: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"LOGIN_FAILURE\", {\n\t\temail,\n\t\tip,\n\t\tuserAgent,\n\t\tsuccess: false,\n\t\tdetails: { reason },\n\t});\n}\n\n/**\n * Log rate limit exceeded\n */\nexport async function logRateLimitExceeded(\n\temail: string,\n\tip: string,\n\tlockedUntil?: number,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"RATE_LIMIT_EXCEEDED\", {\n\t\temail,\n\t\tip,\n\t\tsuccess: false,\n\t\tdetails: {\n\t\t\tlockedUntil: lockedUntil ? new Date(lockedUntil).toISOString() : undefined,\n\t\t},\n\t});\n}\n\n/**\n * Log invalid domain attempt\n */\nexport async function logInvalidDomainAttempt(\n\temail: string,\n\tip: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"INVALID_DOMAIN\", {\n\t\temail,\n\t\tip,\n\t\tsuccess: false,\n\t\tdetails: {\n\t\t\tdomain: email.split(\"@\")[1]?.toLowerCase(),\n\t\t\tmessage: \"Non-admin domain attempted admin login\",\n\t\t},\n\t});\n}\n\n/**\n * Log unauthorized access attempt\n */\nexport async function logUnauthorizedAccess(\n\temail: string | undefined,\n\tip: string,\n\tpath: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"UNAUTHORIZED_ACCESS\", {\n\t\temail,\n\t\tip,\n\t\tsuccess: false,\n\t\tdetails: { path },\n\t});\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 716, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { headers } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { createSession, destroySession, getSession } from \"@/lib/auth/session\";\nimport {\n\tcheckAdminAuthRateLimit,\n\tresetRateLimitForEmail,\n\tgetClientIP,\n\tRateLimitError,\n} from \"@/lib/security/rate-limit\";\nimport {\n\tlogAdminLoginSuccess,\n\tlogAdminLoginFailure,\n\tlogRateLimitExceeded,\n} from \"@/lib/security/audit-log\";\n\nexport type AdminLoginResult = {\n\tsuccess: boolean;\n\terror?: string;\n\trateLimited?: boolean;\n\tretryAfter?: number;\n};\n\n/**\n * Admin Sign In Server Action\n *\n * Authenticates admin users against the admin_users table in the admin database.\n * Uses custom JWT-based sessions instead of Supabase Auth.\n */\nexport async function adminSignIn(formData: FormData): Promise<AdminLoginResult> {\n\tconst email = (formData.get(\"email\") as string)?.trim().toLowerCase();\n\tconst password = formData.get(\"password\") as string;\n\n\t// Get client info for rate limiting and logging\n\tconst headersList = await headers();\n\tconst ip = getClientIP(headersList);\n\tconst userAgent = headersList.get(\"user-agent\") || undefined;\n\n\t// Validate inputs\n\tif (!email || !password) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Email and password are required.\",\n\t\t};\n\t}\n\n\t// Check rate limits BEFORE any other validation\n\ttry {\n\t\tawait checkAdminAuthRateLimit(email, ip);\n\t} catch (error) {\n\t\tif (error instanceof RateLimitError) {\n\t\t\tawait logRateLimitExceeded(email, ip, Date.now() + error.retryAfter);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t\trateLimited: true,\n\t\t\t\tretryAfter: error.retryAfter,\n\t\t\t};\n\t\t}\n\t\tthrow error;\n\t}\n\n\t// Get admin user from database\n\tconst supabase = await createClient();\n\n\t// Check if user exists and is active\n\tconst { data: adminUser, error: userError } = await supabase\n\t\t.from(\"admin_users\")\n\t\t.select(\"*\")\n\t\t.eq(\"email\", email)\n\t\t.single();\n\n\tif (userError || !adminUser) {\n\t\tawait logAdminLoginFailure(email, ip, \"User not found\", userAgent);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Invalid email or password.\",\n\t\t};\n\t}\n\n\t// Check if account is active\n\tif (!adminUser.is_active) {\n\t\tawait logAdminLoginFailure(email, ip, \"Account disabled\", userAgent);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Your account has been disabled. Contact a super admin.\",\n\t\t};\n\t}\n\n\t// Check if account is locked\n\tif (adminUser.locked_until && new Date(adminUser.locked_until) > new Date()) {\n\t\tconst lockRemaining = Math.ceil(\n\t\t\t(new Date(adminUser.locked_until).getTime() - Date.now()) / 1000 / 60\n\t\t);\n\t\tawait logAdminLoginFailure(email, ip, \"Account locked\", userAgent);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: `Account is locked. Try again in ${lockRemaining} minutes.`,\n\t\t};\n\t}\n\n\t// Verify password using PostgreSQL crypt function\n\tconst { data: passwordMatch, error: verifyError } = await supabase.rpc(\"verify_password\", {\n\t\tpassword_text: password,\n\t\tpassword_hash: adminUser.password_hash,\n\t});\n\n\tif (verifyError || !passwordMatch) {\n\t\t// Increment failed login attempts\n\t\tconst newAttempts = (adminUser.failed_login_attempts || 0) + 1;\n\t\tconst lockUntil = newAttempts >= 5 ? new Date(Date.now() + 15 * 60 * 1000) : null;\n\n\t\tawait supabase\n\t\t\t.from(\"admin_users\")\n\t\t\t.update({\n\t\t\t\tfailed_login_attempts: newAttempts,\n\t\t\t\tlocked_until: lockUntil?.toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", adminUser.id);\n\n\t\tawait logAdminLoginFailure(email, ip, \"Invalid password\", userAgent);\n\n\t\tif (newAttempts >= 5) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"Too many failed attempts. Account locked for 15 minutes.\",\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Invalid email or password.\",\n\t\t};\n\t}\n\n\t// Successful login - create session\n\ttry {\n\t\tawait createSession(adminUser.id, adminUser.email, adminUser.role, ip, userAgent);\n\n\t\t// Reset failed attempts and update last login\n\t\tawait supabase\n\t\t\t.from(\"admin_users\")\n\t\t\t.update({\n\t\t\t\tfailed_login_attempts: 0,\n\t\t\t\tlocked_until: null,\n\t\t\t\tlast_login_at: new Date().toISOString(),\n\t\t\t})\n\t\t\t.eq(\"id\", adminUser.id);\n\n\t\t// Reset rate limit and log success\n\t\tresetRateLimitForEmail(email);\n\t\tawait logAdminLoginSuccess(email, ip, userAgent);\n\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Session creation error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Failed to create session. Please try again.\",\n\t\t};\n\t}\n}\n\n/**\n * Admin Sign Out Server Action\n */\nexport async function adminSignOut(): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tawait destroySession();\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconsole.error(\"Sign out error:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Failed to sign out. Please try again.\",\n\t\t};\n\t}\n}\n\n/**\n * Get current admin user\n */\nexport async function getCurrentAdmin() {\n\tconst session = await getSession();\n\n\tif (!session) {\n\t\treturn null;\n\t}\n\n\tconst supabase = await createClient();\n\tconst { data, error } = await supabase\n\t\t.from(\"admin_users\")\n\t\t.select(\"id, email, full_name, avatar_url, role, is_active\")\n\t\t.eq(\"id\", session.userId)\n\t\t.single();\n\n\tif (error || !data) {\n\t\treturn null;\n\t}\n\n\treturn data;\n}\n\n/**\n * Require admin authentication (redirect if not authenticated)\n */\nexport async function requireAdmin() {\n\tconst admin = await getCurrentAdmin();\n\n\tif (!admin) {\n\t\tredirect(\"/login\");\n\t}\n\n\treturn admin;\n}\n\n/**\n * Change admin password\n */\nexport async function changePassword(\n\tcurrentPassword: string,\n\tnewPassword: string\n): Promise<{ success: boolean; error?: string }> {\n\tconst session = await getSession();\n\n\tif (!session) {\n\t\treturn { success: false, error: \"Not authenticated\" };\n\t}\n\n\tconst supabase = await createClient();\n\n\t// Get current user\n\tconst { data: adminUser, error: userError } = await supabase\n\t\t.from(\"admin_users\")\n\t\t.select(\"password_hash\")\n\t\t.eq(\"id\", session.userId)\n\t\t.single();\n\n\tif (userError || !adminUser) {\n\t\treturn { success: false, error: \"User not found\" };\n\t}\n\n\t// Verify current password\n\tconst { data: passwordMatch } = await supabase.rpc(\"verify_password\", {\n\t\tpassword_text: currentPassword,\n\t\tpassword_hash: adminUser.password_hash,\n\t});\n\n\tif (!passwordMatch) {\n\t\treturn { success: false, error: \"Current password is incorrect\" };\n\t}\n\n\t// Hash new password\n\tconst { data: newHash, error: hashError } = await supabase.rpc(\"crypt_password\", {\n\t\tpassword_text: newPassword,\n\t});\n\n\tif (hashError || !newHash) {\n\t\treturn { success: false, error: \"Failed to hash new password\" };\n\t}\n\n\t// Update password\n\tconst { error: updateError } = await supabase\n\t\t.from(\"admin_users\")\n\t\t.update({ password_hash: newHash })\n\t\t.eq(\"id\", session.userId);\n\n\tif (updateError) {\n\t\treturn { success: false, error: \"Failed to update password\" };\n\t}\n\n\treturn { success: true };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/.next-internal/server/app/login/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {adminSignIn as '40c8fabab10a3afae1dc2c6e3f07a4797e6cfb34b0'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}}]
}