{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\n\n/**\n * Cookie name prefix for admin app session isolation\n * This ensures admin cookies don't conflict with contractor web app cookies\n * Both apps share the same domain but use different cookie prefixes\n */\nconst COOKIE_PREFIX = \"admin_\";\n\n/**\n * Add prefix to cookie name for isolation\n */\nconst prefixCookieName = (name: string) => `${COOKIE_PREFIX}${name}`;\n\n/**\n * Remove prefix from cookie name\n */\nconst unprefixCookieName = (name: string) =>\n\tname.startsWith(COOKIE_PREFIX) ? name.slice(COOKIE_PREFIX.length) : name;\n\nexport async function createClient() {\n\tconst cookieStore = await cookies();\n\n\treturn createServerClient(\n\t\tprocess.env.NEXT_PUBLIC_SUPABASE_URL!,\n\t\tprocess.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n\t\t{\n\t\t\tcookies: {\n\t\t\t\tgetAll() {\n\t\t\t\t\t// Get all cookies and filter/unprefix admin cookies\n\t\t\t\t\treturn cookieStore\n\t\t\t\t\t\t.getAll()\n\t\t\t\t\t\t.filter((cookie) => cookie.name.startsWith(COOKIE_PREFIX))\n\t\t\t\t\t\t.map((cookie) => ({\n\t\t\t\t\t\t\t...cookie,\n\t\t\t\t\t\t\tname: unprefixCookieName(cookie.name),\n\t\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tsetAll(cookiesToSet) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcookiesToSet.forEach(({ name, value, options }) =>\n\t\t\t\t\t\t\tcookieStore.set(prefixCookieName(name), value, options),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// The `setAll` method was called from a Server Component.\n\t\t\t\t\t\t// This can be ignored if you have middleware refreshing\n\t\t\t\t\t\t// user sessions.\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t);\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEA;;;;CAIC,GACD,MAAM,gBAAgB;AAEtB;;CAEC,GACD,MAAM,mBAAmB,CAAC,OAAiB,GAAG,gBAAgB,MAAM;AAEpE;;CAEC,GACD,MAAM,qBAAqB,CAAC,OAC3B,KAAK,UAAU,CAAC,iBAAiB,KAAK,KAAK,CAAC,cAAc,MAAM,IAAI;AAE9D,eAAe;IACrB,MAAM,cAAc,MAAM,IAAA,iTAAO;IAEjC,OAAO,IAAA,4SAAkB,sUAGxB;QACC,SAAS;YACR;gBACC,oDAAoD;gBACpD,OAAO,YACL,MAAM,GACN,MAAM,CAAC,CAAC,SAAW,OAAO,IAAI,CAAC,UAAU,CAAC,gBAC1C,GAAG,CAAC,CAAC,SAAW,CAAC;wBACjB,GAAG,MAAM;wBACT,MAAM,mBAAmB,OAAO,IAAI;oBACrC,CAAC;YACH;YACA,QAAO,YAAY;gBAClB,IAAI;oBACH,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC7C,YAAY,GAAG,CAAC,iBAAiB,OAAO,OAAO;gBAEjD,EAAE,OAAM;gBACP,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBAClB;YACD;QACD;IACD;AAEF","debugId":null}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/admin-auth.ts"],"sourcesContent":["/**\n * Admin Authentication Utilities\n *\n * Validates that users are authorized Thorbis employees.\n * Uses strict domain validation to prevent unauthorized access.\n *\n * Security measures:\n * - Case-insensitive domain matching\n * - Whitespace trimming\n * - Multiple @ symbol detection (email injection)\n * - Subdomain validation (prevents attacker.thorbis.com.evil.com)\n * - Empty/null handling\n */\n\n// Authorized admin domains (must be exact match, no subdomains)\nconst ALLOWED_DOMAINS = [\"thorbis.com\", \"stratos.com\"] as const;\n\n// Email validation regex (basic RFC 5322 compliance)\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n/**\n * Validate and normalize email address\n *\n * @param email - Email to validate\n * @returns Normalized email or null if invalid\n */\nfunction normalizeEmail(email: string | undefined | null): string | null {\n\tif (!email || typeof email !== \"string\") {\n\t\treturn null;\n\t}\n\n\t// Trim whitespace\n\tconst trimmed = email.trim().toLowerCase();\n\n\t// Check for empty string\n\tif (trimmed.length === 0) {\n\t\treturn null;\n\t}\n\n\t// Check for multiple @ symbols (potential injection)\n\tconst atCount = (trimmed.match(/@/g) || []).length;\n\tif (atCount !== 1) {\n\t\treturn null;\n\t}\n\n\t// Basic format validation\n\tif (!EMAIL_REGEX.test(trimmed)) {\n\t\treturn null;\n\t}\n\n\treturn trimmed;\n}\n\n/**\n * Extract and validate domain from email\n *\n * Prevents attacks like:\n * - user@thorbis.com.evil.com (subdomain of evil.com)\n * - user@evil.com\\n@thorbis.com (newline injection)\n * - user@thorbis.com%00@evil.com (null byte injection)\n *\n * @param email - Normalized email address\n * @returns Domain or null if invalid\n */\nfunction extractDomain(email: string): string | null {\n\tconst parts = email.split(\"@\");\n\n\tif (parts.length !== 2) {\n\t\treturn null;\n\t}\n\n\tconst domain = parts[1];\n\n\tif (!domain) {\n\t\treturn null;\n\t}\n\n\t// Check for suspicious characters\n\tif (/[\\s\\n\\r\\0%]/.test(domain)) {\n\t\treturn null;\n\t}\n\n\t// Must be exact domain match (no subdomains of allowed domains)\n\t// e.g., \"mail.thorbis.com\" would NOT be allowed\n\treturn domain;\n}\n\n/**\n * Check if email belongs to an authorized admin domain\n *\n * @param email - Email address to check\n * @returns true if email is from an authorized admin domain\n */\nexport function isAdminEmail(email: string | undefined | null): boolean {\n\tconst normalized = normalizeEmail(email);\n\n\tif (!normalized) {\n\t\treturn false;\n\t}\n\n\tconst domain = extractDomain(normalized);\n\n\tif (!domain) {\n\t\treturn false;\n\t}\n\n\t// Exact domain match only (case-insensitive already from normalization)\n\treturn ALLOWED_DOMAINS.includes(domain as typeof ALLOWED_DOMAINS[number]);\n}\n\n/**\n * Get email domain (for logging/display purposes)\n *\n * @param email - Email address\n * @returns Domain portion of email or null if invalid\n */\nexport function getEmailDomain(email: string): string | null {\n\tconst normalized = normalizeEmail(email);\n\n\tif (!normalized) {\n\t\treturn null;\n\t}\n\n\treturn extractDomain(normalized);\n}\n\n/**\n * Get list of allowed admin domains\n *\n * @returns Array of allowed domain strings\n */\nexport function getAllowedDomains(): readonly string[] {\n\treturn ALLOWED_DOMAINS;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;CAYC,GAED,gEAAgE;;;;;;;;;AAChE,MAAM,kBAAkB;IAAC;IAAe;CAAc;AAEtD,qDAAqD;AACrD,MAAM,cAAc;AAEpB;;;;;CAKC,GACD,SAAS,eAAe,KAAgC;IACvD,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU;QACxC,OAAO;IACR;IAEA,kBAAkB;IAClB,MAAM,UAAU,MAAM,IAAI,GAAG,WAAW;IAExC,yBAAyB;IACzB,IAAI,QAAQ,MAAM,KAAK,GAAG;QACzB,OAAO;IACR;IAEA,qDAAqD;IACrD,MAAM,UAAU,CAAC,QAAQ,KAAK,CAAC,SAAS,EAAE,EAAE,MAAM;IAClD,IAAI,YAAY,GAAG;QAClB,OAAO;IACR;IAEA,0BAA0B;IAC1B,IAAI,CAAC,YAAY,IAAI,CAAC,UAAU;QAC/B,OAAO;IACR;IAEA,OAAO;AACR;AAEA;;;;;;;;;;CAUC,GACD,SAAS,cAAc,KAAa;IACnC,MAAM,QAAQ,MAAM,KAAK,CAAC;IAE1B,IAAI,MAAM,MAAM,KAAK,GAAG;QACvB,OAAO;IACR;IAEA,MAAM,SAAS,KAAK,CAAC,EAAE;IAEvB,IAAI,CAAC,QAAQ;QACZ,OAAO;IACR;IAEA,kCAAkC;IAClC,IAAI,cAAc,IAAI,CAAC,SAAS;QAC/B,OAAO;IACR;IAEA,gEAAgE;IAChE,gDAAgD;IAChD,OAAO;AACR;AAQO,SAAS,aAAa,KAAgC;IAC5D,MAAM,aAAa,eAAe;IAElC,IAAI,CAAC,YAAY;QAChB,OAAO;IACR;IAEA,MAAM,SAAS,cAAc;IAE7B,IAAI,CAAC,QAAQ;QACZ,OAAO;IACR;IAEA,wEAAwE;IACxE,OAAO,gBAAgB,QAAQ,CAAC;AACjC;AAQO,SAAS,eAAe,KAAa;IAC3C,MAAM,aAAa,eAAe;IAElC,IAAI,CAAC,YAAY;QAChB,OAAO;IACR;IAEA,OAAO,cAAc;AACtB;AAOO,SAAS;IACf,OAAO;AACR","debugId":null}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/security/rate-limit.ts"],"sourcesContent":["/**\n * Admin Rate Limiting\n *\n * Protects against brute force attacks on admin login.\n * More restrictive than contractor app due to higher privileges.\n *\n * Limits:\n * - Auth: 3 attempts per 30 minutes per email\n * - Auth: 10 attempts per 30 minutes per IP\n * - After lockout: exponential backoff\n */\n\ninterface RateLimitRecord {\n\tcount: number;\n\trequests: number[];\n\tlockedUntil?: number;\n}\n\nclass AdminRateLimiter {\n\tprivate requests: Map<string, RateLimitRecord>;\n\tprivate readonly maxRequests: number;\n\tprivate readonly windowMs: number;\n\tprivate readonly lockoutMultiplier: number;\n\n\tconstructor(maxRequests: number, windowMs: number, lockoutMultiplier = 2) {\n\t\tthis.requests = new Map();\n\t\tthis.maxRequests = maxRequests;\n\t\tthis.windowMs = windowMs;\n\t\tthis.lockoutMultiplier = lockoutMultiplier;\n\n\t\t// Cleanup old entries every minute\n\t\tif (typeof setInterval !== \"undefined\") {\n\t\t\tsetInterval(() => this.cleanup(), 60_000);\n\t\t}\n\t}\n\n\tasync limit(identifier: string): Promise<{\n\t\tsuccess: boolean;\n\t\tlimit: number;\n\t\tremaining: number;\n\t\treset: number;\n\t\tlocked: boolean;\n\t\tlockoutEnds?: number;\n\t}> {\n\t\tconst now = Date.now();\n\t\tconst key = identifier.toLowerCase(); // Normalize for case-insensitive matching\n\n\t\tlet record = this.requests.get(key);\n\n\t\t// Initialize if doesn't exist\n\t\tif (!record) {\n\t\t\trecord = {\n\t\t\t\tcount: 0,\n\t\t\t\trequests: [],\n\t\t\t};\n\t\t\tthis.requests.set(key, record);\n\t\t}\n\n\t\t// Check if currently locked out\n\t\tif (record.lockedUntil && now < record.lockedUntil) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tlimit: this.maxRequests,\n\t\t\t\tremaining: 0,\n\t\t\t\treset: record.lockedUntil,\n\t\t\t\tlocked: true,\n\t\t\t\tlockoutEnds: record.lockedUntil,\n\t\t\t};\n\t\t}\n\n\t\t// Clear lockout if expired\n\t\tif (record.lockedUntil && now >= record.lockedUntil) {\n\t\t\trecord.lockedUntil = undefined;\n\t\t}\n\n\t\t// Remove requests outside the sliding window\n\t\trecord.requests = record.requests.filter(\n\t\t\t(timestamp) => timestamp > now - this.windowMs,\n\t\t);\n\n\t\t// Check if limit exceeded\n\t\tif (record.requests.length >= this.maxRequests) {\n\t\t\t// Apply lockout with exponential backoff\n\t\t\tconst lockoutDuration =\n\t\t\t\tthis.windowMs *\n\t\t\t\tMath.pow(\n\t\t\t\t\tthis.lockoutMultiplier,\n\t\t\t\t\tMath.floor(record.requests.length / this.maxRequests),\n\t\t\t\t);\n\t\t\trecord.lockedUntil = now + lockoutDuration;\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tlimit: this.maxRequests,\n\t\t\t\tremaining: 0,\n\t\t\t\treset: record.lockedUntil,\n\t\t\t\tlocked: true,\n\t\t\t\tlockoutEnds: record.lockedUntil,\n\t\t\t};\n\t\t}\n\n\t\t// Add new request\n\t\trecord.requests.push(now);\n\t\trecord.count = record.requests.length;\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tlimit: this.maxRequests,\n\t\t\tremaining: this.maxRequests - record.count,\n\t\t\treset: now + this.windowMs,\n\t\t\tlocked: false,\n\t\t};\n\t}\n\n\tprivate cleanup() {\n\t\tconst now = Date.now();\n\t\tfor (const [key, record] of this.requests.entries()) {\n\t\t\trecord.requests = record.requests.filter(\n\t\t\t\t(timestamp) => timestamp > now - this.windowMs,\n\t\t\t);\n\t\t\t// Remove if no recent requests and no active lockout\n\t\t\tif (\n\t\t\t\trecord.requests.length === 0 &&\n\t\t\t\t(!record.lockedUntil || now >= record.lockedUntil)\n\t\t\t) {\n\t\t\t\tthis.requests.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\treset(identifier: string) {\n\t\tthis.requests.delete(identifier.toLowerCase());\n\t}\n\n\tclear() {\n\t\tthis.requests.clear();\n\t}\n}\n\n// Admin auth rate limiter - stricter than contractor app\n// 3 attempts per 30 minutes, with exponential lockout\nconst adminAuthByEmailLimiter = new AdminRateLimiter(\n\t3, // 3 attempts\n\t30 * 60 * 1000, // per 30 minutes\n\t2, // double lockout each time\n);\n\n// IP-based limiter to prevent distributed attacks\nconst adminAuthByIPLimiter = new AdminRateLimiter(\n\t10, // 10 attempts\n\t30 * 60 * 1000, // per 30 minutes\n\t2,\n);\n\n/**\n * Rate Limit Error\n */\nexport class RateLimitError extends Error {\n\tpublic readonly retryAfter: number;\n\tpublic readonly locked: boolean;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tretryAfter: number,\n\t\tlocked: boolean,\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"RateLimitError\";\n\t\tthis.retryAfter = retryAfter;\n\t\tthis.locked = locked;\n\t}\n}\n\n/**\n * Check Admin Auth Rate Limit\n *\n * Checks both email and IP-based limits.\n * Throws RateLimitError if either limit exceeded.\n *\n * @param email - User's email address\n * @param ip - Client IP address\n */\nexport async function checkAdminAuthRateLimit(\n\temail: string,\n\tip: string,\n): Promise<void> {\n\t// Check email-based limit\n\tconst emailResult = await adminAuthByEmailLimiter.limit(email);\n\tif (!emailResult.success) {\n\t\tconst retryAfterMs = emailResult.reset - Date.now();\n\t\tconst retryAfterSec = Math.ceil(retryAfterMs / 1000);\n\t\tconst minutes = Math.ceil(retryAfterSec / 60);\n\n\t\tthrow new RateLimitError(\n\t\t\temailResult.locked\n\t\t\t\t? `Account temporarily locked. Try again in ${minutes} minute${minutes === 1 ? \"\" : \"s\"}.`\n\t\t\t\t: `Too many login attempts. Try again in ${minutes} minute${minutes === 1 ? \"\" : \"s\"}.`,\n\t\t\tretryAfterMs,\n\t\t\temailResult.locked,\n\t\t);\n\t}\n\n\t// Check IP-based limit\n\tconst ipResult = await adminAuthByIPLimiter.limit(ip);\n\tif (!ipResult.success) {\n\t\tconst retryAfterMs = ipResult.reset - Date.now();\n\t\tconst retryAfterSec = Math.ceil(retryAfterMs / 1000);\n\t\tconst minutes = Math.ceil(retryAfterSec / 60);\n\n\t\tthrow new RateLimitError(\n\t\t\t`Too many requests from this location. Try again in ${minutes} minute${minutes === 1 ? \"\" : \"s\"}.`,\n\t\t\tretryAfterMs,\n\t\t\tipResult.locked,\n\t\t);\n\t}\n}\n\n/**\n * Reset Rate Limit for Email\n *\n * Call this after successful login to reset the counter.\n * This prevents legitimate users from being locked out after a typo.\n */\nexport function resetRateLimitForEmail(email: string): void {\n\tadminAuthByEmailLimiter.reset(email);\n}\n\n/**\n * Get Client IP Address\n *\n * Extracts IP from request headers for rate limiting.\n */\nexport function getClientIP(headers: Headers): string {\n\t// Check common proxy headers in order of preference\n\tconst forwarded = headers.get(\"x-forwarded-for\");\n\tif (forwarded) {\n\t\treturn forwarded.split(\",\")[0].trim();\n\t}\n\n\tconst realIP = headers.get(\"x-real-ip\");\n\tif (realIP) {\n\t\treturn realIP;\n\t}\n\n\tconst cfIP = headers.get(\"cf-connecting-ip\"); // Cloudflare\n\tif (cfIP) {\n\t\treturn cfIP;\n\t}\n\n\tconst vercelIP = headers.get(\"x-vercel-forwarded-for\");\n\tif (vercelIP) {\n\t\treturn vercelIP.split(\",\")[0].trim();\n\t}\n\n\treturn \"unknown\";\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/lib/security/audit-log.ts"],"sourcesContent":["/**\n * Admin Audit Logging\n *\n * Logs all authentication and security events for the admin dashboard.\n * Critical for compliance, security monitoring, and incident response.\n *\n * Events logged:\n * - Login attempts (success/failure)\n * - Logout events\n * - Session refreshes\n * - Unauthorized access attempts\n * - Rate limit violations\n * - Domain validation failures\n */\n\nexport type AuditEventType =\n\t| \"LOGIN_ATTEMPT\"\n\t| \"LOGIN_SUCCESS\"\n\t| \"LOGIN_FAILURE\"\n\t| \"LOGOUT\"\n\t| \"SESSION_REFRESH\"\n\t| \"UNAUTHORIZED_ACCESS\"\n\t| \"RATE_LIMIT_EXCEEDED\"\n\t| \"INVALID_DOMAIN\"\n\t| \"SUSPICIOUS_ACTIVITY\";\n\nexport type AuditEventSeverity = \"INFO\" | \"WARN\" | \"ERROR\" | \"CRITICAL\";\n\nexport interface AuditEvent {\n\ttimestamp: string;\n\teventType: AuditEventType;\n\tseverity: AuditEventSeverity;\n\temail?: string;\n\tip?: string;\n\tuserAgent?: string;\n\tdetails?: Record<string, unknown>;\n\tsuccess: boolean;\n}\n\n/**\n * Determine severity based on event type\n */\nfunction getSeverity(eventType: AuditEventType, success: boolean): AuditEventSeverity {\n\tswitch (eventType) {\n\t\tcase \"LOGIN_SUCCESS\":\n\t\tcase \"LOGOUT\":\n\t\tcase \"SESSION_REFRESH\":\n\t\t\treturn \"INFO\";\n\n\t\tcase \"LOGIN_ATTEMPT\":\n\t\t\treturn \"INFO\";\n\n\t\tcase \"LOGIN_FAILURE\":\n\t\t\treturn \"WARN\";\n\n\t\tcase \"RATE_LIMIT_EXCEEDED\":\n\t\tcase \"INVALID_DOMAIN\":\n\t\t\treturn \"WARN\";\n\n\t\tcase \"UNAUTHORIZED_ACCESS\":\n\t\t\treturn \"ERROR\";\n\n\t\tcase \"SUSPICIOUS_ACTIVITY\":\n\t\t\treturn \"CRITICAL\";\n\n\t\tdefault:\n\t\t\treturn success ? \"INFO\" : \"WARN\";\n\t}\n}\n\n/**\n * Log Admin Auth Event\n *\n * Logs authentication events with structured data.\n * In production, this should send to a logging service (Datadog, LogDNA, etc.)\n *\n * @param eventType - Type of authentication event\n * @param options - Event details\n */\nexport async function logAdminAuthEvent(\n\teventType: AuditEventType,\n\toptions: {\n\t\temail?: string;\n\t\tip?: string;\n\t\tuserAgent?: string;\n\t\tsuccess: boolean;\n\t\tdetails?: Record<string, unknown>;\n\t},\n): Promise<void> {\n\tconst event: AuditEvent = {\n\t\ttimestamp: new Date().toISOString(),\n\t\teventType,\n\t\tseverity: getSeverity(eventType, options.success),\n\t\temail: options.email ? maskEmail(options.email) : undefined,\n\t\tip: options.ip,\n\t\tuserAgent: options.userAgent,\n\t\tdetails: options.details,\n\t\tsuccess: options.success,\n\t};\n\n\t// Log to console in structured format\n\tconst logMessage = formatLogMessage(event);\n\n\tswitch (event.severity) {\n\t\tcase \"CRITICAL\":\n\t\tcase \"ERROR\":\n\t\t\tconsole.error(logMessage);\n\t\t\tbreak;\n\t\tcase \"WARN\":\n\t\t\tconsole.warn(logMessage);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.log(logMessage);\n\t}\n\n\t// In production, send to logging service\n\t// await sendToLoggingService(event);\n}\n\n/**\n * Format log message for structured logging\n */\nfunction formatLogMessage(event: AuditEvent): string {\n\tconst base = `[ADMIN_AUTH] [${event.severity}] ${event.eventType}`;\n\tconst details = [\n\t\tevent.email && `email=${event.email}`,\n\t\tevent.ip && `ip=${event.ip}`,\n\t\t`success=${event.success}`,\n\t\tevent.details && `details=${JSON.stringify(event.details)}`,\n\t]\n\t\t.filter(Boolean)\n\t\t.join(\" \");\n\n\treturn `${base} ${details}`;\n}\n\n/**\n * Mask email for privacy in logs\n * user@domain.com -> u***@domain.com\n */\nfunction maskEmail(email: string): string {\n\tconst [local, domain] = email.split(\"@\");\n\tif (!local || !domain) return \"***@***\";\n\n\tif (local.length <= 2) {\n\t\treturn `${local[0]}***@${domain}`;\n\t}\n\n\treturn `${local[0]}***${local[local.length - 1]}@${domain}`;\n}\n\n/**\n * Log successful admin login\n */\nexport async function logAdminLoginSuccess(\n\temail: string,\n\tip: string,\n\tuserAgent?: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"LOGIN_SUCCESS\", {\n\t\temail,\n\t\tip,\n\t\tuserAgent,\n\t\tsuccess: true,\n\t});\n}\n\n/**\n * Log failed admin login attempt\n */\nexport async function logAdminLoginFailure(\n\temail: string,\n\tip: string,\n\treason: string,\n\tuserAgent?: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"LOGIN_FAILURE\", {\n\t\temail,\n\t\tip,\n\t\tuserAgent,\n\t\tsuccess: false,\n\t\tdetails: { reason },\n\t});\n}\n\n/**\n * Log rate limit exceeded\n */\nexport async function logRateLimitExceeded(\n\temail: string,\n\tip: string,\n\tlockedUntil?: number,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"RATE_LIMIT_EXCEEDED\", {\n\t\temail,\n\t\tip,\n\t\tsuccess: false,\n\t\tdetails: {\n\t\t\tlockedUntil: lockedUntil ? new Date(lockedUntil).toISOString() : undefined,\n\t\t},\n\t});\n}\n\n/**\n * Log invalid domain attempt\n */\nexport async function logInvalidDomainAttempt(\n\temail: string,\n\tip: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"INVALID_DOMAIN\", {\n\t\temail,\n\t\tip,\n\t\tsuccess: false,\n\t\tdetails: {\n\t\t\tdomain: email.split(\"@\")[1]?.toLowerCase(),\n\t\t\tmessage: \"Non-admin domain attempted admin login\",\n\t\t},\n\t});\n}\n\n/**\n * Log unauthorized access attempt\n */\nexport async function logUnauthorizedAccess(\n\temail: string | undefined,\n\tip: string,\n\tpath: string,\n): Promise<void> {\n\tawait logAdminAuthEvent(\"UNAUTHORIZED_ACCESS\", {\n\t\temail,\n\t\tip,\n\t\tsuccess: false,\n\t\tdetails: { path },\n\t});\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/src/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { headers } from \"next/headers\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { isAdminEmail } from \"@/lib/admin-auth\";\nimport {\n\tcheckAdminAuthRateLimit,\n\tresetRateLimitForEmail,\n\tgetClientIP,\n\tRateLimitError,\n} from \"@/lib/security/rate-limit\";\nimport {\n\tlogAdminLoginSuccess,\n\tlogAdminLoginFailure,\n\tlogRateLimitExceeded,\n\tlogInvalidDomainAttempt,\n} from \"@/lib/security/audit-log\";\n\nexport type AdminLoginResult = {\n\tsuccess: boolean;\n\terror?: string;\n\trateLimited?: boolean;\n\tretryAfter?: number;\n};\n\n/**\n * Admin Sign In Server Action\n *\n * Handles admin authentication with:\n * - Rate limiting (per email and IP)\n * - Domain validation\n * - Audit logging\n * - Secure session creation\n */\nexport async function adminSignIn(formData: FormData): Promise<AdminLoginResult> {\n\tconst email = (formData.get(\"email\") as string)?.trim().toLowerCase();\n\tconst password = formData.get(\"password\") as string;\n\n\t// Get client info for rate limiting and logging\n\tconst headersList = await headers();\n\tconst ip = getClientIP(headersList);\n\tconst userAgent = headersList.get(\"user-agent\") || undefined;\n\n\t// Validate inputs\n\tif (!email || !password) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Email and password are required.\",\n\t\t};\n\t}\n\n\t// Check rate limits BEFORE any other validation\n\ttry {\n\t\tawait checkAdminAuthRateLimit(email, ip);\n\t} catch (error) {\n\t\tif (error instanceof RateLimitError) {\n\t\t\tawait logRateLimitExceeded(email, ip, Date.now() + error.retryAfter);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t\trateLimited: true,\n\t\t\t\tretryAfter: error.retryAfter,\n\t\t\t};\n\t\t}\n\t\tthrow error;\n\t}\n\n\t// Validate admin domain BEFORE attempting authentication\n\t// This prevents timing attacks that could reveal valid accounts\n\tif (!isAdminEmail(email)) {\n\t\tawait logInvalidDomainAttempt(email, ip);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Access denied. Admin access is restricted to Thorbis employees.\",\n\t\t};\n\t}\n\n\t// Attempt authentication\n\tconst supabase = await createClient();\n\n\tconst { data, error: authError } = await supabase.auth.signInWithPassword({\n\t\temail,\n\t\tpassword,\n\t});\n\n\tif (authError) {\n\t\tawait logAdminLoginFailure(email, ip, authError.message, userAgent);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Invalid email or password.\",\n\t\t};\n\t}\n\n\t// Double-check the authenticated user's email domain\n\t// Defense in depth - in case of any bypasses\n\tif (!isAdminEmail(data.user?.email)) {\n\t\tawait supabase.auth.signOut();\n\t\tawait logAdminLoginFailure(\n\t\t\temail,\n\t\t\tip,\n\t\t\t\"Email domain mismatch after auth\",\n\t\t\tuserAgent,\n\t\t);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Access denied. Admin access is restricted to Thorbis employees.\",\n\t\t};\n\t}\n\n\t// Success - reset rate limit and log\n\tresetRateLimitForEmail(email);\n\tawait logAdminLoginSuccess(email, ip, userAgent);\n\n\treturn {\n\t\tsuccess: true,\n\t};\n}\n\n/**\n * Admin Sign Out Server Action\n */\nexport async function adminSignOut(): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tconst supabase = await createClient();\n\t\tconst { error } = await supabase.auth.signOut();\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message,\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true };\n\t} catch {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Failed to sign out. Please try again.\",\n\t\t};\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;AAMA;;;;;;;;AAuBO,eAAe,YAAY,QAAkB;IACnD,MAAM,QAAS,SAAS,GAAG,CAAC,UAAqB,OAAO;IACxD,MAAM,WAAW,SAAS,GAAG,CAAC;IAE9B,gDAAgD;IAChD,MAAM,cAAc,MAAM,IAAA,iTAAO;IACjC,MAAM,KAAK,IAAA,uKAAW,EAAC;IACvB,MAAM,YAAY,YAAY,GAAG,CAAC,iBAAiB;IAEnD,kBAAkB;IAClB,IAAI,CAAC,SAAS,CAAC,UAAU;QACxB,OAAO;YACN,SAAS;YACT,OAAO;QACR;IACD;IAEA,gDAAgD;IAChD,IAAI;QACH,MAAM,IAAA,mLAAuB,EAAC,OAAO;IACtC,EAAE,OAAO,OAAO;QACf,IAAI,iBAAiB,0KAAc,EAAE;YACpC,MAAM,IAAA,+KAAoB,EAAC,OAAO,IAAI,KAAK,GAAG,KAAK,MAAM,UAAU;YACnE,OAAO;gBACN,SAAS;gBACT,OAAO,MAAM,OAAO;gBACpB,aAAa;gBACb,YAAY,MAAM,UAAU;YAC7B;QACD;QACA,MAAM;IACP;IAEA,yDAAyD;IACzD,gEAAgE;IAChE,IAAI,CAAC,IAAA,4JAAY,EAAC,QAAQ;QACzB,MAAM,IAAA,kLAAuB,EAAC,OAAO;QACrC,OAAO;YACN,SAAS;YACT,OAAO;QACR;IACD;IAEA,yBAAyB;IACzB,MAAM,WAAW,MAAM,IAAA,iKAAY;IAEnC,MAAM,EAAE,IAAI,EAAE,OAAO,SAAS,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,kBAAkB,CAAC;QACzE;QACA;IACD;IAEA,IAAI,WAAW;QACd,MAAM,IAAA,+KAAoB,EAAC,OAAO,IAAI,UAAU,OAAO,EAAE;QACzD,OAAO;YACN,SAAS;YACT,OAAO;QACR;IACD;IAEA,qDAAqD;IACrD,6CAA6C;IAC7C,IAAI,CAAC,IAAA,4JAAY,EAAC,KAAK,IAAI,EAAE,QAAQ;QACpC,MAAM,SAAS,IAAI,CAAC,OAAO;QAC3B,MAAM,IAAA,+KAAoB,EACzB,OACA,IACA,oCACA;QAED,OAAO;YACN,SAAS;YACT,OAAO;QACR;IACD;IAEA,qCAAqC;IACrC,IAAA,kLAAsB,EAAC;IACvB,MAAM,IAAA,+KAAoB,EAAC,OAAO,IAAI;IAEtC,OAAO;QACN,SAAS;IACV;AACD;AAKO,eAAe;IACrB,IAAI;QACH,MAAM,WAAW,MAAM,IAAA,iKAAY;QACnC,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAE7C,IAAI,OAAO;YACV,OAAO;gBACN,SAAS;gBACT,OAAO,MAAM,OAAO;YACrB;QACD;QAEA,OAAO;YAAE,SAAS;QAAK;IACxB,EAAE,OAAM;QACP,OAAO;YACN,SAAS;YACT,OAAO;QACR;IACD;AACD;;;IA1GsB;IAuFA;;AAvFA,sZAAA;AAuFA,sZAAA","debugId":null}},
    {"offset": {"line": 595, "column": 0}, "map": {"version":3,"sources":["file:///Users/byronwade/Stratos/apps/admin/.next-internal/server/app/login/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {adminSignIn as '40c8fabab10a3afae1dc2c6e3f07a4797e6cfb34b0'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}}]
}